const __vite__mapDeps = (i, m=__vite__mapDeps, d=(m.f || (m.f = ["assets/index-DuKqJIQz.js", "assets/v4-CtRu48qb.js", "assets/index-BZqns2nd.js", "assets/solanaEmbed.esm-CiiaZgXr.js", "assets/index--wg0NHeq.js", "assets/index-BC86n3gC.js", "assets/StyledPageTabs-BVppR5C0.js", "assets/useComputeLayout-CjbkMrNU.js", "assets/useWindowSize-BmlbqoX0.js", "assets/Tooltip-Bcj72A7M.js", "assets/globe-C0f5z-cj.js", "assets/formatDate-DxhhHgeR.js", "assets/index-Se2PPd5m.js", "assets/VirtualTable-CZIzG4Kv.js", "assets/index-BjdiwIS9.js", "assets/index-C71RIlzG.css", "assets/index-D6iOzXLi.js"]))) => i.map(i => d[i]);
var XT = Object.defineProperty;
var L_ = _e => {
    throw TypeError(_e)
}
;
var QT = (_e, $, et) => $ in _e ? XT(_e, $, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: et
}) : _e[$] = et;
var Br = (_e, $, et) => QT(_e, typeof $ != "symbol" ? $ + "" : $, et)
  , X1 = (_e, $, et) => $.has(_e) || L_("Cannot " + et);
var nn = (_e, $, et) => (X1(_e, $, "read from private field"),
et ? et.call(_e) : $.get(_e))
  , gr = (_e, $, et) => $.has(_e) ? L_("Cannot add the same private member more than once") : $ instanceof WeakSet ? $.add(_e) : $.set(_e, et)
  , Yn = (_e, $, et, tt) => (X1(_e, $, "write to private field"),
tt ? tt.call(_e, et) : $.set(_e, et),
et)
  , tr = (_e, $, et) => (X1(_e, $, "access private method"),
et);
var Np = (_e, $, et, tt) => ({
    set _(nt) {
        Yn(_e, $, nt, et)
    },
    get _() {
        return nn(_e, $, tt)
    }
});
function _mergeNamespaces(_e, $) {
    for (var et = 0; et < $.length; et++) {
        const tt = $[et];
        if (typeof tt != "string" && !Array.isArray(tt)) {
            for (const nt in tt)
                if (nt !== "default" && !(nt in _e)) {
                    const rt = Object.getOwnPropertyDescriptor(tt, nt);
                    rt && Object.defineProperty(_e, nt, rt.get ? rt : {
                        enumerable: !0,
                        get: () => tt[nt]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(_e, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const $ = document.createElement("link").relList;
    if ($ && $.supports && $.supports("modulepreload"))
        return;
    for (const nt of document.querySelectorAll('link[rel="modulepreload"]'))
        tt(nt);
    new MutationObserver(nt => {
        for (const rt of nt)
            if (rt.type === "childList")
                for (const it of rt.addedNodes)
                    it.tagName === "LINK" && it.rel === "modulepreload" && tt(it)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function et(nt) {
        const rt = {};
        return nt.integrity && (rt.integrity = nt.integrity),
        nt.referrerPolicy && (rt.referrerPolicy = nt.referrerPolicy),
        nt.crossOrigin === "use-credentials" ? rt.credentials = "include" : nt.crossOrigin === "anonymous" ? rt.credentials = "omit" : rt.credentials = "same-origin",
        rt
    }
    function tt(nt) {
        if (nt.ep)
            return;
        nt.ep = !0;
        const rt = et(nt);
        fetch(nt.href, rt)
    }
}
)();
var commonjsGlobal$1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {};
function getDefaultExportFromCjs$2(_e) {
    return _e && _e.__esModule && Object.prototype.hasOwnProperty.call(_e, "default") ? _e.default : _e
}
function getAugmentedNamespace(_e) {
    if (_e.__esModule)
        return _e;
    var $ = _e.default;
    if (typeof $ == "function") {
        var et = function tt() {
            return this instanceof tt ? Reflect.construct($, arguments, this.constructor) : $.apply(this, arguments)
        };
        et.prototype = $.prototype
    } else
        et = {};
    return Object.defineProperty(et, "__esModule", {
        value: !0
    }),
    Object.keys(_e).forEach(function(tt) {
        var nt = Object.getOwnPropertyDescriptor(_e, tt);
        Object.defineProperty(et, tt, nt.get ? nt : {
            enumerable: !0,
            get: function() {
                return _e[tt]
            }
        })
    }),
    et
}
var jsxRuntime = {
    exports: {}
}
  , reactJsxRuntime_production_min = {}
  , react = {
    exports: {}
}
  , react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = Symbol.for("react.element")
  , n$3 = Symbol.for("react.portal")
  , p$4 = Symbol.for("react.fragment")
  , q$3 = Symbol.for("react.strict_mode")
  , r$2 = Symbol.for("react.profiler")
  , t$2 = Symbol.for("react.provider")
  , u$2 = Symbol.for("react.context")
  , v$2 = Symbol.for("react.forward_ref")
  , w$1 = Symbol.for("react.suspense")
  , x$2 = Symbol.for("react.memo")
  , y$2 = Symbol.for("react.lazy")
  , z$2 = Symbol.iterator;
function A$3(_e) {
    return _e === null || typeof _e != "object" ? null : (_e = z$2 && _e[z$2] || _e["@@iterator"],
    typeof _e == "function" ? _e : null)
}
var B$1 = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , C$2 = Object.assign
  , D$2 = {};
function E$1(_e, $, et) {
    this.props = _e,
    this.context = $,
    this.refs = D$2,
    this.updater = et || B$1
}
E$1.prototype.isReactComponent = {};
E$1.prototype.setState = function(_e, $) {
    if (typeof _e != "object" && typeof _e != "function" && _e != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, _e, $, "setState")
}
;
E$1.prototype.forceUpdate = function(_e) {
    this.updater.enqueueForceUpdate(this, _e, "forceUpdate")
}
;
function F$1() {}
F$1.prototype = E$1.prototype;
function G$1(_e, $, et) {
    this.props = _e,
    this.context = $,
    this.refs = D$2,
    this.updater = et || B$1
}
var H$1 = G$1.prototype = new F$1;
H$1.constructor = G$1;
C$2(H$1, E$1.prototype);
H$1.isPureReactComponent = !0;
var I$1 = Array.isArray
  , J$1 = Object.prototype.hasOwnProperty
  , K$2 = {
    current: null
}
  , L$1 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function M$2(_e, $, et) {
    var tt, nt = {}, rt = null, it = null;
    if ($ != null)
        for (tt in $.ref !== void 0 && (it = $.ref),
        $.key !== void 0 && (rt = "" + $.key),
        $)
            J$1.call($, tt) && !L$1.hasOwnProperty(tt) && (nt[tt] = $[tt]);
    var ot = arguments.length - 2;
    if (ot === 1)
        nt.children = et;
    else if (1 < ot) {
        for (var st = Array(ot), lt = 0; lt < ot; lt++)
            st[lt] = arguments[lt + 2];
        nt.children = st
    }
    if (_e && _e.defaultProps)
        for (tt in ot = _e.defaultProps,
        ot)
            nt[tt] === void 0 && (nt[tt] = ot[tt]);
    return {
        $$typeof: l$3,
        type: _e,
        key: rt,
        ref: it,
        props: nt,
        _owner: K$2.current
    }
}
function N$1(_e, $) {
    return {
        $$typeof: l$3,
        type: _e.type,
        key: $,
        ref: _e.ref,
        props: _e.props,
        _owner: _e._owner
    }
}
function O$2(_e) {
    return typeof _e == "object" && _e !== null && _e.$$typeof === l$3
}
function escape(_e) {
    var $ = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + _e.replace(/[=:]/g, function(et) {
        return $[et]
    })
}
var P$3 = /\/+/g;
function Q$1(_e, $) {
    return typeof _e == "object" && _e !== null && _e.key != null ? escape("" + _e.key) : $.toString(36)
}
function R$2(_e, $, et, tt, nt) {
    var rt = typeof _e;
    (rt === "undefined" || rt === "boolean") && (_e = null);
    var it = !1;
    if (_e === null)
        it = !0;
    else
        switch (rt) {
        case "string":
        case "number":
            it = !0;
            break;
        case "object":
            switch (_e.$$typeof) {
            case l$3:
            case n$3:
                it = !0
            }
        }
    if (it)
        return it = _e,
        nt = nt(it),
        _e = tt === "" ? "." + Q$1(it, 0) : tt,
        I$1(nt) ? (et = "",
        _e != null && (et = _e.replace(P$3, "$&/") + "/"),
        R$2(nt, $, et, "", function(lt) {
            return lt
        })) : nt != null && (O$2(nt) && (nt = N$1(nt, et + (!nt.key || it && it.key === nt.key ? "" : ("" + nt.key).replace(P$3, "$&/") + "/") + _e)),
        $.push(nt)),
        1;
    if (it = 0,
    tt = tt === "" ? "." : tt + ":",
    I$1(_e))
        for (var ot = 0; ot < _e.length; ot++) {
            rt = _e[ot];
            var st = tt + Q$1(rt, ot);
            it += R$2(rt, $, et, st, nt)
        }
    else if (st = A$3(_e),
    typeof st == "function")
        for (_e = st.call(_e),
        ot = 0; !(rt = _e.next()).done; )
            rt = rt.value,
            st = tt + Q$1(rt, ot++),
            it += R$2(rt, $, et, st, nt);
    else if (rt === "object")
        throw $ = String(_e),
        Error("Objects are not valid as a React child (found: " + ($ === "[object Object]" ? "object with keys {" + Object.keys(_e).join(", ") + "}" : $) + "). If you meant to render a collection of children, use an array instead.");
    return it
}
function S$1(_e, $, et) {
    if (_e == null)
        return _e;
    var tt = []
      , nt = 0;
    return R$2(_e, tt, "", "", function(rt) {
        return $.call(et, rt, nt++)
    }),
    tt
}
function T$1(_e) {
    if (_e._status === -1) {
        var $ = _e._result;
        $ = $(),
        $.then(function(et) {
            (_e._status === 0 || _e._status === -1) && (_e._status = 1,
            _e._result = et)
        }, function(et) {
            (_e._status === 0 || _e._status === -1) && (_e._status = 2,
            _e._result = et)
        }),
        _e._status === -1 && (_e._status = 0,
        _e._result = $)
    }
    if (_e._status === 1)
        return _e._result.default;
    throw _e._result
}
var U$2 = {
    current: null
}
  , V$2 = {
    transition: null
}
  , W$2 = {
    ReactCurrentDispatcher: U$2,
    ReactCurrentBatchConfig: V$2,
    ReactCurrentOwner: K$2
};
function X$2() {
    throw Error("act(...) is not supported in production builds of React.")
}
react_production_min.Children = {
    map: S$1,
    forEach: function(_e, $, et) {
        S$1(_e, function() {
            $.apply(this, arguments)
        }, et)
    },
    count: function(_e) {
        var $ = 0;
        return S$1(_e, function() {
            $++
        }),
        $
    },
    toArray: function(_e) {
        return S$1(_e, function($) {
            return $
        }) || []
    },
    only: function(_e) {
        if (!O$2(_e))
            throw Error("React.Children.only expected to receive a single React element child.");
        return _e
    }
};
react_production_min.Component = E$1;
react_production_min.Fragment = p$4;
react_production_min.Profiler = r$2;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$3;
react_production_min.Suspense = w$1;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$2;
react_production_min.act = X$2;
react_production_min.cloneElement = function(_e, $, et) {
    if (_e == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + _e + ".");
    var tt = C$2({}, _e.props)
      , nt = _e.key
      , rt = _e.ref
      , it = _e._owner;
    if ($ != null) {
        if ($.ref !== void 0 && (rt = $.ref,
        it = K$2.current),
        $.key !== void 0 && (nt = "" + $.key),
        _e.type && _e.type.defaultProps)
            var ot = _e.type.defaultProps;
        for (st in $)
            J$1.call($, st) && !L$1.hasOwnProperty(st) && (tt[st] = $[st] === void 0 && ot !== void 0 ? ot[st] : $[st])
    }
    var st = arguments.length - 2;
    if (st === 1)
        tt.children = et;
    else if (1 < st) {
        ot = Array(st);
        for (var lt = 0; lt < st; lt++)
            ot[lt] = arguments[lt + 2];
        tt.children = ot
    }
    return {
        $$typeof: l$3,
        type: _e.type,
        key: nt,
        ref: rt,
        props: tt,
        _owner: it
    }
}
;
react_production_min.createContext = function(_e) {
    return _e = {
        $$typeof: u$2,
        _currentValue: _e,
        _currentValue2: _e,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    _e.Provider = {
        $$typeof: t$2,
        _context: _e
    },
    _e.Consumer = _e
}
;
react_production_min.createElement = M$2;
react_production_min.createFactory = function(_e) {
    var $ = M$2.bind(null, _e);
    return $.type = _e,
    $
}
;
react_production_min.createRef = function() {
    return {
        current: null
    }
}
;
react_production_min.forwardRef = function(_e) {
    return {
        $$typeof: v$2,
        render: _e
    }
}
;
react_production_min.isValidElement = O$2;
react_production_min.lazy = function(_e) {
    return {
        $$typeof: y$2,
        _payload: {
            _status: -1,
            _result: _e
        },
        _init: T$1
    }
}
;
react_production_min.memo = function(_e, $) {
    return {
        $$typeof: x$2,
        type: _e,
        compare: $ === void 0 ? null : $
    }
}
;
react_production_min.startTransition = function(_e) {
    var $ = V$2.transition;
    V$2.transition = {};
    try {
        _e()
    } finally {
        V$2.transition = $
    }
}
;
react_production_min.unstable_act = X$2;
react_production_min.useCallback = function(_e, $) {
    return U$2.current.useCallback(_e, $)
}
;
react_production_min.useContext = function(_e) {
    return U$2.current.useContext(_e)
}
;
react_production_min.useDebugValue = function() {}
;
react_production_min.useDeferredValue = function(_e) {
    return U$2.current.useDeferredValue(_e)
}
;
react_production_min.useEffect = function(_e, $) {
    return U$2.current.useEffect(_e, $)
}
;
react_production_min.useId = function() {
    return U$2.current.useId()
}
;
react_production_min.useImperativeHandle = function(_e, $, et) {
    return U$2.current.useImperativeHandle(_e, $, et)
}
;
react_production_min.useInsertionEffect = function(_e, $) {
    return U$2.current.useInsertionEffect(_e, $)
}
;
react_production_min.useLayoutEffect = function(_e, $) {
    return U$2.current.useLayoutEffect(_e, $)
}
;
react_production_min.useMemo = function(_e, $) {
    return U$2.current.useMemo(_e, $)
}
;
react_production_min.useReducer = function(_e, $, et) {
    return U$2.current.useReducer(_e, $, et)
}
;
react_production_min.useRef = function(_e) {
    return U$2.current.useRef(_e)
}
;
react_production_min.useState = function(_e) {
    return U$2.current.useState(_e)
}
;
react_production_min.useSyncExternalStore = function(_e, $, et) {
    return U$2.current.useSyncExternalStore(_e, $, et)
}
;
react_production_min.useTransition = function() {
    return U$2.current.useTransition()
}
;
react_production_min.version = "18.3.1";
react.exports = react_production_min;
var reactExports = react.exports;
const React = getDefaultExportFromCjs$2(reactExports)
  , React$1 = _mergeNamespaces({
    __proto__: null,
    default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$4 = reactExports
  , k$3 = Symbol.for("react.element")
  , l$2 = Symbol.for("react.fragment")
  , m$3 = Object.prototype.hasOwnProperty
  , n$2 = f$4.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , p$3 = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function q$2(_e, $, et) {
    var tt, nt = {}, rt = null, it = null;
    et !== void 0 && (rt = "" + et),
    $.key !== void 0 && (rt = "" + $.key),
    $.ref !== void 0 && (it = $.ref);
    for (tt in $)
        m$3.call($, tt) && !p$3.hasOwnProperty(tt) && (nt[tt] = $[tt]);
    if (_e && _e.defaultProps)
        for (tt in $ = _e.defaultProps,
        $)
            nt[tt] === void 0 && (nt[tt] = $[tt]);
    return {
        $$typeof: k$3,
        type: _e,
        key: rt,
        ref: it,
        props: nt,
        _owner: n$2.current
    }
}
reactJsxRuntime_production_min.Fragment = l$2;
reactJsxRuntime_production_min.jsx = q$2;
reactJsxRuntime_production_min.jsxs = q$2;
jsxRuntime.exports = reactJsxRuntime_production_min;
var jsxRuntimeExports = jsxRuntime.exports
  , reactDom = {
    exports: {}
}
  , reactDom_production_min = {}
  , scheduler = {
    exports: {}
}
  , scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(_e) {
    function $(Ft, Ht) {
        var qt = Ft.length;
        Ft.push(Ht);
        e: for (; 0 < qt; ) {
            var Wt = qt - 1 >>> 1
              , Mt = Ft[Wt];
            if (0 < nt(Mt, Ht))
                Ft[Wt] = Ht,
                Ft[qt] = Mt,
                qt = Wt;
            else
                break e
        }
    }
    function et(Ft) {
        return Ft.length === 0 ? null : Ft[0]
    }
    function tt(Ft) {
        if (Ft.length === 0)
            return null;
        var Ht = Ft[0]
          , qt = Ft.pop();
        if (qt !== Ht) {
            Ft[0] = qt;
            e: for (var Wt = 0, Mt = Ft.length, Yt = Mt >>> 1; Wt < Yt; ) {
                var un = 2 * (Wt + 1) - 1
                  , hn = Ft[un]
                  , _n = un + 1
                  , kn = Ft[_n];
                if (0 > nt(hn, qt))
                    _n < Mt && 0 > nt(kn, hn) ? (Ft[Wt] = kn,
                    Ft[_n] = qt,
                    Wt = _n) : (Ft[Wt] = hn,
                    Ft[un] = qt,
                    Wt = un);
                else if (_n < Mt && 0 > nt(kn, qt))
                    Ft[Wt] = kn,
                    Ft[_n] = qt,
                    Wt = _n;
                else
                    break e
            }
        }
        return Ht
    }
    function nt(Ft, Ht) {
        var qt = Ft.sortIndex - Ht.sortIndex;
        return qt !== 0 ? qt : Ft.id - Ht.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var rt = performance;
        _e.unstable_now = function() {
            return rt.now()
        }
    } else {
        var it = Date
          , ot = it.now();
        _e.unstable_now = function() {
            return it.now() - ot
        }
    }
    var st = []
      , lt = []
      , ct = 1
      , dt = null
      , pt = 3
      , ht = !1
      , mt = !1
      , yt = !1
      , Et = typeof setTimeout == "function" ? setTimeout : null
      , _t = typeof clearTimeout == "function" ? clearTimeout : null
      , wt = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function St(Ft) {
        for (var Ht = et(lt); Ht !== null; ) {
            if (Ht.callback === null)
                tt(lt);
            else if (Ht.startTime <= Ft)
                tt(lt),
                Ht.sortIndex = Ht.expirationTime,
                $(st, Ht);
            else
                break;
            Ht = et(lt)
        }
    }
    function Ct(Ft) {
        if (yt = !1,
        St(Ft),
        !mt)
            if (et(st) !== null)
                mt = !0,
                Dt(Nt);
            else {
                var Ht = et(lt);
                Ht !== null && jt(Ct, Ht.startTime - Ft)
            }
    }
    function Nt(Ft, Ht) {
        mt = !1,
        yt && (yt = !1,
        _t(Ut),
        Ut = -1),
        ht = !0;
        var qt = pt;
        try {
            for (St(Ht),
            dt = et(st); dt !== null && (!(dt.expirationTime > Ht) || Ft && !Xt()); ) {
                var Wt = dt.callback;
                if (typeof Wt == "function") {
                    dt.callback = null,
                    pt = dt.priorityLevel;
                    var Mt = Wt(dt.expirationTime <= Ht);
                    Ht = _e.unstable_now(),
                    typeof Mt == "function" ? dt.callback = Mt : dt === et(st) && tt(st),
                    St(Ht)
                } else
                    tt(st);
                dt = et(st)
            }
            if (dt !== null)
                var Yt = !0;
            else {
                var un = et(lt);
                un !== null && jt(Ct, un.startTime - Ht),
                Yt = !1
            }
            return Yt
        } finally {
            dt = null,
            pt = qt,
            ht = !1
        }
    }
    var Lt = !1
      , kt = null
      , Ut = -1
      , Jt = 5
      , Pt = -1;
    function Xt() {
        return !(_e.unstable_now() - Pt < Jt)
    }
    function rn() {
        if (kt !== null) {
            var Ft = _e.unstable_now();
            Pt = Ft;
            var Ht = !0;
            try {
                Ht = kt(!0, Ft)
            } finally {
                Ht ? zt() : (Lt = !1,
                kt = null)
            }
        } else
            Lt = !1
    }
    var zt;
    if (typeof wt == "function")
        zt = function() {
            wt(rn)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var xt = new MessageChannel
          , $t = xt.port2;
        xt.port1.onmessage = rn,
        zt = function() {
            $t.postMessage(null)
        }
    } else
        zt = function() {
            Et(rn, 0)
        }
        ;
    function Dt(Ft) {
        kt = Ft,
        Lt || (Lt = !0,
        zt())
    }
    function jt(Ft, Ht) {
        Ut = Et(function() {
            Ft(_e.unstable_now())
        }, Ht)
    }
    _e.unstable_IdlePriority = 5,
    _e.unstable_ImmediatePriority = 1,
    _e.unstable_LowPriority = 4,
    _e.unstable_NormalPriority = 3,
    _e.unstable_Profiling = null,
    _e.unstable_UserBlockingPriority = 2,
    _e.unstable_cancelCallback = function(Ft) {
        Ft.callback = null
    }
    ,
    _e.unstable_continueExecution = function() {
        mt || ht || (mt = !0,
        Dt(Nt))
    }
    ,
    _e.unstable_forceFrameRate = function(Ft) {
        0 > Ft || 125 < Ft || (Jt = 0 < Ft ? Math.floor(1e3 / Ft) : 5)
    }
    ,
    _e.unstable_getCurrentPriorityLevel = function() {
        return pt
    }
    ,
    _e.unstable_getFirstCallbackNode = function() {
        return et(st)
    }
    ,
    _e.unstable_next = function(Ft) {
        switch (pt) {
        case 1:
        case 2:
        case 3:
            var Ht = 3;
            break;
        default:
            Ht = pt
        }
        var qt = pt;
        pt = Ht;
        try {
            return Ft()
        } finally {
            pt = qt
        }
    }
    ,
    _e.unstable_pauseExecution = function() {}
    ,
    _e.unstable_requestPaint = function() {}
    ,
    _e.unstable_runWithPriority = function(Ft, Ht) {
        switch (Ft) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            Ft = 3
        }
        var qt = pt;
        pt = Ft;
        try {
            return Ht()
        } finally {
            pt = qt
        }
    }
    ,
    _e.unstable_scheduleCallback = function(Ft, Ht, qt) {
        var Wt = _e.unstable_now();
        switch (typeof qt == "object" && qt !== null ? (qt = qt.delay,
        qt = typeof qt == "number" && 0 < qt ? Wt + qt : Wt) : qt = Wt,
        Ft) {
        case 1:
            var Mt = -1;
            break;
        case 2:
            Mt = 250;
            break;
        case 5:
            Mt = 1073741823;
            break;
        case 4:
            Mt = 1e4;
            break;
        default:
            Mt = 5e3
        }
        return Mt = qt + Mt,
        Ft = {
            id: ct++,
            callback: Ht,
            priorityLevel: Ft,
            startTime: qt,
            expirationTime: Mt,
            sortIndex: -1
        },
        qt > Wt ? (Ft.sortIndex = qt,
        $(lt, Ft),
        et(st) === null && Ft === et(lt) && (yt ? (_t(Ut),
        Ut = -1) : yt = !0,
        jt(Ct, qt - Wt))) : (Ft.sortIndex = Mt,
        $(st, Ft),
        mt || ht || (mt = !0,
        Dt(Nt))),
        Ft
    }
    ,
    _e.unstable_shouldYield = Xt,
    _e.unstable_wrapCallback = function(Ft) {
        var Ht = pt;
        return function() {
            var qt = pt;
            pt = Ht;
            try {
                return Ft.apply(this, arguments)
            } finally {
                pt = qt
            }
        }
    }
}
)(scheduler_production_min);
scheduler.exports = scheduler_production_min;
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports
  , ca = schedulerExports;
function p$2(_e) {
    for (var $ = "https://reactjs.org/docs/error-decoder.html?invariant=" + _e, et = 1; et < arguments.length; et++)
        $ += "&args[]=" + encodeURIComponent(arguments[et]);
    return "Minified React error #" + _e + "; visit " + $ + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var da = new Set
  , ea = {};
function fa(_e, $) {
    ha(_e, $),
    ha(_e + "Capture", $)
}
function ha(_e, $) {
    for (ea[_e] = $,
    _e = 0; _e < $.length; _e++)
        da.add($[_e])
}
var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , ja$1 = Object.prototype.hasOwnProperty
  , ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , la = {}
  , ma = {};
function oa(_e) {
    return ja$1.call(ma, _e) ? !0 : ja$1.call(la, _e) ? !1 : ka.test(_e) ? ma[_e] = !0 : (la[_e] = !0,
    !1)
}
function pa(_e, $, et, tt) {
    if (et !== null && et.type === 0)
        return !1;
    switch (typeof $) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return tt ? !1 : et !== null ? !et.acceptsBooleans : (_e = _e.toLowerCase().slice(0, 5),
        _e !== "data-" && _e !== "aria-");
    default:
        return !1
    }
}
function qa(_e, $, et, tt) {
    if ($ === null || typeof $ > "u" || pa(_e, $, et, tt))
        return !0;
    if (tt)
        return !1;
    if (et !== null)
        switch (et.type) {
        case 3:
            return !$;
        case 4:
            return $ === !1;
        case 5:
            return isNaN($);
        case 6:
            return isNaN($) || 1 > $
        }
    return !1
}
function v$1(_e, $, et, tt, nt, rt, it) {
    this.acceptsBooleans = $ === 2 || $ === 3 || $ === 4,
    this.attributeName = tt,
    this.attributeNamespace = nt,
    this.mustUseProperty = et,
    this.propertyName = _e,
    this.type = $,
    this.sanitizeURL = rt,
    this.removeEmptyString = it
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(_e) {
    z$1[_e] = new v$1(_e,0,!1,_e,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_e) {
    var $ = _e[0];
    z$1[$] = new v$1($,1,!1,_e[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(_e) {
    z$1[_e] = new v$1(_e,2,!1,_e.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(_e) {
    z$1[_e] = new v$1(_e,2,!1,_e,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(_e) {
    z$1[_e] = new v$1(_e,3,!1,_e.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(_e) {
    z$1[_e] = new v$1(_e,3,!0,_e,null,!1,!1)
});
["capture", "download"].forEach(function(_e) {
    z$1[_e] = new v$1(_e,4,!1,_e,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(_e) {
    z$1[_e] = new v$1(_e,6,!1,_e,null,!1,!1)
});
["rowSpan", "start"].forEach(function(_e) {
    z$1[_e] = new v$1(_e,5,!1,_e.toLowerCase(),null,!1,!1)
});
var ra = /[\-:]([a-z])/g;
function sa(_e) {
    return _e[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(_e) {
    var $ = _e.replace(ra, sa);
    z$1[$] = new v$1($,1,!1,_e,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(_e) {
    var $ = _e.replace(ra, sa);
    z$1[$] = new v$1($,1,!1,_e,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(_e) {
    var $ = _e.replace(ra, sa);
    z$1[$] = new v$1($,1,!1,_e,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(_e) {
    z$1[_e] = new v$1(_e,1,!1,_e.toLowerCase(),null,!1,!1)
});
z$1.xlinkHref = new v$1("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(_e) {
    z$1[_e] = new v$1(_e,1,!1,_e.toLowerCase(),null,!0,!0)
});
function ta(_e, $, et, tt) {
    var nt = z$1.hasOwnProperty($) ? z$1[$] : null;
    (nt !== null ? nt.type !== 0 : tt || !(2 < $.length) || $[0] !== "o" && $[0] !== "O" || $[1] !== "n" && $[1] !== "N") && (qa($, et, nt, tt) && (et = null),
    tt || nt === null ? oa($) && (et === null ? _e.removeAttribute($) : _e.setAttribute($, "" + et)) : nt.mustUseProperty ? _e[nt.propertyName] = et === null ? nt.type === 3 ? !1 : "" : et : ($ = nt.attributeName,
    tt = nt.attributeNamespace,
    et === null ? _e.removeAttribute($) : (nt = nt.type,
    et = nt === 3 || nt === 4 && et === !0 ? "" : "" + et,
    tt ? _e.setAttributeNS(tt, $, et) : _e.setAttribute($, et))))
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , va = Symbol.for("react.element")
  , wa = Symbol.for("react.portal")
  , ya = Symbol.for("react.fragment")
  , za = Symbol.for("react.strict_mode")
  , Aa = Symbol.for("react.profiler")
  , Ba = Symbol.for("react.provider")
  , Ca = Symbol.for("react.context")
  , Da = Symbol.for("react.forward_ref")
  , Ea = Symbol.for("react.suspense")
  , Fa = Symbol.for("react.suspense_list")
  , Ga = Symbol.for("react.memo")
  , Ha = Symbol.for("react.lazy")
  , Ia = Symbol.for("react.offscreen")
  , Ja = Symbol.iterator;
function Ka(_e) {
    return _e === null || typeof _e != "object" ? null : (_e = Ja && _e[Ja] || _e["@@iterator"],
    typeof _e == "function" ? _e : null)
}
var A$2 = Object.assign, La;
function Ma(_e) {
    if (La === void 0)
        try {
            throw Error()
        } catch (et) {
            var $ = et.stack.trim().match(/\n( *(at )?)/);
            La = $ && $[1] || ""
        }
    return `
` + La + _e
}
var Na = !1;
function Oa(_e, $) {
    if (!_e || Na)
        return "";
    Na = !0;
    var et = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if ($)
            if ($ = function() {
                throw Error()
            }
            ,
            Object.defineProperty($.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct($, [])
                } catch (lt) {
                    var tt = lt
                }
                Reflect.construct(_e, [], $)
            } else {
                try {
                    $.call()
                } catch (lt) {
                    tt = lt
                }
                _e.call($.prototype)
            }
        else {
            try {
                throw Error()
            } catch (lt) {
                tt = lt
            }
            _e()
        }
    } catch (lt) {
        if (lt && tt && typeof lt.stack == "string") {
            for (var nt = lt.stack.split(`
`), rt = tt.stack.split(`
`), it = nt.length - 1, ot = rt.length - 1; 1 <= it && 0 <= ot && nt[it] !== rt[ot]; )
                ot--;
            for (; 1 <= it && 0 <= ot; it--,
            ot--)
                if (nt[it] !== rt[ot]) {
                    if (it !== 1 || ot !== 1)
                        do
                            if (it--,
                            ot--,
                            0 > ot || nt[it] !== rt[ot]) {
                                var st = `
` + nt[it].replace(" at new ", " at ");
                                return _e.displayName && st.includes("<anonymous>") && (st = st.replace("<anonymous>", _e.displayName)),
                                st
                            }
                        while (1 <= it && 0 <= ot);
                    break
                }
        }
    } finally {
        Na = !1,
        Error.prepareStackTrace = et
    }
    return (_e = _e ? _e.displayName || _e.name : "") ? Ma(_e) : ""
}
function Pa(_e) {
    switch (_e.tag) {
    case 5:
        return Ma(_e.type);
    case 16:
        return Ma("Lazy");
    case 13:
        return Ma("Suspense");
    case 19:
        return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
        return _e = Oa(_e.type, !1),
        _e;
    case 11:
        return _e = Oa(_e.type.render, !1),
        _e;
    case 1:
        return _e = Oa(_e.type, !0),
        _e;
    default:
        return ""
    }
}
function Qa(_e) {
    if (_e == null)
        return null;
    if (typeof _e == "function")
        return _e.displayName || _e.name || null;
    if (typeof _e == "string")
        return _e;
    switch (_e) {
    case ya:
        return "Fragment";
    case wa:
        return "Portal";
    case Aa:
        return "Profiler";
    case za:
        return "StrictMode";
    case Ea:
        return "Suspense";
    case Fa:
        return "SuspenseList"
    }
    if (typeof _e == "object")
        switch (_e.$$typeof) {
        case Ca:
            return (_e.displayName || "Context") + ".Consumer";
        case Ba:
            return (_e._context.displayName || "Context") + ".Provider";
        case Da:
            var $ = _e.render;
            return _e = _e.displayName,
            _e || (_e = $.displayName || $.name || "",
            _e = _e !== "" ? "ForwardRef(" + _e + ")" : "ForwardRef"),
            _e;
        case Ga:
            return $ = _e.displayName || null,
            $ !== null ? $ : Qa(_e.type) || "Memo";
        case Ha:
            $ = _e._payload,
            _e = _e._init;
            try {
                return Qa(_e($))
            } catch {}
        }
    return null
}
function Ra(_e) {
    var $ = _e.type;
    switch (_e.tag) {
    case 24:
        return "Cache";
    case 9:
        return ($.displayName || "Context") + ".Consumer";
    case 10:
        return ($._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return _e = $.render,
        _e = _e.displayName || _e.name || "",
        $.displayName || (_e !== "" ? "ForwardRef(" + _e + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return $;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return Qa($);
    case 8:
        return $ === za ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof $ == "function")
            return $.displayName || $.name || null;
        if (typeof $ == "string")
            return $
    }
    return null
}
function Sa(_e) {
    switch (typeof _e) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return _e;
    case "object":
        return _e;
    default:
        return ""
    }
}
function Ta(_e) {
    var $ = _e.type;
    return (_e = _e.nodeName) && _e.toLowerCase() === "input" && ($ === "checkbox" || $ === "radio")
}
function Ua(_e) {
    var $ = Ta(_e) ? "checked" : "value"
      , et = Object.getOwnPropertyDescriptor(_e.constructor.prototype, $)
      , tt = "" + _e[$];
    if (!_e.hasOwnProperty($) && typeof et < "u" && typeof et.get == "function" && typeof et.set == "function") {
        var nt = et.get
          , rt = et.set;
        return Object.defineProperty(_e, $, {
            configurable: !0,
            get: function() {
                return nt.call(this)
            },
            set: function(it) {
                tt = "" + it,
                rt.call(this, it)
            }
        }),
        Object.defineProperty(_e, $, {
            enumerable: et.enumerable
        }),
        {
            getValue: function() {
                return tt
            },
            setValue: function(it) {
                tt = "" + it
            },
            stopTracking: function() {
                _e._valueTracker = null,
                delete _e[$]
            }
        }
    }
}
function Va(_e) {
    _e._valueTracker || (_e._valueTracker = Ua(_e))
}
function Wa(_e) {
    if (!_e)
        return !1;
    var $ = _e._valueTracker;
    if (!$)
        return !0;
    var et = $.getValue()
      , tt = "";
    return _e && (tt = Ta(_e) ? _e.checked ? "true" : "false" : _e.value),
    _e = tt,
    _e !== et ? ($.setValue(_e),
    !0) : !1
}
function Xa(_e) {
    if (_e = _e || (typeof document < "u" ? document : void 0),
    typeof _e > "u")
        return null;
    try {
        return _e.activeElement || _e.body
    } catch {
        return _e.body
    }
}
function Ya(_e, $) {
    var et = $.checked;
    return A$2({}, $, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: et ?? _e._wrapperState.initialChecked
    })
}
function Za(_e, $) {
    var et = $.defaultValue == null ? "" : $.defaultValue
      , tt = $.checked != null ? $.checked : $.defaultChecked;
    et = Sa($.value != null ? $.value : et),
    _e._wrapperState = {
        initialChecked: tt,
        initialValue: et,
        controlled: $.type === "checkbox" || $.type === "radio" ? $.checked != null : $.value != null
    }
}
function ab(_e, $) {
    $ = $.checked,
    $ != null && ta(_e, "checked", $, !1)
}
function bb(_e, $) {
    ab(_e, $);
    var et = Sa($.value)
      , tt = $.type;
    if (et != null)
        tt === "number" ? (et === 0 && _e.value === "" || _e.value != et) && (_e.value = "" + et) : _e.value !== "" + et && (_e.value = "" + et);
    else if (tt === "submit" || tt === "reset") {
        _e.removeAttribute("value");
        return
    }
    $.hasOwnProperty("value") ? cb(_e, $.type, et) : $.hasOwnProperty("defaultValue") && cb(_e, $.type, Sa($.defaultValue)),
    $.checked == null && $.defaultChecked != null && (_e.defaultChecked = !!$.defaultChecked)
}
function db(_e, $, et) {
    if ($.hasOwnProperty("value") || $.hasOwnProperty("defaultValue")) {
        var tt = $.type;
        if (!(tt !== "submit" && tt !== "reset" || $.value !== void 0 && $.value !== null))
            return;
        $ = "" + _e._wrapperState.initialValue,
        et || $ === _e.value || (_e.value = $),
        _e.defaultValue = $
    }
    et = _e.name,
    et !== "" && (_e.name = ""),
    _e.defaultChecked = !!_e._wrapperState.initialChecked,
    et !== "" && (_e.name = et)
}
function cb(_e, $, et) {
    ($ !== "number" || Xa(_e.ownerDocument) !== _e) && (et == null ? _e.defaultValue = "" + _e._wrapperState.initialValue : _e.defaultValue !== "" + et && (_e.defaultValue = "" + et))
}
var eb = Array.isArray;
function fb(_e, $, et, tt) {
    if (_e = _e.options,
    $) {
        $ = {};
        for (var nt = 0; nt < et.length; nt++)
            $["$" + et[nt]] = !0;
        for (et = 0; et < _e.length; et++)
            nt = $.hasOwnProperty("$" + _e[et].value),
            _e[et].selected !== nt && (_e[et].selected = nt),
            nt && tt && (_e[et].defaultSelected = !0)
    } else {
        for (et = "" + Sa(et),
        $ = null,
        nt = 0; nt < _e.length; nt++) {
            if (_e[nt].value === et) {
                _e[nt].selected = !0,
                tt && (_e[nt].defaultSelected = !0);
                return
            }
            $ !== null || _e[nt].disabled || ($ = _e[nt])
        }
        $ !== null && ($.selected = !0)
    }
}
function gb(_e, $) {
    if ($.dangerouslySetInnerHTML != null)
        throw Error(p$2(91));
    return A$2({}, $, {
        value: void 0,
        defaultValue: void 0,
        children: "" + _e._wrapperState.initialValue
    })
}
function hb(_e, $) {
    var et = $.value;
    if (et == null) {
        if (et = $.children,
        $ = $.defaultValue,
        et != null) {
            if ($ != null)
                throw Error(p$2(92));
            if (eb(et)) {
                if (1 < et.length)
                    throw Error(p$2(93));
                et = et[0]
            }
            $ = et
        }
        $ == null && ($ = ""),
        et = $
    }
    _e._wrapperState = {
        initialValue: Sa(et)
    }
}
function ib(_e, $) {
    var et = Sa($.value)
      , tt = Sa($.defaultValue);
    et != null && (et = "" + et,
    et !== _e.value && (_e.value = et),
    $.defaultValue == null && _e.defaultValue !== et && (_e.defaultValue = et)),
    tt != null && (_e.defaultValue = "" + tt)
}
function jb(_e) {
    var $ = _e.textContent;
    $ === _e._wrapperState.initialValue && $ !== "" && $ !== null && (_e.value = $)
}
function kb(_e) {
    switch (_e) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function lb(_e, $) {
    return _e == null || _e === "http://www.w3.org/1999/xhtml" ? kb($) : _e === "http://www.w3.org/2000/svg" && $ === "foreignObject" ? "http://www.w3.org/1999/xhtml" : _e
}
var mb, nb = function(_e) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function($, et, tt, nt) {
        MSApp.execUnsafeLocalFunction(function() {
            return _e($, et, tt, nt)
        })
    }
    : _e
}(function(_e, $) {
    if (_e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in _e)
        _e.innerHTML = $;
    else {
        for (mb = mb || document.createElement("div"),
        mb.innerHTML = "<svg>" + $.valueOf().toString() + "</svg>",
        $ = mb.firstChild; _e.firstChild; )
            _e.removeChild(_e.firstChild);
        for (; $.firstChild; )
            _e.appendChild($.firstChild)
    }
});
function ob(_e, $) {
    if ($) {
        var et = _e.firstChild;
        if (et && et === _e.lastChild && et.nodeType === 3) {
            et.nodeValue = $;
            return
        }
    }
    _e.textContent = $
}
var pb = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(_e) {
    qb.forEach(function($) {
        $ = $ + _e.charAt(0).toUpperCase() + _e.substring(1),
        pb[$] = pb[_e]
    })
});
function rb(_e, $, et) {
    return $ == null || typeof $ == "boolean" || $ === "" ? "" : et || typeof $ != "number" || $ === 0 || pb.hasOwnProperty(_e) && pb[_e] ? ("" + $).trim() : $ + "px"
}
function sb(_e, $) {
    _e = _e.style;
    for (var et in $)
        if ($.hasOwnProperty(et)) {
            var tt = et.indexOf("--") === 0
              , nt = rb(et, $[et], tt);
            et === "float" && (et = "cssFloat"),
            tt ? _e.setProperty(et, nt) : _e[et] = nt
        }
}
var tb = A$2({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function ub(_e, $) {
    if ($) {
        if (tb[_e] && ($.children != null || $.dangerouslySetInnerHTML != null))
            throw Error(p$2(137, _e));
        if ($.dangerouslySetInnerHTML != null) {
            if ($.children != null)
                throw Error(p$2(60));
            if (typeof $.dangerouslySetInnerHTML != "object" || !("__html"in $.dangerouslySetInnerHTML))
                throw Error(p$2(61))
        }
        if ($.style != null && typeof $.style != "object")
            throw Error(p$2(62))
    }
}
function vb(_e, $) {
    if (_e.indexOf("-") === -1)
        return typeof $.is == "string";
    switch (_e) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var wb = null;
function xb(_e) {
    return _e = _e.target || _e.srcElement || window,
    _e.correspondingUseElement && (_e = _e.correspondingUseElement),
    _e.nodeType === 3 ? _e.parentNode : _e
}
var yb = null
  , zb = null
  , Ab = null;
function Bb(_e) {
    if (_e = Cb(_e)) {
        if (typeof yb != "function")
            throw Error(p$2(280));
        var $ = _e.stateNode;
        $ && ($ = Db($),
        yb(_e.stateNode, _e.type, $))
    }
}
function Eb(_e) {
    zb ? Ab ? Ab.push(_e) : Ab = [_e] : zb = _e
}
function Fb() {
    if (zb) {
        var _e = zb
          , $ = Ab;
        if (Ab = zb = null,
        Bb(_e),
        $)
            for (_e = 0; _e < $.length; _e++)
                Bb($[_e])
    }
}
function Gb(_e, $) {
    return _e($)
}
function Hb() {}
var Ib = !1;
function Jb(_e, $, et) {
    if (Ib)
        return _e($, et);
    Ib = !0;
    try {
        return Gb(_e, $, et)
    } finally {
        Ib = !1,
        (zb !== null || Ab !== null) && (Hb(),
        Fb())
    }
}
function Kb(_e, $) {
    var et = _e.stateNode;
    if (et === null)
        return null;
    var tt = Db(et);
    if (tt === null)
        return null;
    et = tt[$];
    e: switch ($) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (tt = !tt.disabled) || (_e = _e.type,
        tt = !(_e === "button" || _e === "input" || _e === "select" || _e === "textarea")),
        _e = !tt;
        break e;
    default:
        _e = !1
    }
    if (_e)
        return null;
    if (et && typeof et != "function")
        throw Error(p$2(231, $, typeof et));
    return et
}
var Lb = !1;
if (ia)
    try {
        var Mb = {};
        Object.defineProperty(Mb, "passive", {
            get: function() {
                Lb = !0
            }
        }),
        window.addEventListener("test", Mb, Mb),
        window.removeEventListener("test", Mb, Mb)
    } catch {
        Lb = !1
    }
function Nb(_e, $, et, tt, nt, rt, it, ot, st) {
    var lt = Array.prototype.slice.call(arguments, 3);
    try {
        $.apply(et, lt)
    } catch (ct) {
        this.onError(ct)
    }
}
var Ob = !1
  , Pb = null
  , Qb = !1
  , Rb = null
  , Sb = {
    onError: function(_e) {
        Ob = !0,
        Pb = _e
    }
};
function Tb(_e, $, et, tt, nt, rt, it, ot, st) {
    Ob = !1,
    Pb = null,
    Nb.apply(Sb, arguments)
}
function Ub(_e, $, et, tt, nt, rt, it, ot, st) {
    if (Tb.apply(this, arguments),
    Ob) {
        if (Ob) {
            var lt = Pb;
            Ob = !1,
            Pb = null
        } else
            throw Error(p$2(198));
        Qb || (Qb = !0,
        Rb = lt)
    }
}
function Vb(_e) {
    var $ = _e
      , et = _e;
    if (_e.alternate)
        for (; $.return; )
            $ = $.return;
    else {
        _e = $;
        do
            $ = _e,
            $.flags & 4098 && (et = $.return),
            _e = $.return;
        while (_e)
    }
    return $.tag === 3 ? et : null
}
function Wb(_e) {
    if (_e.tag === 13) {
        var $ = _e.memoizedState;
        if ($ === null && (_e = _e.alternate,
        _e !== null && ($ = _e.memoizedState)),
        $ !== null)
            return $.dehydrated
    }
    return null
}
function Xb(_e) {
    if (Vb(_e) !== _e)
        throw Error(p$2(188))
}
function Yb(_e) {
    var $ = _e.alternate;
    if (!$) {
        if ($ = Vb(_e),
        $ === null)
            throw Error(p$2(188));
        return $ !== _e ? null : _e
    }
    for (var et = _e, tt = $; ; ) {
        var nt = et.return;
        if (nt === null)
            break;
        var rt = nt.alternate;
        if (rt === null) {
            if (tt = nt.return,
            tt !== null) {
                et = tt;
                continue
            }
            break
        }
        if (nt.child === rt.child) {
            for (rt = nt.child; rt; ) {
                if (rt === et)
                    return Xb(nt),
                    _e;
                if (rt === tt)
                    return Xb(nt),
                    $;
                rt = rt.sibling
            }
            throw Error(p$2(188))
        }
        if (et.return !== tt.return)
            et = nt,
            tt = rt;
        else {
            for (var it = !1, ot = nt.child; ot; ) {
                if (ot === et) {
                    it = !0,
                    et = nt,
                    tt = rt;
                    break
                }
                if (ot === tt) {
                    it = !0,
                    tt = nt,
                    et = rt;
                    break
                }
                ot = ot.sibling
            }
            if (!it) {
                for (ot = rt.child; ot; ) {
                    if (ot === et) {
                        it = !0,
                        et = rt,
                        tt = nt;
                        break
                    }
                    if (ot === tt) {
                        it = !0,
                        tt = rt,
                        et = nt;
                        break
                    }
                    ot = ot.sibling
                }
                if (!it)
                    throw Error(p$2(189))
            }
        }
        if (et.alternate !== tt)
            throw Error(p$2(190))
    }
    if (et.tag !== 3)
        throw Error(p$2(188));
    return et.stateNode.current === et ? _e : $
}
function Zb(_e) {
    return _e = Yb(_e),
    _e !== null ? $b(_e) : null
}
function $b(_e) {
    if (_e.tag === 5 || _e.tag === 6)
        return _e;
    for (_e = _e.child; _e !== null; ) {
        var $ = $b(_e);
        if ($ !== null)
            return $;
        _e = _e.sibling
    }
    return null
}
var ac = ca.unstable_scheduleCallback
  , bc = ca.unstable_cancelCallback
  , cc = ca.unstable_shouldYield
  , dc = ca.unstable_requestPaint
  , B = ca.unstable_now
  , ec = ca.unstable_getCurrentPriorityLevel
  , fc = ca.unstable_ImmediatePriority
  , gc = ca.unstable_UserBlockingPriority
  , hc = ca.unstable_NormalPriority
  , ic = ca.unstable_LowPriority
  , jc = ca.unstable_IdlePriority
  , kc = null
  , lc = null;
function mc(_e) {
    if (lc && typeof lc.onCommitFiberRoot == "function")
        try {
            lc.onCommitFiberRoot(kc, _e, void 0, (_e.current.flags & 128) === 128)
        } catch {}
}
var oc = Math.clz32 ? Math.clz32 : nc
  , pc = Math.log
  , qc = Math.LN2;
function nc(_e) {
    return _e >>>= 0,
    _e === 0 ? 32 : 31 - (pc(_e) / qc | 0) | 0
}
var rc = 64
  , sc = 4194304;
function tc(_e) {
    switch (_e & -_e) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return _e & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return _e & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return _e
    }
}
function uc(_e, $) {
    var et = _e.pendingLanes;
    if (et === 0)
        return 0;
    var tt = 0
      , nt = _e.suspendedLanes
      , rt = _e.pingedLanes
      , it = et & 268435455;
    if (it !== 0) {
        var ot = it & ~nt;
        ot !== 0 ? tt = tc(ot) : (rt &= it,
        rt !== 0 && (tt = tc(rt)))
    } else
        it = et & ~nt,
        it !== 0 ? tt = tc(it) : rt !== 0 && (tt = tc(rt));
    if (tt === 0)
        return 0;
    if ($ !== 0 && $ !== tt && !($ & nt) && (nt = tt & -tt,
    rt = $ & -$,
    nt >= rt || nt === 16 && (rt & 4194240) !== 0))
        return $;
    if (tt & 4 && (tt |= et & 16),
    $ = _e.entangledLanes,
    $ !== 0)
        for (_e = _e.entanglements,
        $ &= tt; 0 < $; )
            et = 31 - oc($),
            nt = 1 << et,
            tt |= _e[et],
            $ &= ~nt;
    return tt
}
function vc(_e, $) {
    switch (_e) {
    case 1:
    case 2:
    case 4:
        return $ + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return $ + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function wc(_e, $) {
    for (var et = _e.suspendedLanes, tt = _e.pingedLanes, nt = _e.expirationTimes, rt = _e.pendingLanes; 0 < rt; ) {
        var it = 31 - oc(rt)
          , ot = 1 << it
          , st = nt[it];
        st === -1 ? (!(ot & et) || ot & tt) && (nt[it] = vc(ot, $)) : st <= $ && (_e.expiredLanes |= ot),
        rt &= ~ot
    }
}
function xc(_e) {
    return _e = _e.pendingLanes & -1073741825,
    _e !== 0 ? _e : _e & 1073741824 ? 1073741824 : 0
}
function yc() {
    var _e = rc;
    return rc <<= 1,
    !(rc & 4194240) && (rc = 64),
    _e
}
function zc(_e) {
    for (var $ = [], et = 0; 31 > et; et++)
        $.push(_e);
    return $
}
function Ac(_e, $, et) {
    _e.pendingLanes |= $,
    $ !== 536870912 && (_e.suspendedLanes = 0,
    _e.pingedLanes = 0),
    _e = _e.eventTimes,
    $ = 31 - oc($),
    _e[$] = et
}
function Bc(_e, $) {
    var et = _e.pendingLanes & ~$;
    _e.pendingLanes = $,
    _e.suspendedLanes = 0,
    _e.pingedLanes = 0,
    _e.expiredLanes &= $,
    _e.mutableReadLanes &= $,
    _e.entangledLanes &= $,
    $ = _e.entanglements;
    var tt = _e.eventTimes;
    for (_e = _e.expirationTimes; 0 < et; ) {
        var nt = 31 - oc(et)
          , rt = 1 << nt;
        $[nt] = 0,
        tt[nt] = -1,
        _e[nt] = -1,
        et &= ~rt
    }
}
function Cc(_e, $) {
    var et = _e.entangledLanes |= $;
    for (_e = _e.entanglements; et; ) {
        var tt = 31 - oc(et)
          , nt = 1 << tt;
        nt & $ | _e[tt] & $ && (_e[tt] |= $),
        et &= ~nt
    }
}
var C$1 = 0;
function Dc(_e) {
    return _e &= -_e,
    1 < _e ? 4 < _e ? _e & 268435455 ? 16 : 536870912 : 4 : 1
}
var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = new Map, Pc = new Map, Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(_e, $) {
    switch (_e) {
    case "focusin":
    case "focusout":
        Lc = null;
        break;
    case "dragenter":
    case "dragleave":
        Mc = null;
        break;
    case "mouseover":
    case "mouseout":
        Nc = null;
        break;
    case "pointerover":
    case "pointerout":
        Oc.delete($.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        Pc.delete($.pointerId)
    }
}
function Tc(_e, $, et, tt, nt, rt) {
    return _e === null || _e.nativeEvent !== rt ? (_e = {
        blockedOn: $,
        domEventName: et,
        eventSystemFlags: tt,
        nativeEvent: rt,
        targetContainers: [nt]
    },
    $ !== null && ($ = Cb($),
    $ !== null && Fc($)),
    _e) : (_e.eventSystemFlags |= tt,
    $ = _e.targetContainers,
    nt !== null && $.indexOf(nt) === -1 && $.push(nt),
    _e)
}
function Uc(_e, $, et, tt, nt) {
    switch ($) {
    case "focusin":
        return Lc = Tc(Lc, _e, $, et, tt, nt),
        !0;
    case "dragenter":
        return Mc = Tc(Mc, _e, $, et, tt, nt),
        !0;
    case "mouseover":
        return Nc = Tc(Nc, _e, $, et, tt, nt),
        !0;
    case "pointerover":
        var rt = nt.pointerId;
        return Oc.set(rt, Tc(Oc.get(rt) || null, _e, $, et, tt, nt)),
        !0;
    case "gotpointercapture":
        return rt = nt.pointerId,
        Pc.set(rt, Tc(Pc.get(rt) || null, _e, $, et, tt, nt)),
        !0
    }
    return !1
}
function Vc(_e) {
    var $ = Wc(_e.target);
    if ($ !== null) {
        var et = Vb($);
        if (et !== null) {
            if ($ = et.tag,
            $ === 13) {
                if ($ = Wb(et),
                $ !== null) {
                    _e.blockedOn = $,
                    Ic(_e.priority, function() {
                        Gc(et)
                    });
                    return
                }
            } else if ($ === 3 && et.stateNode.current.memoizedState.isDehydrated) {
                _e.blockedOn = et.tag === 3 ? et.stateNode.containerInfo : null;
                return
            }
        }
    }
    _e.blockedOn = null
}
function Xc(_e) {
    if (_e.blockedOn !== null)
        return !1;
    for (var $ = _e.targetContainers; 0 < $.length; ) {
        var et = Yc(_e.domEventName, _e.eventSystemFlags, $[0], _e.nativeEvent);
        if (et === null) {
            et = _e.nativeEvent;
            var tt = new et.constructor(et.type,et);
            wb = tt,
            et.target.dispatchEvent(tt),
            wb = null
        } else
            return $ = Cb(et),
            $ !== null && Fc($),
            _e.blockedOn = et,
            !1;
        $.shift()
    }
    return !0
}
function Zc(_e, $, et) {
    Xc(_e) && et.delete($)
}
function $c() {
    Jc = !1,
    Lc !== null && Xc(Lc) && (Lc = null),
    Mc !== null && Xc(Mc) && (Mc = null),
    Nc !== null && Xc(Nc) && (Nc = null),
    Oc.forEach(Zc),
    Pc.forEach(Zc)
}
function ad(_e, $) {
    _e.blockedOn === $ && (_e.blockedOn = null,
    Jc || (Jc = !0,
    ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)))
}
function bd(_e) {
    function $(nt) {
        return ad(nt, _e)
    }
    if (0 < Kc.length) {
        ad(Kc[0], _e);
        for (var et = 1; et < Kc.length; et++) {
            var tt = Kc[et];
            tt.blockedOn === _e && (tt.blockedOn = null)
        }
    }
    for (Lc !== null && ad(Lc, _e),
    Mc !== null && ad(Mc, _e),
    Nc !== null && ad(Nc, _e),
    Oc.forEach($),
    Pc.forEach($),
    et = 0; et < Qc.length; et++)
        tt = Qc[et],
        tt.blockedOn === _e && (tt.blockedOn = null);
    for (; 0 < Qc.length && (et = Qc[0],
    et.blockedOn === null); )
        Vc(et),
        et.blockedOn === null && Qc.shift()
}
var cd = ua.ReactCurrentBatchConfig
  , dd = !0;
function ed(_e, $, et, tt) {
    var nt = C$1
      , rt = cd.transition;
    cd.transition = null;
    try {
        C$1 = 1,
        fd(_e, $, et, tt)
    } finally {
        C$1 = nt,
        cd.transition = rt
    }
}
function gd(_e, $, et, tt) {
    var nt = C$1
      , rt = cd.transition;
    cd.transition = null;
    try {
        C$1 = 4,
        fd(_e, $, et, tt)
    } finally {
        C$1 = nt,
        cd.transition = rt
    }
}
function fd(_e, $, et, tt) {
    if (dd) {
        var nt = Yc(_e, $, et, tt);
        if (nt === null)
            hd(_e, $, tt, id$2, et),
            Sc(_e, tt);
        else if (Uc(nt, _e, $, et, tt))
            tt.stopPropagation();
        else if (Sc(_e, tt),
        $ & 4 && -1 < Rc.indexOf(_e)) {
            for (; nt !== null; ) {
                var rt = Cb(nt);
                if (rt !== null && Ec(rt),
                rt = Yc(_e, $, et, tt),
                rt === null && hd(_e, $, tt, id$2, et),
                rt === nt)
                    break;
                nt = rt
            }
            nt !== null && tt.stopPropagation()
        } else
            hd(_e, $, tt, null, et)
    }
}
var id$2 = null;
function Yc(_e, $, et, tt) {
    if (id$2 = null,
    _e = xb(tt),
    _e = Wc(_e),
    _e !== null)
        if ($ = Vb(_e),
        $ === null)
            _e = null;
        else if (et = $.tag,
        et === 13) {
            if (_e = Wb($),
            _e !== null)
                return _e;
            _e = null
        } else if (et === 3) {
            if ($.stateNode.current.memoizedState.isDehydrated)
                return $.tag === 3 ? $.stateNode.containerInfo : null;
            _e = null
        } else
            $ !== _e && (_e = null);
    return id$2 = _e,
    null
}
function jd(_e) {
    switch (_e) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (ec()) {
        case fc:
            return 1;
        case gc:
            return 4;
        case hc:
        case ic:
            return 16;
        case jc:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var kd = null
  , ld = null
  , md = null;
function nd() {
    if (md)
        return md;
    var _e, $ = ld, et = $.length, tt, nt = "value"in kd ? kd.value : kd.textContent, rt = nt.length;
    for (_e = 0; _e < et && $[_e] === nt[_e]; _e++)
        ;
    var it = et - _e;
    for (tt = 1; tt <= it && $[et - tt] === nt[rt - tt]; tt++)
        ;
    return md = nt.slice(_e, 1 < tt ? 1 - tt : void 0)
}
function od(_e) {
    var $ = _e.keyCode;
    return "charCode"in _e ? (_e = _e.charCode,
    _e === 0 && $ === 13 && (_e = 13)) : _e = $,
    _e === 10 && (_e = 13),
    32 <= _e || _e === 13 ? _e : 0
}
function pd() {
    return !0
}
function qd() {
    return !1
}
function rd(_e) {
    function $(et, tt, nt, rt, it) {
        this._reactName = et,
        this._targetInst = nt,
        this.type = tt,
        this.nativeEvent = rt,
        this.target = it,
        this.currentTarget = null;
        for (var ot in _e)
            _e.hasOwnProperty(ot) && (et = _e[ot],
            this[ot] = et ? et(rt) : rt[ot]);
        return this.isDefaultPrevented = (rt.defaultPrevented != null ? rt.defaultPrevented : rt.returnValue === !1) ? pd : qd,
        this.isPropagationStopped = qd,
        this
    }
    return A$2($.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var et = this.nativeEvent;
            et && (et.preventDefault ? et.preventDefault() : typeof et.returnValue != "unknown" && (et.returnValue = !1),
            this.isDefaultPrevented = pd)
        },
        stopPropagation: function() {
            var et = this.nativeEvent;
            et && (et.stopPropagation ? et.stopPropagation() : typeof et.cancelBubble != "unknown" && (et.cancelBubble = !0),
            this.isPropagationStopped = pd)
        },
        persist: function() {},
        isPersistent: pd
    }),
    $
}
var sd = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(_e) {
        return _e.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, td = rd(sd), ud = A$2({}, sd, {
    view: 0,
    detail: 0
}), vd = rd(ud), wd, xd, yd, Ad = A$2({}, ud, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: zd,
    button: 0,
    buttons: 0,
    relatedTarget: function(_e) {
        return _e.relatedTarget === void 0 ? _e.fromElement === _e.srcElement ? _e.toElement : _e.fromElement : _e.relatedTarget
    },
    movementX: function(_e) {
        return "movementX"in _e ? _e.movementX : (_e !== yd && (yd && _e.type === "mousemove" ? (wd = _e.screenX - yd.screenX,
        xd = _e.screenY - yd.screenY) : xd = wd = 0,
        yd = _e),
        wd)
    },
    movementY: function(_e) {
        return "movementY"in _e ? _e.movementY : xd
    }
}), Bd = rd(Ad), Cd = A$2({}, Ad, {
    dataTransfer: 0
}), Dd = rd(Cd), Ed = A$2({}, ud, {
    relatedTarget: 0
}), Fd = rd(Ed), Gd = A$2({}, sd, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), Hd = rd(Gd), Id = A$2({}, sd, {
    clipboardData: function(_e) {
        return "clipboardData"in _e ? _e.clipboardData : window.clipboardData
    }
}), Jd = rd(Id), Kd = A$2({}, sd, {
    data: 0
}), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, Od = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function Pd(_e) {
    var $ = this.nativeEvent;
    return $.getModifierState ? $.getModifierState(_e) : (_e = Od[_e]) ? !!$[_e] : !1
}
function zd() {
    return Pd
}
var Qd = A$2({}, ud, {
    key: function(_e) {
        if (_e.key) {
            var $ = Md[_e.key] || _e.key;
            if ($ !== "Unidentified")
                return $
        }
        return _e.type === "keypress" ? (_e = od(_e),
        _e === 13 ? "Enter" : String.fromCharCode(_e)) : _e.type === "keydown" || _e.type === "keyup" ? Nd[_e.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: zd,
    charCode: function(_e) {
        return _e.type === "keypress" ? od(_e) : 0
    },
    keyCode: function(_e) {
        return _e.type === "keydown" || _e.type === "keyup" ? _e.keyCode : 0
    },
    which: function(_e) {
        return _e.type === "keypress" ? od(_e) : _e.type === "keydown" || _e.type === "keyup" ? _e.keyCode : 0
    }
})
  , Rd = rd(Qd)
  , Sd = A$2({}, Ad, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , Td = rd(Sd)
  , Ud = A$2({}, ud, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: zd
})
  , Vd = rd(Ud)
  , Wd = A$2({}, sd, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , Xd = rd(Wd)
  , Yd = A$2({}, Ad, {
    deltaX: function(_e) {
        return "deltaX"in _e ? _e.deltaX : "wheelDeltaX"in _e ? -_e.wheelDeltaX : 0
    },
    deltaY: function(_e) {
        return "deltaY"in _e ? _e.deltaY : "wheelDeltaY"in _e ? -_e.wheelDeltaY : "wheelDelta"in _e ? -_e.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , Zd = rd(Yd)
  , $d = [9, 13, 27, 32]
  , ae = ia && "CompositionEvent"in window
  , be$1 = null;
ia && "documentMode"in document && (be$1 = document.documentMode);
var ce = ia && "TextEvent"in window && !be$1
  , de$1 = ia && (!ae || be$1 && 8 < be$1 && 11 >= be$1)
  , ee$1 = " "
  , fe$1 = !1;
function ge$1(_e, $) {
    switch (_e) {
    case "keyup":
        return $d.indexOf($.keyCode) !== -1;
    case "keydown":
        return $.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function he$1(_e) {
    return _e = _e.detail,
    typeof _e == "object" && "data"in _e ? _e.data : null
}
var ie = !1;
function je(_e, $) {
    switch (_e) {
    case "compositionend":
        return he$1($);
    case "keypress":
        return $.which !== 32 ? null : (fe$1 = !0,
        ee$1);
    case "textInput":
        return _e = $.data,
        _e === ee$1 && fe$1 ? null : _e;
    default:
        return null
    }
}
function ke(_e, $) {
    if (ie)
        return _e === "compositionend" || !ae && ge$1(_e, $) ? (_e = nd(),
        md = ld = kd = null,
        ie = !1,
        _e) : null;
    switch (_e) {
    case "paste":
        return null;
    case "keypress":
        if (!($.ctrlKey || $.altKey || $.metaKey) || $.ctrlKey && $.altKey) {
            if ($.char && 1 < $.char.length)
                return $.char;
            if ($.which)
                return String.fromCharCode($.which)
        }
        return null;
    case "compositionend":
        return de$1 && $.locale !== "ko" ? null : $.data;
    default:
        return null
    }
}
var le$1 = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function me(_e) {
    var $ = _e && _e.nodeName && _e.nodeName.toLowerCase();
    return $ === "input" ? !!le$1[_e.type] : $ === "textarea"
}
function ne$1(_e, $, et, tt) {
    Eb(tt),
    $ = oe$1($, "onChange"),
    0 < $.length && (et = new td("onChange","change",null,et,tt),
    _e.push({
        event: et,
        listeners: $
    }))
}
var pe$1 = null
  , qe = null;
function re$1(_e) {
    se$1(_e, 0)
}
function te(_e) {
    var $ = ue$1(_e);
    if (Wa($))
        return _e
}
function ve$1(_e, $) {
    if (_e === "change")
        return $
}
var we = !1;
if (ia) {
    var xe$1;
    if (ia) {
        var ye$1 = "oninput"in document;
        if (!ye$1) {
            var ze = document.createElement("div");
            ze.setAttribute("oninput", "return;"),
            ye$1 = typeof ze.oninput == "function"
        }
        xe$1 = ye$1
    } else
        xe$1 = !1;
    we = xe$1 && (!document.documentMode || 9 < document.documentMode)
}
function Ae$1() {
    pe$1 && (pe$1.detachEvent("onpropertychange", Be),
    qe = pe$1 = null)
}
function Be(_e) {
    if (_e.propertyName === "value" && te(qe)) {
        var $ = [];
        ne$1($, qe, _e, xb(_e)),
        Jb(re$1, $)
    }
}
function Ce(_e, $, et) {
    _e === "focusin" ? (Ae$1(),
    pe$1 = $,
    qe = et,
    pe$1.attachEvent("onpropertychange", Be)) : _e === "focusout" && Ae$1()
}
function De$1(_e) {
    if (_e === "selectionchange" || _e === "keyup" || _e === "keydown")
        return te(qe)
}
function Ee$1(_e, $) {
    if (_e === "click")
        return te($)
}
function Fe(_e, $) {
    if (_e === "input" || _e === "change")
        return te($)
}
function Ge(_e, $) {
    return _e === $ && (_e !== 0 || 1 / _e === 1 / $) || _e !== _e && $ !== $
}
var He = typeof Object.is == "function" ? Object.is : Ge;
function Ie(_e, $) {
    if (He(_e, $))
        return !0;
    if (typeof _e != "object" || _e === null || typeof $ != "object" || $ === null)
        return !1;
    var et = Object.keys(_e)
      , tt = Object.keys($);
    if (et.length !== tt.length)
        return !1;
    for (tt = 0; tt < et.length; tt++) {
        var nt = et[tt];
        if (!ja$1.call($, nt) || !He(_e[nt], $[nt]))
            return !1
    }
    return !0
}
function Je(_e) {
    for (; _e && _e.firstChild; )
        _e = _e.firstChild;
    return _e
}
function Ke(_e, $) {
    var et = Je(_e);
    _e = 0;
    for (var tt; et; ) {
        if (et.nodeType === 3) {
            if (tt = _e + et.textContent.length,
            _e <= $ && tt >= $)
                return {
                    node: et,
                    offset: $ - _e
                };
            _e = tt
        }
        e: {
            for (; et; ) {
                if (et.nextSibling) {
                    et = et.nextSibling;
                    break e
                }
                et = et.parentNode
            }
            et = void 0
        }
        et = Je(et)
    }
}
function Le(_e, $) {
    return _e && $ ? _e === $ ? !0 : _e && _e.nodeType === 3 ? !1 : $ && $.nodeType === 3 ? Le(_e, $.parentNode) : "contains"in _e ? _e.contains($) : _e.compareDocumentPosition ? !!(_e.compareDocumentPosition($) & 16) : !1 : !1
}
function Me() {
    for (var _e = window, $ = Xa(); $ instanceof _e.HTMLIFrameElement; ) {
        try {
            var et = typeof $.contentWindow.location.href == "string"
        } catch {
            et = !1
        }
        if (et)
            _e = $.contentWindow;
        else
            break;
        $ = Xa(_e.document)
    }
    return $
}
function Ne(_e) {
    var $ = _e && _e.nodeName && _e.nodeName.toLowerCase();
    return $ && ($ === "input" && (_e.type === "text" || _e.type === "search" || _e.type === "tel" || _e.type === "url" || _e.type === "password") || $ === "textarea" || _e.contentEditable === "true")
}
function Oe$1(_e) {
    var $ = Me()
      , et = _e.focusedElem
      , tt = _e.selectionRange;
    if ($ !== et && et && et.ownerDocument && Le(et.ownerDocument.documentElement, et)) {
        if (tt !== null && Ne(et)) {
            if ($ = tt.start,
            _e = tt.end,
            _e === void 0 && (_e = $),
            "selectionStart"in et)
                et.selectionStart = $,
                et.selectionEnd = Math.min(_e, et.value.length);
            else if (_e = ($ = et.ownerDocument || document) && $.defaultView || window,
            _e.getSelection) {
                _e = _e.getSelection();
                var nt = et.textContent.length
                  , rt = Math.min(tt.start, nt);
                tt = tt.end === void 0 ? rt : Math.min(tt.end, nt),
                !_e.extend && rt > tt && (nt = tt,
                tt = rt,
                rt = nt),
                nt = Ke(et, rt);
                var it = Ke(et, tt);
                nt && it && (_e.rangeCount !== 1 || _e.anchorNode !== nt.node || _e.anchorOffset !== nt.offset || _e.focusNode !== it.node || _e.focusOffset !== it.offset) && ($ = $.createRange(),
                $.setStart(nt.node, nt.offset),
                _e.removeAllRanges(),
                rt > tt ? (_e.addRange($),
                _e.extend(it.node, it.offset)) : ($.setEnd(it.node, it.offset),
                _e.addRange($)))
            }
        }
        for ($ = [],
        _e = et; _e = _e.parentNode; )
            _e.nodeType === 1 && $.push({
                element: _e,
                left: _e.scrollLeft,
                top: _e.scrollTop
            });
        for (typeof et.focus == "function" && et.focus(),
        et = 0; et < $.length; et++)
            _e = $[et],
            _e.element.scrollLeft = _e.left,
            _e.element.scrollTop = _e.top
    }
}
var Pe = ia && "documentMode"in document && 11 >= document.documentMode
  , Qe = null
  , Re = null
  , Se$1 = null
  , Te$1 = !1;
function Ue(_e, $, et) {
    var tt = et.window === et ? et.document : et.nodeType === 9 ? et : et.ownerDocument;
    Te$1 || Qe == null || Qe !== Xa(tt) || (tt = Qe,
    "selectionStart"in tt && Ne(tt) ? tt = {
        start: tt.selectionStart,
        end: tt.selectionEnd
    } : (tt = (tt.ownerDocument && tt.ownerDocument.defaultView || window).getSelection(),
    tt = {
        anchorNode: tt.anchorNode,
        anchorOffset: tt.anchorOffset,
        focusNode: tt.focusNode,
        focusOffset: tt.focusOffset
    }),
    Se$1 && Ie(Se$1, tt) || (Se$1 = tt,
    tt = oe$1(Re, "onSelect"),
    0 < tt.length && ($ = new td("onSelect","select",null,$,et),
    _e.push({
        event: $,
        listeners: tt
    }),
    $.target = Qe)))
}
function Ve(_e, $) {
    var et = {};
    return et[_e.toLowerCase()] = $.toLowerCase(),
    et["Webkit" + _e] = "webkit" + $,
    et["Moz" + _e] = "moz" + $,
    et
}
var We = {
    animationend: Ve("Animation", "AnimationEnd"),
    animationiteration: Ve("Animation", "AnimationIteration"),
    animationstart: Ve("Animation", "AnimationStart"),
    transitionend: Ve("Transition", "TransitionEnd")
}
  , Xe = {}
  , Ye = {};
ia && (Ye = document.createElement("div").style,
"AnimationEvent"in window || (delete We.animationend.animation,
delete We.animationiteration.animation,
delete We.animationstart.animation),
"TransitionEvent"in window || delete We.transitionend.transition);
function Ze(_e) {
    if (Xe[_e])
        return Xe[_e];
    if (!We[_e])
        return _e;
    var $ = We[_e], et;
    for (et in $)
        if ($.hasOwnProperty(et) && et in Ye)
            return Xe[_e] = $[et];
    return _e
}
var $e = Ze("animationend")
  , af = Ze("animationiteration")
  , bf = Ze("animationstart")
  , cf = Ze("transitionend")
  , df = new Map
  , ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(_e, $) {
    df.set(_e, $),
    fa($, [_e])
}
for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf]
      , jf = hf.toLowerCase()
      , kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf)
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(_e, $, et) {
    var tt = _e.type || "unknown-event";
    _e.currentTarget = et,
    Ub(tt, $, void 0, _e),
    _e.currentTarget = null
}
function se$1(_e, $) {
    $ = ($ & 4) !== 0;
    for (var et = 0; et < _e.length; et++) {
        var tt = _e[et]
          , nt = tt.event;
        tt = tt.listeners;
        e: {
            var rt = void 0;
            if ($)
                for (var it = tt.length - 1; 0 <= it; it--) {
                    var ot = tt[it]
                      , st = ot.instance
                      , lt = ot.currentTarget;
                    if (ot = ot.listener,
                    st !== rt && nt.isPropagationStopped())
                        break e;
                    nf(nt, ot, lt),
                    rt = st
                }
            else
                for (it = 0; it < tt.length; it++) {
                    if (ot = tt[it],
                    st = ot.instance,
                    lt = ot.currentTarget,
                    ot = ot.listener,
                    st !== rt && nt.isPropagationStopped())
                        break e;
                    nf(nt, ot, lt),
                    rt = st
                }
        }
    }
    if (Qb)
        throw _e = Rb,
        Qb = !1,
        Rb = null,
        _e
}
function D$1(_e, $) {
    var et = $[of];
    et === void 0 && (et = $[of] = new Set);
    var tt = _e + "__bubble";
    et.has(tt) || (pf($, _e, 2, !1),
    et.add(tt))
}
function qf(_e, $, et) {
    var tt = 0;
    $ && (tt |= 4),
    pf(et, _e, tt, $)
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(_e) {
    if (!_e[rf]) {
        _e[rf] = !0,
        da.forEach(function(et) {
            et !== "selectionchange" && (mf.has(et) || qf(et, !1, _e),
            qf(et, !0, _e))
        });
        var $ = _e.nodeType === 9 ? _e : _e.ownerDocument;
        $ === null || $[rf] || ($[rf] = !0,
        qf("selectionchange", !1, $))
    }
}
function pf(_e, $, et, tt) {
    switch (jd($)) {
    case 1:
        var nt = ed;
        break;
    case 4:
        nt = gd;
        break;
    default:
        nt = fd
    }
    et = nt.bind(null, $, et, _e),
    nt = void 0,
    !Lb || $ !== "touchstart" && $ !== "touchmove" && $ !== "wheel" || (nt = !0),
    tt ? nt !== void 0 ? _e.addEventListener($, et, {
        capture: !0,
        passive: nt
    }) : _e.addEventListener($, et, !0) : nt !== void 0 ? _e.addEventListener($, et, {
        passive: nt
    }) : _e.addEventListener($, et, !1)
}
function hd(_e, $, et, tt, nt) {
    var rt = tt;
    if (!($ & 1) && !($ & 2) && tt !== null)
        e: for (; ; ) {
            if (tt === null)
                return;
            var it = tt.tag;
            if (it === 3 || it === 4) {
                var ot = tt.stateNode.containerInfo;
                if (ot === nt || ot.nodeType === 8 && ot.parentNode === nt)
                    break;
                if (it === 4)
                    for (it = tt.return; it !== null; ) {
                        var st = it.tag;
                        if ((st === 3 || st === 4) && (st = it.stateNode.containerInfo,
                        st === nt || st.nodeType === 8 && st.parentNode === nt))
                            return;
                        it = it.return
                    }
                for (; ot !== null; ) {
                    if (it = Wc(ot),
                    it === null)
                        return;
                    if (st = it.tag,
                    st === 5 || st === 6) {
                        tt = rt = it;
                        continue e
                    }
                    ot = ot.parentNode
                }
            }
            tt = tt.return
        }
    Jb(function() {
        var lt = rt
          , ct = xb(et)
          , dt = [];
        e: {
            var pt = df.get(_e);
            if (pt !== void 0) {
                var ht = td
                  , mt = _e;
                switch (_e) {
                case "keypress":
                    if (od(et) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    ht = Rd;
                    break;
                case "focusin":
                    mt = "focus",
                    ht = Fd;
                    break;
                case "focusout":
                    mt = "blur",
                    ht = Fd;
                    break;
                case "beforeblur":
                case "afterblur":
                    ht = Fd;
                    break;
                case "click":
                    if (et.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    ht = Bd;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    ht = Dd;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    ht = Vd;
                    break;
                case $e:
                case af:
                case bf:
                    ht = Hd;
                    break;
                case cf:
                    ht = Xd;
                    break;
                case "scroll":
                    ht = vd;
                    break;
                case "wheel":
                    ht = Zd;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    ht = Jd;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    ht = Td
                }
                var yt = ($ & 4) !== 0
                  , Et = !yt && _e === "scroll"
                  , _t = yt ? pt !== null ? pt + "Capture" : null : pt;
                yt = [];
                for (var wt = lt, St; wt !== null; ) {
                    St = wt;
                    var Ct = St.stateNode;
                    if (St.tag === 5 && Ct !== null && (St = Ct,
                    _t !== null && (Ct = Kb(wt, _t),
                    Ct != null && yt.push(tf(wt, Ct, St)))),
                    Et)
                        break;
                    wt = wt.return
                }
                0 < yt.length && (pt = new ht(pt,mt,null,et,ct),
                dt.push({
                    event: pt,
                    listeners: yt
                }))
            }
        }
        if (!($ & 7)) {
            e: {
                if (pt = _e === "mouseover" || _e === "pointerover",
                ht = _e === "mouseout" || _e === "pointerout",
                pt && et !== wb && (mt = et.relatedTarget || et.fromElement) && (Wc(mt) || mt[uf]))
                    break e;
                if ((ht || pt) && (pt = ct.window === ct ? ct : (pt = ct.ownerDocument) ? pt.defaultView || pt.parentWindow : window,
                ht ? (mt = et.relatedTarget || et.toElement,
                ht = lt,
                mt = mt ? Wc(mt) : null,
                mt !== null && (Et = Vb(mt),
                mt !== Et || mt.tag !== 5 && mt.tag !== 6) && (mt = null)) : (ht = null,
                mt = lt),
                ht !== mt)) {
                    if (yt = Bd,
                    Ct = "onMouseLeave",
                    _t = "onMouseEnter",
                    wt = "mouse",
                    (_e === "pointerout" || _e === "pointerover") && (yt = Td,
                    Ct = "onPointerLeave",
                    _t = "onPointerEnter",
                    wt = "pointer"),
                    Et = ht == null ? pt : ue$1(ht),
                    St = mt == null ? pt : ue$1(mt),
                    pt = new yt(Ct,wt + "leave",ht,et,ct),
                    pt.target = Et,
                    pt.relatedTarget = St,
                    Ct = null,
                    Wc(ct) === lt && (yt = new yt(_t,wt + "enter",mt,et,ct),
                    yt.target = St,
                    yt.relatedTarget = Et,
                    Ct = yt),
                    Et = Ct,
                    ht && mt)
                        t: {
                            for (yt = ht,
                            _t = mt,
                            wt = 0,
                            St = yt; St; St = vf(St))
                                wt++;
                            for (St = 0,
                            Ct = _t; Ct; Ct = vf(Ct))
                                St++;
                            for (; 0 < wt - St; )
                                yt = vf(yt),
                                wt--;
                            for (; 0 < St - wt; )
                                _t = vf(_t),
                                St--;
                            for (; wt--; ) {
                                if (yt === _t || _t !== null && yt === _t.alternate)
                                    break t;
                                yt = vf(yt),
                                _t = vf(_t)
                            }
                            yt = null
                        }
                    else
                        yt = null;
                    ht !== null && wf(dt, pt, ht, yt, !1),
                    mt !== null && Et !== null && wf(dt, Et, mt, yt, !0)
                }
            }
            e: {
                if (pt = lt ? ue$1(lt) : window,
                ht = pt.nodeName && pt.nodeName.toLowerCase(),
                ht === "select" || ht === "input" && pt.type === "file")
                    var Nt = ve$1;
                else if (me(pt))
                    if (we)
                        Nt = Fe;
                    else {
                        Nt = De$1;
                        var Lt = Ce
                    }
                else
                    (ht = pt.nodeName) && ht.toLowerCase() === "input" && (pt.type === "checkbox" || pt.type === "radio") && (Nt = Ee$1);
                if (Nt && (Nt = Nt(_e, lt))) {
                    ne$1(dt, Nt, et, ct);
                    break e
                }
                Lt && Lt(_e, pt, lt),
                _e === "focusout" && (Lt = pt._wrapperState) && Lt.controlled && pt.type === "number" && cb(pt, "number", pt.value)
            }
            switch (Lt = lt ? ue$1(lt) : window,
            _e) {
            case "focusin":
                (me(Lt) || Lt.contentEditable === "true") && (Qe = Lt,
                Re = lt,
                Se$1 = null);
                break;
            case "focusout":
                Se$1 = Re = Qe = null;
                break;
            case "mousedown":
                Te$1 = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                Te$1 = !1,
                Ue(dt, et, ct);
                break;
            case "selectionchange":
                if (Pe)
                    break;
            case "keydown":
            case "keyup":
                Ue(dt, et, ct)
            }
            var kt;
            if (ae)
                e: {
                    switch (_e) {
                    case "compositionstart":
                        var Ut = "onCompositionStart";
                        break e;
                    case "compositionend":
                        Ut = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        Ut = "onCompositionUpdate";
                        break e
                    }
                    Ut = void 0
                }
            else
                ie ? ge$1(_e, et) && (Ut = "onCompositionEnd") : _e === "keydown" && et.keyCode === 229 && (Ut = "onCompositionStart");
            Ut && (de$1 && et.locale !== "ko" && (ie || Ut !== "onCompositionStart" ? Ut === "onCompositionEnd" && ie && (kt = nd()) : (kd = ct,
            ld = "value"in kd ? kd.value : kd.textContent,
            ie = !0)),
            Lt = oe$1(lt, Ut),
            0 < Lt.length && (Ut = new Ld(Ut,_e,null,et,ct),
            dt.push({
                event: Ut,
                listeners: Lt
            }),
            kt ? Ut.data = kt : (kt = he$1(et),
            kt !== null && (Ut.data = kt)))),
            (kt = ce ? je(_e, et) : ke(_e, et)) && (lt = oe$1(lt, "onBeforeInput"),
            0 < lt.length && (ct = new Ld("onBeforeInput","beforeinput",null,et,ct),
            dt.push({
                event: ct,
                listeners: lt
            }),
            ct.data = kt))
        }
        se$1(dt, $)
    })
}
function tf(_e, $, et) {
    return {
        instance: _e,
        listener: $,
        currentTarget: et
    }
}
function oe$1(_e, $) {
    for (var et = $ + "Capture", tt = []; _e !== null; ) {
        var nt = _e
          , rt = nt.stateNode;
        nt.tag === 5 && rt !== null && (nt = rt,
        rt = Kb(_e, et),
        rt != null && tt.unshift(tf(_e, rt, nt)),
        rt = Kb(_e, $),
        rt != null && tt.push(tf(_e, rt, nt))),
        _e = _e.return
    }
    return tt
}
function vf(_e) {
    if (_e === null)
        return null;
    do
        _e = _e.return;
    while (_e && _e.tag !== 5);
    return _e || null
}
function wf(_e, $, et, tt, nt) {
    for (var rt = $._reactName, it = []; et !== null && et !== tt; ) {
        var ot = et
          , st = ot.alternate
          , lt = ot.stateNode;
        if (st !== null && st === tt)
            break;
        ot.tag === 5 && lt !== null && (ot = lt,
        nt ? (st = Kb(et, rt),
        st != null && it.unshift(tf(et, st, ot))) : nt || (st = Kb(et, rt),
        st != null && it.push(tf(et, st, ot)))),
        et = et.return
    }
    it.length !== 0 && _e.push({
        event: $,
        listeners: it
    })
}
var xf = /\r\n?/g
  , yf = /\u0000|\uFFFD/g;
function zf(_e) {
    return (typeof _e == "string" ? _e : "" + _e).replace(xf, `
`).replace(yf, "")
}
function Af(_e, $, et) {
    if ($ = zf($),
    zf(_e) !== $ && et)
        throw Error(p$2(425))
}
function Bf() {}
var Cf = null
  , Df = null;
function Ef(_e, $) {
    return _e === "textarea" || _e === "noscript" || typeof $.children == "string" || typeof $.children == "number" || typeof $.dangerouslySetInnerHTML == "object" && $.dangerouslySetInnerHTML !== null && $.dangerouslySetInnerHTML.__html != null
}
var Ff = typeof setTimeout == "function" ? setTimeout : void 0
  , Gf = typeof clearTimeout == "function" ? clearTimeout : void 0
  , Hf = typeof Promise == "function" ? Promise : void 0
  , Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(_e) {
    return Hf.resolve(null).then(_e).catch(If)
}
: Ff;
function If(_e) {
    setTimeout(function() {
        throw _e
    })
}
function Kf(_e, $) {
    var et = $
      , tt = 0;
    do {
        var nt = et.nextSibling;
        if (_e.removeChild(et),
        nt && nt.nodeType === 8)
            if (et = nt.data,
            et === "/$") {
                if (tt === 0) {
                    _e.removeChild(nt),
                    bd($);
                    return
                }
                tt--
            } else
                et !== "$" && et !== "$?" && et !== "$!" || tt++;
        et = nt
    } while (et);
    bd($)
}
function Lf(_e) {
    for (; _e != null; _e = _e.nextSibling) {
        var $ = _e.nodeType;
        if ($ === 1 || $ === 3)
            break;
        if ($ === 8) {
            if ($ = _e.data,
            $ === "$" || $ === "$!" || $ === "$?")
                break;
            if ($ === "/$")
                return null
        }
    }
    return _e
}
function Mf(_e) {
    _e = _e.previousSibling;
    for (var $ = 0; _e; ) {
        if (_e.nodeType === 8) {
            var et = _e.data;
            if (et === "$" || et === "$!" || et === "$?") {
                if ($ === 0)
                    return _e;
                $--
            } else
                et === "/$" && $++
        }
        _e = _e.previousSibling
    }
    return null
}
var Nf = Math.random().toString(36).slice(2)
  , Of = "__reactFiber$" + Nf
  , Pf = "__reactProps$" + Nf
  , uf = "__reactContainer$" + Nf
  , of = "__reactEvents$" + Nf
  , Qf = "__reactListeners$" + Nf
  , Rf = "__reactHandles$" + Nf;
function Wc(_e) {
    var $ = _e[Of];
    if ($)
        return $;
    for (var et = _e.parentNode; et; ) {
        if ($ = et[uf] || et[Of]) {
            if (et = $.alternate,
            $.child !== null || et !== null && et.child !== null)
                for (_e = Mf(_e); _e !== null; ) {
                    if (et = _e[Of])
                        return et;
                    _e = Mf(_e)
                }
            return $
        }
        _e = et,
        et = _e.parentNode
    }
    return null
}
function Cb(_e) {
    return _e = _e[Of] || _e[uf],
    !_e || _e.tag !== 5 && _e.tag !== 6 && _e.tag !== 13 && _e.tag !== 3 ? null : _e
}
function ue$1(_e) {
    if (_e.tag === 5 || _e.tag === 6)
        return _e.stateNode;
    throw Error(p$2(33))
}
function Db(_e) {
    return _e[Pf] || null
}
var Sf = []
  , Tf = -1;
function Uf(_e) {
    return {
        current: _e
    }
}
function E(_e) {
    0 > Tf || (_e.current = Sf[Tf],
    Sf[Tf] = null,
    Tf--)
}
function G(_e, $) {
    Tf++,
    Sf[Tf] = _e.current,
    _e.current = $
}
var Vf = {}
  , H = Uf(Vf)
  , Wf = Uf(!1)
  , Xf = Vf;
function Yf(_e, $) {
    var et = _e.type.contextTypes;
    if (!et)
        return Vf;
    var tt = _e.stateNode;
    if (tt && tt.__reactInternalMemoizedUnmaskedChildContext === $)
        return tt.__reactInternalMemoizedMaskedChildContext;
    var nt = {}, rt;
    for (rt in et)
        nt[rt] = $[rt];
    return tt && (_e = _e.stateNode,
    _e.__reactInternalMemoizedUnmaskedChildContext = $,
    _e.__reactInternalMemoizedMaskedChildContext = nt),
    nt
}
function Zf(_e) {
    return _e = _e.childContextTypes,
    _e != null
}
function $f() {
    E(Wf),
    E(H)
}
function ag(_e, $, et) {
    if (H.current !== Vf)
        throw Error(p$2(168));
    G(H, $),
    G(Wf, et)
}
function bg(_e, $, et) {
    var tt = _e.stateNode;
    if ($ = $.childContextTypes,
    typeof tt.getChildContext != "function")
        return et;
    tt = tt.getChildContext();
    for (var nt in tt)
        if (!(nt in $))
            throw Error(p$2(108, Ra(_e) || "Unknown", nt));
    return A$2({}, et, tt)
}
function cg(_e) {
    return _e = (_e = _e.stateNode) && _e.__reactInternalMemoizedMergedChildContext || Vf,
    Xf = H.current,
    G(H, _e),
    G(Wf, Wf.current),
    !0
}
function dg(_e, $, et) {
    var tt = _e.stateNode;
    if (!tt)
        throw Error(p$2(169));
    et ? (_e = bg(_e, $, Xf),
    tt.__reactInternalMemoizedMergedChildContext = _e,
    E(Wf),
    E(H),
    G(H, _e)) : E(Wf),
    G(Wf, et)
}
var eg = null
  , fg = !1
  , gg = !1;
function hg(_e) {
    eg === null ? eg = [_e] : eg.push(_e)
}
function ig(_e) {
    fg = !0,
    hg(_e)
}
function jg() {
    if (!gg && eg !== null) {
        gg = !0;
        var _e = 0
          , $ = C$1;
        try {
            var et = eg;
            for (C$1 = 1; _e < et.length; _e++) {
                var tt = et[_e];
                do
                    tt = tt(!0);
                while (tt !== null)
            }
            eg = null,
            fg = !1
        } catch (nt) {
            throw eg !== null && (eg = eg.slice(_e + 1)),
            ac(fc, jg),
            nt
        } finally {
            C$1 = $,
            gg = !1
        }
    }
    return null
}
var kg = []
  , lg = 0
  , mg = null
  , ng = 0
  , og = []
  , pg = 0
  , qg = null
  , rg = 1
  , sg = "";
function tg(_e, $) {
    kg[lg++] = ng,
    kg[lg++] = mg,
    mg = _e,
    ng = $
}
function ug(_e, $, et) {
    og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    qg = _e;
    var tt = rg;
    _e = sg;
    var nt = 32 - oc(tt) - 1;
    tt &= ~(1 << nt),
    et += 1;
    var rt = 32 - oc($) + nt;
    if (30 < rt) {
        var it = nt - nt % 5;
        rt = (tt & (1 << it) - 1).toString(32),
        tt >>= it,
        nt -= it,
        rg = 1 << 32 - oc($) + nt | et << nt | tt,
        sg = rt + _e
    } else
        rg = 1 << rt | et << nt | tt,
        sg = _e
}
function vg(_e) {
    _e.return !== null && (tg(_e, 1),
    ug(_e, 1, 0))
}
function wg(_e) {
    for (; _e === mg; )
        mg = kg[--lg],
        kg[lg] = null,
        ng = kg[--lg],
        kg[lg] = null;
    for (; _e === qg; )
        qg = og[--pg],
        og[pg] = null,
        sg = og[--pg],
        og[pg] = null,
        rg = og[--pg],
        og[pg] = null
}
var xg = null
  , yg = null
  , I = !1
  , zg = null;
function Ag(_e, $) {
    var et = Bg(5, null, null, 0);
    et.elementType = "DELETED",
    et.stateNode = $,
    et.return = _e,
    $ = _e.deletions,
    $ === null ? (_e.deletions = [et],
    _e.flags |= 16) : $.push(et)
}
function Cg(_e, $) {
    switch (_e.tag) {
    case 5:
        var et = _e.type;
        return $ = $.nodeType !== 1 || et.toLowerCase() !== $.nodeName.toLowerCase() ? null : $,
        $ !== null ? (_e.stateNode = $,
        xg = _e,
        yg = Lf($.firstChild),
        !0) : !1;
    case 6:
        return $ = _e.pendingProps === "" || $.nodeType !== 3 ? null : $,
        $ !== null ? (_e.stateNode = $,
        xg = _e,
        yg = null,
        !0) : !1;
    case 13:
        return $ = $.nodeType !== 8 ? null : $,
        $ !== null ? (et = qg !== null ? {
            id: rg,
            overflow: sg
        } : null,
        _e.memoizedState = {
            dehydrated: $,
            treeContext: et,
            retryLane: 1073741824
        },
        et = Bg(18, null, null, 0),
        et.stateNode = $,
        et.return = _e,
        _e.child = et,
        xg = _e,
        yg = null,
        !0) : !1;
    default:
        return !1
    }
}
function Dg(_e) {
    return (_e.mode & 1) !== 0 && (_e.flags & 128) === 0
}
function Eg(_e) {
    if (I) {
        var $ = yg;
        if ($) {
            var et = $;
            if (!Cg(_e, $)) {
                if (Dg(_e))
                    throw Error(p$2(418));
                $ = Lf(et.nextSibling);
                var tt = xg;
                $ && Cg(_e, $) ? Ag(tt, et) : (_e.flags = _e.flags & -4097 | 2,
                I = !1,
                xg = _e)
            }
        } else {
            if (Dg(_e))
                throw Error(p$2(418));
            _e.flags = _e.flags & -4097 | 2,
            I = !1,
            xg = _e
        }
    }
}
function Fg(_e) {
    for (_e = _e.return; _e !== null && _e.tag !== 5 && _e.tag !== 3 && _e.tag !== 13; )
        _e = _e.return;
    xg = _e
}
function Gg(_e) {
    if (_e !== xg)
        return !1;
    if (!I)
        return Fg(_e),
        I = !0,
        !1;
    var $;
    if (($ = _e.tag !== 3) && !($ = _e.tag !== 5) && ($ = _e.type,
    $ = $ !== "head" && $ !== "body" && !Ef(_e.type, _e.memoizedProps)),
    $ && ($ = yg)) {
        if (Dg(_e))
            throw Hg(),
            Error(p$2(418));
        for (; $; )
            Ag(_e, $),
            $ = Lf($.nextSibling)
    }
    if (Fg(_e),
    _e.tag === 13) {
        if (_e = _e.memoizedState,
        _e = _e !== null ? _e.dehydrated : null,
        !_e)
            throw Error(p$2(317));
        e: {
            for (_e = _e.nextSibling,
            $ = 0; _e; ) {
                if (_e.nodeType === 8) {
                    var et = _e.data;
                    if (et === "/$") {
                        if ($ === 0) {
                            yg = Lf(_e.nextSibling);
                            break e
                        }
                        $--
                    } else
                        et !== "$" && et !== "$!" && et !== "$?" || $++
                }
                _e = _e.nextSibling
            }
            yg = null
        }
    } else
        yg = xg ? Lf(_e.stateNode.nextSibling) : null;
    return !0
}
function Hg() {
    for (var _e = yg; _e; )
        _e = Lf(_e.nextSibling)
}
function Ig() {
    yg = xg = null,
    I = !1
}
function Jg(_e) {
    zg === null ? zg = [_e] : zg.push(_e)
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(_e, $, et) {
    if (_e = et.ref,
    _e !== null && typeof _e != "function" && typeof _e != "object") {
        if (et._owner) {
            if (et = et._owner,
            et) {
                if (et.tag !== 1)
                    throw Error(p$2(309));
                var tt = et.stateNode
            }
            if (!tt)
                throw Error(p$2(147, _e));
            var nt = tt
              , rt = "" + _e;
            return $ !== null && $.ref !== null && typeof $.ref == "function" && $.ref._stringRef === rt ? $.ref : ($ = function(it) {
                var ot = nt.refs;
                it === null ? delete ot[rt] : ot[rt] = it
            }
            ,
            $._stringRef = rt,
            $)
        }
        if (typeof _e != "string")
            throw Error(p$2(284));
        if (!et._owner)
            throw Error(p$2(290, _e))
    }
    return _e
}
function Mg(_e, $) {
    throw _e = Object.prototype.toString.call($),
    Error(p$2(31, _e === "[object Object]" ? "object with keys {" + Object.keys($).join(", ") + "}" : _e))
}
function Ng(_e) {
    var $ = _e._init;
    return $(_e._payload)
}
function Og(_e) {
    function $(_t, wt) {
        if (_e) {
            var St = _t.deletions;
            St === null ? (_t.deletions = [wt],
            _t.flags |= 16) : St.push(wt)
        }
    }
    function et(_t, wt) {
        if (!_e)
            return null;
        for (; wt !== null; )
            $(_t, wt),
            wt = wt.sibling;
        return null
    }
    function tt(_t, wt) {
        for (_t = new Map; wt !== null; )
            wt.key !== null ? _t.set(wt.key, wt) : _t.set(wt.index, wt),
            wt = wt.sibling;
        return _t
    }
    function nt(_t, wt) {
        return _t = Pg(_t, wt),
        _t.index = 0,
        _t.sibling = null,
        _t
    }
    function rt(_t, wt, St) {
        return _t.index = St,
        _e ? (St = _t.alternate,
        St !== null ? (St = St.index,
        St < wt ? (_t.flags |= 2,
        wt) : St) : (_t.flags |= 2,
        wt)) : (_t.flags |= 1048576,
        wt)
    }
    function it(_t) {
        return _e && _t.alternate === null && (_t.flags |= 2),
        _t
    }
    function ot(_t, wt, St, Ct) {
        return wt === null || wt.tag !== 6 ? (wt = Qg(St, _t.mode, Ct),
        wt.return = _t,
        wt) : (wt = nt(wt, St),
        wt.return = _t,
        wt)
    }
    function st(_t, wt, St, Ct) {
        var Nt = St.type;
        return Nt === ya ? ct(_t, wt, St.props.children, Ct, St.key) : wt !== null && (wt.elementType === Nt || typeof Nt == "object" && Nt !== null && Nt.$$typeof === Ha && Ng(Nt) === wt.type) ? (Ct = nt(wt, St.props),
        Ct.ref = Lg(_t, wt, St),
        Ct.return = _t,
        Ct) : (Ct = Rg(St.type, St.key, St.props, null, _t.mode, Ct),
        Ct.ref = Lg(_t, wt, St),
        Ct.return = _t,
        Ct)
    }
    function lt(_t, wt, St, Ct) {
        return wt === null || wt.tag !== 4 || wt.stateNode.containerInfo !== St.containerInfo || wt.stateNode.implementation !== St.implementation ? (wt = Sg(St, _t.mode, Ct),
        wt.return = _t,
        wt) : (wt = nt(wt, St.children || []),
        wt.return = _t,
        wt)
    }
    function ct(_t, wt, St, Ct, Nt) {
        return wt === null || wt.tag !== 7 ? (wt = Tg(St, _t.mode, Ct, Nt),
        wt.return = _t,
        wt) : (wt = nt(wt, St),
        wt.return = _t,
        wt)
    }
    function dt(_t, wt, St) {
        if (typeof wt == "string" && wt !== "" || typeof wt == "number")
            return wt = Qg("" + wt, _t.mode, St),
            wt.return = _t,
            wt;
        if (typeof wt == "object" && wt !== null) {
            switch (wt.$$typeof) {
            case va:
                return St = Rg(wt.type, wt.key, wt.props, null, _t.mode, St),
                St.ref = Lg(_t, null, wt),
                St.return = _t,
                St;
            case wa:
                return wt = Sg(wt, _t.mode, St),
                wt.return = _t,
                wt;
            case Ha:
                var Ct = wt._init;
                return dt(_t, Ct(wt._payload), St)
            }
            if (eb(wt) || Ka(wt))
                return wt = Tg(wt, _t.mode, St, null),
                wt.return = _t,
                wt;
            Mg(_t, wt)
        }
        return null
    }
    function pt(_t, wt, St, Ct) {
        var Nt = wt !== null ? wt.key : null;
        if (typeof St == "string" && St !== "" || typeof St == "number")
            return Nt !== null ? null : ot(_t, wt, "" + St, Ct);
        if (typeof St == "object" && St !== null) {
            switch (St.$$typeof) {
            case va:
                return St.key === Nt ? st(_t, wt, St, Ct) : null;
            case wa:
                return St.key === Nt ? lt(_t, wt, St, Ct) : null;
            case Ha:
                return Nt = St._init,
                pt(_t, wt, Nt(St._payload), Ct)
            }
            if (eb(St) || Ka(St))
                return Nt !== null ? null : ct(_t, wt, St, Ct, null);
            Mg(_t, St)
        }
        return null
    }
    function ht(_t, wt, St, Ct, Nt) {
        if (typeof Ct == "string" && Ct !== "" || typeof Ct == "number")
            return _t = _t.get(St) || null,
            ot(wt, _t, "" + Ct, Nt);
        if (typeof Ct == "object" && Ct !== null) {
            switch (Ct.$$typeof) {
            case va:
                return _t = _t.get(Ct.key === null ? St : Ct.key) || null,
                st(wt, _t, Ct, Nt);
            case wa:
                return _t = _t.get(Ct.key === null ? St : Ct.key) || null,
                lt(wt, _t, Ct, Nt);
            case Ha:
                var Lt = Ct._init;
                return ht(_t, wt, St, Lt(Ct._payload), Nt)
            }
            if (eb(Ct) || Ka(Ct))
                return _t = _t.get(St) || null,
                ct(wt, _t, Ct, Nt, null);
            Mg(wt, Ct)
        }
        return null
    }
    function mt(_t, wt, St, Ct) {
        for (var Nt = null, Lt = null, kt = wt, Ut = wt = 0, Jt = null; kt !== null && Ut < St.length; Ut++) {
            kt.index > Ut ? (Jt = kt,
            kt = null) : Jt = kt.sibling;
            var Pt = pt(_t, kt, St[Ut], Ct);
            if (Pt === null) {
                kt === null && (kt = Jt);
                break
            }
            _e && kt && Pt.alternate === null && $(_t, kt),
            wt = rt(Pt, wt, Ut),
            Lt === null ? Nt = Pt : Lt.sibling = Pt,
            Lt = Pt,
            kt = Jt
        }
        if (Ut === St.length)
            return et(_t, kt),
            I && tg(_t, Ut),
            Nt;
        if (kt === null) {
            for (; Ut < St.length; Ut++)
                kt = dt(_t, St[Ut], Ct),
                kt !== null && (wt = rt(kt, wt, Ut),
                Lt === null ? Nt = kt : Lt.sibling = kt,
                Lt = kt);
            return I && tg(_t, Ut),
            Nt
        }
        for (kt = tt(_t, kt); Ut < St.length; Ut++)
            Jt = ht(kt, _t, Ut, St[Ut], Ct),
            Jt !== null && (_e && Jt.alternate !== null && kt.delete(Jt.key === null ? Ut : Jt.key),
            wt = rt(Jt, wt, Ut),
            Lt === null ? Nt = Jt : Lt.sibling = Jt,
            Lt = Jt);
        return _e && kt.forEach(function(Xt) {
            return $(_t, Xt)
        }),
        I && tg(_t, Ut),
        Nt
    }
    function yt(_t, wt, St, Ct) {
        var Nt = Ka(St);
        if (typeof Nt != "function")
            throw Error(p$2(150));
        if (St = Nt.call(St),
        St == null)
            throw Error(p$2(151));
        for (var Lt = Nt = null, kt = wt, Ut = wt = 0, Jt = null, Pt = St.next(); kt !== null && !Pt.done; Ut++,
        Pt = St.next()) {
            kt.index > Ut ? (Jt = kt,
            kt = null) : Jt = kt.sibling;
            var Xt = pt(_t, kt, Pt.value, Ct);
            if (Xt === null) {
                kt === null && (kt = Jt);
                break
            }
            _e && kt && Xt.alternate === null && $(_t, kt),
            wt = rt(Xt, wt, Ut),
            Lt === null ? Nt = Xt : Lt.sibling = Xt,
            Lt = Xt,
            kt = Jt
        }
        if (Pt.done)
            return et(_t, kt),
            I && tg(_t, Ut),
            Nt;
        if (kt === null) {
            for (; !Pt.done; Ut++,
            Pt = St.next())
                Pt = dt(_t, Pt.value, Ct),
                Pt !== null && (wt = rt(Pt, wt, Ut),
                Lt === null ? Nt = Pt : Lt.sibling = Pt,
                Lt = Pt);
            return I && tg(_t, Ut),
            Nt
        }
        for (kt = tt(_t, kt); !Pt.done; Ut++,
        Pt = St.next())
            Pt = ht(kt, _t, Ut, Pt.value, Ct),
            Pt !== null && (_e && Pt.alternate !== null && kt.delete(Pt.key === null ? Ut : Pt.key),
            wt = rt(Pt, wt, Ut),
            Lt === null ? Nt = Pt : Lt.sibling = Pt,
            Lt = Pt);
        return _e && kt.forEach(function(rn) {
            return $(_t, rn)
        }),
        I && tg(_t, Ut),
        Nt
    }
    function Et(_t, wt, St, Ct) {
        if (typeof St == "object" && St !== null && St.type === ya && St.key === null && (St = St.props.children),
        typeof St == "object" && St !== null) {
            switch (St.$$typeof) {
            case va:
                e: {
                    for (var Nt = St.key, Lt = wt; Lt !== null; ) {
                        if (Lt.key === Nt) {
                            if (Nt = St.type,
                            Nt === ya) {
                                if (Lt.tag === 7) {
                                    et(_t, Lt.sibling),
                                    wt = nt(Lt, St.props.children),
                                    wt.return = _t,
                                    _t = wt;
                                    break e
                                }
                            } else if (Lt.elementType === Nt || typeof Nt == "object" && Nt !== null && Nt.$$typeof === Ha && Ng(Nt) === Lt.type) {
                                et(_t, Lt.sibling),
                                wt = nt(Lt, St.props),
                                wt.ref = Lg(_t, Lt, St),
                                wt.return = _t,
                                _t = wt;
                                break e
                            }
                            et(_t, Lt);
                            break
                        } else
                            $(_t, Lt);
                        Lt = Lt.sibling
                    }
                    St.type === ya ? (wt = Tg(St.props.children, _t.mode, Ct, St.key),
                    wt.return = _t,
                    _t = wt) : (Ct = Rg(St.type, St.key, St.props, null, _t.mode, Ct),
                    Ct.ref = Lg(_t, wt, St),
                    Ct.return = _t,
                    _t = Ct)
                }
                return it(_t);
            case wa:
                e: {
                    for (Lt = St.key; wt !== null; ) {
                        if (wt.key === Lt)
                            if (wt.tag === 4 && wt.stateNode.containerInfo === St.containerInfo && wt.stateNode.implementation === St.implementation) {
                                et(_t, wt.sibling),
                                wt = nt(wt, St.children || []),
                                wt.return = _t,
                                _t = wt;
                                break e
                            } else {
                                et(_t, wt);
                                break
                            }
                        else
                            $(_t, wt);
                        wt = wt.sibling
                    }
                    wt = Sg(St, _t.mode, Ct),
                    wt.return = _t,
                    _t = wt
                }
                return it(_t);
            case Ha:
                return Lt = St._init,
                Et(_t, wt, Lt(St._payload), Ct)
            }
            if (eb(St))
                return mt(_t, wt, St, Ct);
            if (Ka(St))
                return yt(_t, wt, St, Ct);
            Mg(_t, St)
        }
        return typeof St == "string" && St !== "" || typeof St == "number" ? (St = "" + St,
        wt !== null && wt.tag === 6 ? (et(_t, wt.sibling),
        wt = nt(wt, St),
        wt.return = _t,
        _t = wt) : (et(_t, wt),
        wt = Qg(St, _t.mode, Ct),
        wt.return = _t,
        _t = wt),
        it(_t)) : et(_t, wt)
    }
    return Et
}
var Ug = Og(!0)
  , Vg = Og(!1)
  , Wg = Uf(null)
  , Xg = null
  , Yg = null
  , Zg = null;
function $g() {
    Zg = Yg = Xg = null
}
function ah(_e) {
    var $ = Wg.current;
    E(Wg),
    _e._currentValue = $
}
function bh(_e, $, et) {
    for (; _e !== null; ) {
        var tt = _e.alternate;
        if ((_e.childLanes & $) !== $ ? (_e.childLanes |= $,
        tt !== null && (tt.childLanes |= $)) : tt !== null && (tt.childLanes & $) !== $ && (tt.childLanes |= $),
        _e === et)
            break;
        _e = _e.return
    }
}
function ch(_e, $) {
    Xg = _e,
    Zg = Yg = null,
    _e = _e.dependencies,
    _e !== null && _e.firstContext !== null && (_e.lanes & $ && (dh = !0),
    _e.firstContext = null)
}
function eh(_e) {
    var $ = _e._currentValue;
    if (Zg !== _e)
        if (_e = {
            context: _e,
            memoizedValue: $,
            next: null
        },
        Yg === null) {
            if (Xg === null)
                throw Error(p$2(308));
            Yg = _e,
            Xg.dependencies = {
                lanes: 0,
                firstContext: _e
            }
        } else
            Yg = Yg.next = _e;
    return $
}
var fh = null;
function gh(_e) {
    fh === null ? fh = [_e] : fh.push(_e)
}
function hh(_e, $, et, tt) {
    var nt = $.interleaved;
    return nt === null ? (et.next = et,
    gh($)) : (et.next = nt.next,
    nt.next = et),
    $.interleaved = et,
    ih(_e, tt)
}
function ih(_e, $) {
    _e.lanes |= $;
    var et = _e.alternate;
    for (et !== null && (et.lanes |= $),
    et = _e,
    _e = _e.return; _e !== null; )
        _e.childLanes |= $,
        et = _e.alternate,
        et !== null && (et.childLanes |= $),
        et = _e,
        _e = _e.return;
    return et.tag === 3 ? et.stateNode : null
}
var jh = !1;
function kh(_e) {
    _e.updateQueue = {
        baseState: _e.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function lh(_e, $) {
    _e = _e.updateQueue,
    $.updateQueue === _e && ($.updateQueue = {
        baseState: _e.baseState,
        firstBaseUpdate: _e.firstBaseUpdate,
        lastBaseUpdate: _e.lastBaseUpdate,
        shared: _e.shared,
        effects: _e.effects
    })
}
function mh(_e, $) {
    return {
        eventTime: _e,
        lane: $,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function nh(_e, $, et) {
    var tt = _e.updateQueue;
    if (tt === null)
        return null;
    if (tt = tt.shared,
    K$1 & 2) {
        var nt = tt.pending;
        return nt === null ? $.next = $ : ($.next = nt.next,
        nt.next = $),
        tt.pending = $,
        ih(_e, et)
    }
    return nt = tt.interleaved,
    nt === null ? ($.next = $,
    gh(tt)) : ($.next = nt.next,
    nt.next = $),
    tt.interleaved = $,
    ih(_e, et)
}
function oh(_e, $, et) {
    if ($ = $.updateQueue,
    $ !== null && ($ = $.shared,
    (et & 4194240) !== 0)) {
        var tt = $.lanes;
        tt &= _e.pendingLanes,
        et |= tt,
        $.lanes = et,
        Cc(_e, et)
    }
}
function ph(_e, $) {
    var et = _e.updateQueue
      , tt = _e.alternate;
    if (tt !== null && (tt = tt.updateQueue,
    et === tt)) {
        var nt = null
          , rt = null;
        if (et = et.firstBaseUpdate,
        et !== null) {
            do {
                var it = {
                    eventTime: et.eventTime,
                    lane: et.lane,
                    tag: et.tag,
                    payload: et.payload,
                    callback: et.callback,
                    next: null
                };
                rt === null ? nt = rt = it : rt = rt.next = it,
                et = et.next
            } while (et !== null);
            rt === null ? nt = rt = $ : rt = rt.next = $
        } else
            nt = rt = $;
        et = {
            baseState: tt.baseState,
            firstBaseUpdate: nt,
            lastBaseUpdate: rt,
            shared: tt.shared,
            effects: tt.effects
        },
        _e.updateQueue = et;
        return
    }
    _e = et.lastBaseUpdate,
    _e === null ? et.firstBaseUpdate = $ : _e.next = $,
    et.lastBaseUpdate = $
}
function qh(_e, $, et, tt) {
    var nt = _e.updateQueue;
    jh = !1;
    var rt = nt.firstBaseUpdate
      , it = nt.lastBaseUpdate
      , ot = nt.shared.pending;
    if (ot !== null) {
        nt.shared.pending = null;
        var st = ot
          , lt = st.next;
        st.next = null,
        it === null ? rt = lt : it.next = lt,
        it = st;
        var ct = _e.alternate;
        ct !== null && (ct = ct.updateQueue,
        ot = ct.lastBaseUpdate,
        ot !== it && (ot === null ? ct.firstBaseUpdate = lt : ot.next = lt,
        ct.lastBaseUpdate = st))
    }
    if (rt !== null) {
        var dt = nt.baseState;
        it = 0,
        ct = lt = st = null,
        ot = rt;
        do {
            var pt = ot.lane
              , ht = ot.eventTime;
            if ((tt & pt) === pt) {
                ct !== null && (ct = ct.next = {
                    eventTime: ht,
                    lane: 0,
                    tag: ot.tag,
                    payload: ot.payload,
                    callback: ot.callback,
                    next: null
                });
                e: {
                    var mt = _e
                      , yt = ot;
                    switch (pt = $,
                    ht = et,
                    yt.tag) {
                    case 1:
                        if (mt = yt.payload,
                        typeof mt == "function") {
                            dt = mt.call(ht, dt, pt);
                            break e
                        }
                        dt = mt;
                        break e;
                    case 3:
                        mt.flags = mt.flags & -65537 | 128;
                    case 0:
                        if (mt = yt.payload,
                        pt = typeof mt == "function" ? mt.call(ht, dt, pt) : mt,
                        pt == null)
                            break e;
                        dt = A$2({}, dt, pt);
                        break e;
                    case 2:
                        jh = !0
                    }
                }
                ot.callback !== null && ot.lane !== 0 && (_e.flags |= 64,
                pt = nt.effects,
                pt === null ? nt.effects = [ot] : pt.push(ot))
            } else
                ht = {
                    eventTime: ht,
                    lane: pt,
                    tag: ot.tag,
                    payload: ot.payload,
                    callback: ot.callback,
                    next: null
                },
                ct === null ? (lt = ct = ht,
                st = dt) : ct = ct.next = ht,
                it |= pt;
            if (ot = ot.next,
            ot === null) {
                if (ot = nt.shared.pending,
                ot === null)
                    break;
                pt = ot,
                ot = pt.next,
                pt.next = null,
                nt.lastBaseUpdate = pt,
                nt.shared.pending = null
            }
        } while (!0);
        if (ct === null && (st = dt),
        nt.baseState = st,
        nt.firstBaseUpdate = lt,
        nt.lastBaseUpdate = ct,
        $ = nt.shared.interleaved,
        $ !== null) {
            nt = $;
            do
                it |= nt.lane,
                nt = nt.next;
            while (nt !== $)
        } else
            rt === null && (nt.shared.lanes = 0);
        rh |= it,
        _e.lanes = it,
        _e.memoizedState = dt
    }
}
function sh(_e, $, et) {
    if (_e = $.effects,
    $.effects = null,
    _e !== null)
        for ($ = 0; $ < _e.length; $++) {
            var tt = _e[$]
              , nt = tt.callback;
            if (nt !== null) {
                if (tt.callback = null,
                tt = et,
                typeof nt != "function")
                    throw Error(p$2(191, nt));
                nt.call(tt)
            }
        }
}
var th = {}
  , uh = Uf(th)
  , vh = Uf(th)
  , wh = Uf(th);
function xh(_e) {
    if (_e === th)
        throw Error(p$2(174));
    return _e
}
function yh(_e, $) {
    switch (G(wh, $),
    G(vh, _e),
    G(uh, th),
    _e = $.nodeType,
    _e) {
    case 9:
    case 11:
        $ = ($ = $.documentElement) ? $.namespaceURI : lb(null, "");
        break;
    default:
        _e = _e === 8 ? $.parentNode : $,
        $ = _e.namespaceURI || null,
        _e = _e.tagName,
        $ = lb($, _e)
    }
    E(uh),
    G(uh, $)
}
function zh() {
    E(uh),
    E(vh),
    E(wh)
}
function Ah(_e) {
    xh(wh.current);
    var $ = xh(uh.current)
      , et = lb($, _e.type);
    $ !== et && (G(vh, _e),
    G(uh, et))
}
function Bh(_e) {
    vh.current === _e && (E(uh),
    E(vh))
}
var L = Uf(0);
function Ch(_e) {
    for (var $ = _e; $ !== null; ) {
        if ($.tag === 13) {
            var et = $.memoizedState;
            if (et !== null && (et = et.dehydrated,
            et === null || et.data === "$?" || et.data === "$!"))
                return $
        } else if ($.tag === 19 && $.memoizedProps.revealOrder !== void 0) {
            if ($.flags & 128)
                return $
        } else if ($.child !== null) {
            $.child.return = $,
            $ = $.child;
            continue
        }
        if ($ === _e)
            break;
        for (; $.sibling === null; ) {
            if ($.return === null || $.return === _e)
                return null;
            $ = $.return
        }
        $.sibling.return = $.return,
        $ = $.sibling
    }
    return null
}
var Dh = [];
function Eh() {
    for (var _e = 0; _e < Dh.length; _e++)
        Dh[_e]._workInProgressVersionPrimary = null;
    Dh.length = 0
}
var Fh = ua.ReactCurrentDispatcher
  , Gh = ua.ReactCurrentBatchConfig
  , Hh = 0
  , M$1 = null
  , N = null
  , O$1 = null
  , Ih = !1
  , Jh = !1
  , Kh = 0
  , Lh = 0;
function P$2() {
    throw Error(p$2(321))
}
function Mh(_e, $) {
    if ($ === null)
        return !1;
    for (var et = 0; et < $.length && et < _e.length; et++)
        if (!He(_e[et], $[et]))
            return !1;
    return !0
}
function Nh(_e, $, et, tt, nt, rt) {
    if (Hh = rt,
    M$1 = $,
    $.memoizedState = null,
    $.updateQueue = null,
    $.lanes = 0,
    Fh.current = _e === null || _e.memoizedState === null ? Oh : Ph,
    _e = et(tt, nt),
    Jh) {
        rt = 0;
        do {
            if (Jh = !1,
            Kh = 0,
            25 <= rt)
                throw Error(p$2(301));
            rt += 1,
            O$1 = N = null,
            $.updateQueue = null,
            Fh.current = Qh,
            _e = et(tt, nt)
        } while (Jh)
    }
    if (Fh.current = Rh,
    $ = N !== null && N.next !== null,
    Hh = 0,
    O$1 = N = M$1 = null,
    Ih = !1,
    $)
        throw Error(p$2(300));
    return _e
}
function Sh() {
    var _e = Kh !== 0;
    return Kh = 0,
    _e
}
function Th() {
    var _e = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return O$1 === null ? M$1.memoizedState = O$1 = _e : O$1 = O$1.next = _e,
    O$1
}
function Uh() {
    if (N === null) {
        var _e = M$1.alternate;
        _e = _e !== null ? _e.memoizedState : null
    } else
        _e = N.next;
    var $ = O$1 === null ? M$1.memoizedState : O$1.next;
    if ($ !== null)
        O$1 = $,
        N = _e;
    else {
        if (_e === null)
            throw Error(p$2(310));
        N = _e,
        _e = {
            memoizedState: N.memoizedState,
            baseState: N.baseState,
            baseQueue: N.baseQueue,
            queue: N.queue,
            next: null
        },
        O$1 === null ? M$1.memoizedState = O$1 = _e : O$1 = O$1.next = _e
    }
    return O$1
}
function Vh(_e, $) {
    return typeof $ == "function" ? $(_e) : $
}
function Wh(_e) {
    var $ = Uh()
      , et = $.queue;
    if (et === null)
        throw Error(p$2(311));
    et.lastRenderedReducer = _e;
    var tt = N
      , nt = tt.baseQueue
      , rt = et.pending;
    if (rt !== null) {
        if (nt !== null) {
            var it = nt.next;
            nt.next = rt.next,
            rt.next = it
        }
        tt.baseQueue = nt = rt,
        et.pending = null
    }
    if (nt !== null) {
        rt = nt.next,
        tt = tt.baseState;
        var ot = it = null
          , st = null
          , lt = rt;
        do {
            var ct = lt.lane;
            if ((Hh & ct) === ct)
                st !== null && (st = st.next = {
                    lane: 0,
                    action: lt.action,
                    hasEagerState: lt.hasEagerState,
                    eagerState: lt.eagerState,
                    next: null
                }),
                tt = lt.hasEagerState ? lt.eagerState : _e(tt, lt.action);
            else {
                var dt = {
                    lane: ct,
                    action: lt.action,
                    hasEagerState: lt.hasEagerState,
                    eagerState: lt.eagerState,
                    next: null
                };
                st === null ? (ot = st = dt,
                it = tt) : st = st.next = dt,
                M$1.lanes |= ct,
                rh |= ct
            }
            lt = lt.next
        } while (lt !== null && lt !== rt);
        st === null ? it = tt : st.next = ot,
        He(tt, $.memoizedState) || (dh = !0),
        $.memoizedState = tt,
        $.baseState = it,
        $.baseQueue = st,
        et.lastRenderedState = tt
    }
    if (_e = et.interleaved,
    _e !== null) {
        nt = _e;
        do
            rt = nt.lane,
            M$1.lanes |= rt,
            rh |= rt,
            nt = nt.next;
        while (nt !== _e)
    } else
        nt === null && (et.lanes = 0);
    return [$.memoizedState, et.dispatch]
}
function Xh(_e) {
    var $ = Uh()
      , et = $.queue;
    if (et === null)
        throw Error(p$2(311));
    et.lastRenderedReducer = _e;
    var tt = et.dispatch
      , nt = et.pending
      , rt = $.memoizedState;
    if (nt !== null) {
        et.pending = null;
        var it = nt = nt.next;
        do
            rt = _e(rt, it.action),
            it = it.next;
        while (it !== nt);
        He(rt, $.memoizedState) || (dh = !0),
        $.memoizedState = rt,
        $.baseQueue === null && ($.baseState = rt),
        et.lastRenderedState = rt
    }
    return [rt, tt]
}
function Yh() {}
function Zh(_e, $) {
    var et = M$1
      , tt = Uh()
      , nt = $()
      , rt = !He(tt.memoizedState, nt);
    if (rt && (tt.memoizedState = nt,
    dh = !0),
    tt = tt.queue,
    $h(ai.bind(null, et, tt, _e), [_e]),
    tt.getSnapshot !== $ || rt || O$1 !== null && O$1.memoizedState.tag & 1) {
        if (et.flags |= 2048,
        bi(9, ci.bind(null, et, tt, nt, $), void 0, null),
        Q === null)
            throw Error(p$2(349));
        Hh & 30 || di(et, $, nt)
    }
    return nt
}
function di(_e, $, et) {
    _e.flags |= 16384,
    _e = {
        getSnapshot: $,
        value: et
    },
    $ = M$1.updateQueue,
    $ === null ? ($ = {
        lastEffect: null,
        stores: null
    },
    M$1.updateQueue = $,
    $.stores = [_e]) : (et = $.stores,
    et === null ? $.stores = [_e] : et.push(_e))
}
function ci(_e, $, et, tt) {
    $.value = et,
    $.getSnapshot = tt,
    ei($) && fi(_e)
}
function ai(_e, $, et) {
    return et(function() {
        ei($) && fi(_e)
    })
}
function ei(_e) {
    var $ = _e.getSnapshot;
    _e = _e.value;
    try {
        var et = $();
        return !He(_e, et)
    } catch {
        return !0
    }
}
function fi(_e) {
    var $ = ih(_e, 1);
    $ !== null && gi($, _e, 1, -1)
}
function hi(_e) {
    var $ = Th();
    return typeof _e == "function" && (_e = _e()),
    $.memoizedState = $.baseState = _e,
    _e = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Vh,
        lastRenderedState: _e
    },
    $.queue = _e,
    _e = _e.dispatch = ii.bind(null, M$1, _e),
    [$.memoizedState, _e]
}
function bi(_e, $, et, tt) {
    return _e = {
        tag: _e,
        create: $,
        destroy: et,
        deps: tt,
        next: null
    },
    $ = M$1.updateQueue,
    $ === null ? ($ = {
        lastEffect: null,
        stores: null
    },
    M$1.updateQueue = $,
    $.lastEffect = _e.next = _e) : (et = $.lastEffect,
    et === null ? $.lastEffect = _e.next = _e : (tt = et.next,
    et.next = _e,
    _e.next = tt,
    $.lastEffect = _e)),
    _e
}
function ji() {
    return Uh().memoizedState
}
function ki(_e, $, et, tt) {
    var nt = Th();
    M$1.flags |= _e,
    nt.memoizedState = bi(1 | $, et, void 0, tt === void 0 ? null : tt)
}
function li(_e, $, et, tt) {
    var nt = Uh();
    tt = tt === void 0 ? null : tt;
    var rt = void 0;
    if (N !== null) {
        var it = N.memoizedState;
        if (rt = it.destroy,
        tt !== null && Mh(tt, it.deps)) {
            nt.memoizedState = bi($, et, rt, tt);
            return
        }
    }
    M$1.flags |= _e,
    nt.memoizedState = bi(1 | $, et, rt, tt)
}
function mi(_e, $) {
    return ki(8390656, 8, _e, $)
}
function $h(_e, $) {
    return li(2048, 8, _e, $)
}
function ni(_e, $) {
    return li(4, 2, _e, $)
}
function oi(_e, $) {
    return li(4, 4, _e, $)
}
function pi(_e, $) {
    if (typeof $ == "function")
        return _e = _e(),
        $(_e),
        function() {
            $(null)
        }
        ;
    if ($ != null)
        return _e = _e(),
        $.current = _e,
        function() {
            $.current = null
        }
}
function qi(_e, $, et) {
    return et = et != null ? et.concat([_e]) : null,
    li(4, 4, pi.bind(null, $, _e), et)
}
function ri() {}
function si(_e, $) {
    var et = Uh();
    $ = $ === void 0 ? null : $;
    var tt = et.memoizedState;
    return tt !== null && $ !== null && Mh($, tt[1]) ? tt[0] : (et.memoizedState = [_e, $],
    _e)
}
function ti(_e, $) {
    var et = Uh();
    $ = $ === void 0 ? null : $;
    var tt = et.memoizedState;
    return tt !== null && $ !== null && Mh($, tt[1]) ? tt[0] : (_e = _e(),
    et.memoizedState = [_e, $],
    _e)
}
function ui(_e, $, et) {
    return Hh & 21 ? (He(et, $) || (et = yc(),
    M$1.lanes |= et,
    rh |= et,
    _e.baseState = !0),
    $) : (_e.baseState && (_e.baseState = !1,
    dh = !0),
    _e.memoizedState = et)
}
function vi(_e, $) {
    var et = C$1;
    C$1 = et !== 0 && 4 > et ? et : 4,
    _e(!0);
    var tt = Gh.transition;
    Gh.transition = {};
    try {
        _e(!1),
        $()
    } finally {
        C$1 = et,
        Gh.transition = tt
    }
}
function wi() {
    return Uh().memoizedState
}
function xi(_e, $, et) {
    var tt = yi(_e);
    if (et = {
        lane: tt,
        action: et,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    zi(_e))
        Ai($, et);
    else if (et = hh(_e, $, et, tt),
    et !== null) {
        var nt = R$1();
        gi(et, _e, tt, nt),
        Bi(et, $, tt)
    }
}
function ii(_e, $, et) {
    var tt = yi(_e)
      , nt = {
        lane: tt,
        action: et,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (zi(_e))
        Ai($, nt);
    else {
        var rt = _e.alternate;
        if (_e.lanes === 0 && (rt === null || rt.lanes === 0) && (rt = $.lastRenderedReducer,
        rt !== null))
            try {
                var it = $.lastRenderedState
                  , ot = rt(it, et);
                if (nt.hasEagerState = !0,
                nt.eagerState = ot,
                He(ot, it)) {
                    var st = $.interleaved;
                    st === null ? (nt.next = nt,
                    gh($)) : (nt.next = st.next,
                    st.next = nt),
                    $.interleaved = nt;
                    return
                }
            } catch {} finally {}
        et = hh(_e, $, nt, tt),
        et !== null && (nt = R$1(),
        gi(et, _e, tt, nt),
        Bi(et, $, tt))
    }
}
function zi(_e) {
    var $ = _e.alternate;
    return _e === M$1 || $ !== null && $ === M$1
}
function Ai(_e, $) {
    Jh = Ih = !0;
    var et = _e.pending;
    et === null ? $.next = $ : ($.next = et.next,
    et.next = $),
    _e.pending = $
}
function Bi(_e, $, et) {
    if (et & 4194240) {
        var tt = $.lanes;
        tt &= _e.pendingLanes,
        et |= tt,
        $.lanes = et,
        Cc(_e, et)
    }
}
var Rh = {
    readContext: eh,
    useCallback: P$2,
    useContext: P$2,
    useEffect: P$2,
    useImperativeHandle: P$2,
    useInsertionEffect: P$2,
    useLayoutEffect: P$2,
    useMemo: P$2,
    useReducer: P$2,
    useRef: P$2,
    useState: P$2,
    useDebugValue: P$2,
    useDeferredValue: P$2,
    useTransition: P$2,
    useMutableSource: P$2,
    useSyncExternalStore: P$2,
    useId: P$2,
    unstable_isNewReconciler: !1
}
  , Oh = {
    readContext: eh,
    useCallback: function(_e, $) {
        return Th().memoizedState = [_e, $ === void 0 ? null : $],
        _e
    },
    useContext: eh,
    useEffect: mi,
    useImperativeHandle: function(_e, $, et) {
        return et = et != null ? et.concat([_e]) : null,
        ki(4194308, 4, pi.bind(null, $, _e), et)
    },
    useLayoutEffect: function(_e, $) {
        return ki(4194308, 4, _e, $)
    },
    useInsertionEffect: function(_e, $) {
        return ki(4, 2, _e, $)
    },
    useMemo: function(_e, $) {
        var et = Th();
        return $ = $ === void 0 ? null : $,
        _e = _e(),
        et.memoizedState = [_e, $],
        _e
    },
    useReducer: function(_e, $, et) {
        var tt = Th();
        return $ = et !== void 0 ? et($) : $,
        tt.memoizedState = tt.baseState = $,
        _e = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: _e,
            lastRenderedState: $
        },
        tt.queue = _e,
        _e = _e.dispatch = xi.bind(null, M$1, _e),
        [tt.memoizedState, _e]
    },
    useRef: function(_e) {
        var $ = Th();
        return _e = {
            current: _e
        },
        $.memoizedState = _e
    },
    useState: hi,
    useDebugValue: ri,
    useDeferredValue: function(_e) {
        return Th().memoizedState = _e
    },
    useTransition: function() {
        var _e = hi(!1)
          , $ = _e[0];
        return _e = vi.bind(null, _e[1]),
        Th().memoizedState = _e,
        [$, _e]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(_e, $, et) {
        var tt = M$1
          , nt = Th();
        if (I) {
            if (et === void 0)
                throw Error(p$2(407));
            et = et()
        } else {
            if (et = $(),
            Q === null)
                throw Error(p$2(349));
            Hh & 30 || di(tt, $, et)
        }
        nt.memoizedState = et;
        var rt = {
            value: et,
            getSnapshot: $
        };
        return nt.queue = rt,
        mi(ai.bind(null, tt, rt, _e), [_e]),
        tt.flags |= 2048,
        bi(9, ci.bind(null, tt, rt, et, $), void 0, null),
        et
    },
    useId: function() {
        var _e = Th()
          , $ = Q.identifierPrefix;
        if (I) {
            var et = sg
              , tt = rg;
            et = (tt & ~(1 << 32 - oc(tt) - 1)).toString(32) + et,
            $ = ":" + $ + "R" + et,
            et = Kh++,
            0 < et && ($ += "H" + et.toString(32)),
            $ += ":"
        } else
            et = Lh++,
            $ = ":" + $ + "r" + et.toString(32) + ":";
        return _e.memoizedState = $
    },
    unstable_isNewReconciler: !1
}
  , Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
        return Wh(Vh)
    },
    useDebugValue: ri,
    useDeferredValue: function(_e) {
        var $ = Uh();
        return ui($, N.memoizedState, _e)
    },
    useTransition: function() {
        var _e = Wh(Vh)[0]
          , $ = Uh().memoizedState;
        return [_e, $]
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: !1
}
  , Qh = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Xh,
    useRef: ji,
    useState: function() {
        return Xh(Vh)
    },
    useDebugValue: ri,
    useDeferredValue: function(_e) {
        var $ = Uh();
        return N === null ? $.memoizedState = _e : ui($, N.memoizedState, _e)
    },
    useTransition: function() {
        var _e = Xh(Vh)[0]
          , $ = Uh().memoizedState;
        return [_e, $]
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: !1
};
function Ci(_e, $) {
    if (_e && _e.defaultProps) {
        $ = A$2({}, $),
        _e = _e.defaultProps;
        for (var et in _e)
            $[et] === void 0 && ($[et] = _e[et]);
        return $
    }
    return $
}
function Di(_e, $, et, tt) {
    $ = _e.memoizedState,
    et = et(tt, $),
    et = et == null ? $ : A$2({}, $, et),
    _e.memoizedState = et,
    _e.lanes === 0 && (_e.updateQueue.baseState = et)
}
var Ei = {
    isMounted: function(_e) {
        return (_e = _e._reactInternals) ? Vb(_e) === _e : !1
    },
    enqueueSetState: function(_e, $, et) {
        _e = _e._reactInternals;
        var tt = R$1()
          , nt = yi(_e)
          , rt = mh(tt, nt);
        rt.payload = $,
        et != null && (rt.callback = et),
        $ = nh(_e, rt, nt),
        $ !== null && (gi($, _e, nt, tt),
        oh($, _e, nt))
    },
    enqueueReplaceState: function(_e, $, et) {
        _e = _e._reactInternals;
        var tt = R$1()
          , nt = yi(_e)
          , rt = mh(tt, nt);
        rt.tag = 1,
        rt.payload = $,
        et != null && (rt.callback = et),
        $ = nh(_e, rt, nt),
        $ !== null && (gi($, _e, nt, tt),
        oh($, _e, nt))
    },
    enqueueForceUpdate: function(_e, $) {
        _e = _e._reactInternals;
        var et = R$1()
          , tt = yi(_e)
          , nt = mh(et, tt);
        nt.tag = 2,
        $ != null && (nt.callback = $),
        $ = nh(_e, nt, tt),
        $ !== null && (gi($, _e, tt, et),
        oh($, _e, tt))
    }
};
function Fi(_e, $, et, tt, nt, rt, it) {
    return _e = _e.stateNode,
    typeof _e.shouldComponentUpdate == "function" ? _e.shouldComponentUpdate(tt, rt, it) : $.prototype && $.prototype.isPureReactComponent ? !Ie(et, tt) || !Ie(nt, rt) : !0
}
function Gi(_e, $, et) {
    var tt = !1
      , nt = Vf
      , rt = $.contextType;
    return typeof rt == "object" && rt !== null ? rt = eh(rt) : (nt = Zf($) ? Xf : H.current,
    tt = $.contextTypes,
    rt = (tt = tt != null) ? Yf(_e, nt) : Vf),
    $ = new $(et,rt),
    _e.memoizedState = $.state !== null && $.state !== void 0 ? $.state : null,
    $.updater = Ei,
    _e.stateNode = $,
    $._reactInternals = _e,
    tt && (_e = _e.stateNode,
    _e.__reactInternalMemoizedUnmaskedChildContext = nt,
    _e.__reactInternalMemoizedMaskedChildContext = rt),
    $
}
function Hi(_e, $, et, tt) {
    _e = $.state,
    typeof $.componentWillReceiveProps == "function" && $.componentWillReceiveProps(et, tt),
    typeof $.UNSAFE_componentWillReceiveProps == "function" && $.UNSAFE_componentWillReceiveProps(et, tt),
    $.state !== _e && Ei.enqueueReplaceState($, $.state, null)
}
function Ii(_e, $, et, tt) {
    var nt = _e.stateNode;
    nt.props = et,
    nt.state = _e.memoizedState,
    nt.refs = {},
    kh(_e);
    var rt = $.contextType;
    typeof rt == "object" && rt !== null ? nt.context = eh(rt) : (rt = Zf($) ? Xf : H.current,
    nt.context = Yf(_e, rt)),
    nt.state = _e.memoizedState,
    rt = $.getDerivedStateFromProps,
    typeof rt == "function" && (Di(_e, $, rt, et),
    nt.state = _e.memoizedState),
    typeof $.getDerivedStateFromProps == "function" || typeof nt.getSnapshotBeforeUpdate == "function" || typeof nt.UNSAFE_componentWillMount != "function" && typeof nt.componentWillMount != "function" || ($ = nt.state,
    typeof nt.componentWillMount == "function" && nt.componentWillMount(),
    typeof nt.UNSAFE_componentWillMount == "function" && nt.UNSAFE_componentWillMount(),
    $ !== nt.state && Ei.enqueueReplaceState(nt, nt.state, null),
    qh(_e, et, nt, tt),
    nt.state = _e.memoizedState),
    typeof nt.componentDidMount == "function" && (_e.flags |= 4194308)
}
function Ji(_e, $) {
    try {
        var et = ""
          , tt = $;
        do
            et += Pa(tt),
            tt = tt.return;
        while (tt);
        var nt = et
    } catch (rt) {
        nt = `
Error generating stack: ` + rt.message + `
` + rt.stack
    }
    return {
        value: _e,
        source: $,
        stack: nt,
        digest: null
    }
}
function Ki(_e, $, et) {
    return {
        value: _e,
        source: null,
        stack: et ?? null,
        digest: $ ?? null
    }
}
function Li(_e, $) {
    try {} catch (et) {
        setTimeout(function() {
            throw et
        })
    }
}
var Mi = typeof WeakMap == "function" ? WeakMap : Map;
function Ni(_e, $, et) {
    et = mh(-1, et),
    et.tag = 3,
    et.payload = {
        element: null
    };
    var tt = $.value;
    return et.callback = function() {
        Oi || (Oi = !0,
        Pi = tt),
        Li(_e, $)
    }
    ,
    et
}
function Qi(_e, $, et) {
    et = mh(-1, et),
    et.tag = 3;
    var tt = _e.type.getDerivedStateFromError;
    if (typeof tt == "function") {
        var nt = $.value;
        et.payload = function() {
            return tt(nt)
        }
        ,
        et.callback = function() {
            Li(_e, $)
        }
    }
    var rt = _e.stateNode;
    return rt !== null && typeof rt.componentDidCatch == "function" && (et.callback = function() {
        Li(_e, $),
        typeof tt != "function" && (Ri === null ? Ri = new Set([this]) : Ri.add(this));
        var it = $.stack;
        this.componentDidCatch($.value, {
            componentStack: it !== null ? it : ""
        })
    }
    ),
    et
}
function Si(_e, $, et) {
    var tt = _e.pingCache;
    if (tt === null) {
        tt = _e.pingCache = new Mi;
        var nt = new Set;
        tt.set($, nt)
    } else
        nt = tt.get($),
        nt === void 0 && (nt = new Set,
        tt.set($, nt));
    nt.has(et) || (nt.add(et),
    _e = Ti.bind(null, _e, $, et),
    $.then(_e, _e))
}
function Ui(_e) {
    do {
        var $;
        if (($ = _e.tag === 13) && ($ = _e.memoizedState,
        $ = $ !== null ? $.dehydrated !== null : !0),
        $)
            return _e;
        _e = _e.return
    } while (_e !== null);
    return null
}
function Vi(_e, $, et, tt, nt) {
    return _e.mode & 1 ? (_e.flags |= 65536,
    _e.lanes = nt,
    _e) : (_e === $ ? _e.flags |= 65536 : (_e.flags |= 128,
    et.flags |= 131072,
    et.flags &= -52805,
    et.tag === 1 && (et.alternate === null ? et.tag = 17 : ($ = mh(-1, 1),
    $.tag = 2,
    nh(et, $, 1))),
    et.lanes |= 1),
    _e)
}
var Wi = ua.ReactCurrentOwner
  , dh = !1;
function Xi(_e, $, et, tt) {
    $.child = _e === null ? Vg($, null, et, tt) : Ug($, _e.child, et, tt)
}
function Yi(_e, $, et, tt, nt) {
    et = et.render;
    var rt = $.ref;
    return ch($, nt),
    tt = Nh(_e, $, et, tt, rt, nt),
    et = Sh(),
    _e !== null && !dh ? ($.updateQueue = _e.updateQueue,
    $.flags &= -2053,
    _e.lanes &= ~nt,
    Zi(_e, $, nt)) : (I && et && vg($),
    $.flags |= 1,
    Xi(_e, $, tt, nt),
    $.child)
}
function $i(_e, $, et, tt, nt) {
    if (_e === null) {
        var rt = et.type;
        return typeof rt == "function" && !aj(rt) && rt.defaultProps === void 0 && et.compare === null && et.defaultProps === void 0 ? ($.tag = 15,
        $.type = rt,
        bj(_e, $, rt, tt, nt)) : (_e = Rg(et.type, null, tt, $, $.mode, nt),
        _e.ref = $.ref,
        _e.return = $,
        $.child = _e)
    }
    if (rt = _e.child,
    !(_e.lanes & nt)) {
        var it = rt.memoizedProps;
        if (et = et.compare,
        et = et !== null ? et : Ie,
        et(it, tt) && _e.ref === $.ref)
            return Zi(_e, $, nt)
    }
    return $.flags |= 1,
    _e = Pg(rt, tt),
    _e.ref = $.ref,
    _e.return = $,
    $.child = _e
}
function bj(_e, $, et, tt, nt) {
    if (_e !== null) {
        var rt = _e.memoizedProps;
        if (Ie(rt, tt) && _e.ref === $.ref)
            if (dh = !1,
            $.pendingProps = tt = rt,
            (_e.lanes & nt) !== 0)
                _e.flags & 131072 && (dh = !0);
            else
                return $.lanes = _e.lanes,
                Zi(_e, $, nt)
    }
    return cj(_e, $, et, tt, nt)
}
function dj(_e, $, et) {
    var tt = $.pendingProps
      , nt = tt.children
      , rt = _e !== null ? _e.memoizedState : null;
    if (tt.mode === "hidden")
        if (!($.mode & 1))
            $.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            G(ej, fj),
            fj |= et;
        else {
            if (!(et & 1073741824))
                return _e = rt !== null ? rt.baseLanes | et : et,
                $.lanes = $.childLanes = 1073741824,
                $.memoizedState = {
                    baseLanes: _e,
                    cachePool: null,
                    transitions: null
                },
                $.updateQueue = null,
                G(ej, fj),
                fj |= _e,
                null;
            $.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            tt = rt !== null ? rt.baseLanes : et,
            G(ej, fj),
            fj |= tt
        }
    else
        rt !== null ? (tt = rt.baseLanes | et,
        $.memoizedState = null) : tt = et,
        G(ej, fj),
        fj |= tt;
    return Xi(_e, $, nt, et),
    $.child
}
function gj(_e, $) {
    var et = $.ref;
    (_e === null && et !== null || _e !== null && _e.ref !== et) && ($.flags |= 512,
    $.flags |= 2097152)
}
function cj(_e, $, et, tt, nt) {
    var rt = Zf(et) ? Xf : H.current;
    return rt = Yf($, rt),
    ch($, nt),
    et = Nh(_e, $, et, tt, rt, nt),
    tt = Sh(),
    _e !== null && !dh ? ($.updateQueue = _e.updateQueue,
    $.flags &= -2053,
    _e.lanes &= ~nt,
    Zi(_e, $, nt)) : (I && tt && vg($),
    $.flags |= 1,
    Xi(_e, $, et, nt),
    $.child)
}
function hj(_e, $, et, tt, nt) {
    if (Zf(et)) {
        var rt = !0;
        cg($)
    } else
        rt = !1;
    if (ch($, nt),
    $.stateNode === null)
        ij(_e, $),
        Gi($, et, tt),
        Ii($, et, tt, nt),
        tt = !0;
    else if (_e === null) {
        var it = $.stateNode
          , ot = $.memoizedProps;
        it.props = ot;
        var st = it.context
          , lt = et.contextType;
        typeof lt == "object" && lt !== null ? lt = eh(lt) : (lt = Zf(et) ? Xf : H.current,
        lt = Yf($, lt));
        var ct = et.getDerivedStateFromProps
          , dt = typeof ct == "function" || typeof it.getSnapshotBeforeUpdate == "function";
        dt || typeof it.UNSAFE_componentWillReceiveProps != "function" && typeof it.componentWillReceiveProps != "function" || (ot !== tt || st !== lt) && Hi($, it, tt, lt),
        jh = !1;
        var pt = $.memoizedState;
        it.state = pt,
        qh($, tt, it, nt),
        st = $.memoizedState,
        ot !== tt || pt !== st || Wf.current || jh ? (typeof ct == "function" && (Di($, et, ct, tt),
        st = $.memoizedState),
        (ot = jh || Fi($, et, ot, tt, pt, st, lt)) ? (dt || typeof it.UNSAFE_componentWillMount != "function" && typeof it.componentWillMount != "function" || (typeof it.componentWillMount == "function" && it.componentWillMount(),
        typeof it.UNSAFE_componentWillMount == "function" && it.UNSAFE_componentWillMount()),
        typeof it.componentDidMount == "function" && ($.flags |= 4194308)) : (typeof it.componentDidMount == "function" && ($.flags |= 4194308),
        $.memoizedProps = tt,
        $.memoizedState = st),
        it.props = tt,
        it.state = st,
        it.context = lt,
        tt = ot) : (typeof it.componentDidMount == "function" && ($.flags |= 4194308),
        tt = !1)
    } else {
        it = $.stateNode,
        lh(_e, $),
        ot = $.memoizedProps,
        lt = $.type === $.elementType ? ot : Ci($.type, ot),
        it.props = lt,
        dt = $.pendingProps,
        pt = it.context,
        st = et.contextType,
        typeof st == "object" && st !== null ? st = eh(st) : (st = Zf(et) ? Xf : H.current,
        st = Yf($, st));
        var ht = et.getDerivedStateFromProps;
        (ct = typeof ht == "function" || typeof it.getSnapshotBeforeUpdate == "function") || typeof it.UNSAFE_componentWillReceiveProps != "function" && typeof it.componentWillReceiveProps != "function" || (ot !== dt || pt !== st) && Hi($, it, tt, st),
        jh = !1,
        pt = $.memoizedState,
        it.state = pt,
        qh($, tt, it, nt);
        var mt = $.memoizedState;
        ot !== dt || pt !== mt || Wf.current || jh ? (typeof ht == "function" && (Di($, et, ht, tt),
        mt = $.memoizedState),
        (lt = jh || Fi($, et, lt, tt, pt, mt, st) || !1) ? (ct || typeof it.UNSAFE_componentWillUpdate != "function" && typeof it.componentWillUpdate != "function" || (typeof it.componentWillUpdate == "function" && it.componentWillUpdate(tt, mt, st),
        typeof it.UNSAFE_componentWillUpdate == "function" && it.UNSAFE_componentWillUpdate(tt, mt, st)),
        typeof it.componentDidUpdate == "function" && ($.flags |= 4),
        typeof it.getSnapshotBeforeUpdate == "function" && ($.flags |= 1024)) : (typeof it.componentDidUpdate != "function" || ot === _e.memoizedProps && pt === _e.memoizedState || ($.flags |= 4),
        typeof it.getSnapshotBeforeUpdate != "function" || ot === _e.memoizedProps && pt === _e.memoizedState || ($.flags |= 1024),
        $.memoizedProps = tt,
        $.memoizedState = mt),
        it.props = tt,
        it.state = mt,
        it.context = st,
        tt = lt) : (typeof it.componentDidUpdate != "function" || ot === _e.memoizedProps && pt === _e.memoizedState || ($.flags |= 4),
        typeof it.getSnapshotBeforeUpdate != "function" || ot === _e.memoizedProps && pt === _e.memoizedState || ($.flags |= 1024),
        tt = !1)
    }
    return jj(_e, $, et, tt, rt, nt)
}
function jj(_e, $, et, tt, nt, rt) {
    gj(_e, $);
    var it = ($.flags & 128) !== 0;
    if (!tt && !it)
        return nt && dg($, et, !1),
        Zi(_e, $, rt);
    tt = $.stateNode,
    Wi.current = $;
    var ot = it && typeof et.getDerivedStateFromError != "function" ? null : tt.render();
    return $.flags |= 1,
    _e !== null && it ? ($.child = Ug($, _e.child, null, rt),
    $.child = Ug($, null, ot, rt)) : Xi(_e, $, ot, rt),
    $.memoizedState = tt.state,
    nt && dg($, et, !0),
    $.child
}
function kj(_e) {
    var $ = _e.stateNode;
    $.pendingContext ? ag(_e, $.pendingContext, $.pendingContext !== $.context) : $.context && ag(_e, $.context, !1),
    yh(_e, $.containerInfo)
}
function lj(_e, $, et, tt, nt) {
    return Ig(),
    Jg(nt),
    $.flags |= 256,
    Xi(_e, $, et, tt),
    $.child
}
var mj = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function nj(_e) {
    return {
        baseLanes: _e,
        cachePool: null,
        transitions: null
    }
}
function oj(_e, $, et) {
    var tt = $.pendingProps, nt = L.current, rt = !1, it = ($.flags & 128) !== 0, ot;
    if ((ot = it) || (ot = _e !== null && _e.memoizedState === null ? !1 : (nt & 2) !== 0),
    ot ? (rt = !0,
    $.flags &= -129) : (_e === null || _e.memoizedState !== null) && (nt |= 1),
    G(L, nt & 1),
    _e === null)
        return Eg($),
        _e = $.memoizedState,
        _e !== null && (_e = _e.dehydrated,
        _e !== null) ? ($.mode & 1 ? _e.data === "$!" ? $.lanes = 8 : $.lanes = 1073741824 : $.lanes = 1,
        null) : (it = tt.children,
        _e = tt.fallback,
        rt ? (tt = $.mode,
        rt = $.child,
        it = {
            mode: "hidden",
            children: it
        },
        !(tt & 1) && rt !== null ? (rt.childLanes = 0,
        rt.pendingProps = it) : rt = pj(it, tt, 0, null),
        _e = Tg(_e, tt, et, null),
        rt.return = $,
        _e.return = $,
        rt.sibling = _e,
        $.child = rt,
        $.child.memoizedState = nj(et),
        $.memoizedState = mj,
        _e) : qj($, it));
    if (nt = _e.memoizedState,
    nt !== null && (ot = nt.dehydrated,
    ot !== null))
        return rj(_e, $, it, tt, ot, nt, et);
    if (rt) {
        rt = tt.fallback,
        it = $.mode,
        nt = _e.child,
        ot = nt.sibling;
        var st = {
            mode: "hidden",
            children: tt.children
        };
        return !(it & 1) && $.child !== nt ? (tt = $.child,
        tt.childLanes = 0,
        tt.pendingProps = st,
        $.deletions = null) : (tt = Pg(nt, st),
        tt.subtreeFlags = nt.subtreeFlags & 14680064),
        ot !== null ? rt = Pg(ot, rt) : (rt = Tg(rt, it, et, null),
        rt.flags |= 2),
        rt.return = $,
        tt.return = $,
        tt.sibling = rt,
        $.child = tt,
        tt = rt,
        rt = $.child,
        it = _e.child.memoizedState,
        it = it === null ? nj(et) : {
            baseLanes: it.baseLanes | et,
            cachePool: null,
            transitions: it.transitions
        },
        rt.memoizedState = it,
        rt.childLanes = _e.childLanes & ~et,
        $.memoizedState = mj,
        tt
    }
    return rt = _e.child,
    _e = rt.sibling,
    tt = Pg(rt, {
        mode: "visible",
        children: tt.children
    }),
    !($.mode & 1) && (tt.lanes = et),
    tt.return = $,
    tt.sibling = null,
    _e !== null && (et = $.deletions,
    et === null ? ($.deletions = [_e],
    $.flags |= 16) : et.push(_e)),
    $.child = tt,
    $.memoizedState = null,
    tt
}
function qj(_e, $) {
    return $ = pj({
        mode: "visible",
        children: $
    }, _e.mode, 0, null),
    $.return = _e,
    _e.child = $
}
function sj(_e, $, et, tt) {
    return tt !== null && Jg(tt),
    Ug($, _e.child, null, et),
    _e = qj($, $.pendingProps.children),
    _e.flags |= 2,
    $.memoizedState = null,
    _e
}
function rj(_e, $, et, tt, nt, rt, it) {
    if (et)
        return $.flags & 256 ? ($.flags &= -257,
        tt = Ki(Error(p$2(422))),
        sj(_e, $, it, tt)) : $.memoizedState !== null ? ($.child = _e.child,
        $.flags |= 128,
        null) : (rt = tt.fallback,
        nt = $.mode,
        tt = pj({
            mode: "visible",
            children: tt.children
        }, nt, 0, null),
        rt = Tg(rt, nt, it, null),
        rt.flags |= 2,
        tt.return = $,
        rt.return = $,
        tt.sibling = rt,
        $.child = tt,
        $.mode & 1 && Ug($, _e.child, null, it),
        $.child.memoizedState = nj(it),
        $.memoizedState = mj,
        rt);
    if (!($.mode & 1))
        return sj(_e, $, it, null);
    if (nt.data === "$!") {
        if (tt = nt.nextSibling && nt.nextSibling.dataset,
        tt)
            var ot = tt.dgst;
        return tt = ot,
        rt = Error(p$2(419)),
        tt = Ki(rt, tt, void 0),
        sj(_e, $, it, tt)
    }
    if (ot = (it & _e.childLanes) !== 0,
    dh || ot) {
        if (tt = Q,
        tt !== null) {
            switch (it & -it) {
            case 4:
                nt = 2;
                break;
            case 16:
                nt = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                nt = 32;
                break;
            case 536870912:
                nt = 268435456;
                break;
            default:
                nt = 0
            }
            nt = nt & (tt.suspendedLanes | it) ? 0 : nt,
            nt !== 0 && nt !== rt.retryLane && (rt.retryLane = nt,
            ih(_e, nt),
            gi(tt, _e, nt, -1))
        }
        return tj(),
        tt = Ki(Error(p$2(421))),
        sj(_e, $, it, tt)
    }
    return nt.data === "$?" ? ($.flags |= 128,
    $.child = _e.child,
    $ = uj.bind(null, _e),
    nt._reactRetry = $,
    null) : (_e = rt.treeContext,
    yg = Lf(nt.nextSibling),
    xg = $,
    I = !0,
    zg = null,
    _e !== null && (og[pg++] = rg,
    og[pg++] = sg,
    og[pg++] = qg,
    rg = _e.id,
    sg = _e.overflow,
    qg = $),
    $ = qj($, tt.children),
    $.flags |= 4096,
    $)
}
function vj(_e, $, et) {
    _e.lanes |= $;
    var tt = _e.alternate;
    tt !== null && (tt.lanes |= $),
    bh(_e.return, $, et)
}
function wj(_e, $, et, tt, nt) {
    var rt = _e.memoizedState;
    rt === null ? _e.memoizedState = {
        isBackwards: $,
        rendering: null,
        renderingStartTime: 0,
        last: tt,
        tail: et,
        tailMode: nt
    } : (rt.isBackwards = $,
    rt.rendering = null,
    rt.renderingStartTime = 0,
    rt.last = tt,
    rt.tail = et,
    rt.tailMode = nt)
}
function xj(_e, $, et) {
    var tt = $.pendingProps
      , nt = tt.revealOrder
      , rt = tt.tail;
    if (Xi(_e, $, tt.children, et),
    tt = L.current,
    tt & 2)
        tt = tt & 1 | 2,
        $.flags |= 128;
    else {
        if (_e !== null && _e.flags & 128)
            e: for (_e = $.child; _e !== null; ) {
                if (_e.tag === 13)
                    _e.memoizedState !== null && vj(_e, et, $);
                else if (_e.tag === 19)
                    vj(_e, et, $);
                else if (_e.child !== null) {
                    _e.child.return = _e,
                    _e = _e.child;
                    continue
                }
                if (_e === $)
                    break e;
                for (; _e.sibling === null; ) {
                    if (_e.return === null || _e.return === $)
                        break e;
                    _e = _e.return
                }
                _e.sibling.return = _e.return,
                _e = _e.sibling
            }
        tt &= 1
    }
    if (G(L, tt),
    !($.mode & 1))
        $.memoizedState = null;
    else
        switch (nt) {
        case "forwards":
            for (et = $.child,
            nt = null; et !== null; )
                _e = et.alternate,
                _e !== null && Ch(_e) === null && (nt = et),
                et = et.sibling;
            et = nt,
            et === null ? (nt = $.child,
            $.child = null) : (nt = et.sibling,
            et.sibling = null),
            wj($, !1, nt, et, rt);
            break;
        case "backwards":
            for (et = null,
            nt = $.child,
            $.child = null; nt !== null; ) {
                if (_e = nt.alternate,
                _e !== null && Ch(_e) === null) {
                    $.child = nt;
                    break
                }
                _e = nt.sibling,
                nt.sibling = et,
                et = nt,
                nt = _e
            }
            wj($, !0, et, null, rt);
            break;
        case "together":
            wj($, !1, null, null, void 0);
            break;
        default:
            $.memoizedState = null
        }
    return $.child
}
function ij(_e, $) {
    !($.mode & 1) && _e !== null && (_e.alternate = null,
    $.alternate = null,
    $.flags |= 2)
}
function Zi(_e, $, et) {
    if (_e !== null && ($.dependencies = _e.dependencies),
    rh |= $.lanes,
    !(et & $.childLanes))
        return null;
    if (_e !== null && $.child !== _e.child)
        throw Error(p$2(153));
    if ($.child !== null) {
        for (_e = $.child,
        et = Pg(_e, _e.pendingProps),
        $.child = et,
        et.return = $; _e.sibling !== null; )
            _e = _e.sibling,
            et = et.sibling = Pg(_e, _e.pendingProps),
            et.return = $;
        et.sibling = null
    }
    return $.child
}
function yj(_e, $, et) {
    switch ($.tag) {
    case 3:
        kj($),
        Ig();
        break;
    case 5:
        Ah($);
        break;
    case 1:
        Zf($.type) && cg($);
        break;
    case 4:
        yh($, $.stateNode.containerInfo);
        break;
    case 10:
        var tt = $.type._context
          , nt = $.memoizedProps.value;
        G(Wg, tt._currentValue),
        tt._currentValue = nt;
        break;
    case 13:
        if (tt = $.memoizedState,
        tt !== null)
            return tt.dehydrated !== null ? (G(L, L.current & 1),
            $.flags |= 128,
            null) : et & $.child.childLanes ? oj(_e, $, et) : (G(L, L.current & 1),
            _e = Zi(_e, $, et),
            _e !== null ? _e.sibling : null);
        G(L, L.current & 1);
        break;
    case 19:
        if (tt = (et & $.childLanes) !== 0,
        _e.flags & 128) {
            if (tt)
                return xj(_e, $, et);
            $.flags |= 128
        }
        if (nt = $.memoizedState,
        nt !== null && (nt.rendering = null,
        nt.tail = null,
        nt.lastEffect = null),
        G(L, L.current),
        tt)
            break;
        return null;
    case 22:
    case 23:
        return $.lanes = 0,
        dj(_e, $, et)
    }
    return Zi(_e, $, et)
}
var zj, Aj, Bj, Cj;
zj = function(_e, $) {
    for (var et = $.child; et !== null; ) {
        if (et.tag === 5 || et.tag === 6)
            _e.appendChild(et.stateNode);
        else if (et.tag !== 4 && et.child !== null) {
            et.child.return = et,
            et = et.child;
            continue
        }
        if (et === $)
            break;
        for (; et.sibling === null; ) {
            if (et.return === null || et.return === $)
                return;
            et = et.return
        }
        et.sibling.return = et.return,
        et = et.sibling
    }
}
;
Aj = function() {}
;
Bj = function(_e, $, et, tt) {
    var nt = _e.memoizedProps;
    if (nt !== tt) {
        _e = $.stateNode,
        xh(uh.current);
        var rt = null;
        switch (et) {
        case "input":
            nt = Ya(_e, nt),
            tt = Ya(_e, tt),
            rt = [];
            break;
        case "select":
            nt = A$2({}, nt, {
                value: void 0
            }),
            tt = A$2({}, tt, {
                value: void 0
            }),
            rt = [];
            break;
        case "textarea":
            nt = gb(_e, nt),
            tt = gb(_e, tt),
            rt = [];
            break;
        default:
            typeof nt.onClick != "function" && typeof tt.onClick == "function" && (_e.onclick = Bf)
        }
        ub(et, tt);
        var it;
        et = null;
        for (lt in nt)
            if (!tt.hasOwnProperty(lt) && nt.hasOwnProperty(lt) && nt[lt] != null)
                if (lt === "style") {
                    var ot = nt[lt];
                    for (it in ot)
                        ot.hasOwnProperty(it) && (et || (et = {}),
                        et[it] = "")
                } else
                    lt !== "dangerouslySetInnerHTML" && lt !== "children" && lt !== "suppressContentEditableWarning" && lt !== "suppressHydrationWarning" && lt !== "autoFocus" && (ea.hasOwnProperty(lt) ? rt || (rt = []) : (rt = rt || []).push(lt, null));
        for (lt in tt) {
            var st = tt[lt];
            if (ot = nt != null ? nt[lt] : void 0,
            tt.hasOwnProperty(lt) && st !== ot && (st != null || ot != null))
                if (lt === "style")
                    if (ot) {
                        for (it in ot)
                            !ot.hasOwnProperty(it) || st && st.hasOwnProperty(it) || (et || (et = {}),
                            et[it] = "");
                        for (it in st)
                            st.hasOwnProperty(it) && ot[it] !== st[it] && (et || (et = {}),
                            et[it] = st[it])
                    } else
                        et || (rt || (rt = []),
                        rt.push(lt, et)),
                        et = st;
                else
                    lt === "dangerouslySetInnerHTML" ? (st = st ? st.__html : void 0,
                    ot = ot ? ot.__html : void 0,
                    st != null && ot !== st && (rt = rt || []).push(lt, st)) : lt === "children" ? typeof st != "string" && typeof st != "number" || (rt = rt || []).push(lt, "" + st) : lt !== "suppressContentEditableWarning" && lt !== "suppressHydrationWarning" && (ea.hasOwnProperty(lt) ? (st != null && lt === "onScroll" && D$1("scroll", _e),
                    rt || ot === st || (rt = [])) : (rt = rt || []).push(lt, st))
        }
        et && (rt = rt || []).push("style", et);
        var lt = rt;
        ($.updateQueue = lt) && ($.flags |= 4)
    }
}
;
Cj = function(_e, $, et, tt) {
    et !== tt && ($.flags |= 4)
}
;
function Dj(_e, $) {
    if (!I)
        switch (_e.tailMode) {
        case "hidden":
            $ = _e.tail;
            for (var et = null; $ !== null; )
                $.alternate !== null && (et = $),
                $ = $.sibling;
            et === null ? _e.tail = null : et.sibling = null;
            break;
        case "collapsed":
            et = _e.tail;
            for (var tt = null; et !== null; )
                et.alternate !== null && (tt = et),
                et = et.sibling;
            tt === null ? $ || _e.tail === null ? _e.tail = null : _e.tail.sibling = null : tt.sibling = null
        }
}
function S(_e) {
    var $ = _e.alternate !== null && _e.alternate.child === _e.child
      , et = 0
      , tt = 0;
    if ($)
        for (var nt = _e.child; nt !== null; )
            et |= nt.lanes | nt.childLanes,
            tt |= nt.subtreeFlags & 14680064,
            tt |= nt.flags & 14680064,
            nt.return = _e,
            nt = nt.sibling;
    else
        for (nt = _e.child; nt !== null; )
            et |= nt.lanes | nt.childLanes,
            tt |= nt.subtreeFlags,
            tt |= nt.flags,
            nt.return = _e,
            nt = nt.sibling;
    return _e.subtreeFlags |= tt,
    _e.childLanes = et,
    $
}
function Ej(_e, $, et) {
    var tt = $.pendingProps;
    switch (wg($),
    $.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return S($),
        null;
    case 1:
        return Zf($.type) && $f(),
        S($),
        null;
    case 3:
        return tt = $.stateNode,
        zh(),
        E(Wf),
        E(H),
        Eh(),
        tt.pendingContext && (tt.context = tt.pendingContext,
        tt.pendingContext = null),
        (_e === null || _e.child === null) && (Gg($) ? $.flags |= 4 : _e === null || _e.memoizedState.isDehydrated && !($.flags & 256) || ($.flags |= 1024,
        zg !== null && (Fj(zg),
        zg = null))),
        Aj(_e, $),
        S($),
        null;
    case 5:
        Bh($);
        var nt = xh(wh.current);
        if (et = $.type,
        _e !== null && $.stateNode != null)
            Bj(_e, $, et, tt, nt),
            _e.ref !== $.ref && ($.flags |= 512,
            $.flags |= 2097152);
        else {
            if (!tt) {
                if ($.stateNode === null)
                    throw Error(p$2(166));
                return S($),
                null
            }
            if (_e = xh(uh.current),
            Gg($)) {
                tt = $.stateNode,
                et = $.type;
                var rt = $.memoizedProps;
                switch (tt[Of] = $,
                tt[Pf] = rt,
                _e = ($.mode & 1) !== 0,
                et) {
                case "dialog":
                    D$1("cancel", tt),
                    D$1("close", tt);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    D$1("load", tt);
                    break;
                case "video":
                case "audio":
                    for (nt = 0; nt < lf.length; nt++)
                        D$1(lf[nt], tt);
                    break;
                case "source":
                    D$1("error", tt);
                    break;
                case "img":
                case "image":
                case "link":
                    D$1("error", tt),
                    D$1("load", tt);
                    break;
                case "details":
                    D$1("toggle", tt);
                    break;
                case "input":
                    Za(tt, rt),
                    D$1("invalid", tt);
                    break;
                case "select":
                    tt._wrapperState = {
                        wasMultiple: !!rt.multiple
                    },
                    D$1("invalid", tt);
                    break;
                case "textarea":
                    hb(tt, rt),
                    D$1("invalid", tt)
                }
                ub(et, rt),
                nt = null;
                for (var it in rt)
                    if (rt.hasOwnProperty(it)) {
                        var ot = rt[it];
                        it === "children" ? typeof ot == "string" ? tt.textContent !== ot && (rt.suppressHydrationWarning !== !0 && Af(tt.textContent, ot, _e),
                        nt = ["children", ot]) : typeof ot == "number" && tt.textContent !== "" + ot && (rt.suppressHydrationWarning !== !0 && Af(tt.textContent, ot, _e),
                        nt = ["children", "" + ot]) : ea.hasOwnProperty(it) && ot != null && it === "onScroll" && D$1("scroll", tt)
                    }
                switch (et) {
                case "input":
                    Va(tt),
                    db(tt, rt, !0);
                    break;
                case "textarea":
                    Va(tt),
                    jb(tt);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof rt.onClick == "function" && (tt.onclick = Bf)
                }
                tt = nt,
                $.updateQueue = tt,
                tt !== null && ($.flags |= 4)
            } else {
                it = nt.nodeType === 9 ? nt : nt.ownerDocument,
                _e === "http://www.w3.org/1999/xhtml" && (_e = kb(et)),
                _e === "http://www.w3.org/1999/xhtml" ? et === "script" ? (_e = it.createElement("div"),
                _e.innerHTML = "<script><\/script>",
                _e = _e.removeChild(_e.firstChild)) : typeof tt.is == "string" ? _e = it.createElement(et, {
                    is: tt.is
                }) : (_e = it.createElement(et),
                et === "select" && (it = _e,
                tt.multiple ? it.multiple = !0 : tt.size && (it.size = tt.size))) : _e = it.createElementNS(_e, et),
                _e[Of] = $,
                _e[Pf] = tt,
                zj(_e, $, !1, !1),
                $.stateNode = _e;
                e: {
                    switch (it = vb(et, tt),
                    et) {
                    case "dialog":
                        D$1("cancel", _e),
                        D$1("close", _e),
                        nt = tt;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        D$1("load", _e),
                        nt = tt;
                        break;
                    case "video":
                    case "audio":
                        for (nt = 0; nt < lf.length; nt++)
                            D$1(lf[nt], _e);
                        nt = tt;
                        break;
                    case "source":
                        D$1("error", _e),
                        nt = tt;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        D$1("error", _e),
                        D$1("load", _e),
                        nt = tt;
                        break;
                    case "details":
                        D$1("toggle", _e),
                        nt = tt;
                        break;
                    case "input":
                        Za(_e, tt),
                        nt = Ya(_e, tt),
                        D$1("invalid", _e);
                        break;
                    case "option":
                        nt = tt;
                        break;
                    case "select":
                        _e._wrapperState = {
                            wasMultiple: !!tt.multiple
                        },
                        nt = A$2({}, tt, {
                            value: void 0
                        }),
                        D$1("invalid", _e);
                        break;
                    case "textarea":
                        hb(_e, tt),
                        nt = gb(_e, tt),
                        D$1("invalid", _e);
                        break;
                    default:
                        nt = tt
                    }
                    ub(et, nt),
                    ot = nt;
                    for (rt in ot)
                        if (ot.hasOwnProperty(rt)) {
                            var st = ot[rt];
                            rt === "style" ? sb(_e, st) : rt === "dangerouslySetInnerHTML" ? (st = st ? st.__html : void 0,
                            st != null && nb(_e, st)) : rt === "children" ? typeof st == "string" ? (et !== "textarea" || st !== "") && ob(_e, st) : typeof st == "number" && ob(_e, "" + st) : rt !== "suppressContentEditableWarning" && rt !== "suppressHydrationWarning" && rt !== "autoFocus" && (ea.hasOwnProperty(rt) ? st != null && rt === "onScroll" && D$1("scroll", _e) : st != null && ta(_e, rt, st, it))
                        }
                    switch (et) {
                    case "input":
                        Va(_e),
                        db(_e, tt, !1);
                        break;
                    case "textarea":
                        Va(_e),
                        jb(_e);
                        break;
                    case "option":
                        tt.value != null && _e.setAttribute("value", "" + Sa(tt.value));
                        break;
                    case "select":
                        _e.multiple = !!tt.multiple,
                        rt = tt.value,
                        rt != null ? fb(_e, !!tt.multiple, rt, !1) : tt.defaultValue != null && fb(_e, !!tt.multiple, tt.defaultValue, !0);
                        break;
                    default:
                        typeof nt.onClick == "function" && (_e.onclick = Bf)
                    }
                    switch (et) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        tt = !!tt.autoFocus;
                        break e;
                    case "img":
                        tt = !0;
                        break e;
                    default:
                        tt = !1
                    }
                }
                tt && ($.flags |= 4)
            }
            $.ref !== null && ($.flags |= 512,
            $.flags |= 2097152)
        }
        return S($),
        null;
    case 6:
        if (_e && $.stateNode != null)
            Cj(_e, $, _e.memoizedProps, tt);
        else {
            if (typeof tt != "string" && $.stateNode === null)
                throw Error(p$2(166));
            if (et = xh(wh.current),
            xh(uh.current),
            Gg($)) {
                if (tt = $.stateNode,
                et = $.memoizedProps,
                tt[Of] = $,
                (rt = tt.nodeValue !== et) && (_e = xg,
                _e !== null))
                    switch (_e.tag) {
                    case 3:
                        Af(tt.nodeValue, et, (_e.mode & 1) !== 0);
                        break;
                    case 5:
                        _e.memoizedProps.suppressHydrationWarning !== !0 && Af(tt.nodeValue, et, (_e.mode & 1) !== 0)
                    }
                rt && ($.flags |= 4)
            } else
                tt = (et.nodeType === 9 ? et : et.ownerDocument).createTextNode(tt),
                tt[Of] = $,
                $.stateNode = tt
        }
        return S($),
        null;
    case 13:
        if (E(L),
        tt = $.memoizedState,
        _e === null || _e.memoizedState !== null && _e.memoizedState.dehydrated !== null) {
            if (I && yg !== null && $.mode & 1 && !($.flags & 128))
                Hg(),
                Ig(),
                $.flags |= 98560,
                rt = !1;
            else if (rt = Gg($),
            tt !== null && tt.dehydrated !== null) {
                if (_e === null) {
                    if (!rt)
                        throw Error(p$2(318));
                    if (rt = $.memoizedState,
                    rt = rt !== null ? rt.dehydrated : null,
                    !rt)
                        throw Error(p$2(317));
                    rt[Of] = $
                } else
                    Ig(),
                    !($.flags & 128) && ($.memoizedState = null),
                    $.flags |= 4;
                S($),
                rt = !1
            } else
                zg !== null && (Fj(zg),
                zg = null),
                rt = !0;
            if (!rt)
                return $.flags & 65536 ? $ : null
        }
        return $.flags & 128 ? ($.lanes = et,
        $) : (tt = tt !== null,
        tt !== (_e !== null && _e.memoizedState !== null) && tt && ($.child.flags |= 8192,
        $.mode & 1 && (_e === null || L.current & 1 ? T === 0 && (T = 3) : tj())),
        $.updateQueue !== null && ($.flags |= 4),
        S($),
        null);
    case 4:
        return zh(),
        Aj(_e, $),
        _e === null && sf($.stateNode.containerInfo),
        S($),
        null;
    case 10:
        return ah($.type._context),
        S($),
        null;
    case 17:
        return Zf($.type) && $f(),
        S($),
        null;
    case 19:
        if (E(L),
        rt = $.memoizedState,
        rt === null)
            return S($),
            null;
        if (tt = ($.flags & 128) !== 0,
        it = rt.rendering,
        it === null)
            if (tt)
                Dj(rt, !1);
            else {
                if (T !== 0 || _e !== null && _e.flags & 128)
                    for (_e = $.child; _e !== null; ) {
                        if (it = Ch(_e),
                        it !== null) {
                            for ($.flags |= 128,
                            Dj(rt, !1),
                            tt = it.updateQueue,
                            tt !== null && ($.updateQueue = tt,
                            $.flags |= 4),
                            $.subtreeFlags = 0,
                            tt = et,
                            et = $.child; et !== null; )
                                rt = et,
                                _e = tt,
                                rt.flags &= 14680066,
                                it = rt.alternate,
                                it === null ? (rt.childLanes = 0,
                                rt.lanes = _e,
                                rt.child = null,
                                rt.subtreeFlags = 0,
                                rt.memoizedProps = null,
                                rt.memoizedState = null,
                                rt.updateQueue = null,
                                rt.dependencies = null,
                                rt.stateNode = null) : (rt.childLanes = it.childLanes,
                                rt.lanes = it.lanes,
                                rt.child = it.child,
                                rt.subtreeFlags = 0,
                                rt.deletions = null,
                                rt.memoizedProps = it.memoizedProps,
                                rt.memoizedState = it.memoizedState,
                                rt.updateQueue = it.updateQueue,
                                rt.type = it.type,
                                _e = it.dependencies,
                                rt.dependencies = _e === null ? null : {
                                    lanes: _e.lanes,
                                    firstContext: _e.firstContext
                                }),
                                et = et.sibling;
                            return G(L, L.current & 1 | 2),
                            $.child
                        }
                        _e = _e.sibling
                    }
                rt.tail !== null && B() > Gj && ($.flags |= 128,
                tt = !0,
                Dj(rt, !1),
                $.lanes = 4194304)
            }
        else {
            if (!tt)
                if (_e = Ch(it),
                _e !== null) {
                    if ($.flags |= 128,
                    tt = !0,
                    et = _e.updateQueue,
                    et !== null && ($.updateQueue = et,
                    $.flags |= 4),
                    Dj(rt, !0),
                    rt.tail === null && rt.tailMode === "hidden" && !it.alternate && !I)
                        return S($),
                        null
                } else
                    2 * B() - rt.renderingStartTime > Gj && et !== 1073741824 && ($.flags |= 128,
                    tt = !0,
                    Dj(rt, !1),
                    $.lanes = 4194304);
            rt.isBackwards ? (it.sibling = $.child,
            $.child = it) : (et = rt.last,
            et !== null ? et.sibling = it : $.child = it,
            rt.last = it)
        }
        return rt.tail !== null ? ($ = rt.tail,
        rt.rendering = $,
        rt.tail = $.sibling,
        rt.renderingStartTime = B(),
        $.sibling = null,
        et = L.current,
        G(L, tt ? et & 1 | 2 : et & 1),
        $) : (S($),
        null);
    case 22:
    case 23:
        return Hj(),
        tt = $.memoizedState !== null,
        _e !== null && _e.memoizedState !== null !== tt && ($.flags |= 8192),
        tt && $.mode & 1 ? fj & 1073741824 && (S($),
        $.subtreeFlags & 6 && ($.flags |= 8192)) : S($),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(p$2(156, $.tag))
}
function Ij(_e, $) {
    switch (wg($),
    $.tag) {
    case 1:
        return Zf($.type) && $f(),
        _e = $.flags,
        _e & 65536 ? ($.flags = _e & -65537 | 128,
        $) : null;
    case 3:
        return zh(),
        E(Wf),
        E(H),
        Eh(),
        _e = $.flags,
        _e & 65536 && !(_e & 128) ? ($.flags = _e & -65537 | 128,
        $) : null;
    case 5:
        return Bh($),
        null;
    case 13:
        if (E(L),
        _e = $.memoizedState,
        _e !== null && _e.dehydrated !== null) {
            if ($.alternate === null)
                throw Error(p$2(340));
            Ig()
        }
        return _e = $.flags,
        _e & 65536 ? ($.flags = _e & -65537 | 128,
        $) : null;
    case 19:
        return E(L),
        null;
    case 4:
        return zh(),
        null;
    case 10:
        return ah($.type._context),
        null;
    case 22:
    case 23:
        return Hj(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var Jj = !1
  , U$1 = !1
  , Kj = typeof WeakSet == "function" ? WeakSet : Set
  , V$1 = null;
function Lj(_e, $) {
    var et = _e.ref;
    if (et !== null)
        if (typeof et == "function")
            try {
                et(null)
            } catch (tt) {
                W$1(_e, $, tt)
            }
        else
            et.current = null
}
function Mj(_e, $, et) {
    try {
        et()
    } catch (tt) {
        W$1(_e, $, tt)
    }
}
var Nj = !1;
function Oj(_e, $) {
    if (Cf = dd,
    _e = Me(),
    Ne(_e)) {
        if ("selectionStart"in _e)
            var et = {
                start: _e.selectionStart,
                end: _e.selectionEnd
            };
        else
            e: {
                et = (et = _e.ownerDocument) && et.defaultView || window;
                var tt = et.getSelection && et.getSelection();
                if (tt && tt.rangeCount !== 0) {
                    et = tt.anchorNode;
                    var nt = tt.anchorOffset
                      , rt = tt.focusNode;
                    tt = tt.focusOffset;
                    try {
                        et.nodeType,
                        rt.nodeType
                    } catch {
                        et = null;
                        break e
                    }
                    var it = 0
                      , ot = -1
                      , st = -1
                      , lt = 0
                      , ct = 0
                      , dt = _e
                      , pt = null;
                    t: for (; ; ) {
                        for (var ht; dt !== et || nt !== 0 && dt.nodeType !== 3 || (ot = it + nt),
                        dt !== rt || tt !== 0 && dt.nodeType !== 3 || (st = it + tt),
                        dt.nodeType === 3 && (it += dt.nodeValue.length),
                        (ht = dt.firstChild) !== null; )
                            pt = dt,
                            dt = ht;
                        for (; ; ) {
                            if (dt === _e)
                                break t;
                            if (pt === et && ++lt === nt && (ot = it),
                            pt === rt && ++ct === tt && (st = it),
                            (ht = dt.nextSibling) !== null)
                                break;
                            dt = pt,
                            pt = dt.parentNode
                        }
                        dt = ht
                    }
                    et = ot === -1 || st === -1 ? null : {
                        start: ot,
                        end: st
                    }
                } else
                    et = null
            }
        et = et || {
            start: 0,
            end: 0
        }
    } else
        et = null;
    for (Df = {
        focusedElem: _e,
        selectionRange: et
    },
    dd = !1,
    V$1 = $; V$1 !== null; )
        if ($ = V$1,
        _e = $.child,
        ($.subtreeFlags & 1028) !== 0 && _e !== null)
            _e.return = $,
            V$1 = _e;
        else
            for (; V$1 !== null; ) {
                $ = V$1;
                try {
                    var mt = $.alternate;
                    if ($.flags & 1024)
                        switch ($.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (mt !== null) {
                                var yt = mt.memoizedProps
                                  , Et = mt.memoizedState
                                  , _t = $.stateNode
                                  , wt = _t.getSnapshotBeforeUpdate($.elementType === $.type ? yt : Ci($.type, yt), Et);
                                _t.__reactInternalSnapshotBeforeUpdate = wt
                            }
                            break;
                        case 3:
                            var St = $.stateNode.containerInfo;
                            St.nodeType === 1 ? St.textContent = "" : St.nodeType === 9 && St.documentElement && St.removeChild(St.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(p$2(163))
                        }
                } catch (Ct) {
                    W$1($, $.return, Ct)
                }
                if (_e = $.sibling,
                _e !== null) {
                    _e.return = $.return,
                    V$1 = _e;
                    break
                }
                V$1 = $.return
            }
    return mt = Nj,
    Nj = !1,
    mt
}
function Pj(_e, $, et) {
    var tt = $.updateQueue;
    if (tt = tt !== null ? tt.lastEffect : null,
    tt !== null) {
        var nt = tt = tt.next;
        do {
            if ((nt.tag & _e) === _e) {
                var rt = nt.destroy;
                nt.destroy = void 0,
                rt !== void 0 && Mj($, et, rt)
            }
            nt = nt.next
        } while (nt !== tt)
    }
}
function Qj(_e, $) {
    if ($ = $.updateQueue,
    $ = $ !== null ? $.lastEffect : null,
    $ !== null) {
        var et = $ = $.next;
        do {
            if ((et.tag & _e) === _e) {
                var tt = et.create;
                et.destroy = tt()
            }
            et = et.next
        } while (et !== $)
    }
}
function Rj(_e) {
    var $ = _e.ref;
    if ($ !== null) {
        var et = _e.stateNode;
        switch (_e.tag) {
        case 5:
            _e = et;
            break;
        default:
            _e = et
        }
        typeof $ == "function" ? $(_e) : $.current = _e
    }
}
function Sj(_e) {
    var $ = _e.alternate;
    $ !== null && (_e.alternate = null,
    Sj($)),
    _e.child = null,
    _e.deletions = null,
    _e.sibling = null,
    _e.tag === 5 && ($ = _e.stateNode,
    $ !== null && (delete $[Of],
    delete $[Pf],
    delete $[of],
    delete $[Qf],
    delete $[Rf])),
    _e.stateNode = null,
    _e.return = null,
    _e.dependencies = null,
    _e.memoizedProps = null,
    _e.memoizedState = null,
    _e.pendingProps = null,
    _e.stateNode = null,
    _e.updateQueue = null
}
function Tj(_e) {
    return _e.tag === 5 || _e.tag === 3 || _e.tag === 4
}
function Uj(_e) {
    e: for (; ; ) {
        for (; _e.sibling === null; ) {
            if (_e.return === null || Tj(_e.return))
                return null;
            _e = _e.return
        }
        for (_e.sibling.return = _e.return,
        _e = _e.sibling; _e.tag !== 5 && _e.tag !== 6 && _e.tag !== 18; ) {
            if (_e.flags & 2 || _e.child === null || _e.tag === 4)
                continue e;
            _e.child.return = _e,
            _e = _e.child
        }
        if (!(_e.flags & 2))
            return _e.stateNode
    }
}
function Vj(_e, $, et) {
    var tt = _e.tag;
    if (tt === 5 || tt === 6)
        _e = _e.stateNode,
        $ ? et.nodeType === 8 ? et.parentNode.insertBefore(_e, $) : et.insertBefore(_e, $) : (et.nodeType === 8 ? ($ = et.parentNode,
        $.insertBefore(_e, et)) : ($ = et,
        $.appendChild(_e)),
        et = et._reactRootContainer,
        et != null || $.onclick !== null || ($.onclick = Bf));
    else if (tt !== 4 && (_e = _e.child,
    _e !== null))
        for (Vj(_e, $, et),
        _e = _e.sibling; _e !== null; )
            Vj(_e, $, et),
            _e = _e.sibling
}
function Wj(_e, $, et) {
    var tt = _e.tag;
    if (tt === 5 || tt === 6)
        _e = _e.stateNode,
        $ ? et.insertBefore(_e, $) : et.appendChild(_e);
    else if (tt !== 4 && (_e = _e.child,
    _e !== null))
        for (Wj(_e, $, et),
        _e = _e.sibling; _e !== null; )
            Wj(_e, $, et),
            _e = _e.sibling
}
var X$1 = null
  , Xj = !1;
function Yj(_e, $, et) {
    for (et = et.child; et !== null; )
        Zj(_e, $, et),
        et = et.sibling
}
function Zj(_e, $, et) {
    if (lc && typeof lc.onCommitFiberUnmount == "function")
        try {
            lc.onCommitFiberUnmount(kc, et)
        } catch {}
    switch (et.tag) {
    case 5:
        U$1 || Lj(et, $);
    case 6:
        var tt = X$1
          , nt = Xj;
        X$1 = null,
        Yj(_e, $, et),
        X$1 = tt,
        Xj = nt,
        X$1 !== null && (Xj ? (_e = X$1,
        et = et.stateNode,
        _e.nodeType === 8 ? _e.parentNode.removeChild(et) : _e.removeChild(et)) : X$1.removeChild(et.stateNode));
        break;
    case 18:
        X$1 !== null && (Xj ? (_e = X$1,
        et = et.stateNode,
        _e.nodeType === 8 ? Kf(_e.parentNode, et) : _e.nodeType === 1 && Kf(_e, et),
        bd(_e)) : Kf(X$1, et.stateNode));
        break;
    case 4:
        tt = X$1,
        nt = Xj,
        X$1 = et.stateNode.containerInfo,
        Xj = !0,
        Yj(_e, $, et),
        X$1 = tt,
        Xj = nt;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!U$1 && (tt = et.updateQueue,
        tt !== null && (tt = tt.lastEffect,
        tt !== null))) {
            nt = tt = tt.next;
            do {
                var rt = nt
                  , it = rt.destroy;
                rt = rt.tag,
                it !== void 0 && (rt & 2 || rt & 4) && Mj(et, $, it),
                nt = nt.next
            } while (nt !== tt)
        }
        Yj(_e, $, et);
        break;
    case 1:
        if (!U$1 && (Lj(et, $),
        tt = et.stateNode,
        typeof tt.componentWillUnmount == "function"))
            try {
                tt.props = et.memoizedProps,
                tt.state = et.memoizedState,
                tt.componentWillUnmount()
            } catch (ot) {
                W$1(et, $, ot)
            }
        Yj(_e, $, et);
        break;
    case 21:
        Yj(_e, $, et);
        break;
    case 22:
        et.mode & 1 ? (U$1 = (tt = U$1) || et.memoizedState !== null,
        Yj(_e, $, et),
        U$1 = tt) : Yj(_e, $, et);
        break;
    default:
        Yj(_e, $, et)
    }
}
function ak(_e) {
    var $ = _e.updateQueue;
    if ($ !== null) {
        _e.updateQueue = null;
        var et = _e.stateNode;
        et === null && (et = _e.stateNode = new Kj),
        $.forEach(function(tt) {
            var nt = bk.bind(null, _e, tt);
            et.has(tt) || (et.add(tt),
            tt.then(nt, nt))
        })
    }
}
function ck(_e, $) {
    var et = $.deletions;
    if (et !== null)
        for (var tt = 0; tt < et.length; tt++) {
            var nt = et[tt];
            try {
                var rt = _e
                  , it = $
                  , ot = it;
                e: for (; ot !== null; ) {
                    switch (ot.tag) {
                    case 5:
                        X$1 = ot.stateNode,
                        Xj = !1;
                        break e;
                    case 3:
                        X$1 = ot.stateNode.containerInfo,
                        Xj = !0;
                        break e;
                    case 4:
                        X$1 = ot.stateNode.containerInfo,
                        Xj = !0;
                        break e
                    }
                    ot = ot.return
                }
                if (X$1 === null)
                    throw Error(p$2(160));
                Zj(rt, it, nt),
                X$1 = null,
                Xj = !1;
                var st = nt.alternate;
                st !== null && (st.return = null),
                nt.return = null
            } catch (lt) {
                W$1(nt, $, lt)
            }
        }
    if ($.subtreeFlags & 12854)
        for ($ = $.child; $ !== null; )
            dk($, _e),
            $ = $.sibling
}
function dk(_e, $) {
    var et = _e.alternate
      , tt = _e.flags;
    switch (_e.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (ck($, _e),
        ek(_e),
        tt & 4) {
            try {
                Pj(3, _e, _e.return),
                Qj(3, _e)
            } catch (yt) {
                W$1(_e, _e.return, yt)
            }
            try {
                Pj(5, _e, _e.return)
            } catch (yt) {
                W$1(_e, _e.return, yt)
            }
        }
        break;
    case 1:
        ck($, _e),
        ek(_e),
        tt & 512 && et !== null && Lj(et, et.return);
        break;
    case 5:
        if (ck($, _e),
        ek(_e),
        tt & 512 && et !== null && Lj(et, et.return),
        _e.flags & 32) {
            var nt = _e.stateNode;
            try {
                ob(nt, "")
            } catch (yt) {
                W$1(_e, _e.return, yt)
            }
        }
        if (tt & 4 && (nt = _e.stateNode,
        nt != null)) {
            var rt = _e.memoizedProps
              , it = et !== null ? et.memoizedProps : rt
              , ot = _e.type
              , st = _e.updateQueue;
            if (_e.updateQueue = null,
            st !== null)
                try {
                    ot === "input" && rt.type === "radio" && rt.name != null && ab(nt, rt),
                    vb(ot, it);
                    var lt = vb(ot, rt);
                    for (it = 0; it < st.length; it += 2) {
                        var ct = st[it]
                          , dt = st[it + 1];
                        ct === "style" ? sb(nt, dt) : ct === "dangerouslySetInnerHTML" ? nb(nt, dt) : ct === "children" ? ob(nt, dt) : ta(nt, ct, dt, lt)
                    }
                    switch (ot) {
                    case "input":
                        bb(nt, rt);
                        break;
                    case "textarea":
                        ib(nt, rt);
                        break;
                    case "select":
                        var pt = nt._wrapperState.wasMultiple;
                        nt._wrapperState.wasMultiple = !!rt.multiple;
                        var ht = rt.value;
                        ht != null ? fb(nt, !!rt.multiple, ht, !1) : pt !== !!rt.multiple && (rt.defaultValue != null ? fb(nt, !!rt.multiple, rt.defaultValue, !0) : fb(nt, !!rt.multiple, rt.multiple ? [] : "", !1))
                    }
                    nt[Pf] = rt
                } catch (yt) {
                    W$1(_e, _e.return, yt)
                }
        }
        break;
    case 6:
        if (ck($, _e),
        ek(_e),
        tt & 4) {
            if (_e.stateNode === null)
                throw Error(p$2(162));
            nt = _e.stateNode,
            rt = _e.memoizedProps;
            try {
                nt.nodeValue = rt
            } catch (yt) {
                W$1(_e, _e.return, yt)
            }
        }
        break;
    case 3:
        if (ck($, _e),
        ek(_e),
        tt & 4 && et !== null && et.memoizedState.isDehydrated)
            try {
                bd($.containerInfo)
            } catch (yt) {
                W$1(_e, _e.return, yt)
            }
        break;
    case 4:
        ck($, _e),
        ek(_e);
        break;
    case 13:
        ck($, _e),
        ek(_e),
        nt = _e.child,
        nt.flags & 8192 && (rt = nt.memoizedState !== null,
        nt.stateNode.isHidden = rt,
        !rt || nt.alternate !== null && nt.alternate.memoizedState !== null || (fk = B())),
        tt & 4 && ak(_e);
        break;
    case 22:
        if (ct = et !== null && et.memoizedState !== null,
        _e.mode & 1 ? (U$1 = (lt = U$1) || ct,
        ck($, _e),
        U$1 = lt) : ck($, _e),
        ek(_e),
        tt & 8192) {
            if (lt = _e.memoizedState !== null,
            (_e.stateNode.isHidden = lt) && !ct && _e.mode & 1)
                for (V$1 = _e,
                ct = _e.child; ct !== null; ) {
                    for (dt = V$1 = ct; V$1 !== null; ) {
                        switch (pt = V$1,
                        ht = pt.child,
                        pt.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Pj(4, pt, pt.return);
                            break;
                        case 1:
                            Lj(pt, pt.return);
                            var mt = pt.stateNode;
                            if (typeof mt.componentWillUnmount == "function") {
                                tt = pt,
                                et = pt.return;
                                try {
                                    $ = tt,
                                    mt.props = $.memoizedProps,
                                    mt.state = $.memoizedState,
                                    mt.componentWillUnmount()
                                } catch (yt) {
                                    W$1(tt, et, yt)
                                }
                            }
                            break;
                        case 5:
                            Lj(pt, pt.return);
                            break;
                        case 22:
                            if (pt.memoizedState !== null) {
                                gk(dt);
                                continue
                            }
                        }
                        ht !== null ? (ht.return = pt,
                        V$1 = ht) : gk(dt)
                    }
                    ct = ct.sibling
                }
            e: for (ct = null,
            dt = _e; ; ) {
                if (dt.tag === 5) {
                    if (ct === null) {
                        ct = dt;
                        try {
                            nt = dt.stateNode,
                            lt ? (rt = nt.style,
                            typeof rt.setProperty == "function" ? rt.setProperty("display", "none", "important") : rt.display = "none") : (ot = dt.stateNode,
                            st = dt.memoizedProps.style,
                            it = st != null && st.hasOwnProperty("display") ? st.display : null,
                            ot.style.display = rb("display", it))
                        } catch (yt) {
                            W$1(_e, _e.return, yt)
                        }
                    }
                } else if (dt.tag === 6) {
                    if (ct === null)
                        try {
                            dt.stateNode.nodeValue = lt ? "" : dt.memoizedProps
                        } catch (yt) {
                            W$1(_e, _e.return, yt)
                        }
                } else if ((dt.tag !== 22 && dt.tag !== 23 || dt.memoizedState === null || dt === _e) && dt.child !== null) {
                    dt.child.return = dt,
                    dt = dt.child;
                    continue
                }
                if (dt === _e)
                    break e;
                for (; dt.sibling === null; ) {
                    if (dt.return === null || dt.return === _e)
                        break e;
                    ct === dt && (ct = null),
                    dt = dt.return
                }
                ct === dt && (ct = null),
                dt.sibling.return = dt.return,
                dt = dt.sibling
            }
        }
        break;
    case 19:
        ck($, _e),
        ek(_e),
        tt & 4 && ak(_e);
        break;
    case 21:
        break;
    default:
        ck($, _e),
        ek(_e)
    }
}
function ek(_e) {
    var $ = _e.flags;
    if ($ & 2) {
        try {
            e: {
                for (var et = _e.return; et !== null; ) {
                    if (Tj(et)) {
                        var tt = et;
                        break e
                    }
                    et = et.return
                }
                throw Error(p$2(160))
            }
            switch (tt.tag) {
            case 5:
                var nt = tt.stateNode;
                tt.flags & 32 && (ob(nt, ""),
                tt.flags &= -33);
                var rt = Uj(_e);
                Wj(_e, rt, nt);
                break;
            case 3:
            case 4:
                var it = tt.stateNode.containerInfo
                  , ot = Uj(_e);
                Vj(_e, ot, it);
                break;
            default:
                throw Error(p$2(161))
            }
        } catch (st) {
            W$1(_e, _e.return, st)
        }
        _e.flags &= -3
    }
    $ & 4096 && (_e.flags &= -4097)
}
function hk(_e, $, et) {
    V$1 = _e,
    ik(_e)
}
function ik(_e, $, et) {
    for (var tt = (_e.mode & 1) !== 0; V$1 !== null; ) {
        var nt = V$1
          , rt = nt.child;
        if (nt.tag === 22 && tt) {
            var it = nt.memoizedState !== null || Jj;
            if (!it) {
                var ot = nt.alternate
                  , st = ot !== null && ot.memoizedState !== null || U$1;
                ot = Jj;
                var lt = U$1;
                if (Jj = it,
                (U$1 = st) && !lt)
                    for (V$1 = nt; V$1 !== null; )
                        it = V$1,
                        st = it.child,
                        it.tag === 22 && it.memoizedState !== null ? jk(nt) : st !== null ? (st.return = it,
                        V$1 = st) : jk(nt);
                for (; rt !== null; )
                    V$1 = rt,
                    ik(rt),
                    rt = rt.sibling;
                V$1 = nt,
                Jj = ot,
                U$1 = lt
            }
            kk(_e)
        } else
            nt.subtreeFlags & 8772 && rt !== null ? (rt.return = nt,
            V$1 = rt) : kk(_e)
    }
}
function kk(_e) {
    for (; V$1 !== null; ) {
        var $ = V$1;
        if ($.flags & 8772) {
            var et = $.alternate;
            try {
                if ($.flags & 8772)
                    switch ($.tag) {
                    case 0:
                    case 11:
                    case 15:
                        U$1 || Qj(5, $);
                        break;
                    case 1:
                        var tt = $.stateNode;
                        if ($.flags & 4 && !U$1)
                            if (et === null)
                                tt.componentDidMount();
                            else {
                                var nt = $.elementType === $.type ? et.memoizedProps : Ci($.type, et.memoizedProps);
                                tt.componentDidUpdate(nt, et.memoizedState, tt.__reactInternalSnapshotBeforeUpdate)
                            }
                        var rt = $.updateQueue;
                        rt !== null && sh($, rt, tt);
                        break;
                    case 3:
                        var it = $.updateQueue;
                        if (it !== null) {
                            if (et = null,
                            $.child !== null)
                                switch ($.child.tag) {
                                case 5:
                                    et = $.child.stateNode;
                                    break;
                                case 1:
                                    et = $.child.stateNode
                                }
                            sh($, it, et)
                        }
                        break;
                    case 5:
                        var ot = $.stateNode;
                        if (et === null && $.flags & 4) {
                            et = ot;
                            var st = $.memoizedProps;
                            switch ($.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                st.autoFocus && et.focus();
                                break;
                            case "img":
                                st.src && (et.src = st.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if ($.memoizedState === null) {
                            var lt = $.alternate;
                            if (lt !== null) {
                                var ct = lt.memoizedState;
                                if (ct !== null) {
                                    var dt = ct.dehydrated;
                                    dt !== null && bd(dt)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(p$2(163))
                    }
                U$1 || $.flags & 512 && Rj($)
            } catch (pt) {
                W$1($, $.return, pt)
            }
        }
        if ($ === _e) {
            V$1 = null;
            break
        }
        if (et = $.sibling,
        et !== null) {
            et.return = $.return,
            V$1 = et;
            break
        }
        V$1 = $.return
    }
}
function gk(_e) {
    for (; V$1 !== null; ) {
        var $ = V$1;
        if ($ === _e) {
            V$1 = null;
            break
        }
        var et = $.sibling;
        if (et !== null) {
            et.return = $.return,
            V$1 = et;
            break
        }
        V$1 = $.return
    }
}
function jk(_e) {
    for (; V$1 !== null; ) {
        var $ = V$1;
        try {
            switch ($.tag) {
            case 0:
            case 11:
            case 15:
                var et = $.return;
                try {
                    Qj(4, $)
                } catch (st) {
                    W$1($, et, st)
                }
                break;
            case 1:
                var tt = $.stateNode;
                if (typeof tt.componentDidMount == "function") {
                    var nt = $.return;
                    try {
                        tt.componentDidMount()
                    } catch (st) {
                        W$1($, nt, st)
                    }
                }
                var rt = $.return;
                try {
                    Rj($)
                } catch (st) {
                    W$1($, rt, st)
                }
                break;
            case 5:
                var it = $.return;
                try {
                    Rj($)
                } catch (st) {
                    W$1($, it, st)
                }
            }
        } catch (st) {
            W$1($, $.return, st)
        }
        if ($ === _e) {
            V$1 = null;
            break
        }
        var ot = $.sibling;
        if (ot !== null) {
            ot.return = $.return,
            V$1 = ot;
            break
        }
        V$1 = $.return
    }
}
var lk = Math.ceil
  , mk = ua.ReactCurrentDispatcher
  , nk = ua.ReactCurrentOwner
  , ok = ua.ReactCurrentBatchConfig
  , K$1 = 0
  , Q = null
  , Y$1 = null
  , Z$1 = 0
  , fj = 0
  , ej = Uf(0)
  , T = 0
  , pk = null
  , rh = 0
  , qk = 0
  , rk = 0
  , sk = null
  , tk = null
  , fk = 0
  , Gj = 1 / 0
  , uk = null
  , Oi = !1
  , Pi = null
  , Ri = null
  , vk = !1
  , wk = null
  , xk = 0
  , yk = 0
  , zk = null
  , Ak = -1
  , Bk = 0;
function R$1() {
    return K$1 & 6 ? B() : Ak !== -1 ? Ak : Ak = B()
}
function yi(_e) {
    return _e.mode & 1 ? K$1 & 2 && Z$1 !== 0 ? Z$1 & -Z$1 : Kg.transition !== null ? (Bk === 0 && (Bk = yc()),
    Bk) : (_e = C$1,
    _e !== 0 || (_e = window.event,
    _e = _e === void 0 ? 16 : jd(_e.type)),
    _e) : 1
}
function gi(_e, $, et, tt) {
    if (50 < yk)
        throw yk = 0,
        zk = null,
        Error(p$2(185));
    Ac(_e, et, tt),
    (!(K$1 & 2) || _e !== Q) && (_e === Q && (!(K$1 & 2) && (qk |= et),
    T === 4 && Ck(_e, Z$1)),
    Dk(_e, tt),
    et === 1 && K$1 === 0 && !($.mode & 1) && (Gj = B() + 500,
    fg && jg()))
}
function Dk(_e, $) {
    var et = _e.callbackNode;
    wc(_e, $);
    var tt = uc(_e, _e === Q ? Z$1 : 0);
    if (tt === 0)
        et !== null && bc(et),
        _e.callbackNode = null,
        _e.callbackPriority = 0;
    else if ($ = tt & -tt,
    _e.callbackPriority !== $) {
        if (et != null && bc(et),
        $ === 1)
            _e.tag === 0 ? ig(Ek.bind(null, _e)) : hg(Ek.bind(null, _e)),
            Jf(function() {
                !(K$1 & 6) && jg()
            }),
            et = null;
        else {
            switch (Dc(tt)) {
            case 1:
                et = fc;
                break;
            case 4:
                et = gc;
                break;
            case 16:
                et = hc;
                break;
            case 536870912:
                et = jc;
                break;
            default:
                et = hc
            }
            et = Fk(et, Gk.bind(null, _e))
        }
        _e.callbackPriority = $,
        _e.callbackNode = et
    }
}
function Gk(_e, $) {
    if (Ak = -1,
    Bk = 0,
    K$1 & 6)
        throw Error(p$2(327));
    var et = _e.callbackNode;
    if (Hk() && _e.callbackNode !== et)
        return null;
    var tt = uc(_e, _e === Q ? Z$1 : 0);
    if (tt === 0)
        return null;
    if (tt & 30 || tt & _e.expiredLanes || $)
        $ = Ik(_e, tt);
    else {
        $ = tt;
        var nt = K$1;
        K$1 |= 2;
        var rt = Jk();
        (Q !== _e || Z$1 !== $) && (uk = null,
        Gj = B() + 500,
        Kk(_e, $));
        do
            try {
                Lk();
                break
            } catch (ot) {
                Mk(_e, ot)
            }
        while (!0);
        $g(),
        mk.current = rt,
        K$1 = nt,
        Y$1 !== null ? $ = 0 : (Q = null,
        Z$1 = 0,
        $ = T)
    }
    if ($ !== 0) {
        if ($ === 2 && (nt = xc(_e),
        nt !== 0 && (tt = nt,
        $ = Nk(_e, nt))),
        $ === 1)
            throw et = pk,
            Kk(_e, 0),
            Ck(_e, tt),
            Dk(_e, B()),
            et;
        if ($ === 6)
            Ck(_e, tt);
        else {
            if (nt = _e.current.alternate,
            !(tt & 30) && !Ok(nt) && ($ = Ik(_e, tt),
            $ === 2 && (rt = xc(_e),
            rt !== 0 && (tt = rt,
            $ = Nk(_e, rt))),
            $ === 1))
                throw et = pk,
                Kk(_e, 0),
                Ck(_e, tt),
                Dk(_e, B()),
                et;
            switch (_e.finishedWork = nt,
            _e.finishedLanes = tt,
            $) {
            case 0:
            case 1:
                throw Error(p$2(345));
            case 2:
                Pk(_e, tk, uk);
                break;
            case 3:
                if (Ck(_e, tt),
                (tt & 130023424) === tt && ($ = fk + 500 - B(),
                10 < $)) {
                    if (uc(_e, 0) !== 0)
                        break;
                    if (nt = _e.suspendedLanes,
                    (nt & tt) !== tt) {
                        R$1(),
                        _e.pingedLanes |= _e.suspendedLanes & nt;
                        break
                    }
                    _e.timeoutHandle = Ff(Pk.bind(null, _e, tk, uk), $);
                    break
                }
                Pk(_e, tk, uk);
                break;
            case 4:
                if (Ck(_e, tt),
                (tt & 4194240) === tt)
                    break;
                for ($ = _e.eventTimes,
                nt = -1; 0 < tt; ) {
                    var it = 31 - oc(tt);
                    rt = 1 << it,
                    it = $[it],
                    it > nt && (nt = it),
                    tt &= ~rt
                }
                if (tt = nt,
                tt = B() - tt,
                tt = (120 > tt ? 120 : 480 > tt ? 480 : 1080 > tt ? 1080 : 1920 > tt ? 1920 : 3e3 > tt ? 3e3 : 4320 > tt ? 4320 : 1960 * lk(tt / 1960)) - tt,
                10 < tt) {
                    _e.timeoutHandle = Ff(Pk.bind(null, _e, tk, uk), tt);
                    break
                }
                Pk(_e, tk, uk);
                break;
            case 5:
                Pk(_e, tk, uk);
                break;
            default:
                throw Error(p$2(329))
            }
        }
    }
    return Dk(_e, B()),
    _e.callbackNode === et ? Gk.bind(null, _e) : null
}
function Nk(_e, $) {
    var et = sk;
    return _e.current.memoizedState.isDehydrated && (Kk(_e, $).flags |= 256),
    _e = Ik(_e, $),
    _e !== 2 && ($ = tk,
    tk = et,
    $ !== null && Fj($)),
    _e
}
function Fj(_e) {
    tk === null ? tk = _e : tk.push.apply(tk, _e)
}
function Ok(_e) {
    for (var $ = _e; ; ) {
        if ($.flags & 16384) {
            var et = $.updateQueue;
            if (et !== null && (et = et.stores,
            et !== null))
                for (var tt = 0; tt < et.length; tt++) {
                    var nt = et[tt]
                      , rt = nt.getSnapshot;
                    nt = nt.value;
                    try {
                        if (!He(rt(), nt))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (et = $.child,
        $.subtreeFlags & 16384 && et !== null)
            et.return = $,
            $ = et;
        else {
            if ($ === _e)
                break;
            for (; $.sibling === null; ) {
                if ($.return === null || $.return === _e)
                    return !0;
                $ = $.return
            }
            $.sibling.return = $.return,
            $ = $.sibling
        }
    }
    return !0
}
function Ck(_e, $) {
    for ($ &= ~rk,
    $ &= ~qk,
    _e.suspendedLanes |= $,
    _e.pingedLanes &= ~$,
    _e = _e.expirationTimes; 0 < $; ) {
        var et = 31 - oc($)
          , tt = 1 << et;
        _e[et] = -1,
        $ &= ~tt
    }
}
function Ek(_e) {
    if (K$1 & 6)
        throw Error(p$2(327));
    Hk();
    var $ = uc(_e, 0);
    if (!($ & 1))
        return Dk(_e, B()),
        null;
    var et = Ik(_e, $);
    if (_e.tag !== 0 && et === 2) {
        var tt = xc(_e);
        tt !== 0 && ($ = tt,
        et = Nk(_e, tt))
    }
    if (et === 1)
        throw et = pk,
        Kk(_e, 0),
        Ck(_e, $),
        Dk(_e, B()),
        et;
    if (et === 6)
        throw Error(p$2(345));
    return _e.finishedWork = _e.current.alternate,
    _e.finishedLanes = $,
    Pk(_e, tk, uk),
    Dk(_e, B()),
    null
}
function Qk(_e, $) {
    var et = K$1;
    K$1 |= 1;
    try {
        return _e($)
    } finally {
        K$1 = et,
        K$1 === 0 && (Gj = B() + 500,
        fg && jg())
    }
}
function Rk(_e) {
    wk !== null && wk.tag === 0 && !(K$1 & 6) && Hk();
    var $ = K$1;
    K$1 |= 1;
    var et = ok.transition
      , tt = C$1;
    try {
        if (ok.transition = null,
        C$1 = 1,
        _e)
            return _e()
    } finally {
        C$1 = tt,
        ok.transition = et,
        K$1 = $,
        !(K$1 & 6) && jg()
    }
}
function Hj() {
    fj = ej.current,
    E(ej)
}
function Kk(_e, $) {
    _e.finishedWork = null,
    _e.finishedLanes = 0;
    var et = _e.timeoutHandle;
    if (et !== -1 && (_e.timeoutHandle = -1,
    Gf(et)),
    Y$1 !== null)
        for (et = Y$1.return; et !== null; ) {
            var tt = et;
            switch (wg(tt),
            tt.tag) {
            case 1:
                tt = tt.type.childContextTypes,
                tt != null && $f();
                break;
            case 3:
                zh(),
                E(Wf),
                E(H),
                Eh();
                break;
            case 5:
                Bh(tt);
                break;
            case 4:
                zh();
                break;
            case 13:
                E(L);
                break;
            case 19:
                E(L);
                break;
            case 10:
                ah(tt.type._context);
                break;
            case 22:
            case 23:
                Hj()
            }
            et = et.return
        }
    if (Q = _e,
    Y$1 = _e = Pg(_e.current, null),
    Z$1 = fj = $,
    T = 0,
    pk = null,
    rk = qk = rh = 0,
    tk = sk = null,
    fh !== null) {
        for ($ = 0; $ < fh.length; $++)
            if (et = fh[$],
            tt = et.interleaved,
            tt !== null) {
                et.interleaved = null;
                var nt = tt.next
                  , rt = et.pending;
                if (rt !== null) {
                    var it = rt.next;
                    rt.next = nt,
                    tt.next = it
                }
                et.pending = tt
            }
        fh = null
    }
    return _e
}
function Mk(_e, $) {
    do {
        var et = Y$1;
        try {
            if ($g(),
            Fh.current = Rh,
            Ih) {
                for (var tt = M$1.memoizedState; tt !== null; ) {
                    var nt = tt.queue;
                    nt !== null && (nt.pending = null),
                    tt = tt.next
                }
                Ih = !1
            }
            if (Hh = 0,
            O$1 = N = M$1 = null,
            Jh = !1,
            Kh = 0,
            nk.current = null,
            et === null || et.return === null) {
                T = 1,
                pk = $,
                Y$1 = null;
                break
            }
            e: {
                var rt = _e
                  , it = et.return
                  , ot = et
                  , st = $;
                if ($ = Z$1,
                ot.flags |= 32768,
                st !== null && typeof st == "object" && typeof st.then == "function") {
                    var lt = st
                      , ct = ot
                      , dt = ct.tag;
                    if (!(ct.mode & 1) && (dt === 0 || dt === 11 || dt === 15)) {
                        var pt = ct.alternate;
                        pt ? (ct.updateQueue = pt.updateQueue,
                        ct.memoizedState = pt.memoizedState,
                        ct.lanes = pt.lanes) : (ct.updateQueue = null,
                        ct.memoizedState = null)
                    }
                    var ht = Ui(it);
                    if (ht !== null) {
                        ht.flags &= -257,
                        Vi(ht, it, ot, rt, $),
                        ht.mode & 1 && Si(rt, lt, $),
                        $ = ht,
                        st = lt;
                        var mt = $.updateQueue;
                        if (mt === null) {
                            var yt = new Set;
                            yt.add(st),
                            $.updateQueue = yt
                        } else
                            mt.add(st);
                        break e
                    } else {
                        if (!($ & 1)) {
                            Si(rt, lt, $),
                            tj();
                            break e
                        }
                        st = Error(p$2(426))
                    }
                } else if (I && ot.mode & 1) {
                    var Et = Ui(it);
                    if (Et !== null) {
                        !(Et.flags & 65536) && (Et.flags |= 256),
                        Vi(Et, it, ot, rt, $),
                        Jg(Ji(st, ot));
                        break e
                    }
                }
                rt = st = Ji(st, ot),
                T !== 4 && (T = 2),
                sk === null ? sk = [rt] : sk.push(rt),
                rt = it;
                do {
                    switch (rt.tag) {
                    case 3:
                        rt.flags |= 65536,
                        $ &= -$,
                        rt.lanes |= $;
                        var _t = Ni(rt, st, $);
                        ph(rt, _t);
                        break e;
                    case 1:
                        ot = st;
                        var wt = rt.type
                          , St = rt.stateNode;
                        if (!(rt.flags & 128) && (typeof wt.getDerivedStateFromError == "function" || St !== null && typeof St.componentDidCatch == "function" && (Ri === null || !Ri.has(St)))) {
                            rt.flags |= 65536,
                            $ &= -$,
                            rt.lanes |= $;
                            var Ct = Qi(rt, ot, $);
                            ph(rt, Ct);
                            break e
                        }
                    }
                    rt = rt.return
                } while (rt !== null)
            }
            Sk(et)
        } catch (Nt) {
            $ = Nt,
            Y$1 === et && et !== null && (Y$1 = et = et.return);
            continue
        }
        break
    } while (!0)
}
function Jk() {
    var _e = mk.current;
    return mk.current = Rh,
    _e === null ? Rh : _e
}
function tj() {
    (T === 0 || T === 3 || T === 2) && (T = 4),
    Q === null || !(rh & 268435455) && !(qk & 268435455) || Ck(Q, Z$1)
}
function Ik(_e, $) {
    var et = K$1;
    K$1 |= 2;
    var tt = Jk();
    (Q !== _e || Z$1 !== $) && (uk = null,
    Kk(_e, $));
    do
        try {
            Tk();
            break
        } catch (nt) {
            Mk(_e, nt)
        }
    while (!0);
    if ($g(),
    K$1 = et,
    mk.current = tt,
    Y$1 !== null)
        throw Error(p$2(261));
    return Q = null,
    Z$1 = 0,
    T
}
function Tk() {
    for (; Y$1 !== null; )
        Uk(Y$1)
}
function Lk() {
    for (; Y$1 !== null && !cc(); )
        Uk(Y$1)
}
function Uk(_e) {
    var $ = Vk(_e.alternate, _e, fj);
    _e.memoizedProps = _e.pendingProps,
    $ === null ? Sk(_e) : Y$1 = $,
    nk.current = null
}
function Sk(_e) {
    var $ = _e;
    do {
        var et = $.alternate;
        if (_e = $.return,
        $.flags & 32768) {
            if (et = Ij(et, $),
            et !== null) {
                et.flags &= 32767,
                Y$1 = et;
                return
            }
            if (_e !== null)
                _e.flags |= 32768,
                _e.subtreeFlags = 0,
                _e.deletions = null;
            else {
                T = 6,
                Y$1 = null;
                return
            }
        } else if (et = Ej(et, $, fj),
        et !== null) {
            Y$1 = et;
            return
        }
        if ($ = $.sibling,
        $ !== null) {
            Y$1 = $;
            return
        }
        Y$1 = $ = _e
    } while ($ !== null);
    T === 0 && (T = 5)
}
function Pk(_e, $, et) {
    var tt = C$1
      , nt = ok.transition;
    try {
        ok.transition = null,
        C$1 = 1,
        Wk(_e, $, et, tt)
    } finally {
        ok.transition = nt,
        C$1 = tt
    }
    return null
}
function Wk(_e, $, et, tt) {
    do
        Hk();
    while (wk !== null);
    if (K$1 & 6)
        throw Error(p$2(327));
    et = _e.finishedWork;
    var nt = _e.finishedLanes;
    if (et === null)
        return null;
    if (_e.finishedWork = null,
    _e.finishedLanes = 0,
    et === _e.current)
        throw Error(p$2(177));
    _e.callbackNode = null,
    _e.callbackPriority = 0;
    var rt = et.lanes | et.childLanes;
    if (Bc(_e, rt),
    _e === Q && (Y$1 = Q = null,
    Z$1 = 0),
    !(et.subtreeFlags & 2064) && !(et.flags & 2064) || vk || (vk = !0,
    Fk(hc, function() {
        return Hk(),
        null
    })),
    rt = (et.flags & 15990) !== 0,
    et.subtreeFlags & 15990 || rt) {
        rt = ok.transition,
        ok.transition = null;
        var it = C$1;
        C$1 = 1;
        var ot = K$1;
        K$1 |= 4,
        nk.current = null,
        Oj(_e, et),
        dk(et, _e),
        Oe$1(Df),
        dd = !!Cf,
        Df = Cf = null,
        _e.current = et,
        hk(et),
        dc(),
        K$1 = ot,
        C$1 = it,
        ok.transition = rt
    } else
        _e.current = et;
    if (vk && (vk = !1,
    wk = _e,
    xk = nt),
    rt = _e.pendingLanes,
    rt === 0 && (Ri = null),
    mc(et.stateNode),
    Dk(_e, B()),
    $ !== null)
        for (tt = _e.onRecoverableError,
        et = 0; et < $.length; et++)
            nt = $[et],
            tt(nt.value, {
                componentStack: nt.stack,
                digest: nt.digest
            });
    if (Oi)
        throw Oi = !1,
        _e = Pi,
        Pi = null,
        _e;
    return xk & 1 && _e.tag !== 0 && Hk(),
    rt = _e.pendingLanes,
    rt & 1 ? _e === zk ? yk++ : (yk = 0,
    zk = _e) : yk = 0,
    jg(),
    null
}
function Hk() {
    if (wk !== null) {
        var _e = Dc(xk)
          , $ = ok.transition
          , et = C$1;
        try {
            if (ok.transition = null,
            C$1 = 16 > _e ? 16 : _e,
            wk === null)
                var tt = !1;
            else {
                if (_e = wk,
                wk = null,
                xk = 0,
                K$1 & 6)
                    throw Error(p$2(331));
                var nt = K$1;
                for (K$1 |= 4,
                V$1 = _e.current; V$1 !== null; ) {
                    var rt = V$1
                      , it = rt.child;
                    if (V$1.flags & 16) {
                        var ot = rt.deletions;
                        if (ot !== null) {
                            for (var st = 0; st < ot.length; st++) {
                                var lt = ot[st];
                                for (V$1 = lt; V$1 !== null; ) {
                                    var ct = V$1;
                                    switch (ct.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Pj(8, ct, rt)
                                    }
                                    var dt = ct.child;
                                    if (dt !== null)
                                        dt.return = ct,
                                        V$1 = dt;
                                    else
                                        for (; V$1 !== null; ) {
                                            ct = V$1;
                                            var pt = ct.sibling
                                              , ht = ct.return;
                                            if (Sj(ct),
                                            ct === lt) {
                                                V$1 = null;
                                                break
                                            }
                                            if (pt !== null) {
                                                pt.return = ht,
                                                V$1 = pt;
                                                break
                                            }
                                            V$1 = ht
                                        }
                                }
                            }
                            var mt = rt.alternate;
                            if (mt !== null) {
                                var yt = mt.child;
                                if (yt !== null) {
                                    mt.child = null;
                                    do {
                                        var Et = yt.sibling;
                                        yt.sibling = null,
                                        yt = Et
                                    } while (yt !== null)
                                }
                            }
                            V$1 = rt
                        }
                    }
                    if (rt.subtreeFlags & 2064 && it !== null)
                        it.return = rt,
                        V$1 = it;
                    else
                        e: for (; V$1 !== null; ) {
                            if (rt = V$1,
                            rt.flags & 2048)
                                switch (rt.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Pj(9, rt, rt.return)
                                }
                            var _t = rt.sibling;
                            if (_t !== null) {
                                _t.return = rt.return,
                                V$1 = _t;
                                break e
                            }
                            V$1 = rt.return
                        }
                }
                var wt = _e.current;
                for (V$1 = wt; V$1 !== null; ) {
                    it = V$1;
                    var St = it.child;
                    if (it.subtreeFlags & 2064 && St !== null)
                        St.return = it,
                        V$1 = St;
                    else
                        e: for (it = wt; V$1 !== null; ) {
                            if (ot = V$1,
                            ot.flags & 2048)
                                try {
                                    switch (ot.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Qj(9, ot)
                                    }
                                } catch (Nt) {
                                    W$1(ot, ot.return, Nt)
                                }
                            if (ot === it) {
                                V$1 = null;
                                break e
                            }
                            var Ct = ot.sibling;
                            if (Ct !== null) {
                                Ct.return = ot.return,
                                V$1 = Ct;
                                break e
                            }
                            V$1 = ot.return
                        }
                }
                if (K$1 = nt,
                jg(),
                lc && typeof lc.onPostCommitFiberRoot == "function")
                    try {
                        lc.onPostCommitFiberRoot(kc, _e)
                    } catch {}
                tt = !0
            }
            return tt
        } finally {
            C$1 = et,
            ok.transition = $
        }
    }
    return !1
}
function Xk(_e, $, et) {
    $ = Ji(et, $),
    $ = Ni(_e, $, 1),
    _e = nh(_e, $, 1),
    $ = R$1(),
    _e !== null && (Ac(_e, 1, $),
    Dk(_e, $))
}
function W$1(_e, $, et) {
    if (_e.tag === 3)
        Xk(_e, _e, et);
    else
        for (; $ !== null; ) {
            if ($.tag === 3) {
                Xk($, _e, et);
                break
            } else if ($.tag === 1) {
                var tt = $.stateNode;
                if (typeof $.type.getDerivedStateFromError == "function" || typeof tt.componentDidCatch == "function" && (Ri === null || !Ri.has(tt))) {
                    _e = Ji(et, _e),
                    _e = Qi($, _e, 1),
                    $ = nh($, _e, 1),
                    _e = R$1(),
                    $ !== null && (Ac($, 1, _e),
                    Dk($, _e));
                    break
                }
            }
            $ = $.return
        }
}
function Ti(_e, $, et) {
    var tt = _e.pingCache;
    tt !== null && tt.delete($),
    $ = R$1(),
    _e.pingedLanes |= _e.suspendedLanes & et,
    Q === _e && (Z$1 & et) === et && (T === 4 || T === 3 && (Z$1 & 130023424) === Z$1 && 500 > B() - fk ? Kk(_e, 0) : rk |= et),
    Dk(_e, $)
}
function Yk(_e, $) {
    $ === 0 && (_e.mode & 1 ? ($ = sc,
    sc <<= 1,
    !(sc & 130023424) && (sc = 4194304)) : $ = 1);
    var et = R$1();
    _e = ih(_e, $),
    _e !== null && (Ac(_e, $, et),
    Dk(_e, et))
}
function uj(_e) {
    var $ = _e.memoizedState
      , et = 0;
    $ !== null && (et = $.retryLane),
    Yk(_e, et)
}
function bk(_e, $) {
    var et = 0;
    switch (_e.tag) {
    case 13:
        var tt = _e.stateNode
          , nt = _e.memoizedState;
        nt !== null && (et = nt.retryLane);
        break;
    case 19:
        tt = _e.stateNode;
        break;
    default:
        throw Error(p$2(314))
    }
    tt !== null && tt.delete($),
    Yk(_e, et)
}
var Vk;
Vk = function(_e, $, et) {
    if (_e !== null)
        if (_e.memoizedProps !== $.pendingProps || Wf.current)
            dh = !0;
        else {
            if (!(_e.lanes & et) && !($.flags & 128))
                return dh = !1,
                yj(_e, $, et);
            dh = !!(_e.flags & 131072)
        }
    else
        dh = !1,
        I && $.flags & 1048576 && ug($, ng, $.index);
    switch ($.lanes = 0,
    $.tag) {
    case 2:
        var tt = $.type;
        ij(_e, $),
        _e = $.pendingProps;
        var nt = Yf($, H.current);
        ch($, et),
        nt = Nh(null, $, tt, _e, nt, et);
        var rt = Sh();
        return $.flags |= 1,
        typeof nt == "object" && nt !== null && typeof nt.render == "function" && nt.$$typeof === void 0 ? ($.tag = 1,
        $.memoizedState = null,
        $.updateQueue = null,
        Zf(tt) ? (rt = !0,
        cg($)) : rt = !1,
        $.memoizedState = nt.state !== null && nt.state !== void 0 ? nt.state : null,
        kh($),
        nt.updater = Ei,
        $.stateNode = nt,
        nt._reactInternals = $,
        Ii($, tt, _e, et),
        $ = jj(null, $, tt, !0, rt, et)) : ($.tag = 0,
        I && rt && vg($),
        Xi(null, $, nt, et),
        $ = $.child),
        $;
    case 16:
        tt = $.elementType;
        e: {
            switch (ij(_e, $),
            _e = $.pendingProps,
            nt = tt._init,
            tt = nt(tt._payload),
            $.type = tt,
            nt = $.tag = Zk(tt),
            _e = Ci(tt, _e),
            nt) {
            case 0:
                $ = cj(null, $, tt, _e, et);
                break e;
            case 1:
                $ = hj(null, $, tt, _e, et);
                break e;
            case 11:
                $ = Yi(null, $, tt, _e, et);
                break e;
            case 14:
                $ = $i(null, $, tt, Ci(tt.type, _e), et);
                break e
            }
            throw Error(p$2(306, tt, ""))
        }
        return $;
    case 0:
        return tt = $.type,
        nt = $.pendingProps,
        nt = $.elementType === tt ? nt : Ci(tt, nt),
        cj(_e, $, tt, nt, et);
    case 1:
        return tt = $.type,
        nt = $.pendingProps,
        nt = $.elementType === tt ? nt : Ci(tt, nt),
        hj(_e, $, tt, nt, et);
    case 3:
        e: {
            if (kj($),
            _e === null)
                throw Error(p$2(387));
            tt = $.pendingProps,
            rt = $.memoizedState,
            nt = rt.element,
            lh(_e, $),
            qh($, tt, null, et);
            var it = $.memoizedState;
            if (tt = it.element,
            rt.isDehydrated)
                if (rt = {
                    element: tt,
                    isDehydrated: !1,
                    cache: it.cache,
                    pendingSuspenseBoundaries: it.pendingSuspenseBoundaries,
                    transitions: it.transitions
                },
                $.updateQueue.baseState = rt,
                $.memoizedState = rt,
                $.flags & 256) {
                    nt = Ji(Error(p$2(423)), $),
                    $ = lj(_e, $, tt, et, nt);
                    break e
                } else if (tt !== nt) {
                    nt = Ji(Error(p$2(424)), $),
                    $ = lj(_e, $, tt, et, nt);
                    break e
                } else
                    for (yg = Lf($.stateNode.containerInfo.firstChild),
                    xg = $,
                    I = !0,
                    zg = null,
                    et = Vg($, null, tt, et),
                    $.child = et; et; )
                        et.flags = et.flags & -3 | 4096,
                        et = et.sibling;
            else {
                if (Ig(),
                tt === nt) {
                    $ = Zi(_e, $, et);
                    break e
                }
                Xi(_e, $, tt, et)
            }
            $ = $.child
        }
        return $;
    case 5:
        return Ah($),
        _e === null && Eg($),
        tt = $.type,
        nt = $.pendingProps,
        rt = _e !== null ? _e.memoizedProps : null,
        it = nt.children,
        Ef(tt, nt) ? it = null : rt !== null && Ef(tt, rt) && ($.flags |= 32),
        gj(_e, $),
        Xi(_e, $, it, et),
        $.child;
    case 6:
        return _e === null && Eg($),
        null;
    case 13:
        return oj(_e, $, et);
    case 4:
        return yh($, $.stateNode.containerInfo),
        tt = $.pendingProps,
        _e === null ? $.child = Ug($, null, tt, et) : Xi(_e, $, tt, et),
        $.child;
    case 11:
        return tt = $.type,
        nt = $.pendingProps,
        nt = $.elementType === tt ? nt : Ci(tt, nt),
        Yi(_e, $, tt, nt, et);
    case 7:
        return Xi(_e, $, $.pendingProps, et),
        $.child;
    case 8:
        return Xi(_e, $, $.pendingProps.children, et),
        $.child;
    case 12:
        return Xi(_e, $, $.pendingProps.children, et),
        $.child;
    case 10:
        e: {
            if (tt = $.type._context,
            nt = $.pendingProps,
            rt = $.memoizedProps,
            it = nt.value,
            G(Wg, tt._currentValue),
            tt._currentValue = it,
            rt !== null)
                if (He(rt.value, it)) {
                    if (rt.children === nt.children && !Wf.current) {
                        $ = Zi(_e, $, et);
                        break e
                    }
                } else
                    for (rt = $.child,
                    rt !== null && (rt.return = $); rt !== null; ) {
                        var ot = rt.dependencies;
                        if (ot !== null) {
                            it = rt.child;
                            for (var st = ot.firstContext; st !== null; ) {
                                if (st.context === tt) {
                                    if (rt.tag === 1) {
                                        st = mh(-1, et & -et),
                                        st.tag = 2;
                                        var lt = rt.updateQueue;
                                        if (lt !== null) {
                                            lt = lt.shared;
                                            var ct = lt.pending;
                                            ct === null ? st.next = st : (st.next = ct.next,
                                            ct.next = st),
                                            lt.pending = st
                                        }
                                    }
                                    rt.lanes |= et,
                                    st = rt.alternate,
                                    st !== null && (st.lanes |= et),
                                    bh(rt.return, et, $),
                                    ot.lanes |= et;
                                    break
                                }
                                st = st.next
                            }
                        } else if (rt.tag === 10)
                            it = rt.type === $.type ? null : rt.child;
                        else if (rt.tag === 18) {
                            if (it = rt.return,
                            it === null)
                                throw Error(p$2(341));
                            it.lanes |= et,
                            ot = it.alternate,
                            ot !== null && (ot.lanes |= et),
                            bh(it, et, $),
                            it = rt.sibling
                        } else
                            it = rt.child;
                        if (it !== null)
                            it.return = rt;
                        else
                            for (it = rt; it !== null; ) {
                                if (it === $) {
                                    it = null;
                                    break
                                }
                                if (rt = it.sibling,
                                rt !== null) {
                                    rt.return = it.return,
                                    it = rt;
                                    break
                                }
                                it = it.return
                            }
                        rt = it
                    }
            Xi(_e, $, nt.children, et),
            $ = $.child
        }
        return $;
    case 9:
        return nt = $.type,
        tt = $.pendingProps.children,
        ch($, et),
        nt = eh(nt),
        tt = tt(nt),
        $.flags |= 1,
        Xi(_e, $, tt, et),
        $.child;
    case 14:
        return tt = $.type,
        nt = Ci(tt, $.pendingProps),
        nt = Ci(tt.type, nt),
        $i(_e, $, tt, nt, et);
    case 15:
        return bj(_e, $, $.type, $.pendingProps, et);
    case 17:
        return tt = $.type,
        nt = $.pendingProps,
        nt = $.elementType === tt ? nt : Ci(tt, nt),
        ij(_e, $),
        $.tag = 1,
        Zf(tt) ? (_e = !0,
        cg($)) : _e = !1,
        ch($, et),
        Gi($, tt, nt),
        Ii($, tt, nt, et),
        jj(null, $, tt, !0, _e, et);
    case 19:
        return xj(_e, $, et);
    case 22:
        return dj(_e, $, et)
    }
    throw Error(p$2(156, $.tag))
}
;
function Fk(_e, $) {
    return ac(_e, $)
}
function $k(_e, $, et, tt) {
    this.tag = _e,
    this.key = et,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = $,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = tt,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Bg(_e, $, et, tt) {
    return new $k(_e,$,et,tt)
}
function aj(_e) {
    return _e = _e.prototype,
    !(!_e || !_e.isReactComponent)
}
function Zk(_e) {
    if (typeof _e == "function")
        return aj(_e) ? 1 : 0;
    if (_e != null) {
        if (_e = _e.$$typeof,
        _e === Da)
            return 11;
        if (_e === Ga)
            return 14
    }
    return 2
}
function Pg(_e, $) {
    var et = _e.alternate;
    return et === null ? (et = Bg(_e.tag, $, _e.key, _e.mode),
    et.elementType = _e.elementType,
    et.type = _e.type,
    et.stateNode = _e.stateNode,
    et.alternate = _e,
    _e.alternate = et) : (et.pendingProps = $,
    et.type = _e.type,
    et.flags = 0,
    et.subtreeFlags = 0,
    et.deletions = null),
    et.flags = _e.flags & 14680064,
    et.childLanes = _e.childLanes,
    et.lanes = _e.lanes,
    et.child = _e.child,
    et.memoizedProps = _e.memoizedProps,
    et.memoizedState = _e.memoizedState,
    et.updateQueue = _e.updateQueue,
    $ = _e.dependencies,
    et.dependencies = $ === null ? null : {
        lanes: $.lanes,
        firstContext: $.firstContext
    },
    et.sibling = _e.sibling,
    et.index = _e.index,
    et.ref = _e.ref,
    et
}
function Rg(_e, $, et, tt, nt, rt) {
    var it = 2;
    if (tt = _e,
    typeof _e == "function")
        aj(_e) && (it = 1);
    else if (typeof _e == "string")
        it = 5;
    else
        e: switch (_e) {
        case ya:
            return Tg(et.children, nt, rt, $);
        case za:
            it = 8,
            nt |= 8;
            break;
        case Aa:
            return _e = Bg(12, et, $, nt | 2),
            _e.elementType = Aa,
            _e.lanes = rt,
            _e;
        case Ea:
            return _e = Bg(13, et, $, nt),
            _e.elementType = Ea,
            _e.lanes = rt,
            _e;
        case Fa:
            return _e = Bg(19, et, $, nt),
            _e.elementType = Fa,
            _e.lanes = rt,
            _e;
        case Ia:
            return pj(et, nt, rt, $);
        default:
            if (typeof _e == "object" && _e !== null)
                switch (_e.$$typeof) {
                case Ba:
                    it = 10;
                    break e;
                case Ca:
                    it = 9;
                    break e;
                case Da:
                    it = 11;
                    break e;
                case Ga:
                    it = 14;
                    break e;
                case Ha:
                    it = 16,
                    tt = null;
                    break e
                }
            throw Error(p$2(130, _e == null ? _e : typeof _e, ""))
        }
    return $ = Bg(it, et, $, nt),
    $.elementType = _e,
    $.type = tt,
    $.lanes = rt,
    $
}
function Tg(_e, $, et, tt) {
    return _e = Bg(7, _e, tt, $),
    _e.lanes = et,
    _e
}
function pj(_e, $, et, tt) {
    return _e = Bg(22, _e, tt, $),
    _e.elementType = Ia,
    _e.lanes = et,
    _e.stateNode = {
        isHidden: !1
    },
    _e
}
function Qg(_e, $, et) {
    return _e = Bg(6, _e, null, $),
    _e.lanes = et,
    _e
}
function Sg(_e, $, et) {
    return $ = Bg(4, _e.children !== null ? _e.children : [], _e.key, $),
    $.lanes = et,
    $.stateNode = {
        containerInfo: _e.containerInfo,
        pendingChildren: null,
        implementation: _e.implementation
    },
    $
}
function al(_e, $, et, tt, nt) {
    this.tag = $,
    this.containerInfo = _e,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = zc(0),
    this.expirationTimes = zc(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = zc(0),
    this.identifierPrefix = tt,
    this.onRecoverableError = nt,
    this.mutableSourceEagerHydrationData = null
}
function bl(_e, $, et, tt, nt, rt, it, ot, st) {
    return _e = new al(_e,$,et,ot,st),
    $ === 1 ? ($ = 1,
    rt === !0 && ($ |= 8)) : $ = 0,
    rt = Bg(3, null, null, $),
    _e.current = rt,
    rt.stateNode = _e,
    rt.memoizedState = {
        element: tt,
        isDehydrated: et,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    kh(rt),
    _e
}
function cl(_e, $, et) {
    var tt = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: wa,
        key: tt == null ? null : "" + tt,
        children: _e,
        containerInfo: $,
        implementation: et
    }
}
function dl(_e) {
    if (!_e)
        return Vf;
    _e = _e._reactInternals;
    e: {
        if (Vb(_e) !== _e || _e.tag !== 1)
            throw Error(p$2(170));
        var $ = _e;
        do {
            switch ($.tag) {
            case 3:
                $ = $.stateNode.context;
                break e;
            case 1:
                if (Zf($.type)) {
                    $ = $.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            $ = $.return
        } while ($ !== null);
        throw Error(p$2(171))
    }
    if (_e.tag === 1) {
        var et = _e.type;
        if (Zf(et))
            return bg(_e, et, $)
    }
    return $
}
function el(_e, $, et, tt, nt, rt, it, ot, st) {
    return _e = bl(et, tt, !0, _e, nt, rt, it, ot, st),
    _e.context = dl(null),
    et = _e.current,
    tt = R$1(),
    nt = yi(et),
    rt = mh(tt, nt),
    rt.callback = $ ?? null,
    nh(et, rt, nt),
    _e.current.lanes = nt,
    Ac(_e, nt, tt),
    Dk(_e, tt),
    _e
}
function fl(_e, $, et, tt) {
    var nt = $.current
      , rt = R$1()
      , it = yi(nt);
    return et = dl(et),
    $.context === null ? $.context = et : $.pendingContext = et,
    $ = mh(rt, it),
    $.payload = {
        element: _e
    },
    tt = tt === void 0 ? null : tt,
    tt !== null && ($.callback = tt),
    _e = nh(nt, $, it),
    _e !== null && (gi(_e, nt, it, rt),
    oh(_e, nt, it)),
    it
}
function gl(_e) {
    if (_e = _e.current,
    !_e.child)
        return null;
    switch (_e.child.tag) {
    case 5:
        return _e.child.stateNode;
    default:
        return _e.child.stateNode
    }
}
function hl(_e, $) {
    if (_e = _e.memoizedState,
    _e !== null && _e.dehydrated !== null) {
        var et = _e.retryLane;
        _e.retryLane = et !== 0 && et < $ ? et : $
    }
}
function il(_e, $) {
    hl(_e, $),
    (_e = _e.alternate) && hl(_e, $)
}
function jl() {
    return null
}
var kl = typeof reportError == "function" ? reportError : function(_e) {}
;
function ll(_e) {
    this._internalRoot = _e
}
ml.prototype.render = ll.prototype.render = function(_e) {
    var $ = this._internalRoot;
    if ($ === null)
        throw Error(p$2(409));
    fl(_e, $, null, null)
}
;
ml.prototype.unmount = ll.prototype.unmount = function() {
    var _e = this._internalRoot;
    if (_e !== null) {
        this._internalRoot = null;
        var $ = _e.containerInfo;
        Rk(function() {
            fl(null, _e, null, null)
        }),
        $[uf] = null
    }
}
;
function ml(_e) {
    this._internalRoot = _e
}
ml.prototype.unstable_scheduleHydration = function(_e) {
    if (_e) {
        var $ = Hc();
        _e = {
            blockedOn: null,
            target: _e,
            priority: $
        };
        for (var et = 0; et < Qc.length && $ !== 0 && $ < Qc[et].priority; et++)
            ;
        Qc.splice(et, 0, _e),
        et === 0 && Vc(_e)
    }
}
;
function nl(_e) {
    return !(!_e || _e.nodeType !== 1 && _e.nodeType !== 9 && _e.nodeType !== 11)
}
function ol(_e) {
    return !(!_e || _e.nodeType !== 1 && _e.nodeType !== 9 && _e.nodeType !== 11 && (_e.nodeType !== 8 || _e.nodeValue !== " react-mount-point-unstable "))
}
function pl() {}
function ql(_e, $, et, tt, nt) {
    if (nt) {
        if (typeof tt == "function") {
            var rt = tt;
            tt = function() {
                var lt = gl(it);
                rt.call(lt)
            }
        }
        var it = el($, tt, _e, 0, null, !1, !1, "", pl);
        return _e._reactRootContainer = it,
        _e[uf] = it.current,
        sf(_e.nodeType === 8 ? _e.parentNode : _e),
        Rk(),
        it
    }
    for (; nt = _e.lastChild; )
        _e.removeChild(nt);
    if (typeof tt == "function") {
        var ot = tt;
        tt = function() {
            var lt = gl(st);
            ot.call(lt)
        }
    }
    var st = bl(_e, 0, !1, null, null, !1, !1, "", pl);
    return _e._reactRootContainer = st,
    _e[uf] = st.current,
    sf(_e.nodeType === 8 ? _e.parentNode : _e),
    Rk(function() {
        fl($, st, et, tt)
    }),
    st
}
function rl(_e, $, et, tt, nt) {
    var rt = et._reactRootContainer;
    if (rt) {
        var it = rt;
        if (typeof nt == "function") {
            var ot = nt;
            nt = function() {
                var st = gl(it);
                ot.call(st)
            }
        }
        fl($, it, _e, nt)
    } else
        it = ql(et, $, _e, nt, tt);
    return gl(it)
}
Ec = function(_e) {
    switch (_e.tag) {
    case 3:
        var $ = _e.stateNode;
        if ($.current.memoizedState.isDehydrated) {
            var et = tc($.pendingLanes);
            et !== 0 && (Cc($, et | 1),
            Dk($, B()),
            !(K$1 & 6) && (Gj = B() + 500,
            jg()))
        }
        break;
    case 13:
        Rk(function() {
            var tt = ih(_e, 1);
            if (tt !== null) {
                var nt = R$1();
                gi(tt, _e, 1, nt)
            }
        }),
        il(_e, 1)
    }
}
;
Fc = function(_e) {
    if (_e.tag === 13) {
        var $ = ih(_e, 134217728);
        if ($ !== null) {
            var et = R$1();
            gi($, _e, 134217728, et)
        }
        il(_e, 134217728)
    }
}
;
Gc = function(_e) {
    if (_e.tag === 13) {
        var $ = yi(_e)
          , et = ih(_e, $);
        if (et !== null) {
            var tt = R$1();
            gi(et, _e, $, tt)
        }
        il(_e, $)
    }
}
;
Hc = function() {
    return C$1
}
;
Ic = function(_e, $) {
    var et = C$1;
    try {
        return C$1 = _e,
        $()
    } finally {
        C$1 = et
    }
}
;
yb = function(_e, $, et) {
    switch ($) {
    case "input":
        if (bb(_e, et),
        $ = et.name,
        et.type === "radio" && $ != null) {
            for (et = _e; et.parentNode; )
                et = et.parentNode;
            for (et = et.querySelectorAll("input[name=" + JSON.stringify("" + $) + '][type="radio"]'),
            $ = 0; $ < et.length; $++) {
                var tt = et[$];
                if (tt !== _e && tt.form === _e.form) {
                    var nt = Db(tt);
                    if (!nt)
                        throw Error(p$2(90));
                    Wa(tt),
                    bb(tt, nt)
                }
            }
        }
        break;
    case "textarea":
        ib(_e, et);
        break;
    case "select":
        $ = et.value,
        $ != null && fb(_e, !!et.multiple, $, !1)
    }
}
;
Gb = Qk;
Hb = Rk;
var sl = {
    usingClientEntryPoint: !1,
    Events: [Cb, ue$1, Db, Eb, Fb, Qk]
}
  , tl = {
    findFiberByHostInstance: Wc,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , ul = {
    bundleType: tl.bundleType,
    version: tl.version,
    rendererPackageName: tl.rendererPackageName,
    rendererConfig: tl.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: ua.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(_e) {
        return _e = Zb(_e),
        _e === null ? null : _e.stateNode
    },
    findFiberByHostInstance: tl.findFiberByHostInstance || jl,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber)
        try {
            kc = vl.inject(ul),
            lc = vl
        } catch {}
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(_e, $) {
    var et = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!nl($))
        throw Error(p$2(200));
    return cl(_e, $, null, et)
}
;
reactDom_production_min.createRoot = function(_e, $) {
    if (!nl(_e))
        throw Error(p$2(299));
    var et = !1
      , tt = ""
      , nt = kl;
    return $ != null && ($.unstable_strictMode === !0 && (et = !0),
    $.identifierPrefix !== void 0 && (tt = $.identifierPrefix),
    $.onRecoverableError !== void 0 && (nt = $.onRecoverableError)),
    $ = bl(_e, 1, !1, null, null, et, !1, tt, nt),
    _e[uf] = $.current,
    sf(_e.nodeType === 8 ? _e.parentNode : _e),
    new ll($)
}
;
reactDom_production_min.findDOMNode = function(_e) {
    if (_e == null)
        return null;
    if (_e.nodeType === 1)
        return _e;
    var $ = _e._reactInternals;
    if ($ === void 0)
        throw typeof _e.render == "function" ? Error(p$2(188)) : (_e = Object.keys(_e).join(","),
        Error(p$2(268, _e)));
    return _e = Zb($),
    _e = _e === null ? null : _e.stateNode,
    _e
}
;
reactDom_production_min.flushSync = function(_e) {
    return Rk(_e)
}
;
reactDom_production_min.hydrate = function(_e, $, et) {
    if (!ol($))
        throw Error(p$2(200));
    return rl(null, _e, $, !0, et)
}
;
reactDom_production_min.hydrateRoot = function(_e, $, et) {
    if (!nl(_e))
        throw Error(p$2(405));
    var tt = et != null && et.hydratedSources || null
      , nt = !1
      , rt = ""
      , it = kl;
    if (et != null && (et.unstable_strictMode === !0 && (nt = !0),
    et.identifierPrefix !== void 0 && (rt = et.identifierPrefix),
    et.onRecoverableError !== void 0 && (it = et.onRecoverableError)),
    $ = el($, null, _e, 1, et ?? null, nt, !1, rt, it),
    _e[uf] = $.current,
    sf(_e),
    tt)
        for (_e = 0; _e < tt.length; _e++)
            et = tt[_e],
            nt = et._getVersion,
            nt = nt(et._source),
            $.mutableSourceEagerHydrationData == null ? $.mutableSourceEagerHydrationData = [et, nt] : $.mutableSourceEagerHydrationData.push(et, nt);
    return new ml($)
}
;
reactDom_production_min.render = function(_e, $, et) {
    if (!ol($))
        throw Error(p$2(200));
    return rl(null, _e, $, !1, et)
}
;
reactDom_production_min.unmountComponentAtNode = function(_e) {
    if (!ol(_e))
        throw Error(p$2(40));
    return _e._reactRootContainer ? (Rk(function() {
        rl(null, null, _e, !1, function() {
            _e._reactRootContainer = null,
            _e[uf] = null
        })
    }),
    !0) : !1
}
;
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(_e, $, et, tt) {
    if (!ol(et))
        throw Error(p$2(200));
    if (_e == null || _e._reactInternals === void 0)
        throw Error(p$2(38));
    return rl(_e, $, et, !1, tt)
}
;
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
        } catch {}
}
checkDCE(),
reactDom.exports = reactDom_production_min;
var reactDomExports = reactDom.exports;
const io = getDefaultExportFromCjs$2(reactDomExports);
var createRoot, m$2 = reactDomExports;
createRoot = m$2.createRoot,
m$2.hydrateRoot;
/**
 * @remix-run/router v1.22.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$6() {
    return _extends$6 = Object.assign ? Object.assign.bind() : function(_e) {
        for (var $ = 1; $ < arguments.length; $++) {
            var et = arguments[$];
            for (var tt in et)
                Object.prototype.hasOwnProperty.call(et, tt) && (_e[tt] = et[tt])
        }
        return _e
    }
    ,
    _extends$6.apply(this, arguments)
}
var Action;
(function(_e) {
    _e.Pop = "POP",
    _e.Push = "PUSH",
    _e.Replace = "REPLACE"
}
)(Action || (Action = {}));
const PopStateEventType = "popstate";
function createBrowserHistory(_e) {
    _e === void 0 && (_e = {});
    function $(tt, nt) {
        let {pathname: rt, search: it, hash: ot} = tt.location;
        return createLocation("", {
            pathname: rt,
            search: it,
            hash: ot
        }, nt.state && nt.state.usr || null, nt.state && nt.state.key || "default")
    }
    function et(tt, nt) {
        return typeof nt == "string" ? nt : createPath(nt)
    }
    return getUrlBasedHistory($, et, null, _e)
}
function invariant(_e, $) {
    if (_e === !1 || _e === null || typeof _e > "u")
        throw new Error($)
}
function warning(_e, $) {
    if (!_e)
        try {
            throw new Error($)
        } catch {}
}
function createKey() {
    return Math.random().toString(36).substr(2, 8)
}
function getHistoryState(_e, $) {
    return {
        usr: _e.state,
        key: _e.key,
        idx: $
    }
}
function createLocation(_e, $, et, tt) {
    return et === void 0 && (et = null),
    _extends$6({
        pathname: typeof _e == "string" ? _e : _e.pathname,
        search: "",
        hash: ""
    }, typeof $ == "string" ? parsePath($) : $, {
        state: et,
        key: $ && $.key || tt || createKey()
    })
}
function createPath(_e) {
    let {pathname: $="/", search: et="", hash: tt=""} = _e;
    return et && et !== "?" && ($ += et.charAt(0) === "?" ? et : "?" + et),
    tt && tt !== "#" && ($ += tt.charAt(0) === "#" ? tt : "#" + tt),
    $
}
function parsePath(_e) {
    let $ = {};
    if (_e) {
        let et = _e.indexOf("#");
        et >= 0 && ($.hash = _e.substr(et),
        _e = _e.substr(0, et));
        let tt = _e.indexOf("?");
        tt >= 0 && ($.search = _e.substr(tt),
        _e = _e.substr(0, tt)),
        _e && ($.pathname = _e)
    }
    return $
}
function getUrlBasedHistory(_e, $, et, tt) {
    tt === void 0 && (tt = {});
    let {window: nt=document.defaultView, v5Compat: rt=!1} = tt
      , it = nt.history
      , ot = Action.Pop
      , st = null
      , lt = ct();
    lt == null && (lt = 0,
    it.replaceState(_extends$6({}, it.state, {
        idx: lt
    }), ""));
    function ct() {
        return (it.state || {
            idx: null
        }).idx
    }
    function dt() {
        ot = Action.Pop;
        let Et = ct()
          , _t = Et == null ? null : Et - lt;
        lt = Et,
        st && st({
            action: ot,
            location: yt.location,
            delta: _t
        })
    }
    function pt(Et, _t) {
        ot = Action.Push;
        let wt = createLocation(yt.location, Et, _t);
        lt = ct() + 1;
        let St = getHistoryState(wt, lt)
          , Ct = yt.createHref(wt);
        try {
            it.pushState(St, "", Ct)
        } catch (Nt) {
            if (Nt instanceof DOMException && Nt.name === "DataCloneError")
                throw Nt;
            nt.location.assign(Ct)
        }
        rt && st && st({
            action: ot,
            location: yt.location,
            delta: 1
        })
    }
    function ht(Et, _t) {
        ot = Action.Replace;
        let wt = createLocation(yt.location, Et, _t);
        lt = ct();
        let St = getHistoryState(wt, lt)
          , Ct = yt.createHref(wt);
        it.replaceState(St, "", Ct),
        rt && st && st({
            action: ot,
            location: yt.location,
            delta: 0
        })
    }
    function mt(Et) {
        let _t = nt.location.origin !== "null" ? nt.location.origin : nt.location.href
          , wt = typeof Et == "string" ? Et : createPath(Et);
        return wt = wt.replace(/ $/, "%20"),
        invariant(_t, "No window.location.(origin|href) available to create URL for href: " + wt),
        new URL(wt,_t)
    }
    let yt = {
        get action() {
            return ot
        },
        get location() {
            return _e(nt, it)
        },
        listen(Et) {
            if (st)
                throw new Error("A history only accepts one active listener");
            return nt.addEventListener(PopStateEventType, dt),
            st = Et,
            () => {
                nt.removeEventListener(PopStateEventType, dt),
                st = null
            }
        },
        createHref(Et) {
            return $(nt, Et)
        },
        createURL: mt,
        encodeLocation(Et) {
            let _t = mt(Et);
            return {
                pathname: _t.pathname,
                search: _t.search,
                hash: _t.hash
            }
        },
        push: pt,
        replace: ht,
        go(Et) {
            return it.go(Et)
        }
    };
    return yt
}
var ResultType;
(function(_e) {
    _e.data = "data",
    _e.deferred = "deferred",
    _e.redirect = "redirect",
    _e.error = "error"
}
)(ResultType || (ResultType = {}));
function matchRoutes(_e, $, et) {
    return et === void 0 && (et = "/"),
    matchRoutesImpl(_e, $, et)
}
function matchRoutesImpl(_e, $, et, tt) {
    let nt = typeof $ == "string" ? parsePath($) : $
      , rt = stripBasename(nt.pathname || "/", et);
    if (rt == null)
        return null;
    let it = flattenRoutes(_e);
    rankRouteBranches(it);
    let ot = null;
    for (let st = 0; ot == null && st < it.length; ++st) {
        let lt = decodePath(rt);
        ot = matchRouteBranch(it[st], lt)
    }
    return ot
}
function flattenRoutes(_e, $, et, tt) {
    $ === void 0 && ($ = []),
    et === void 0 && (et = []),
    tt === void 0 && (tt = "");
    let nt = (rt, it, ot) => {
        let st = {
            relativePath: ot === void 0 ? rt.path || "" : ot,
            caseSensitive: rt.caseSensitive === !0,
            childrenIndex: it,
            route: rt
        };
        st.relativePath.startsWith("/") && (invariant(st.relativePath.startsWith(tt), 'Absolute route path "' + st.relativePath + '" nested under path ' + ('"' + tt + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."),
        st.relativePath = st.relativePath.slice(tt.length));
        let lt = joinPaths([tt, st.relativePath])
          , ct = et.concat(st);
        rt.children && rt.children.length > 0 && (invariant(rt.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + lt + '".')),
        flattenRoutes(rt.children, $, ct, lt)),
        !(rt.path == null && !rt.index) && $.push({
            path: lt,
            score: computeScore(lt, rt.index),
            routesMeta: ct
        })
    }
    ;
    return _e.forEach( (rt, it) => {
        var ot;
        if (rt.path === "" || !((ot = rt.path) != null && ot.includes("?")))
            nt(rt, it);
        else
            for (let st of explodeOptionalSegments(rt.path))
                nt(rt, it, st)
    }
    ),
    $
}
function explodeOptionalSegments(_e) {
    let $ = _e.split("/");
    if ($.length === 0)
        return [];
    let[et,...tt] = $
      , nt = et.endsWith("?")
      , rt = et.replace(/\?$/, "");
    if (tt.length === 0)
        return nt ? [rt, ""] : [rt];
    let it = explodeOptionalSegments(tt.join("/"))
      , ot = [];
    return ot.push(...it.map(st => st === "" ? rt : [rt, st].join("/"))),
    nt && ot.push(...it),
    ot.map(st => _e.startsWith("/") && st === "" ? "/" : st)
}
function rankRouteBranches(_e) {
    _e.sort( ($, et) => $.score !== et.score ? et.score - $.score : compareIndexes($.routesMeta.map(tt => tt.childrenIndex), et.routesMeta.map(tt => tt.childrenIndex)))
}
const paramRe = /^:[\w-]+$/
  , dynamicSegmentValue = 3
  , indexRouteValue = 2
  , emptySegmentValue = 1
  , staticSegmentValue = 10
  , splatPenalty = -2
  , isSplat = _e => _e === "*";
function computeScore(_e, $) {
    let et = _e.split("/")
      , tt = et.length;
    return et.some(isSplat) && (tt += splatPenalty),
    $ && (tt += indexRouteValue),
    et.filter(nt => !isSplat(nt)).reduce( (nt, rt) => nt + (paramRe.test(rt) ? dynamicSegmentValue : rt === "" ? emptySegmentValue : staticSegmentValue), tt)
}
function compareIndexes(_e, $) {
    return _e.length === $.length && _e.slice(0, -1).every( (tt, nt) => tt === $[nt]) ? _e[_e.length - 1] - $[$.length - 1] : 0
}
function matchRouteBranch(_e, $, et) {
    let {routesMeta: tt} = _e
      , nt = {}
      , rt = "/"
      , it = [];
    for (let ot = 0; ot < tt.length; ++ot) {
        let st = tt[ot]
          , lt = ot === tt.length - 1
          , ct = rt === "/" ? $ : $.slice(rt.length) || "/"
          , dt = matchPath({
            path: st.relativePath,
            caseSensitive: st.caseSensitive,
            end: lt
        }, ct)
          , pt = st.route;
        if (!dt)
            return null;
        Object.assign(nt, dt.params),
        it.push({
            params: nt,
            pathname: joinPaths([rt, dt.pathname]),
            pathnameBase: normalizePathname(joinPaths([rt, dt.pathnameBase])),
            route: pt
        }),
        dt.pathnameBase !== "/" && (rt = joinPaths([rt, dt.pathnameBase]))
    }
    return it
}
function matchPath(_e, $) {
    typeof _e == "string" && (_e = {
        path: _e,
        caseSensitive: !1,
        end: !0
    });
    let[et,tt] = compilePath(_e.path, _e.caseSensitive, _e.end)
      , nt = $.match(et);
    if (!nt)
        return null;
    let rt = nt[0]
      , it = rt.replace(/(.)\/+$/, "$1")
      , ot = nt.slice(1);
    return {
        params: tt.reduce( (lt, ct, dt) => {
            let {paramName: pt, isOptional: ht} = ct;
            if (pt === "*") {
                let yt = ot[dt] || "";
                it = rt.slice(0, rt.length - yt.length).replace(/(.)\/+$/, "$1")
            }
            const mt = ot[dt];
            return ht && !mt ? lt[pt] = void 0 : lt[pt] = (mt || "").replace(/%2F/g, "/"),
            lt
        }
        , {}),
        pathname: rt,
        pathnameBase: it,
        pattern: _e
    }
}
function compilePath(_e, $, et) {
    $ === void 0 && ($ = !1),
    et === void 0 && (et = !0),
    warning(_e === "*" || !_e.endsWith("*") || _e.endsWith("/*"), 'Route path "' + _e + '" will be treated as if it were ' + ('"' + _e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + _e.replace(/\*$/, "/*") + '".'));
    let tt = []
      , nt = "^" + _e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (it, ot, st) => (tt.push({
        paramName: ot,
        isOptional: st != null
    }),
    st ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return _e.endsWith("*") ? (tt.push({
        paramName: "*"
    }),
    nt += _e === "*" || _e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : et ? nt += "\\/*$" : _e !== "" && _e !== "/" && (nt += "(?:(?=\\/|$))"),
    [new RegExp(nt,$ ? void 0 : "i"), tt]
}
function decodePath(_e) {
    try {
        return _e.split("/").map($ => decodeURIComponent($).replace(/\//g, "%2F")).join("/")
    } catch ($) {
        return warning(!1, 'The URL path "' + _e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + $ + ").")),
        _e
    }
}
function stripBasename(_e, $) {
    if ($ === "/")
        return _e;
    if (!_e.toLowerCase().startsWith($.toLowerCase()))
        return null;
    let et = $.endsWith("/") ? $.length - 1 : $.length
      , tt = _e.charAt(et);
    return tt && tt !== "/" ? null : _e.slice(et) || "/"
}
function resolvePath(_e, $) {
    $ === void 0 && ($ = "/");
    let {pathname: et, search: tt="", hash: nt=""} = typeof _e == "string" ? parsePath(_e) : _e;
    return {
        pathname: et ? et.startsWith("/") ? et : resolvePathname(et, $) : $,
        search: normalizeSearch(tt),
        hash: normalizeHash(nt)
    }
}
function resolvePathname(_e, $) {
    let et = $.replace(/\/+$/, "").split("/");
    return _e.split("/").forEach(nt => {
        nt === ".." ? et.length > 1 && et.pop() : nt !== "." && et.push(nt)
    }
    ),
    et.length > 1 ? et.join("/") : "/"
}
function getInvalidPathError(_e, $, et, tt) {
    return "Cannot include a '" + _e + "' character in a manually specified " + ("`to." + $ + "` field [" + JSON.stringify(tt) + "].  Please separate it out to the ") + ("`to." + et + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}
function getPathContributingMatches(_e) {
    return _e.filter( ($, et) => et === 0 || $.route.path && $.route.path.length > 0)
}
function getResolveToMatches(_e, $) {
    let et = getPathContributingMatches(_e);
    return $ ? et.map( (tt, nt) => nt === et.length - 1 ? tt.pathname : tt.pathnameBase) : et.map(tt => tt.pathnameBase)
}
function resolveTo(_e, $, et, tt) {
    tt === void 0 && (tt = !1);
    let nt;
    typeof _e == "string" ? nt = parsePath(_e) : (nt = _extends$6({}, _e),
    invariant(!nt.pathname || !nt.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", nt)),
    invariant(!nt.pathname || !nt.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", nt)),
    invariant(!nt.search || !nt.search.includes("#"), getInvalidPathError("#", "search", "hash", nt)));
    let rt = _e === "" || nt.pathname === "", it = rt ? "/" : nt.pathname, ot;
    if (it == null)
        ot = et;
    else {
        let dt = $.length - 1;
        if (!tt && it.startsWith("..")) {
            let pt = it.split("/");
            for (; pt[0] === ".."; )
                pt.shift(),
                dt -= 1;
            nt.pathname = pt.join("/")
        }
        ot = dt >= 0 ? $[dt] : "/"
    }
    let st = resolvePath(nt, ot)
      , lt = it && it !== "/" && it.endsWith("/")
      , ct = (rt || it === ".") && et.endsWith("/");
    return !st.pathname.endsWith("/") && (lt || ct) && (st.pathname += "/"),
    st
}
const joinPaths = _e => _e.join("/").replace(/\/\/+/g, "/")
  , normalizePathname = _e => _e.replace(/\/+$/, "").replace(/^\/*/, "/")
  , normalizeSearch = _e => !_e || _e === "?" ? "" : _e.startsWith("?") ? _e : "?" + _e
  , normalizeHash = _e => !_e || _e === "#" ? "" : _e.startsWith("#") ? _e : "#" + _e;
function isRouteErrorResponse(_e) {
    return _e != null && typeof _e.status == "number" && typeof _e.statusText == "string" && typeof _e.internal == "boolean" && "data"in _e
}
const validMutationMethodsArr = ["post", "put", "patch", "delete"];
new Set(validMutationMethodsArr);
const validRequestMethodsArr = ["get", ...validMutationMethodsArr];
new Set(validRequestMethodsArr);
/**
 * React Router v6.29.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$5() {
    return _extends$5 = Object.assign ? Object.assign.bind() : function(_e) {
        for (var $ = 1; $ < arguments.length; $++) {
            var et = arguments[$];
            for (var tt in et)
                Object.prototype.hasOwnProperty.call(et, tt) && (_e[tt] = et[tt])
        }
        return _e
    }
    ,
    _extends$5.apply(this, arguments)
}
const DataRouterContext = reactExports.createContext(null)
  , DataRouterStateContext = reactExports.createContext(null)
  , NavigationContext = reactExports.createContext(null)
  , LocationContext = reactExports.createContext(null)
  , RouteContext = reactExports.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
})
  , RouteErrorContext = reactExports.createContext(null);
function useHref(_e, $) {
    let {relative: et} = $ === void 0 ? {} : $;
    useInRouterContext() || invariant(!1);
    let {basename: tt, navigator: nt} = reactExports.useContext(NavigationContext)
      , {hash: rt, pathname: it, search: ot} = useResolvedPath(_e, {
        relative: et
    })
      , st = it;
    return tt !== "/" && (st = it === "/" ? tt : joinPaths([tt, it])),
    nt.createHref({
        pathname: st,
        search: ot,
        hash: rt
    })
}
function useInRouterContext() {
    return reactExports.useContext(LocationContext) != null
}
function useLocation() {
    return useInRouterContext() || invariant(!1),
    reactExports.useContext(LocationContext).location
}
function useIsomorphicLayoutEffect$2(_e) {
    reactExports.useContext(NavigationContext).static || reactExports.useLayoutEffect(_e)
}
function useNavigate() {
    let {isDataRoute: _e} = reactExports.useContext(RouteContext);
    return _e ? useNavigateStable() : useNavigateUnstable()
}
function useNavigateUnstable() {
    useInRouterContext() || invariant(!1);
    let _e = reactExports.useContext(DataRouterContext)
      , {basename: $, future: et, navigator: tt} = reactExports.useContext(NavigationContext)
      , {matches: nt} = reactExports.useContext(RouteContext)
      , {pathname: rt} = useLocation()
      , it = JSON.stringify(getResolveToMatches(nt, et.v7_relativeSplatPath))
      , ot = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect$2( () => {
        ot.current = !0
    }
    ),
    reactExports.useCallback(function(lt, ct) {
        if (ct === void 0 && (ct = {}),
        !ot.current)
            return;
        if (typeof lt == "number") {
            tt.go(lt);
            return
        }
        let dt = resolveTo(lt, JSON.parse(it), rt, ct.relative === "path");
        _e == null && $ !== "/" && (dt.pathname = dt.pathname === "/" ? $ : joinPaths([$, dt.pathname])),
        (ct.replace ? tt.replace : tt.push)(dt, ct.state, ct)
    }, [$, tt, it, rt, _e])
}
function useParams() {
    let {matches: _e} = reactExports.useContext(RouteContext)
      , $ = _e[_e.length - 1];
    return $ ? $.params : {}
}
function useResolvedPath(_e, $) {
    let {relative: et} = $ === void 0 ? {} : $
      , {future: tt} = reactExports.useContext(NavigationContext)
      , {matches: nt} = reactExports.useContext(RouteContext)
      , {pathname: rt} = useLocation()
      , it = JSON.stringify(getResolveToMatches(nt, tt.v7_relativeSplatPath));
    return reactExports.useMemo( () => resolveTo(_e, JSON.parse(it), rt, et === "path"), [_e, it, rt, et])
}
function useRoutes(_e, $) {
    return useRoutesImpl(_e)
}
function useRoutesImpl(_e, $, et, tt) {
    useInRouterContext() || invariant(!1);
    let {navigator: nt, static: rt} = reactExports.useContext(NavigationContext)
      , {matches: it} = reactExports.useContext(RouteContext)
      , ot = it[it.length - 1]
      , st = ot ? ot.params : {};
    ot && ot.pathname;
    let lt = ot ? ot.pathnameBase : "/";
    ot && ot.route;
    let ct = useLocation(), dt;
    dt = ct;
    let pt = dt.pathname || "/"
      , ht = pt;
    if (lt !== "/") {
        let Et = lt.replace(/^\//, "").split("/");
        ht = "/" + pt.replace(/^\//, "").split("/").slice(Et.length).join("/")
    }
    let mt = matchRoutes(_e, {
        pathname: ht
    });
    return _renderMatches(mt && mt.map(Et => Object.assign({}, Et, {
        params: Object.assign({}, st, Et.params),
        pathname: joinPaths([lt, nt.encodeLocation ? nt.encodeLocation(Et.pathname).pathname : Et.pathname]),
        pathnameBase: Et.pathnameBase === "/" ? lt : joinPaths([lt, nt.encodeLocation ? nt.encodeLocation(Et.pathnameBase).pathname : Et.pathnameBase])
    })), it, et, tt)
}
function DefaultErrorComponent() {
    let _e = useRouteError()
      , $ = isRouteErrorResponse(_e) ? _e.status + " " + _e.statusText : _e instanceof Error ? _e.message : JSON.stringify(_e)
      , et = _e instanceof Error ? _e.stack : null
      , nt = {
        padding: "0.5rem",
        backgroundColor: "rgba(200,200,200, 0.5)"
    };
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("h2", null, "Unexpected Application Error!"), reactExports.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, $), et ? reactExports.createElement("pre", {
        style: nt
    }, et) : null, null)
}
const defaultErrorElement = reactExports.createElement(DefaultErrorComponent, null);
class RenderErrorBoundary extends reactExports.Component {
    constructor($) {
        super($),
        this.state = {
            location: $.location,
            revalidation: $.revalidation,
            error: $.error
        }
    }
    static getDerivedStateFromError($) {
        return {
            error: $
        }
    }
    static getDerivedStateFromProps($, et) {
        return et.location !== $.location || et.revalidation !== "idle" && $.revalidation === "idle" ? {
            error: $.error,
            location: $.location,
            revalidation: $.revalidation
        } : {
            error: $.error !== void 0 ? $.error : et.error,
            location: et.location,
            revalidation: $.revalidation || et.revalidation
        }
    }
    componentDidCatch($, et) {}
    render() {
        return this.state.error !== void 0 ? reactExports.createElement(RouteContext.Provider, {
            value: this.props.routeContext
        }, reactExports.createElement(RouteErrorContext.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
function RenderedRoute(_e) {
    let {routeContext: $, match: et, children: tt} = _e
      , nt = reactExports.useContext(DataRouterContext);
    return nt && nt.static && nt.staticContext && (et.route.errorElement || et.route.ErrorBoundary) && (nt.staticContext._deepestRenderedBoundaryId = et.route.id),
    reactExports.createElement(RouteContext.Provider, {
        value: $
    }, tt)
}
function _renderMatches(_e, $, et, tt) {
    var nt;
    if ($ === void 0 && ($ = []),
    et === void 0 && (et = null),
    tt === void 0 && (tt = null),
    _e == null) {
        var rt;
        if (!et)
            return null;
        if (et.errors)
            _e = et.matches;
        else if ((rt = tt) != null && rt.v7_partialHydration && $.length === 0 && !et.initialized && et.matches.length > 0)
            _e = et.matches;
        else
            return null
    }
    let it = _e
      , ot = (nt = et) == null ? void 0 : nt.errors;
    if (ot != null) {
        let ct = it.findIndex(dt => dt.route.id && (ot == null ? void 0 : ot[dt.route.id]) !== void 0);
        ct >= 0 || invariant(!1),
        it = it.slice(0, Math.min(it.length, ct + 1))
    }
    let st = !1
      , lt = -1;
    if (et && tt && tt.v7_partialHydration)
        for (let ct = 0; ct < it.length; ct++) {
            let dt = it[ct];
            if ((dt.route.HydrateFallback || dt.route.hydrateFallbackElement) && (lt = ct),
            dt.route.id) {
                let {loaderData: pt, errors: ht} = et
                  , mt = dt.route.loader && pt[dt.route.id] === void 0 && (!ht || ht[dt.route.id] === void 0);
                if (dt.route.lazy || mt) {
                    st = !0,
                    lt >= 0 ? it = it.slice(0, lt + 1) : it = [it[0]];
                    break
                }
            }
        }
    return it.reduceRight( (ct, dt, pt) => {
        let ht, mt = !1, yt = null, Et = null;
        et && (ht = ot && dt.route.id ? ot[dt.route.id] : void 0,
        yt = dt.route.errorElement || defaultErrorElement,
        st && (lt < 0 && pt === 0 ? (warningOnce("route-fallback"),
        mt = !0,
        Et = null) : lt === pt && (mt = !0,
        Et = dt.route.hydrateFallbackElement || null)));
        let _t = $.concat(it.slice(0, pt + 1))
          , wt = () => {
            let St;
            return ht ? St = yt : mt ? St = Et : dt.route.Component ? St = reactExports.createElement(dt.route.Component, null) : dt.route.element ? St = dt.route.element : St = ct,
            reactExports.createElement(RenderedRoute, {
                match: dt,
                routeContext: {
                    outlet: ct,
                    matches: _t,
                    isDataRoute: et != null
                },
                children: St
            })
        }
        ;
        return et && (dt.route.ErrorBoundary || dt.route.errorElement || pt === 0) ? reactExports.createElement(RenderErrorBoundary, {
            location: et.location,
            revalidation: et.revalidation,
            component: yt,
            error: ht,
            children: wt(),
            routeContext: {
                outlet: null,
                matches: _t,
                isDataRoute: !0
            }
        }) : wt()
    }
    , null)
}
var DataRouterHook$1 = function(_e) {
    return _e.UseBlocker = "useBlocker",
    _e.UseRevalidator = "useRevalidator",
    _e.UseNavigateStable = "useNavigate",
    _e
}(DataRouterHook$1 || {})
  , DataRouterStateHook$1 = function(_e) {
    return _e.UseBlocker = "useBlocker",
    _e.UseLoaderData = "useLoaderData",
    _e.UseActionData = "useActionData",
    _e.UseRouteError = "useRouteError",
    _e.UseNavigation = "useNavigation",
    _e.UseRouteLoaderData = "useRouteLoaderData",
    _e.UseMatches = "useMatches",
    _e.UseRevalidator = "useRevalidator",
    _e.UseNavigateStable = "useNavigate",
    _e.UseRouteId = "useRouteId",
    _e
}(DataRouterStateHook$1 || {});
function useDataRouterContext$1(_e) {
    let $ = reactExports.useContext(DataRouterContext);
    return $ || invariant(!1),
    $
}
function useDataRouterState(_e) {
    let $ = reactExports.useContext(DataRouterStateContext);
    return $ || invariant(!1),
    $
}
function useRouteContext(_e) {
    let $ = reactExports.useContext(RouteContext);
    return $ || invariant(!1),
    $
}
function useCurrentRouteId(_e) {
    let $ = useRouteContext()
      , et = $.matches[$.matches.length - 1];
    return et.route.id || invariant(!1),
    et.route.id
}
function useRouteError() {
    var _e;
    let $ = reactExports.useContext(RouteErrorContext)
      , et = useDataRouterState()
      , tt = useCurrentRouteId();
    return $ !== void 0 ? $ : (_e = et.errors) == null ? void 0 : _e[tt]
}
function useNavigateStable() {
    let {router: _e} = useDataRouterContext$1(DataRouterHook$1.UseNavigateStable)
      , $ = useCurrentRouteId(DataRouterStateHook$1.UseNavigateStable)
      , et = reactExports.useRef(!1);
    return useIsomorphicLayoutEffect$2( () => {
        et.current = !0
    }
    ),
    reactExports.useCallback(function(nt, rt) {
        rt === void 0 && (rt = {}),
        et.current && (typeof nt == "number" ? _e.navigate(nt) : _e.navigate(nt, _extends$5({
            fromRouteId: $
        }, rt)))
    }, [_e, $])
}
const alreadyWarned$1 = {};
function warningOnce(_e, $, et) {
    alreadyWarned$1[_e] || (alreadyWarned$1[_e] = !0)
}
function logV6DeprecationWarnings(_e, $) {
    _e == null || _e.v7_startTransition,
    _e == null || _e.v7_relativeSplatPath
}
function Navigate(_e) {
    let {to: $, replace: et, state: tt, relative: nt} = _e;
    useInRouterContext() || invariant(!1);
    let {future: rt, static: it} = reactExports.useContext(NavigationContext)
      , {matches: ot} = reactExports.useContext(RouteContext)
      , {pathname: st} = useLocation()
      , lt = useNavigate()
      , ct = resolveTo($, getResolveToMatches(ot, rt.v7_relativeSplatPath), st, nt === "path")
      , dt = JSON.stringify(ct);
    return reactExports.useEffect( () => lt(JSON.parse(dt), {
        replace: et,
        state: tt,
        relative: nt
    }), [lt, dt, nt, et, tt]),
    null
}
function Router(_e) {
    let {basename: $="/", children: et=null, location: tt, navigationType: nt=Action.Pop, navigator: rt, static: it=!1, future: ot} = _e;
    useInRouterContext() && invariant(!1);
    let st = $.replace(/^\/*/, "/")
      , lt = reactExports.useMemo( () => ({
        basename: st,
        navigator: rt,
        static: it,
        future: _extends$5({
            v7_relativeSplatPath: !1
        }, ot)
    }), [st, ot, rt, it]);
    typeof tt == "string" && (tt = parsePath(tt));
    let {pathname: ct="/", search: dt="", hash: pt="", state: ht=null, key: mt="default"} = tt
      , yt = reactExports.useMemo( () => {
        let Et = stripBasename(ct, st);
        return Et == null ? null : {
            location: {
                pathname: Et,
                search: dt,
                hash: pt,
                state: ht,
                key: mt
            },
            navigationType: nt
        }
    }
    , [st, ct, dt, pt, ht, mt, nt]);
    return yt == null ? null : reactExports.createElement(NavigationContext.Provider, {
        value: lt
    }, reactExports.createElement(LocationContext.Provider, {
        children: et,
        value: yt
    }))
}
new Promise( () => {}
);
/**
 * React Router DOM v6.29.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _extends$4() {
    return _extends$4 = Object.assign ? Object.assign.bind() : function(_e) {
        for (var $ = 1; $ < arguments.length; $++) {
            var et = arguments[$];
            for (var tt in et)
                Object.prototype.hasOwnProperty.call(et, tt) && (_e[tt] = et[tt])
        }
        return _e
    }
    ,
    _extends$4.apply(this, arguments)
}
function _objectWithoutPropertiesLoose$2(_e, $) {
    if (_e == null)
        return {};
    var et = {}, tt = Object.keys(_e), nt, rt;
    for (rt = 0; rt < tt.length; rt++)
        nt = tt[rt],
        !($.indexOf(nt) >= 0) && (et[nt] = _e[nt]);
    return et
}
function isModifiedEvent(_e) {
    return !!(_e.metaKey || _e.altKey || _e.ctrlKey || _e.shiftKey)
}
function shouldProcessLinkClick(_e, $) {
    return _e.button === 0 && (!$ || $ === "_self") && !isModifiedEvent(_e)
}
const _excluded = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"]
  , _excluded2 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"]
  , REACT_ROUTER_VERSION = "6";
try {
    window.__reactRouterVersion = REACT_ROUTER_VERSION
} catch {}
const ViewTransitionContext = reactExports.createContext({
    isTransitioning: !1
})
  , START_TRANSITION = "startTransition"
  , startTransitionImpl = React$1[START_TRANSITION];
function BrowserRouter(_e) {
    let {basename: $, children: et, future: tt, window: nt} = _e
      , rt = reactExports.useRef();
    rt.current == null && (rt.current = createBrowserHistory({
        window: nt,
        v5Compat: !0
    }));
    let it = rt.current
      , [ot,st] = reactExports.useState({
        action: it.action,
        location: it.location
    })
      , {v7_startTransition: lt} = tt || {}
      , ct = reactExports.useCallback(dt => {
        lt && startTransitionImpl ? startTransitionImpl( () => st(dt)) : st(dt)
    }
    , [st, lt]);
    return reactExports.useLayoutEffect( () => it.listen(ct), [it, ct]),
    reactExports.useEffect( () => logV6DeprecationWarnings(tt), [tt]),
    reactExports.createElement(Router, {
        basename: $,
        children: et,
        location: ot.location,
        navigationType: ot.action,
        navigator: it,
        future: tt
    })
}
const isBrowser$2 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , Link = reactExports.forwardRef(function($, et) {
    let {onClick: tt, relative: nt, reloadDocument: rt, replace: it, state: ot, target: st, to: lt, preventScrollReset: ct, viewTransition: dt} = $, pt = _objectWithoutPropertiesLoose$2($, _excluded), {basename: ht} = reactExports.useContext(NavigationContext), mt, yt = !1;
    if (typeof lt == "string" && ABSOLUTE_URL_REGEX.test(lt) && (mt = lt,
    isBrowser$2))
        try {
            let St = new URL(window.location.href)
              , Ct = lt.startsWith("//") ? new URL(St.protocol + lt) : new URL(lt)
              , Nt = stripBasename(Ct.pathname, ht);
            Ct.origin === St.origin && Nt != null ? lt = Nt + Ct.search + Ct.hash : yt = !0
        } catch {}
    let Et = useHref(lt, {
        relative: nt
    })
      , _t = useLinkClickHandler(lt, {
        replace: it,
        state: ot,
        target: st,
        preventScrollReset: ct,
        relative: nt,
        viewTransition: dt
    });
    function wt(St) {
        tt && tt(St),
        St.defaultPrevented || _t(St)
    }
    return reactExports.createElement("a", _extends$4({}, pt, {
        href: mt || Et,
        onClick: yt || rt ? tt : wt,
        ref: et,
        target: st
    }))
})
  , NavLink = reactExports.forwardRef(function($, et) {
    let {"aria-current": tt="page", caseSensitive: nt=!1, className: rt="", end: it=!1, style: ot, to: st, viewTransition: lt, children: ct} = $
      , dt = _objectWithoutPropertiesLoose$2($, _excluded2)
      , pt = useResolvedPath(st, {
        relative: dt.relative
    })
      , ht = useLocation()
      , mt = reactExports.useContext(DataRouterStateContext)
      , {navigator: yt, basename: Et} = reactExports.useContext(NavigationContext)
      , _t = mt != null && useViewTransitionState(pt) && lt === !0
      , wt = yt.encodeLocation ? yt.encodeLocation(pt).pathname : pt.pathname
      , St = ht.pathname
      , Ct = mt && mt.navigation && mt.navigation.location ? mt.navigation.location.pathname : null;
    nt || (St = St.toLowerCase(),
    Ct = Ct ? Ct.toLowerCase() : null,
    wt = wt.toLowerCase()),
    Ct && Et && (Ct = stripBasename(Ct, Et) || Ct);
    const Nt = wt !== "/" && wt.endsWith("/") ? wt.length - 1 : wt.length;
    let Lt = St === wt || !it && St.startsWith(wt) && St.charAt(Nt) === "/", kt = Ct != null && (Ct === wt || !it && Ct.startsWith(wt) && Ct.charAt(wt.length) === "/"), Ut = {
        isActive: Lt,
        isPending: kt,
        isTransitioning: _t
    }, Jt = Lt ? tt : void 0, Pt;
    typeof rt == "function" ? Pt = rt(Ut) : Pt = [rt, Lt ? "active" : null, kt ? "pending" : null, _t ? "transitioning" : null].filter(Boolean).join(" ");
    let Xt = typeof ot == "function" ? ot(Ut) : ot;
    return reactExports.createElement(Link, _extends$4({}, dt, {
        "aria-current": Jt,
        className: Pt,
        ref: et,
        style: Xt,
        to: st,
        viewTransition: lt
    }), typeof ct == "function" ? ct(Ut) : ct)
});
var DataRouterHook;
(function(_e) {
    _e.UseScrollRestoration = "useScrollRestoration",
    _e.UseSubmit = "useSubmit",
    _e.UseSubmitFetcher = "useSubmitFetcher",
    _e.UseFetcher = "useFetcher",
    _e.useViewTransitionState = "useViewTransitionState"
}
)(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(_e) {
    _e.UseFetcher = "useFetcher",
    _e.UseFetchers = "useFetchers",
    _e.UseScrollRestoration = "useScrollRestoration"
}
)(DataRouterStateHook || (DataRouterStateHook = {}));
function useDataRouterContext(_e) {
    let $ = reactExports.useContext(DataRouterContext);
    return $ || invariant(!1),
    $
}
function useLinkClickHandler(_e, $) {
    let {target: et, replace: tt, state: nt, preventScrollReset: rt, relative: it, viewTransition: ot} = $ === void 0 ? {} : $
      , st = useNavigate()
      , lt = useLocation()
      , ct = useResolvedPath(_e, {
        relative: it
    });
    return reactExports.useCallback(dt => {
        if (shouldProcessLinkClick(dt, et)) {
            dt.preventDefault();
            let pt = tt !== void 0 ? tt : createPath(lt) === createPath(ct);
            st(_e, {
                replace: pt,
                state: nt,
                preventScrollReset: rt,
                relative: it,
                viewTransition: ot
            })
        }
    }
    , [lt, st, ct, tt, nt, et, _e, rt, it, ot])
}
function useViewTransitionState(_e, $) {
    $ === void 0 && ($ = {});
    let et = reactExports.useContext(ViewTransitionContext);
    et == null && invariant(!1);
    let {basename: tt} = useDataRouterContext(DataRouterHook.useViewTransitionState)
      , nt = useResolvedPath(_e, {
        relative: $.relative
    });
    if (!et.isTransitioning)
        return !1;
    let rt = stripBasename(et.currentLocation.pathname, tt) || et.currentLocation.pathname
      , it = stripBasename(et.nextLocation.pathname, tt) || et.nextLocation.pathname;
    return matchPath(nt.pathname, it) != null || matchPath(nt.pathname, rt) != null
}
var Subscribable = class {
    constructor() {
        this.listeners = new Set,
        this.subscribe = this.subscribe.bind(this)
    }
    subscribe(_e) {
        return this.listeners.add(_e),
        this.onSubscribe(),
        () => {
            this.listeners.delete(_e),
            this.onUnsubscribe()
        }
    }
    hasListeners() {
        return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
}
  , isServer = typeof window > "u" || "Deno"in globalThis;
function noop$6() {}
function functionalUpdate(_e, $) {
    return typeof _e == "function" ? _e($) : _e
}
function isValidTimeout(_e) {
    return typeof _e == "number" && _e >= 0 && _e !== 1 / 0
}
function timeUntilStale(_e, $) {
    return Math.max(_e + ($ || 0) - Date.now(), 0)
}
function resolveStaleTime(_e, $) {
    return typeof _e == "function" ? _e($) : _e
}
function resolveEnabled(_e, $) {
    return typeof _e == "function" ? _e($) : _e
}
function matchQuery(_e, $) {
    const {type: et="all", exact: tt, fetchStatus: nt, predicate: rt, queryKey: it, stale: ot} = _e;
    if (it) {
        if (tt) {
            if ($.queryHash !== hashQueryKeyByOptions(it, $.options))
                return !1
        } else if (!partialMatchKey($.queryKey, it))
            return !1
    }
    if (et !== "all") {
        const st = $.isActive();
        if (et === "active" && !st || et === "inactive" && st)
            return !1
    }
    return !(typeof ot == "boolean" && $.isStale() !== ot || nt && nt !== $.state.fetchStatus || rt && !rt($))
}
function matchMutation(_e, $) {
    const {exact: et, status: tt, predicate: nt, mutationKey: rt} = _e;
    if (rt) {
        if (!$.options.mutationKey)
            return !1;
        if (et) {
            if (hashKey($.options.mutationKey) !== hashKey(rt))
                return !1
        } else if (!partialMatchKey($.options.mutationKey, rt))
            return !1
    }
    return !(tt && $.state.status !== tt || nt && !nt($))
}
function hashQueryKeyByOptions(_e, $) {
    return (($ == null ? void 0 : $.queryKeyHashFn) || hashKey)(_e)
}
function hashKey(_e) {
    return JSON.stringify(_e, ($, et) => isPlainObject$4(et) ? Object.keys(et).sort().reduce( (tt, nt) => (tt[nt] = et[nt],
    tt), {}) : et)
}
function partialMatchKey(_e, $) {
    return _e === $ ? !0 : typeof _e != typeof $ ? !1 : _e && $ && typeof _e == "object" && typeof $ == "object" ? !Object.keys($).some(et => !partialMatchKey(_e[et], $[et])) : !1
}
function replaceEqualDeep(_e, $) {
    if (_e === $)
        return _e;
    const et = isPlainArray(_e) && isPlainArray($);
    if (et || isPlainObject$4(_e) && isPlainObject$4($)) {
        const tt = et ? _e : Object.keys(_e)
          , nt = tt.length
          , rt = et ? $ : Object.keys($)
          , it = rt.length
          , ot = et ? [] : {};
        let st = 0;
        for (let lt = 0; lt < it; lt++) {
            const ct = et ? lt : rt[lt];
            (!et && tt.includes(ct) || et) && _e[ct] === void 0 && $[ct] === void 0 ? (ot[ct] = void 0,
            st++) : (ot[ct] = replaceEqualDeep(_e[ct], $[ct]),
            ot[ct] === _e[ct] && _e[ct] !== void 0 && st++)
        }
        return nt === it && st === nt ? _e : ot
    }
    return $
}
function shallowEqualObjects(_e, $) {
    if (!$ || Object.keys(_e).length !== Object.keys($).length)
        return !1;
    for (const et in _e)
        if (_e[et] !== $[et])
            return !1;
    return !0
}
function isPlainArray(_e) {
    return Array.isArray(_e) && _e.length === Object.keys(_e).length
}
function isPlainObject$4(_e) {
    if (!hasObjectPrototype(_e))
        return !1;
    const $ = _e.constructor;
    if ($ === void 0)
        return !0;
    const et = $.prototype;
    return !(!hasObjectPrototype(et) || !et.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(_e) !== Object.prototype)
}
function hasObjectPrototype(_e) {
    return Object.prototype.toString.call(_e) === "[object Object]"
}
function sleep$1(_e) {
    return new Promise($ => {
        setTimeout($, _e)
    }
    )
}
function replaceData(_e, $, et) {
    return typeof et.structuralSharing == "function" ? et.structuralSharing(_e, $) : et.structuralSharing !== !1 ? replaceEqualDeep(_e, $) : $
}
function addToEnd(_e, $, et=0) {
    const tt = [..._e, $];
    return et && tt.length > et ? tt.slice(1) : tt
}
function addToStart(_e, $, et=0) {
    const tt = [$, ..._e];
    return et && tt.length > et ? tt.slice(0, -1) : tt
}
var skipToken = Symbol();
function ensureQueryFn(_e, $) {
    return !_e.queryFn && ($ != null && $.initialPromise) ? () => $.initialPromise : !_e.queryFn || _e.queryFn === skipToken ? () => Promise.reject(new Error(`Missing queryFn: '${_e.queryHash}'`)) : _e.queryFn
}
var Mp, op, $m, N_, FocusManager = (N_ = class extends Subscribable {
    constructor() {
        super();
        gr(this, Mp);
        gr(this, op);
        gr(this, $m);
        Yn(this, $m, $ => {
            if (!isServer && window.addEventListener) {
                const et = () => $();
                return window.addEventListener("visibilitychange", et, !1),
                () => {
                    window.removeEventListener("visibilitychange", et)
                }
            }
        }
        )
    }
    onSubscribe() {
        nn(this, op) || this.setEventListener(nn(this, $m))
    }
    onUnsubscribe() {
        var $;
        this.hasListeners() || (($ = nn(this, op)) == null || $.call(this),
        Yn(this, op, void 0))
    }
    setEventListener($) {
        var et;
        Yn(this, $m, $),
        (et = nn(this, op)) == null || et.call(this),
        Yn(this, op, $(tt => {
            typeof tt == "boolean" ? this.setFocused(tt) : this.onFocus()
        }
        ))
    }
    setFocused($) {
        nn(this, Mp) !== $ && (Yn(this, Mp, $),
        this.onFocus())
    }
    onFocus() {
        const $ = this.isFocused();
        this.listeners.forEach(et => {
            et($)
        }
        )
    }
    isFocused() {
        var $;
        return typeof nn(this, Mp) == "boolean" ? nn(this, Mp) : (($ = globalThis.document) == null ? void 0 : $.visibilityState) !== "hidden"
    }
}
,
Mp = new WeakMap,
op = new WeakMap,
$m = new WeakMap,
N_), focusManager = new FocusManager, Am, sp, Im, M_, OnlineManager = (M_ = class extends Subscribable {
    constructor() {
        super();
        gr(this, Am, !0);
        gr(this, sp);
        gr(this, Im);
        Yn(this, Im, $ => {
            if (!isServer && window.addEventListener) {
                const et = () => $(!0)
                  , tt = () => $(!1);
                return window.addEventListener("online", et, !1),
                window.addEventListener("offline", tt, !1),
                () => {
                    window.removeEventListener("online", et),
                    window.removeEventListener("offline", tt)
                }
            }
        }
        )
    }
    onSubscribe() {
        nn(this, sp) || this.setEventListener(nn(this, Im))
    }
    onUnsubscribe() {
        var $;
        this.hasListeners() || (($ = nn(this, sp)) == null || $.call(this),
        Yn(this, sp, void 0))
    }
    setEventListener($) {
        var et;
        Yn(this, Im, $),
        (et = nn(this, sp)) == null || et.call(this),
        Yn(this, sp, $(this.setOnline.bind(this)))
    }
    setOnline($) {
        nn(this, Am) !== $ && (Yn(this, Am, $),
        this.listeners.forEach(tt => {
            tt($)
        }
        ))
    }
    isOnline() {
        return nn(this, Am)
    }
}
,
Am = new WeakMap,
sp = new WeakMap,
Im = new WeakMap,
M_), onlineManager = new OnlineManager;
function pendingThenable() {
    let _e, $;
    const et = new Promise( (nt, rt) => {
        _e = nt,
        $ = rt
    }
    );
    et.status = "pending",
    et.catch( () => {}
    );
    function tt(nt) {
        Object.assign(et, nt),
        delete et.resolve,
        delete et.reject
    }
    return et.resolve = nt => {
        tt({
            status: "fulfilled",
            value: nt
        }),
        _e(nt)
    }
    ,
    et.reject = nt => {
        tt({
            status: "rejected",
            reason: nt
        }),
        $(nt)
    }
    ,
    et
}
function defaultRetryDelay(_e) {
    return Math.min(1e3 * 2 ** _e, 3e4)
}
function canFetch(_e) {
    return (_e ?? "online") === "online" ? onlineManager.isOnline() : !0
}
var CancelledError = class extends Error {
    constructor(_e) {
        super("CancelledError"),
        this.revert = _e == null ? void 0 : _e.revert,
        this.silent = _e == null ? void 0 : _e.silent
    }
}
;
function isCancelledError(_e) {
    return _e instanceof CancelledError
}
function createRetryer(_e) {
    let $ = !1, et = 0, tt = !1, nt;
    const rt = pendingThenable()
      , it = yt => {
        var Et;
        tt || (pt(new CancelledError(yt)),
        (Et = _e.abort) == null || Et.call(_e))
    }
      , ot = () => {
        $ = !0
    }
      , st = () => {
        $ = !1
    }
      , lt = () => focusManager.isFocused() && (_e.networkMode === "always" || onlineManager.isOnline()) && _e.canRun()
      , ct = () => canFetch(_e.networkMode) && _e.canRun()
      , dt = yt => {
        var Et;
        tt || (tt = !0,
        (Et = _e.onSuccess) == null || Et.call(_e, yt),
        nt == null || nt(),
        rt.resolve(yt))
    }
      , pt = yt => {
        var Et;
        tt || (tt = !0,
        (Et = _e.onError) == null || Et.call(_e, yt),
        nt == null || nt(),
        rt.reject(yt))
    }
      , ht = () => new Promise(yt => {
        var Et;
        nt = _t => {
            (tt || lt()) && yt(_t)
        }
        ,
        (Et = _e.onPause) == null || Et.call(_e)
    }
    ).then( () => {
        var yt;
        nt = void 0,
        tt || (yt = _e.onContinue) == null || yt.call(_e)
    }
    )
      , mt = () => {
        if (tt)
            return;
        let yt;
        const Et = et === 0 ? _e.initialPromise : void 0;
        try {
            yt = Et ?? _e.fn()
        } catch (_t) {
            yt = Promise.reject(_t)
        }
        Promise.resolve(yt).then(dt).catch(_t => {
            var Lt;
            if (tt)
                return;
            const wt = _e.retry ?? (isServer ? 0 : 3)
              , St = _e.retryDelay ?? defaultRetryDelay
              , Ct = typeof St == "function" ? St(et, _t) : St
              , Nt = wt === !0 || typeof wt == "number" && et < wt || typeof wt == "function" && wt(et, _t);
            if ($ || !Nt) {
                pt(_t);
                return
            }
            et++,
            (Lt = _e.onFail) == null || Lt.call(_e, et, _t),
            sleep$1(Ct).then( () => lt() ? void 0 : ht()).then( () => {
                $ ? pt(_t) : mt()
            }
            )
        }
        )
    }
    ;
    return {
        promise: rt,
        cancel: it,
        continue: () => (nt == null || nt(),
        rt),
        cancelRetry: ot,
        continueRetry: st,
        canStart: ct,
        start: () => (ct() ? mt() : ht().then(mt),
        rt)
    }
}
function createNotifyManager() {
    let _e = []
      , $ = 0
      , et = ot => {
        ot()
    }
      , tt = ot => {
        ot()
    }
      , nt = ot => setTimeout(ot, 0);
    const rt = ot => {
        $ ? _e.push(ot) : nt( () => {
            et(ot)
        }
        )
    }
      , it = () => {
        const ot = _e;
        _e = [],
        ot.length && nt( () => {
            tt( () => {
                ot.forEach(st => {
                    et(st)
                }
                )
            }
            )
        }
        )
    }
    ;
    return {
        batch: ot => {
            let st;
            $++;
            try {
                st = ot()
            } finally {
                $--,
                $ || it()
            }
            return st
        }
        ,
        batchCalls: ot => (...st) => {
            rt( () => {
                ot(...st)
            }
            )
        }
        ,
        schedule: rt,
        setNotifyFunction: ot => {
            et = ot
        }
        ,
        setBatchNotifyFunction: ot => {
            tt = ot
        }
        ,
        setScheduler: ot => {
            nt = ot
        }
    }
}
var notifyManager = createNotifyManager(), Pp, P_, Removable = (P_ = class {
    constructor() {
        gr(this, Pp)
    }
    destroy() {
        this.clearGcTimeout()
    }
    scheduleGc() {
        this.clearGcTimeout(),
        isValidTimeout(this.gcTime) && Yn(this, Pp, setTimeout( () => {
            this.optionalRemove()
        }
        , this.gcTime))
    }
    updateGcTime(_e) {
        this.gcTime = Math.max(this.gcTime || 0, _e ?? (isServer ? 1 / 0 : 5 * 60 * 1e3))
    }
    clearGcTimeout() {
        nn(this, Pp) && (clearTimeout(nn(this, Pp)),
        Yn(this, Pp, void 0))
    }
}
,
Pp = new WeakMap,
P_), Om, km, Rl, Dp, As, I0, Bp, Ml, $u, D_, Query = (D_ = class extends Removable {
    constructor($) {
        super();
        gr(this, Ml);
        gr(this, Om);
        gr(this, km);
        gr(this, Rl);
        gr(this, Dp);
        gr(this, As);
        gr(this, I0);
        gr(this, Bp);
        Yn(this, Bp, !1),
        Yn(this, I0, $.defaultOptions),
        this.setOptions($.options),
        this.observers = [],
        Yn(this, Dp, $.client),
        Yn(this, Rl, nn(this, Dp).getQueryCache()),
        this.queryKey = $.queryKey,
        this.queryHash = $.queryHash,
        Yn(this, Om, getDefaultState$1(this.options)),
        this.state = $.state ?? nn(this, Om),
        this.scheduleGc()
    }
    get meta() {
        return this.options.meta
    }
    get promise() {
        var $;
        return ($ = nn(this, As)) == null ? void 0 : $.promise
    }
    setOptions($) {
        this.options = {
            ...nn(this, I0),
            ...$
        },
        this.updateGcTime(this.options.gcTime)
    }
    optionalRemove() {
        !this.observers.length && this.state.fetchStatus === "idle" && nn(this, Rl).remove(this)
    }
    setData($, et) {
        const tt = replaceData(this.state.data, $, this.options);
        return tr(this, Ml, $u).call(this, {
            data: tt,
            type: "success",
            dataUpdatedAt: et == null ? void 0 : et.updatedAt,
            manual: et == null ? void 0 : et.manual
        }),
        tt
    }
    setState($, et) {
        tr(this, Ml, $u).call(this, {
            type: "setState",
            state: $,
            setStateOptions: et
        })
    }
    cancel($) {
        var tt, nt;
        const et = (tt = nn(this, As)) == null ? void 0 : tt.promise;
        return (nt = nn(this, As)) == null || nt.cancel($),
        et ? et.then(noop$6).catch(noop$6) : Promise.resolve()
    }
    destroy() {
        super.destroy(),
        this.cancel({
            silent: !0
        })
    }
    reset() {
        this.destroy(),
        this.setState(nn(this, Om))
    }
    isActive() {
        return this.observers.some($ => resolveEnabled($.options.enabled, this) !== !1)
    }
    isDisabled() {
        return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
    }
    isStale() {
        return this.state.isInvalidated ? !0 : this.getObserversCount() > 0 ? this.observers.some($ => $.getCurrentResult().isStale) : this.state.data === void 0
    }
    isStaleByTime($=0) {
        return this.state.isInvalidated || this.state.data === void 0 || !timeUntilStale(this.state.dataUpdatedAt, $)
    }
    onFocus() {
        var et;
        const $ = this.observers.find(tt => tt.shouldFetchOnWindowFocus());
        $ == null || $.refetch({
            cancelRefetch: !1
        }),
        (et = nn(this, As)) == null || et.continue()
    }
    onOnline() {
        var et;
        const $ = this.observers.find(tt => tt.shouldFetchOnReconnect());
        $ == null || $.refetch({
            cancelRefetch: !1
        }),
        (et = nn(this, As)) == null || et.continue()
    }
    addObserver($) {
        this.observers.includes($) || (this.observers.push($),
        this.clearGcTimeout(),
        nn(this, Rl).notify({
            type: "observerAdded",
            query: this,
            observer: $
        }))
    }
    removeObserver($) {
        this.observers.includes($) && (this.observers = this.observers.filter(et => et !== $),
        this.observers.length || (nn(this, As) && (nn(this, Bp) ? nn(this, As).cancel({
            revert: !0
        }) : nn(this, As).cancelRetry()),
        this.scheduleGc()),
        nn(this, Rl).notify({
            type: "observerRemoved",
            query: this,
            observer: $
        }))
    }
    getObserversCount() {
        return this.observers.length
    }
    invalidate() {
        this.state.isInvalidated || tr(this, Ml, $u).call(this, {
            type: "invalidate"
        })
    }
    fetch($, et) {
        var st, lt, ct;
        if (this.state.fetchStatus !== "idle") {
            if (this.state.data !== void 0 && (et != null && et.cancelRefetch))
                this.cancel({
                    silent: !0
                });
            else if (nn(this, As))
                return nn(this, As).continueRetry(),
                nn(this, As).promise
        }
        if ($ && this.setOptions($),
        !this.options.queryFn) {
            const dt = this.observers.find(pt => pt.options.queryFn);
            dt && this.setOptions(dt.options)
        }
        const tt = new AbortController
          , nt = dt => {
            Object.defineProperty(dt, "signal", {
                enumerable: !0,
                get: () => (Yn(this, Bp, !0),
                tt.signal)
            })
        }
          , rt = () => {
            const dt = ensureQueryFn(this.options, et)
              , pt = {
                client: nn(this, Dp),
                queryKey: this.queryKey,
                meta: this.meta
            };
            return nt(pt),
            Yn(this, Bp, !1),
            this.options.persister ? this.options.persister(dt, pt, this) : dt(pt)
        }
          , it = {
            fetchOptions: et,
            options: this.options,
            queryKey: this.queryKey,
            client: nn(this, Dp),
            state: this.state,
            fetchFn: rt
        };
        nt(it),
        (st = this.options.behavior) == null || st.onFetch(it, this),
        Yn(this, km, this.state),
        (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((lt = it.fetchOptions) == null ? void 0 : lt.meta)) && tr(this, Ml, $u).call(this, {
            type: "fetch",
            meta: (ct = it.fetchOptions) == null ? void 0 : ct.meta
        });
        const ot = dt => {
            var pt, ht, mt, yt;
            isCancelledError(dt) && dt.silent || tr(this, Ml, $u).call(this, {
                type: "error",
                error: dt
            }),
            isCancelledError(dt) || ((ht = (pt = nn(this, Rl).config).onError) == null || ht.call(pt, dt, this),
            (yt = (mt = nn(this, Rl).config).onSettled) == null || yt.call(mt, this.state.data, dt, this)),
            this.scheduleGc()
        }
        ;
        return Yn(this, As, createRetryer({
            initialPromise: et == null ? void 0 : et.initialPromise,
            fn: it.fetchFn,
            abort: tt.abort.bind(tt),
            onSuccess: dt => {
                var pt, ht, mt, yt;
                if (dt === void 0) {
                    ot(new Error(`${this.queryHash} data is undefined`));
                    return
                }
                try {
                    this.setData(dt)
                } catch (Et) {
                    ot(Et);
                    return
                }
                (ht = (pt = nn(this, Rl).config).onSuccess) == null || ht.call(pt, dt, this),
                (yt = (mt = nn(this, Rl).config).onSettled) == null || yt.call(mt, dt, this.state.error, this),
                this.scheduleGc()
            }
            ,
            onError: ot,
            onFail: (dt, pt) => {
                tr(this, Ml, $u).call(this, {
                    type: "failed",
                    failureCount: dt,
                    error: pt
                })
            }
            ,
            onPause: () => {
                tr(this, Ml, $u).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                tr(this, Ml, $u).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: it.options.retry,
            retryDelay: it.options.retryDelay,
            networkMode: it.options.networkMode,
            canRun: () => !0
        })),
        nn(this, As).start()
    }
}
,
Om = new WeakMap,
km = new WeakMap,
Rl = new WeakMap,
Dp = new WeakMap,
As = new WeakMap,
I0 = new WeakMap,
Bp = new WeakMap,
Ml = new WeakSet,
$u = function($) {
    const et = tt => {
        switch ($.type) {
        case "failed":
            return {
                ...tt,
                fetchFailureCount: $.failureCount,
                fetchFailureReason: $.error
            };
        case "pause":
            return {
                ...tt,
                fetchStatus: "paused"
            };
        case "continue":
            return {
                ...tt,
                fetchStatus: "fetching"
            };
        case "fetch":
            return {
                ...tt,
                ...fetchState(tt.data, this.options),
                fetchMeta: $.meta ?? null
            };
        case "success":
            return {
                ...tt,
                data: $.data,
                dataUpdateCount: tt.dataUpdateCount + 1,
                dataUpdatedAt: $.dataUpdatedAt ?? Date.now(),
                error: null,
                isInvalidated: !1,
                status: "success",
                ...!$.manual && {
                    fetchStatus: "idle",
                    fetchFailureCount: 0,
                    fetchFailureReason: null
                }
            };
        case "error":
            const nt = $.error;
            return isCancelledError(nt) && nt.revert && nn(this, km) ? {
                ...nn(this, km),
                fetchStatus: "idle"
            } : {
                ...tt,
                error: nt,
                errorUpdateCount: tt.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: tt.fetchFailureCount + 1,
                fetchFailureReason: nt,
                fetchStatus: "idle",
                status: "error"
            };
        case "invalidate":
            return {
                ...tt,
                isInvalidated: !0
            };
        case "setState":
            return {
                ...tt,
                ...$.state
            }
        }
    }
    ;
    this.state = et(this.state),
    notifyManager.batch( () => {
        this.observers.forEach(tt => {
            tt.onQueryUpdate()
        }
        ),
        nn(this, Rl).notify({
            query: this,
            type: "updated",
            action: $
        })
    }
    )
}
,
D_);
function fetchState(_e, $) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: canFetch($.networkMode) ? "fetching" : "paused",
        ..._e === void 0 && {
            error: null,
            status: "pending"
        }
    }
}
function getDefaultState$1(_e) {
    const $ = typeof _e.initialData == "function" ? _e.initialData() : _e.initialData
      , et = $ !== void 0
      , tt = et ? typeof _e.initialDataUpdatedAt == "function" ? _e.initialDataUpdatedAt() : _e.initialDataUpdatedAt : 0;
    return {
        data: $,
        dataUpdateCount: 0,
        dataUpdatedAt: et ? tt ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: et ? "success" : "pending",
        fetchStatus: "idle"
    }
}
var ru, B_, QueryCache = (B_ = class extends Subscribable {
    constructor($={}) {
        super();
        gr(this, ru);
        this.config = $,
        Yn(this, ru, new Map)
    }
    build($, et, tt) {
        const nt = et.queryKey
          , rt = et.queryHash ?? hashQueryKeyByOptions(nt, et);
        let it = this.get(rt);
        return it || (it = new Query({
            client: $,
            queryKey: nt,
            queryHash: rt,
            options: $.defaultQueryOptions(et),
            state: tt,
            defaultOptions: $.getQueryDefaults(nt)
        }),
        this.add(it)),
        it
    }
    add($) {
        nn(this, ru).has($.queryHash) || (nn(this, ru).set($.queryHash, $),
        this.notify({
            type: "added",
            query: $
        }))
    }
    remove($) {
        const et = nn(this, ru).get($.queryHash);
        et && ($.destroy(),
        et === $ && nn(this, ru).delete($.queryHash),
        this.notify({
            type: "removed",
            query: $
        }))
    }
    clear() {
        notifyManager.batch( () => {
            this.getAll().forEach($ => {
                this.remove($)
            }
            )
        }
        )
    }
    get($) {
        return nn(this, ru).get($)
    }
    getAll() {
        return [...nn(this, ru).values()]
    }
    find($) {
        const et = {
            exact: !0,
            ...$
        };
        return this.getAll().find(tt => matchQuery(et, tt))
    }
    findAll($={}) {
        const et = this.getAll();
        return Object.keys($).length > 0 ? et.filter(tt => matchQuery($, tt)) : et
    }
    notify($) {
        notifyManager.batch( () => {
            this.listeners.forEach(et => {
                et($)
            }
            )
        }
        )
    }
    onFocus() {
        notifyManager.batch( () => {
            this.getAll().forEach($ => {
                $.onFocus()
            }
            )
        }
        )
    }
    onOnline() {
        notifyManager.batch( () => {
            this.getAll().forEach($ => {
                $.onOnline()
            }
            )
        }
        )
    }
}
,
ru = new WeakMap,
B_), iu, Bs, Up, ou, tp, U_, Mutation = (U_ = class extends Removable {
    constructor($) {
        super();
        gr(this, ou);
        gr(this, iu);
        gr(this, Bs);
        gr(this, Up);
        this.mutationId = $.mutationId,
        Yn(this, Bs, $.mutationCache),
        Yn(this, iu, []),
        this.state = $.state || getDefaultState(),
        this.setOptions($.options),
        this.scheduleGc()
    }
    setOptions($) {
        this.options = $,
        this.updateGcTime(this.options.gcTime)
    }
    get meta() {
        return this.options.meta
    }
    addObserver($) {
        nn(this, iu).includes($) || (nn(this, iu).push($),
        this.clearGcTimeout(),
        nn(this, Bs).notify({
            type: "observerAdded",
            mutation: this,
            observer: $
        }))
    }
    removeObserver($) {
        Yn(this, iu, nn(this, iu).filter(et => et !== $)),
        this.scheduleGc(),
        nn(this, Bs).notify({
            type: "observerRemoved",
            mutation: this,
            observer: $
        })
    }
    optionalRemove() {
        nn(this, iu).length || (this.state.status === "pending" ? this.scheduleGc() : nn(this, Bs).remove(this))
    }
    continue() {
        var $;
        return (($ = nn(this, Up)) == null ? void 0 : $.continue()) ?? this.execute(this.state.variables)
    }
    async execute($) {
        var nt, rt, it, ot, st, lt, ct, dt, pt, ht, mt, yt, Et, _t, wt, St, Ct, Nt, Lt, kt;
        Yn(this, Up, createRetryer({
            fn: () => this.options.mutationFn ? this.options.mutationFn($) : Promise.reject(new Error("No mutationFn found")),
            onFail: (Ut, Jt) => {
                tr(this, ou, tp).call(this, {
                    type: "failed",
                    failureCount: Ut,
                    error: Jt
                })
            }
            ,
            onPause: () => {
                tr(this, ou, tp).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                tr(this, ou, tp).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => nn(this, Bs).canRun(this)
        }));
        const et = this.state.status === "pending"
          , tt = !nn(this, Up).canStart();
        try {
            if (!et) {
                tr(this, ou, tp).call(this, {
                    type: "pending",
                    variables: $,
                    isPaused: tt
                }),
                await ((rt = (nt = nn(this, Bs).config).onMutate) == null ? void 0 : rt.call(nt, $, this));
                const Jt = await ((ot = (it = this.options).onMutate) == null ? void 0 : ot.call(it, $));
                Jt !== this.state.context && tr(this, ou, tp).call(this, {
                    type: "pending",
                    context: Jt,
                    variables: $,
                    isPaused: tt
                })
            }
            const Ut = await nn(this, Up).start();
            return await ((lt = (st = nn(this, Bs).config).onSuccess) == null ? void 0 : lt.call(st, Ut, $, this.state.context, this)),
            await ((dt = (ct = this.options).onSuccess) == null ? void 0 : dt.call(ct, Ut, $, this.state.context)),
            await ((ht = (pt = nn(this, Bs).config).onSettled) == null ? void 0 : ht.call(pt, Ut, null, this.state.variables, this.state.context, this)),
            await ((yt = (mt = this.options).onSettled) == null ? void 0 : yt.call(mt, Ut, null, $, this.state.context)),
            tr(this, ou, tp).call(this, {
                type: "success",
                data: Ut
            }),
            Ut
        } catch (Ut) {
            try {
                throw await ((_t = (Et = nn(this, Bs).config).onError) == null ? void 0 : _t.call(Et, Ut, $, this.state.context, this)),
                await ((St = (wt = this.options).onError) == null ? void 0 : St.call(wt, Ut, $, this.state.context)),
                await ((Nt = (Ct = nn(this, Bs).config).onSettled) == null ? void 0 : Nt.call(Ct, void 0, Ut, this.state.variables, this.state.context, this)),
                await ((kt = (Lt = this.options).onSettled) == null ? void 0 : kt.call(Lt, void 0, Ut, $, this.state.context)),
                Ut
            } finally {
                tr(this, ou, tp).call(this, {
                    type: "error",
                    error: Ut
                })
            }
        } finally {
            nn(this, Bs).runNext(this)
        }
    }
}
,
iu = new WeakMap,
Bs = new WeakMap,
Up = new WeakMap,
ou = new WeakSet,
tp = function($) {
    const et = tt => {
        switch ($.type) {
        case "failed":
            return {
                ...tt,
                failureCount: $.failureCount,
                failureReason: $.error
            };
        case "pause":
            return {
                ...tt,
                isPaused: !0
            };
        case "continue":
            return {
                ...tt,
                isPaused: !1
            };
        case "pending":
            return {
                ...tt,
                context: $.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: $.isPaused,
                status: "pending",
                variables: $.variables,
                submittedAt: Date.now()
            };
        case "success":
            return {
                ...tt,
                data: $.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: !1
            };
        case "error":
            return {
                ...tt,
                data: void 0,
                error: $.error,
                failureCount: tt.failureCount + 1,
                failureReason: $.error,
                isPaused: !1,
                status: "error"
            }
        }
    }
    ;
    this.state = et(this.state),
    notifyManager.batch( () => {
        nn(this, iu).forEach(tt => {
            tt.onMutationUpdate($)
        }
        ),
        nn(this, Bs).notify({
            mutation: this,
            type: "updated",
            action: $
        })
    }
    )
}
,
U_);
function getDefaultState() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}
var Iu, Pl, O0, j_, MutationCache = (j_ = class extends Subscribable {
    constructor($={}) {
        super();
        gr(this, Iu);
        gr(this, Pl);
        gr(this, O0);
        this.config = $,
        Yn(this, Iu, new Set),
        Yn(this, Pl, new Map),
        Yn(this, O0, 0)
    }
    build($, et, tt) {
        const nt = new Mutation({
            mutationCache: this,
            mutationId: ++Np(this, O0)._,
            options: $.defaultMutationOptions(et),
            state: tt
        });
        return this.add(nt),
        nt
    }
    add($) {
        nn(this, Iu).add($);
        const et = scopeFor($);
        if (typeof et == "string") {
            const tt = nn(this, Pl).get(et);
            tt ? tt.push($) : nn(this, Pl).set(et, [$])
        }
        this.notify({
            type: "added",
            mutation: $
        })
    }
    remove($) {
        if (nn(this, Iu).delete($)) {
            const et = scopeFor($);
            if (typeof et == "string") {
                const tt = nn(this, Pl).get(et);
                if (tt)
                    if (tt.length > 1) {
                        const nt = tt.indexOf($);
                        nt !== -1 && tt.splice(nt, 1)
                    } else
                        tt[0] === $ && nn(this, Pl).delete(et)
            }
        }
        this.notify({
            type: "removed",
            mutation: $
        })
    }
    canRun($) {
        const et = scopeFor($);
        if (typeof et == "string") {
            const tt = nn(this, Pl).get(et)
              , nt = tt == null ? void 0 : tt.find(rt => rt.state.status === "pending");
            return !nt || nt === $
        } else
            return !0
    }
    runNext($) {
        var tt;
        const et = scopeFor($);
        if (typeof et == "string") {
            const nt = (tt = nn(this, Pl).get(et)) == null ? void 0 : tt.find(rt => rt !== $ && rt.state.isPaused);
            return (nt == null ? void 0 : nt.continue()) ?? Promise.resolve()
        } else
            return Promise.resolve()
    }
    clear() {
        notifyManager.batch( () => {
            nn(this, Iu).forEach($ => {
                this.notify({
                    type: "removed",
                    mutation: $
                })
            }
            ),
            nn(this, Iu).clear(),
            nn(this, Pl).clear()
        }
        )
    }
    getAll() {
        return Array.from(nn(this, Iu))
    }
    find($) {
        const et = {
            exact: !0,
            ...$
        };
        return this.getAll().find(tt => matchMutation(et, tt))
    }
    findAll($={}) {
        return this.getAll().filter(et => matchMutation($, et))
    }
    notify($) {
        notifyManager.batch( () => {
            this.listeners.forEach(et => {
                et($)
            }
            )
        }
        )
    }
    resumePausedMutations() {
        const $ = this.getAll().filter(et => et.state.isPaused);
        return notifyManager.batch( () => Promise.all($.map(et => et.continue().catch(noop$6))))
    }
}
,
Iu = new WeakMap,
Pl = new WeakMap,
O0 = new WeakMap,
j_);
function scopeFor(_e) {
    var $;
    return ($ = _e.options.scope) == null ? void 0 : $.id
}
function infiniteQueryBehavior(_e) {
    return {
        onFetch: ($, et) => {
            var ct, dt, pt, ht, mt;
            const tt = $.options
              , nt = (pt = (dt = (ct = $.fetchOptions) == null ? void 0 : ct.meta) == null ? void 0 : dt.fetchMore) == null ? void 0 : pt.direction
              , rt = ((ht = $.state.data) == null ? void 0 : ht.pages) || []
              , it = ((mt = $.state.data) == null ? void 0 : mt.pageParams) || [];
            let ot = {
                pages: [],
                pageParams: []
            }
              , st = 0;
            const lt = async () => {
                let yt = !1;
                const Et = St => {
                    Object.defineProperty(St, "signal", {
                        enumerable: !0,
                        get: () => ($.signal.aborted ? yt = !0 : $.signal.addEventListener("abort", () => {
                            yt = !0
                        }
                        ),
                        $.signal)
                    })
                }
                  , _t = ensureQueryFn($.options, $.fetchOptions)
                  , wt = async (St, Ct, Nt) => {
                    if (yt)
                        return Promise.reject();
                    if (Ct == null && St.pages.length)
                        return Promise.resolve(St);
                    const Lt = {
                        client: $.client,
                        queryKey: $.queryKey,
                        pageParam: Ct,
                        direction: Nt ? "backward" : "forward",
                        meta: $.options.meta
                    };
                    Et(Lt);
                    const kt = await _t(Lt)
                      , {maxPages: Ut} = $.options
                      , Jt = Nt ? addToStart : addToEnd;
                    return {
                        pages: Jt(St.pages, kt, Ut),
                        pageParams: Jt(St.pageParams, Ct, Ut)
                    }
                }
                ;
                if (nt && rt.length) {
                    const St = nt === "backward"
                      , Ct = St ? getPreviousPageParam : getNextPageParam
                      , Nt = {
                        pages: rt,
                        pageParams: it
                    }
                      , Lt = Ct(tt, Nt);
                    ot = await wt(Nt, Lt, St)
                } else {
                    const St = _e ?? rt.length;
                    do {
                        const Ct = st === 0 ? it[0] ?? tt.initialPageParam : getNextPageParam(tt, ot);
                        if (st > 0 && Ct == null)
                            break;
                        ot = await wt(ot, Ct),
                        st++
                    } while (st < St)
                }
                return ot
            }
            ;
            $.options.persister ? $.fetchFn = () => {
                var yt, Et;
                return (Et = (yt = $.options).persister) == null ? void 0 : Et.call(yt, lt, {
                    client: $.client,
                    queryKey: $.queryKey,
                    meta: $.options.meta,
                    signal: $.signal
                }, et)
            }
            : $.fetchFn = lt
        }
    }
}
function getNextPageParam(_e, {pages: $, pageParams: et}) {
    const tt = $.length - 1;
    return $.length > 0 ? _e.getNextPageParam($[tt], $, et[tt], et) : void 0
}
function getPreviousPageParam(_e, {pages: $, pageParams: et}) {
    var tt;
    return $.length > 0 ? (tt = _e.getPreviousPageParam) == null ? void 0 : tt.call(_e, $[0], $, et[0], et) : void 0
}
var qo, ap, lp, Lm, Nm, cp, Mm, Pm, F_, QueryClient = (F_ = class {
    constructor(_e={}) {
        gr(this, qo);
        gr(this, ap);
        gr(this, lp);
        gr(this, Lm);
        gr(this, Nm);
        gr(this, cp);
        gr(this, Mm);
        gr(this, Pm);
        Yn(this, qo, _e.queryCache || new QueryCache),
        Yn(this, ap, _e.mutationCache || new MutationCache),
        Yn(this, lp, _e.defaultOptions || {}),
        Yn(this, Lm, new Map),
        Yn(this, Nm, new Map),
        Yn(this, cp, 0)
    }
    mount() {
        Np(this, cp)._++,
        nn(this, cp) === 1 && (Yn(this, Mm, focusManager.subscribe(async _e => {
            _e && (await this.resumePausedMutations(),
            nn(this, qo).onFocus())
        }
        )),
        Yn(this, Pm, onlineManager.subscribe(async _e => {
            _e && (await this.resumePausedMutations(),
            nn(this, qo).onOnline())
        }
        )))
    }
    unmount() {
        var _e, $;
        Np(this, cp)._--,
        nn(this, cp) === 0 && ((_e = nn(this, Mm)) == null || _e.call(this),
        Yn(this, Mm, void 0),
        ($ = nn(this, Pm)) == null || $.call(this),
        Yn(this, Pm, void 0))
    }
    isFetching(_e) {
        return nn(this, qo).findAll({
            ..._e,
            fetchStatus: "fetching"
        }).length
    }
    isMutating(_e) {
        return nn(this, ap).findAll({
            ..._e,
            status: "pending"
        }).length
    }
    getQueryData(_e) {
        var et;
        const $ = this.defaultQueryOptions({
            queryKey: _e
        });
        return (et = nn(this, qo).get($.queryHash)) == null ? void 0 : et.state.data
    }
    ensureQueryData(_e) {
        const $ = this.defaultQueryOptions(_e)
          , et = nn(this, qo).build(this, $)
          , tt = et.state.data;
        return tt === void 0 ? this.fetchQuery(_e) : (_e.revalidateIfStale && et.isStaleByTime(resolveStaleTime($.staleTime, et)) && this.prefetchQuery($),
        Promise.resolve(tt))
    }
    getQueriesData(_e) {
        return nn(this, qo).findAll(_e).map( ({queryKey: $, state: et}) => {
            const tt = et.data;
            return [$, tt]
        }
        )
    }
    setQueryData(_e, $, et) {
        const tt = this.defaultQueryOptions({
            queryKey: _e
        })
          , nt = nn(this, qo).get(tt.queryHash)
          , rt = nt == null ? void 0 : nt.state.data
          , it = functionalUpdate($, rt);
        if (it !== void 0)
            return nn(this, qo).build(this, tt).setData(it, {
                ...et,
                manual: !0
            })
    }
    setQueriesData(_e, $, et) {
        return notifyManager.batch( () => nn(this, qo).findAll(_e).map( ({queryKey: tt}) => [tt, this.setQueryData(tt, $, et)]))
    }
    getQueryState(_e) {
        var et;
        const $ = this.defaultQueryOptions({
            queryKey: _e
        });
        return (et = nn(this, qo).get($.queryHash)) == null ? void 0 : et.state
    }
    removeQueries(_e) {
        const $ = nn(this, qo);
        notifyManager.batch( () => {
            $.findAll(_e).forEach(et => {
                $.remove(et)
            }
            )
        }
        )
    }
    resetQueries(_e, $) {
        const et = nn(this, qo)
          , tt = {
            type: "active",
            ..._e
        };
        return notifyManager.batch( () => (et.findAll(_e).forEach(nt => {
            nt.reset()
        }
        ),
        this.refetchQueries(tt, $)))
    }
    cancelQueries(_e, $={}) {
        const et = {
            revert: !0,
            ...$
        }
          , tt = notifyManager.batch( () => nn(this, qo).findAll(_e).map(nt => nt.cancel(et)));
        return Promise.all(tt).then(noop$6).catch(noop$6)
    }
    invalidateQueries(_e, $={}) {
        return notifyManager.batch( () => {
            if (nn(this, qo).findAll(_e).forEach(tt => {
                tt.invalidate()
            }
            ),
            (_e == null ? void 0 : _e.refetchType) === "none")
                return Promise.resolve();
            const et = {
                ..._e,
                type: (_e == null ? void 0 : _e.refetchType) ?? (_e == null ? void 0 : _e.type) ?? "active"
            };
            return this.refetchQueries(et, $)
        }
        )
    }
    refetchQueries(_e, $={}) {
        const et = {
            ...$,
            cancelRefetch: $.cancelRefetch ?? !0
        }
          , tt = notifyManager.batch( () => nn(this, qo).findAll(_e).filter(nt => !nt.isDisabled()).map(nt => {
            let rt = nt.fetch(void 0, et);
            return et.throwOnError || (rt = rt.catch(noop$6)),
            nt.state.fetchStatus === "paused" ? Promise.resolve() : rt
        }
        ));
        return Promise.all(tt).then(noop$6)
    }
    fetchQuery(_e) {
        const $ = this.defaultQueryOptions(_e);
        $.retry === void 0 && ($.retry = !1);
        const et = nn(this, qo).build(this, $);
        return et.isStaleByTime(resolveStaleTime($.staleTime, et)) ? et.fetch($) : Promise.resolve(et.state.data)
    }
    prefetchQuery(_e) {
        return this.fetchQuery(_e).then(noop$6).catch(noop$6)
    }
    fetchInfiniteQuery(_e) {
        return _e.behavior = infiniteQueryBehavior(_e.pages),
        this.fetchQuery(_e)
    }
    prefetchInfiniteQuery(_e) {
        return this.fetchInfiniteQuery(_e).then(noop$6).catch(noop$6)
    }
    ensureInfiniteQueryData(_e) {
        return _e.behavior = infiniteQueryBehavior(_e.pages),
        this.ensureQueryData(_e)
    }
    resumePausedMutations() {
        return onlineManager.isOnline() ? nn(this, ap).resumePausedMutations() : Promise.resolve()
    }
    getQueryCache() {
        return nn(this, qo)
    }
    getMutationCache() {
        return nn(this, ap)
    }
    getDefaultOptions() {
        return nn(this, lp)
    }
    setDefaultOptions(_e) {
        Yn(this, lp, _e)
    }
    setQueryDefaults(_e, $) {
        nn(this, Lm).set(hashKey(_e), {
            queryKey: _e,
            defaultOptions: $
        })
    }
    getQueryDefaults(_e) {
        const $ = [...nn(this, Lm).values()]
          , et = {};
        return $.forEach(tt => {
            partialMatchKey(_e, tt.queryKey) && Object.assign(et, tt.defaultOptions)
        }
        ),
        et
    }
    setMutationDefaults(_e, $) {
        nn(this, Nm).set(hashKey(_e), {
            mutationKey: _e,
            defaultOptions: $
        })
    }
    getMutationDefaults(_e) {
        const $ = [...nn(this, Nm).values()];
        let et = {};
        return $.forEach(tt => {
            partialMatchKey(_e, tt.mutationKey) && (et = {
                ...et,
                ...tt.defaultOptions
            })
        }
        ),
        et
    }
    defaultQueryOptions(_e) {
        if (_e._defaulted)
            return _e;
        const $ = {
            ...nn(this, lp).queries,
            ...this.getQueryDefaults(_e.queryKey),
            ..._e,
            _defaulted: !0
        };
        return $.queryHash || ($.queryHash = hashQueryKeyByOptions($.queryKey, $)),
        $.refetchOnReconnect === void 0 && ($.refetchOnReconnect = $.networkMode !== "always"),
        $.throwOnError === void 0 && ($.throwOnError = !!$.suspense),
        !$.networkMode && $.persister && ($.networkMode = "offlineFirst"),
        $.queryFn === skipToken && ($.enabled = !1),
        $
    }
    defaultMutationOptions(_e) {
        return _e != null && _e._defaulted ? _e : {
            ...nn(this, lp).mutations,
            ...(_e == null ? void 0 : _e.mutationKey) && this.getMutationDefaults(_e.mutationKey),
            ..._e,
            _defaulted: !0
        }
    }
    clear() {
        nn(this, qo).clear(),
        nn(this, ap).clear()
    }
}
,
qo = new WeakMap,
ap = new WeakMap,
lp = new WeakMap,
Lm = new WeakMap,
Nm = new WeakMap,
cp = new WeakMap,
Mm = new WeakMap,
Pm = new WeakMap,
F_), Qs, fo, k0, Us, jp, Dm, up, su, L0, Bm, Um, zp, Wp, dp, jm, wo, $0, Q1, J1, ev, tv, nv, rv, iv, V_, z_, QueryObserver = (z_ = class extends Subscribable {
    constructor($, et) {
        super();
        gr(this, wo);
        gr(this, Qs);
        gr(this, fo);
        gr(this, k0);
        gr(this, Us);
        gr(this, jp);
        gr(this, Dm);
        gr(this, up);
        gr(this, su);
        gr(this, L0);
        gr(this, Bm);
        gr(this, Um);
        gr(this, zp);
        gr(this, Wp);
        gr(this, dp);
        gr(this, jm, new Set);
        this.options = et,
        Yn(this, Qs, $),
        Yn(this, su, null),
        Yn(this, up, pendingThenable()),
        this.options.experimental_prefetchInRender || nn(this, up).reject(new Error("experimental_prefetchInRender feature flag is not enabled")),
        this.bindMethods(),
        this.setOptions(et)
    }
    bindMethods() {
        this.refetch = this.refetch.bind(this)
    }
    onSubscribe() {
        this.listeners.size === 1 && (nn(this, fo).addObserver(this),
        shouldFetchOnMount(nn(this, fo), this.options) ? tr(this, wo, $0).call(this) : this.updateResult(),
        tr(this, wo, tv).call(this))
    }
    onUnsubscribe() {
        this.hasListeners() || this.destroy()
    }
    shouldFetchOnReconnect() {
        return shouldFetchOn(nn(this, fo), this.options, this.options.refetchOnReconnect)
    }
    shouldFetchOnWindowFocus() {
        return shouldFetchOn(nn(this, fo), this.options, this.options.refetchOnWindowFocus)
    }
    destroy() {
        this.listeners = new Set,
        tr(this, wo, nv).call(this),
        tr(this, wo, rv).call(this),
        nn(this, fo).removeObserver(this)
    }
    setOptions($, et) {
        const tt = this.options
          , nt = nn(this, fo);
        if (this.options = nn(this, Qs).defaultQueryOptions($),
        this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof resolveEnabled(this.options.enabled, nn(this, fo)) != "boolean")
            throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
        tr(this, wo, iv).call(this),
        nn(this, fo).setOptions(this.options),
        tt._defaulted && !shallowEqualObjects(this.options, tt) && nn(this, Qs).getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: nn(this, fo),
            observer: this
        });
        const rt = this.hasListeners();
        rt && shouldFetchOptionally(nn(this, fo), nt, this.options, tt) && tr(this, wo, $0).call(this),
        this.updateResult(et),
        rt && (nn(this, fo) !== nt || resolveEnabled(this.options.enabled, nn(this, fo)) !== resolveEnabled(tt.enabled, nn(this, fo)) || resolveStaleTime(this.options.staleTime, nn(this, fo)) !== resolveStaleTime(tt.staleTime, nn(this, fo))) && tr(this, wo, Q1).call(this);
        const it = tr(this, wo, J1).call(this);
        rt && (nn(this, fo) !== nt || resolveEnabled(this.options.enabled, nn(this, fo)) !== resolveEnabled(tt.enabled, nn(this, fo)) || it !== nn(this, dp)) && tr(this, wo, ev).call(this, it)
    }
    getOptimisticResult($) {
        const et = nn(this, Qs).getQueryCache().build(nn(this, Qs), $)
          , tt = this.createResult(et, $);
        return shouldAssignObserverCurrentProperties(this, tt) && (Yn(this, Us, tt),
        Yn(this, Dm, this.options),
        Yn(this, jp, nn(this, fo).state)),
        tt
    }
    getCurrentResult() {
        return nn(this, Us)
    }
    trackResult($, et) {
        const tt = {};
        return Object.keys($).forEach(nt => {
            Object.defineProperty(tt, nt, {
                configurable: !1,
                enumerable: !0,
                get: () => (this.trackProp(nt),
                et == null || et(nt),
                $[nt])
            })
        }
        ),
        tt
    }
    trackProp($) {
        nn(this, jm).add($)
    }
    getCurrentQuery() {
        return nn(this, fo)
    }
    refetch({...$}={}) {
        return this.fetch({
            ...$
        })
    }
    fetchOptimistic($) {
        const et = nn(this, Qs).defaultQueryOptions($)
          , tt = nn(this, Qs).getQueryCache().build(nn(this, Qs), et);
        return tt.fetch().then( () => this.createResult(tt, et))
    }
    fetch($) {
        return tr(this, wo, $0).call(this, {
            ...$,
            cancelRefetch: $.cancelRefetch ?? !0
        }).then( () => (this.updateResult(),
        nn(this, Us)))
    }
    createResult($, et) {
        var Ut;
        const tt = nn(this, fo)
          , nt = this.options
          , rt = nn(this, Us)
          , it = nn(this, jp)
          , ot = nn(this, Dm)
          , lt = $ !== tt ? $.state : nn(this, k0)
          , {state: ct} = $;
        let dt = {
            ...ct
        }, pt = !1, ht;
        if (et._optimisticResults) {
            const Jt = this.hasListeners()
              , Pt = !Jt && shouldFetchOnMount($, et)
              , Xt = Jt && shouldFetchOptionally($, tt, et, nt);
            (Pt || Xt) && (dt = {
                ...dt,
                ...fetchState(ct.data, $.options)
            }),
            et._optimisticResults === "isRestoring" && (dt.fetchStatus = "idle")
        }
        let {error: mt, errorUpdatedAt: yt, status: Et} = dt;
        if (et.select && dt.data !== void 0)
            if (rt && dt.data === (it == null ? void 0 : it.data) && et.select === nn(this, L0))
                ht = nn(this, Bm);
            else
                try {
                    Yn(this, L0, et.select),
                    ht = et.select(dt.data),
                    ht = replaceData(rt == null ? void 0 : rt.data, ht, et),
                    Yn(this, Bm, ht),
                    Yn(this, su, null)
                } catch (Jt) {
                    Yn(this, su, Jt)
                }
        else
            ht = dt.data;
        if (et.placeholderData !== void 0 && ht === void 0 && Et === "pending") {
            let Jt;
            if (rt != null && rt.isPlaceholderData && et.placeholderData === (ot == null ? void 0 : ot.placeholderData))
                Jt = rt.data;
            else if (Jt = typeof et.placeholderData == "function" ? et.placeholderData((Ut = nn(this, Um)) == null ? void 0 : Ut.state.data, nn(this, Um)) : et.placeholderData,
            et.select && Jt !== void 0)
                try {
                    Jt = et.select(Jt),
                    Yn(this, su, null)
                } catch (Pt) {
                    Yn(this, su, Pt)
                }
            Jt !== void 0 && (Et = "success",
            ht = replaceData(rt == null ? void 0 : rt.data, Jt, et),
            pt = !0)
        }
        nn(this, su) && (mt = nn(this, su),
        ht = nn(this, Bm),
        yt = Date.now(),
        Et = "error");
        const _t = dt.fetchStatus === "fetching"
          , wt = Et === "pending"
          , St = Et === "error"
          , Ct = wt && _t
          , Nt = ht !== void 0
          , kt = {
            status: Et,
            fetchStatus: dt.fetchStatus,
            isPending: wt,
            isSuccess: Et === "success",
            isError: St,
            isInitialLoading: Ct,
            isLoading: Ct,
            data: ht,
            dataUpdatedAt: dt.dataUpdatedAt,
            error: mt,
            errorUpdatedAt: yt,
            failureCount: dt.fetchFailureCount,
            failureReason: dt.fetchFailureReason,
            errorUpdateCount: dt.errorUpdateCount,
            isFetched: dt.dataUpdateCount > 0 || dt.errorUpdateCount > 0,
            isFetchedAfterMount: dt.dataUpdateCount > lt.dataUpdateCount || dt.errorUpdateCount > lt.errorUpdateCount,
            isFetching: _t,
            isRefetching: _t && !wt,
            isLoadingError: St && !Nt,
            isPaused: dt.fetchStatus === "paused",
            isPlaceholderData: pt,
            isRefetchError: St && Nt,
            isStale: isStale($, et),
            refetch: this.refetch,
            promise: nn(this, up)
        };
        if (this.options.experimental_prefetchInRender) {
            const Jt = rn => {
                kt.status === "error" ? rn.reject(kt.error) : kt.data !== void 0 && rn.resolve(kt.data)
            }
              , Pt = () => {
                const rn = Yn(this, up, kt.promise = pendingThenable());
                Jt(rn)
            }
              , Xt = nn(this, up);
            switch (Xt.status) {
            case "pending":
                $.queryHash === tt.queryHash && Jt(Xt);
                break;
            case "fulfilled":
                (kt.status === "error" || kt.data !== Xt.value) && Pt();
                break;
            case "rejected":
                (kt.status !== "error" || kt.error !== Xt.reason) && Pt();
                break
            }
        }
        return kt
    }
    updateResult($) {
        const et = nn(this, Us)
          , tt = this.createResult(nn(this, fo), this.options);
        if (Yn(this, jp, nn(this, fo).state),
        Yn(this, Dm, this.options),
        nn(this, jp).data !== void 0 && Yn(this, Um, nn(this, fo)),
        shallowEqualObjects(tt, et))
            return;
        Yn(this, Us, tt);
        const nt = {}
          , rt = () => {
            if (!et)
                return !0;
            const {notifyOnChangeProps: it} = this.options
              , ot = typeof it == "function" ? it() : it;
            if (ot === "all" || !ot && !nn(this, jm).size)
                return !0;
            const st = new Set(ot ?? nn(this, jm));
            return this.options.throwOnError && st.add("error"),
            Object.keys(nn(this, Us)).some(lt => {
                const ct = lt;
                return nn(this, Us)[ct] !== et[ct] && st.has(ct)
            }
            )
        }
        ;
        ($ == null ? void 0 : $.listeners) !== !1 && rt() && (nt.listeners = !0),
        tr(this, wo, V_).call(this, {
            ...nt,
            ...$
        })
    }
    onQueryUpdate() {
        this.updateResult(),
        this.hasListeners() && tr(this, wo, tv).call(this)
    }
}
,
Qs = new WeakMap,
fo = new WeakMap,
k0 = new WeakMap,
Us = new WeakMap,
jp = new WeakMap,
Dm = new WeakMap,
up = new WeakMap,
su = new WeakMap,
L0 = new WeakMap,
Bm = new WeakMap,
Um = new WeakMap,
zp = new WeakMap,
Wp = new WeakMap,
dp = new WeakMap,
jm = new WeakMap,
wo = new WeakSet,
$0 = function($) {
    tr(this, wo, iv).call(this);
    let et = nn(this, fo).fetch(this.options, $);
    return $ != null && $.throwOnError || (et = et.catch(noop$6)),
    et
}
,
Q1 = function() {
    tr(this, wo, nv).call(this);
    const $ = resolveStaleTime(this.options.staleTime, nn(this, fo));
    if (isServer || nn(this, Us).isStale || !isValidTimeout($))
        return;
    const tt = timeUntilStale(nn(this, Us).dataUpdatedAt, $) + 1;
    Yn(this, zp, setTimeout( () => {
        nn(this, Us).isStale || this.updateResult()
    }
    , tt))
}
,
J1 = function() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(nn(this, fo)) : this.options.refetchInterval) ?? !1
}
,
ev = function($) {
    tr(this, wo, rv).call(this),
    Yn(this, dp, $),
    !(isServer || resolveEnabled(this.options.enabled, nn(this, fo)) === !1 || !isValidTimeout(nn(this, dp)) || nn(this, dp) === 0) && Yn(this, Wp, setInterval( () => {
        (this.options.refetchIntervalInBackground || focusManager.isFocused()) && tr(this, wo, $0).call(this)
    }
    , nn(this, dp)))
}
,
tv = function() {
    tr(this, wo, Q1).call(this),
    tr(this, wo, ev).call(this, tr(this, wo, J1).call(this))
}
,
nv = function() {
    nn(this, zp) && (clearTimeout(nn(this, zp)),
    Yn(this, zp, void 0))
}
,
rv = function() {
    nn(this, Wp) && (clearInterval(nn(this, Wp)),
    Yn(this, Wp, void 0))
}
,
iv = function() {
    const $ = nn(this, Qs).getQueryCache().build(nn(this, Qs), this.options);
    if ($ === nn(this, fo))
        return;
    const et = nn(this, fo);
    Yn(this, fo, $),
    Yn(this, k0, $.state),
    this.hasListeners() && (et == null || et.removeObserver(this),
    $.addObserver(this))
}
,
V_ = function($) {
    notifyManager.batch( () => {
        $.listeners && this.listeners.forEach(et => {
            et(nn(this, Us))
        }
        ),
        nn(this, Qs).getQueryCache().notify({
            query: nn(this, fo),
            type: "observerResultsUpdated"
        })
    }
    )
}
,
z_);
function shouldLoadOnMount(_e, $) {
    return resolveEnabled($.enabled, _e) !== !1 && _e.state.data === void 0 && !(_e.state.status === "error" && $.retryOnMount === !1)
}
function shouldFetchOnMount(_e, $) {
    return shouldLoadOnMount(_e, $) || _e.state.data !== void 0 && shouldFetchOn(_e, $, $.refetchOnMount)
}
function shouldFetchOn(_e, $, et) {
    if (resolveEnabled($.enabled, _e) !== !1) {
        const tt = typeof et == "function" ? et(_e) : et;
        return tt === "always" || tt !== !1 && isStale(_e, $)
    }
    return !1
}
function shouldFetchOptionally(_e, $, et, tt) {
    return (_e !== $ || resolveEnabled(tt.enabled, _e) === !1) && (!et.suspense || _e.state.status !== "error") && isStale(_e, et)
}
function isStale(_e, $) {
    return resolveEnabled($.enabled, _e) !== !1 && _e.isStaleByTime(resolveStaleTime($.staleTime, _e))
}
function shouldAssignObserverCurrentProperties(_e, $) {
    return !shallowEqualObjects(_e.getCurrentResult(), $)
}
var fp, pp, Js, Ou, Lu, Wy, ov, W_, MutationObserver$1 = (W_ = class extends Subscribable {
    constructor(et, tt) {
        super();
        gr(this, Lu);
        gr(this, fp);
        gr(this, pp);
        gr(this, Js);
        gr(this, Ou);
        Yn(this, fp, et),
        this.setOptions(tt),
        this.bindMethods(),
        tr(this, Lu, Wy).call(this)
    }
    bindMethods() {
        this.mutate = this.mutate.bind(this),
        this.reset = this.reset.bind(this)
    }
    setOptions(et) {
        var nt;
        const tt = this.options;
        this.options = nn(this, fp).defaultMutationOptions(et),
        shallowEqualObjects(this.options, tt) || nn(this, fp).getMutationCache().notify({
            type: "observerOptionsUpdated",
            mutation: nn(this, Js),
            observer: this
        }),
        tt != null && tt.mutationKey && this.options.mutationKey && hashKey(tt.mutationKey) !== hashKey(this.options.mutationKey) ? this.reset() : ((nt = nn(this, Js)) == null ? void 0 : nt.state.status) === "pending" && nn(this, Js).setOptions(this.options)
    }
    onUnsubscribe() {
        var et;
        this.hasListeners() || (et = nn(this, Js)) == null || et.removeObserver(this)
    }
    onMutationUpdate(et) {
        tr(this, Lu, Wy).call(this),
        tr(this, Lu, ov).call(this, et)
    }
    getCurrentResult() {
        return nn(this, pp)
    }
    reset() {
        var et;
        (et = nn(this, Js)) == null || et.removeObserver(this),
        Yn(this, Js, void 0),
        tr(this, Lu, Wy).call(this),
        tr(this, Lu, ov).call(this)
    }
    mutate(et, tt) {
        var nt;
        return Yn(this, Ou, tt),
        (nt = nn(this, Js)) == null || nt.removeObserver(this),
        Yn(this, Js, nn(this, fp).getMutationCache().build(nn(this, fp), this.options)),
        nn(this, Js).addObserver(this),
        nn(this, Js).execute(et)
    }
}
,
fp = new WeakMap,
pp = new WeakMap,
Js = new WeakMap,
Ou = new WeakMap,
Lu = new WeakSet,
Wy = function() {
    var tt;
    const et = ((tt = nn(this, Js)) == null ? void 0 : tt.state) ?? getDefaultState();
    Yn(this, pp, {
        ...et,
        isPending: et.status === "pending",
        isSuccess: et.status === "success",
        isError: et.status === "error",
        isIdle: et.status === "idle",
        mutate: this.mutate,
        reset: this.reset
    })
}
,
ov = function(et) {
    notifyManager.batch( () => {
        var tt, nt, rt, it, ot, st, lt, ct;
        if (nn(this, Ou) && this.hasListeners()) {
            const dt = nn(this, pp).variables
              , pt = nn(this, pp).context;
            (et == null ? void 0 : et.type) === "success" ? ((nt = (tt = nn(this, Ou)).onSuccess) == null || nt.call(tt, et.data, dt, pt),
            (it = (rt = nn(this, Ou)).onSettled) == null || it.call(rt, et.data, null, dt, pt)) : (et == null ? void 0 : et.type) === "error" && ((st = (ot = nn(this, Ou)).onError) == null || st.call(ot, et.error, dt, pt),
            (ct = (lt = nn(this, Ou)).onSettled) == null || ct.call(lt, void 0, et.error, dt, pt))
        }
        this.listeners.forEach(dt => {
            dt(nn(this, pp))
        }
        )
    }
    )
}
,
W_), QueryClientContext = reactExports.createContext(void 0), useQueryClient = _e => {
    const $ = reactExports.useContext(QueryClientContext);
    if (!$)
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return $
}
, QueryClientProvider = ({client: _e, children: $}) => (reactExports.useEffect( () => (_e.mount(),
() => {
    _e.unmount()
}
), [_e]),
jsxRuntimeExports.jsx(QueryClientContext.Provider, {
    value: _e,
    children: $
})), IsRestoringContext = reactExports.createContext(!1), useIsRestoring = () => reactExports.useContext(IsRestoringContext);
IsRestoringContext.Provider;
function createValue() {
    let _e = !1;
    return {
        clearReset: () => {
            _e = !1
        }
        ,
        reset: () => {
            _e = !0
        }
        ,
        isReset: () => _e
    }
}
var QueryErrorResetBoundaryContext = reactExports.createContext(createValue())
  , useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext);
function shouldThrowError(_e, $) {
    return typeof _e == "function" ? _e(...$) : !!_e
}
function noop$5() {}
var ensurePreventErrorBoundaryRetry = (_e, $) => {
    (_e.suspense || _e.throwOnError || _e.experimental_prefetchInRender) && ($.isReset() || (_e.retryOnMount = !1))
}
  , useClearResetErrorBoundary = _e => {
    reactExports.useEffect( () => {
        _e.clearReset()
    }
    , [_e])
}
  , getHasError = ({result: _e, errorResetBoundary: $, throwOnError: et, query: tt, suspense: nt}) => _e.isError && !$.isReset() && !_e.isFetching && tt && (nt && _e.data === void 0 || shouldThrowError(et, [_e.error, tt]))
  , ensureSuspenseTimers = _e => {
    const $ = _e.staleTime;
    _e.suspense && (_e.staleTime = typeof $ == "function" ? (...et) => Math.max($(...et), 1e3) : Math.max($ ?? 1e3, 1e3),
    typeof _e.gcTime == "number" && (_e.gcTime = Math.max(_e.gcTime, 1e3)))
}
  , willFetch = (_e, $) => _e.isLoading && _e.isFetching && !$
  , shouldSuspend = (_e, $) => (_e == null ? void 0 : _e.suspense) && $.isPending
  , fetchOptimistic = (_e, $, et) => $.fetchOptimistic(_e).catch( () => {
    et.clearReset()
}
);
function useBaseQuery(_e, $, et) {
    var dt, pt, ht, mt, yt;
    const tt = useQueryClient()
      , nt = useIsRestoring()
      , rt = useQueryErrorResetBoundary()
      , it = tt.defaultQueryOptions(_e);
    (pt = (dt = tt.getDefaultOptions().queries) == null ? void 0 : dt._experimental_beforeQuery) == null || pt.call(dt, it),
    it._optimisticResults = nt ? "isRestoring" : "optimistic",
    ensureSuspenseTimers(it),
    ensurePreventErrorBoundaryRetry(it, rt),
    useClearResetErrorBoundary(rt);
    const ot = !tt.getQueryCache().get(it.queryHash)
      , [st] = reactExports.useState( () => new $(tt,it))
      , lt = st.getOptimisticResult(it)
      , ct = !nt && _e.subscribed !== !1;
    if (reactExports.useSyncExternalStore(reactExports.useCallback(Et => {
        const _t = ct ? st.subscribe(notifyManager.batchCalls(Et)) : noop$5;
        return st.updateResult(),
        _t
    }
    , [st, ct]), () => st.getCurrentResult(), () => st.getCurrentResult()),
    reactExports.useEffect( () => {
        st.setOptions(it, {
            listeners: !1
        })
    }
    , [it, st]),
    shouldSuspend(it, lt))
        throw fetchOptimistic(it, st, rt);
    if (getHasError({
        result: lt,
        errorResetBoundary: rt,
        throwOnError: it.throwOnError,
        query: tt.getQueryCache().get(it.queryHash),
        suspense: it.suspense
    }))
        throw lt.error;
    if ((mt = (ht = tt.getDefaultOptions().queries) == null ? void 0 : ht._experimental_afterQuery) == null || mt.call(ht, it, lt),
    it.experimental_prefetchInRender && !isServer && willFetch(lt, nt)) {
        const Et = ot ? fetchOptimistic(it, st, rt) : (yt = tt.getQueryCache().get(it.queryHash)) == null ? void 0 : yt.promise;
        Et == null || Et.catch(noop$5).finally( () => {
            st.updateResult()
        }
        )
    }
    return it.notifyOnChangeProps ? lt : st.trackResult(lt)
}
function useQuery$1(_e, $) {
    return useBaseQuery(_e, QueryObserver)
}
function useMutation(_e, $) {
    const et = useQueryClient()
      , [tt] = reactExports.useState( () => new MutationObserver$1(et,_e));
    reactExports.useEffect( () => {
        tt.setOptions(_e)
    }
    , [tt, _e]);
    const nt = reactExports.useSyncExternalStore(reactExports.useCallback(it => tt.subscribe(notifyManager.batchCalls(it)), [tt]), () => tt.getCurrentResult(), () => tt.getCurrentResult())
      , rt = reactExports.useCallback( (it, ot) => {
        tt.mutate(it, ot).catch(noop$5)
    }
    , [tt]);
    if (nt.error && shouldThrowError(tt.options.throwOnError, [nt.error]))
        throw nt.error;
    return {
        ...nt,
        mutate: rt,
        mutateAsync: nt.mutate
    }
}
var buffer = {}
  , base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = []
  , revLookup = []
  , Arr = typeof Uint8Array < "u" ? Uint8Array : Array
  , code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$4 = 0, len = code.length; i$4 < len; ++i$4)
    lookup[i$4] = code[i$4],
    revLookup[code.charCodeAt(i$4)] = i$4;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(_e) {
    var $ = _e.length;
    if ($ % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
    var et = _e.indexOf("=");
    et === -1 && (et = $);
    var tt = et === $ ? 0 : 4 - et % 4;
    return [et, tt]
}
function byteLength(_e) {
    var $ = getLens(_e)
      , et = $[0]
      , tt = $[1];
    return (et + tt) * 3 / 4 - tt
}
function _byteLength(_e, $, et) {
    return ($ + et) * 3 / 4 - et
}
function toByteArray(_e) {
    var $, et = getLens(_e), tt = et[0], nt = et[1], rt = new Arr(_byteLength(_e, tt, nt)), it = 0, ot = nt > 0 ? tt - 4 : tt, st;
    for (st = 0; st < ot; st += 4)
        $ = revLookup[_e.charCodeAt(st)] << 18 | revLookup[_e.charCodeAt(st + 1)] << 12 | revLookup[_e.charCodeAt(st + 2)] << 6 | revLookup[_e.charCodeAt(st + 3)],
        rt[it++] = $ >> 16 & 255,
        rt[it++] = $ >> 8 & 255,
        rt[it++] = $ & 255;
    return nt === 2 && ($ = revLookup[_e.charCodeAt(st)] << 2 | revLookup[_e.charCodeAt(st + 1)] >> 4,
    rt[it++] = $ & 255),
    nt === 1 && ($ = revLookup[_e.charCodeAt(st)] << 10 | revLookup[_e.charCodeAt(st + 1)] << 4 | revLookup[_e.charCodeAt(st + 2)] >> 2,
    rt[it++] = $ >> 8 & 255,
    rt[it++] = $ & 255),
    rt
}
function tripletToBase64(_e) {
    return lookup[_e >> 18 & 63] + lookup[_e >> 12 & 63] + lookup[_e >> 6 & 63] + lookup[_e & 63]
}
function encodeChunk(_e, $, et) {
    for (var tt, nt = [], rt = $; rt < et; rt += 3)
        tt = (_e[rt] << 16 & 16711680) + (_e[rt + 1] << 8 & 65280) + (_e[rt + 2] & 255),
        nt.push(tripletToBase64(tt));
    return nt.join("")
}
function fromByteArray(_e) {
    for (var $, et = _e.length, tt = et % 3, nt = [], rt = 16383, it = 0, ot = et - tt; it < ot; it += rt)
        nt.push(encodeChunk(_e, it, it + rt > ot ? ot : it + rt));
    return tt === 1 ? ($ = _e[et - 1],
    nt.push(lookup[$ >> 2] + lookup[$ << 4 & 63] + "==")) : tt === 2 && ($ = (_e[et - 2] << 8) + _e[et - 1],
    nt.push(lookup[$ >> 10] + lookup[$ >> 4 & 63] + lookup[$ << 2 & 63] + "=")),
    nt.join("")
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(_e, $, et, tt, nt) {
    var rt, it, ot = nt * 8 - tt - 1, st = (1 << ot) - 1, lt = st >> 1, ct = -7, dt = et ? nt - 1 : 0, pt = et ? -1 : 1, ht = _e[$ + dt];
    for (dt += pt,
    rt = ht & (1 << -ct) - 1,
    ht >>= -ct,
    ct += ot; ct > 0; rt = rt * 256 + _e[$ + dt],
    dt += pt,
    ct -= 8)
        ;
    for (it = rt & (1 << -ct) - 1,
    rt >>= -ct,
    ct += tt; ct > 0; it = it * 256 + _e[$ + dt],
    dt += pt,
    ct -= 8)
        ;
    if (rt === 0)
        rt = 1 - lt;
    else {
        if (rt === st)
            return it ? NaN : (ht ? -1 : 1) * (1 / 0);
        it = it + Math.pow(2, tt),
        rt = rt - lt
    }
    return (ht ? -1 : 1) * it * Math.pow(2, rt - tt)
}
;
ieee754.write = function(_e, $, et, tt, nt, rt) {
    var it, ot, st, lt = rt * 8 - nt - 1, ct = (1 << lt) - 1, dt = ct >> 1, pt = nt === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ht = tt ? 0 : rt - 1, mt = tt ? 1 : -1, yt = $ < 0 || $ === 0 && 1 / $ < 0 ? 1 : 0;
    for ($ = Math.abs($),
    isNaN($) || $ === 1 / 0 ? (ot = isNaN($) ? 1 : 0,
    it = ct) : (it = Math.floor(Math.log($) / Math.LN2),
    $ * (st = Math.pow(2, -it)) < 1 && (it--,
    st *= 2),
    it + dt >= 1 ? $ += pt / st : $ += pt * Math.pow(2, 1 - dt),
    $ * st >= 2 && (it++,
    st /= 2),
    it + dt >= ct ? (ot = 0,
    it = ct) : it + dt >= 1 ? (ot = ($ * st - 1) * Math.pow(2, nt),
    it = it + dt) : (ot = $ * Math.pow(2, dt - 1) * Math.pow(2, nt),
    it = 0)); nt >= 8; _e[et + ht] = ot & 255,
    ht += mt,
    ot /= 256,
    nt -= 8)
        ;
    for (it = it << nt | ot,
    lt += nt; lt > 0; _e[et + ht] = it & 255,
    ht += mt,
    it /= 256,
    lt -= 8)
        ;
    _e[et + ht - mt] |= yt * 128
}
;
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(_e) {
    const $ = base64Js
      , et = ieee754
      , tt = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    _e.Buffer = ct,
    _e.SlowBuffer = Nt,
    _e.INSPECT_MAX_BYTES = 50;
    const nt = 2147483647;
    _e.kMaxLength = nt;
    const {Uint8Array: rt, ArrayBuffer: it, SharedArrayBuffer: ot} = globalThis;
    ct.TYPED_ARRAY_SUPPORT = st(),
    !ct.TYPED_ARRAY_SUPPORT && typeof console < "u";
    function st() {
        try {
            const an = new rt(1)
              , Kt = {
                foo: function() {
                    return 42
                }
            };
            return Object.setPrototypeOf(Kt, rt.prototype),
            Object.setPrototypeOf(an, Kt),
            an.foo() === 42
        } catch {
            return !1
        }
    }
    Object.defineProperty(ct.prototype, "parent", {
        enumerable: !0,
        get: function() {
            if (ct.isBuffer(this))
                return this.buffer
        }
    }),
    Object.defineProperty(ct.prototype, "offset", {
        enumerable: !0,
        get: function() {
            if (ct.isBuffer(this))
                return this.byteOffset
        }
    });
    function lt(an) {
        if (an > nt)
            throw new RangeError('The value "' + an + '" is invalid for option "size"');
        const Kt = new rt(an);
        return Object.setPrototypeOf(Kt, ct.prototype),
        Kt
    }
    function ct(an, Kt, Gt) {
        if (typeof an == "number") {
            if (typeof Kt == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
            return mt(an)
        }
        return dt(an, Kt, Gt)
    }
    ct.poolSize = 8192;
    function dt(an, Kt, Gt) {
        if (typeof an == "string")
            return yt(an, Kt);
        if (it.isView(an))
            return _t(an);
        if (an == null)
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof an);
        if (dr(an, it) || an && dr(an.buffer, it) || typeof ot < "u" && (dr(an, ot) || an && dr(an.buffer, ot)))
            return wt(an, Kt, Gt);
        if (typeof an == "number")
            throw new TypeError('The "value" argument must not be of type number. Received type number');
        const fn = an.valueOf && an.valueOf();
        if (fn != null && fn !== an)
            return ct.from(fn, Kt, Gt);
        const En = St(an);
        if (En)
            return En;
        if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof an[Symbol.toPrimitive] == "function")
            return ct.from(an[Symbol.toPrimitive]("string"), Kt, Gt);
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof an)
    }
    ct.from = function(an, Kt, Gt) {
        return dt(an, Kt, Gt)
    }
    ,
    Object.setPrototypeOf(ct.prototype, rt.prototype),
    Object.setPrototypeOf(ct, rt);
    function pt(an) {
        if (typeof an != "number")
            throw new TypeError('"size" argument must be of type number');
        if (an < 0)
            throw new RangeError('The value "' + an + '" is invalid for option "size"')
    }
    function ht(an, Kt, Gt) {
        return pt(an),
        an <= 0 ? lt(an) : Kt !== void 0 ? typeof Gt == "string" ? lt(an).fill(Kt, Gt) : lt(an).fill(Kt) : lt(an)
    }
    ct.alloc = function(an, Kt, Gt) {
        return ht(an, Kt, Gt)
    }
    ;
    function mt(an) {
        return pt(an),
        lt(an < 0 ? 0 : Ct(an) | 0)
    }
    ct.allocUnsafe = function(an) {
        return mt(an)
    }
    ,
    ct.allocUnsafeSlow = function(an) {
        return mt(an)
    }
    ;
    function yt(an, Kt) {
        if ((typeof Kt != "string" || Kt === "") && (Kt = "utf8"),
        !ct.isEncoding(Kt))
            throw new TypeError("Unknown encoding: " + Kt);
        const Gt = Lt(an, Kt) | 0;
        let fn = lt(Gt);
        const En = fn.write(an, Kt);
        return En !== Gt && (fn = fn.slice(0, En)),
        fn
    }
    function Et(an) {
        const Kt = an.length < 0 ? 0 : Ct(an.length) | 0
          , Gt = lt(Kt);
        for (let fn = 0; fn < Kt; fn += 1)
            Gt[fn] = an[fn] & 255;
        return Gt
    }
    function _t(an) {
        if (dr(an, rt)) {
            const Kt = new rt(an);
            return wt(Kt.buffer, Kt.byteOffset, Kt.byteLength)
        }
        return Et(an)
    }
    function wt(an, Kt, Gt) {
        if (Kt < 0 || an.byteLength < Kt)
            throw new RangeError('"offset" is outside of buffer bounds');
        if (an.byteLength < Kt + (Gt || 0))
            throw new RangeError('"length" is outside of buffer bounds');
        let fn;
        return Kt === void 0 && Gt === void 0 ? fn = new rt(an) : Gt === void 0 ? fn = new rt(an,Kt) : fn = new rt(an,Kt,Gt),
        Object.setPrototypeOf(fn, ct.prototype),
        fn
    }
    function St(an) {
        if (ct.isBuffer(an)) {
            const Kt = Ct(an.length) | 0
              , Gt = lt(Kt);
            return Gt.length === 0 || an.copy(Gt, 0, 0, Kt),
            Gt
        }
        if (an.length !== void 0)
            return typeof an.length != "number" || or(an.length) ? lt(0) : Et(an);
        if (an.type === "Buffer" && Array.isArray(an.data))
            return Et(an.data)
    }
    function Ct(an) {
        if (an >= nt)
            throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + nt.toString(16) + " bytes");
        return an | 0
    }
    function Nt(an) {
        return +an != an && (an = 0),
        ct.alloc(+an)
    }
    ct.isBuffer = function(Kt) {
        return Kt != null && Kt._isBuffer === !0 && Kt !== ct.prototype
    }
    ,
    ct.compare = function(Kt, Gt) {
        if (dr(Kt, rt) && (Kt = ct.from(Kt, Kt.offset, Kt.byteLength)),
        dr(Gt, rt) && (Gt = ct.from(Gt, Gt.offset, Gt.byteLength)),
        !ct.isBuffer(Kt) || !ct.isBuffer(Gt))
            throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
        if (Kt === Gt)
            return 0;
        let fn = Kt.length
          , En = Gt.length;
        for (let vn = 0, Tn = Math.min(fn, En); vn < Tn; ++vn)
            if (Kt[vn] !== Gt[vn]) {
                fn = Kt[vn],
                En = Gt[vn];
                break
            }
        return fn < En ? -1 : En < fn ? 1 : 0
    }
    ,
    ct.isEncoding = function(Kt) {
        switch (String(Kt).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
            return !0;
        default:
            return !1
        }
    }
    ,
    ct.concat = function(Kt, Gt) {
        if (!Array.isArray(Kt))
            throw new TypeError('"list" argument must be an Array of Buffers');
        if (Kt.length === 0)
            return ct.alloc(0);
        let fn;
        if (Gt === void 0)
            for (Gt = 0,
            fn = 0; fn < Kt.length; ++fn)
                Gt += Kt[fn].length;
        const En = ct.allocUnsafe(Gt);
        let vn = 0;
        for (fn = 0; fn < Kt.length; ++fn) {
            let Tn = Kt[fn];
            if (dr(Tn, rt))
                vn + Tn.length > En.length ? (ct.isBuffer(Tn) || (Tn = ct.from(Tn)),
                Tn.copy(En, vn)) : rt.prototype.set.call(En, Tn, vn);
            else if (ct.isBuffer(Tn))
                Tn.copy(En, vn);
            else
                throw new TypeError('"list" argument must be an Array of Buffers');
            vn += Tn.length
        }
        return En
    }
    ;
    function Lt(an, Kt) {
        if (ct.isBuffer(an))
            return an.length;
        if (it.isView(an) || dr(an, it))
            return an.byteLength;
        if (typeof an != "string")
            throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof an);
        const Gt = an.length
          , fn = arguments.length > 2 && arguments[2] === !0;
        if (!fn && Gt === 0)
            return 0;
        let En = !1;
        for (; ; )
            switch (Kt) {
            case "ascii":
            case "latin1":
            case "binary":
                return Gt;
            case "utf8":
            case "utf-8":
                return xr(an).length;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Gt * 2;
            case "hex":
                return Gt >>> 1;
            case "base64":
                return Vn(an).length;
            default:
                if (En)
                    return fn ? -1 : xr(an).length;
                Kt = ("" + Kt).toLowerCase(),
                En = !0
            }
    }
    ct.byteLength = Lt;
    function kt(an, Kt, Gt) {
        let fn = !1;
        if ((Kt === void 0 || Kt < 0) && (Kt = 0),
        Kt > this.length || ((Gt === void 0 || Gt > this.length) && (Gt = this.length),
        Gt <= 0) || (Gt >>>= 0,
        Kt >>>= 0,
        Gt <= Kt))
            return "";
        for (an || (an = "utf8"); ; )
            switch (an) {
            case "hex":
                return Mt(this, Kt, Gt);
            case "utf8":
            case "utf-8":
                return jt(this, Kt, Gt);
            case "ascii":
                return qt(this, Kt, Gt);
            case "latin1":
            case "binary":
                return Wt(this, Kt, Gt);
            case "base64":
                return Dt(this, Kt, Gt);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return Yt(this, Kt, Gt);
            default:
                if (fn)
                    throw new TypeError("Unknown encoding: " + an);
                an = (an + "").toLowerCase(),
                fn = !0
            }
    }
    ct.prototype._isBuffer = !0;
    function Ut(an, Kt, Gt) {
        const fn = an[Kt];
        an[Kt] = an[Gt],
        an[Gt] = fn
    }
    ct.prototype.swap16 = function() {
        const Kt = this.length;
        if (Kt % 2 !== 0)
            throw new RangeError("Buffer size must be a multiple of 16-bits");
        for (let Gt = 0; Gt < Kt; Gt += 2)
            Ut(this, Gt, Gt + 1);
        return this
    }
    ,
    ct.prototype.swap32 = function() {
        const Kt = this.length;
        if (Kt % 4 !== 0)
            throw new RangeError("Buffer size must be a multiple of 32-bits");
        for (let Gt = 0; Gt < Kt; Gt += 4)
            Ut(this, Gt, Gt + 3),
            Ut(this, Gt + 1, Gt + 2);
        return this
    }
    ,
    ct.prototype.swap64 = function() {
        const Kt = this.length;
        if (Kt % 8 !== 0)
            throw new RangeError("Buffer size must be a multiple of 64-bits");
        for (let Gt = 0; Gt < Kt; Gt += 8)
            Ut(this, Gt, Gt + 7),
            Ut(this, Gt + 1, Gt + 6),
            Ut(this, Gt + 2, Gt + 5),
            Ut(this, Gt + 3, Gt + 4);
        return this
    }
    ,
    ct.prototype.toString = function() {
        const Kt = this.length;
        return Kt === 0 ? "" : arguments.length === 0 ? jt(this, 0, Kt) : kt.apply(this, arguments)
    }
    ,
    ct.prototype.toLocaleString = ct.prototype.toString,
    ct.prototype.equals = function(Kt) {
        if (!ct.isBuffer(Kt))
            throw new TypeError("Argument must be a Buffer");
        return this === Kt ? !0 : ct.compare(this, Kt) === 0
    }
    ,
    ct.prototype.inspect = function() {
        let Kt = "";
        const Gt = _e.INSPECT_MAX_BYTES;
        return Kt = this.toString("hex", 0, Gt).replace(/(.{2})/g, "$1 ").trim(),
        this.length > Gt && (Kt += " ... "),
        "<Buffer " + Kt + ">"
    }
    ,
    tt && (ct.prototype[tt] = ct.prototype.inspect),
    ct.prototype.compare = function(Kt, Gt, fn, En, vn) {
        if (dr(Kt, rt) && (Kt = ct.from(Kt, Kt.offset, Kt.byteLength)),
        !ct.isBuffer(Kt))
            throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof Kt);
        if (Gt === void 0 && (Gt = 0),
        fn === void 0 && (fn = Kt ? Kt.length : 0),
        En === void 0 && (En = 0),
        vn === void 0 && (vn = this.length),
        Gt < 0 || fn > Kt.length || En < 0 || vn > this.length)
            throw new RangeError("out of range index");
        if (En >= vn && Gt >= fn)
            return 0;
        if (En >= vn)
            return -1;
        if (Gt >= fn)
            return 1;
        if (Gt >>>= 0,
        fn >>>= 0,
        En >>>= 0,
        vn >>>= 0,
        this === Kt)
            return 0;
        let Tn = vn - En
          , sr = fn - Gt;
        const lr = Math.min(Tn, sr)
          , wn = this.slice(En, vn)
          , Pn = Kt.slice(Gt, fn);
        for (let Cn = 0; Cn < lr; ++Cn)
            if (wn[Cn] !== Pn[Cn]) {
                Tn = wn[Cn],
                sr = Pn[Cn];
                break
            }
        return Tn < sr ? -1 : sr < Tn ? 1 : 0
    }
    ;
    function Jt(an, Kt, Gt, fn, En) {
        if (an.length === 0)
            return -1;
        if (typeof Gt == "string" ? (fn = Gt,
        Gt = 0) : Gt > 2147483647 ? Gt = 2147483647 : Gt < -2147483648 && (Gt = -2147483648),
        Gt = +Gt,
        or(Gt) && (Gt = En ? 0 : an.length - 1),
        Gt < 0 && (Gt = an.length + Gt),
        Gt >= an.length) {
            if (En)
                return -1;
            Gt = an.length - 1
        } else if (Gt < 0)
            if (En)
                Gt = 0;
            else
                return -1;
        if (typeof Kt == "string" && (Kt = ct.from(Kt, fn)),
        ct.isBuffer(Kt))
            return Kt.length === 0 ? -1 : Pt(an, Kt, Gt, fn, En);
        if (typeof Kt == "number")
            return Kt = Kt & 255,
            typeof rt.prototype.indexOf == "function" ? En ? rt.prototype.indexOf.call(an, Kt, Gt) : rt.prototype.lastIndexOf.call(an, Kt, Gt) : Pt(an, [Kt], Gt, fn, En);
        throw new TypeError("val must be string, number or Buffer")
    }
    function Pt(an, Kt, Gt, fn, En) {
        let vn = 1
          , Tn = an.length
          , sr = Kt.length;
        if (fn !== void 0 && (fn = String(fn).toLowerCase(),
        fn === "ucs2" || fn === "ucs-2" || fn === "utf16le" || fn === "utf-16le")) {
            if (an.length < 2 || Kt.length < 2)
                return -1;
            vn = 2,
            Tn /= 2,
            sr /= 2,
            Gt /= 2
        }
        function lr(Pn, Cn) {
            return vn === 1 ? Pn[Cn] : Pn.readUInt16BE(Cn * vn)
        }
        let wn;
        if (En) {
            let Pn = -1;
            for (wn = Gt; wn < Tn; wn++)
                if (lr(an, wn) === lr(Kt, Pn === -1 ? 0 : wn - Pn)) {
                    if (Pn === -1 && (Pn = wn),
                    wn - Pn + 1 === sr)
                        return Pn * vn
                } else
                    Pn !== -1 && (wn -= wn - Pn),
                    Pn = -1
        } else
            for (Gt + sr > Tn && (Gt = Tn - sr),
            wn = Gt; wn >= 0; wn--) {
                let Pn = !0;
                for (let Cn = 0; Cn < sr; Cn++)
                    if (lr(an, wn + Cn) !== lr(Kt, Cn)) {
                        Pn = !1;
                        break
                    }
                if (Pn)
                    return wn
            }
        return -1
    }
    ct.prototype.includes = function(Kt, Gt, fn) {
        return this.indexOf(Kt, Gt, fn) !== -1
    }
    ,
    ct.prototype.indexOf = function(Kt, Gt, fn) {
        return Jt(this, Kt, Gt, fn, !0)
    }
    ,
    ct.prototype.lastIndexOf = function(Kt, Gt, fn) {
        return Jt(this, Kt, Gt, fn, !1)
    }
    ;
    function Xt(an, Kt, Gt, fn) {
        Gt = Number(Gt) || 0;
        const En = an.length - Gt;
        fn ? (fn = Number(fn),
        fn > En && (fn = En)) : fn = En;
        const vn = Kt.length;
        fn > vn / 2 && (fn = vn / 2);
        let Tn;
        for (Tn = 0; Tn < fn; ++Tn) {
            const sr = parseInt(Kt.substr(Tn * 2, 2), 16);
            if (or(sr))
                return Tn;
            an[Gt + Tn] = sr
        }
        return Tn
    }
    function rn(an, Kt, Gt, fn) {
        return qn(xr(Kt, an.length - Gt), an, Gt, fn)
    }
    function zt(an, Kt, Gt, fn) {
        return qn(wr(Kt), an, Gt, fn)
    }
    function xt(an, Kt, Gt, fn) {
        return qn(Vn(Kt), an, Gt, fn)
    }
    function $t(an, Kt, Gt, fn) {
        return qn(Rn(Kt, an.length - Gt), an, Gt, fn)
    }
    ct.prototype.write = function(Kt, Gt, fn, En) {
        if (Gt === void 0)
            En = "utf8",
            fn = this.length,
            Gt = 0;
        else if (fn === void 0 && typeof Gt == "string")
            En = Gt,
            fn = this.length,
            Gt = 0;
        else if (isFinite(Gt))
            Gt = Gt >>> 0,
            isFinite(fn) ? (fn = fn >>> 0,
            En === void 0 && (En = "utf8")) : (En = fn,
            fn = void 0);
        else
            throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        const vn = this.length - Gt;
        if ((fn === void 0 || fn > vn) && (fn = vn),
        Kt.length > 0 && (fn < 0 || Gt < 0) || Gt > this.length)
            throw new RangeError("Attempt to write outside buffer bounds");
        En || (En = "utf8");
        let Tn = !1;
        for (; ; )
            switch (En) {
            case "hex":
                return Xt(this, Kt, Gt, fn);
            case "utf8":
            case "utf-8":
                return rn(this, Kt, Gt, fn);
            case "ascii":
            case "latin1":
            case "binary":
                return zt(this, Kt, Gt, fn);
            case "base64":
                return xt(this, Kt, Gt, fn);
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
                return $t(this, Kt, Gt, fn);
            default:
                if (Tn)
                    throw new TypeError("Unknown encoding: " + En);
                En = ("" + En).toLowerCase(),
                Tn = !0
            }
    }
    ,
    ct.prototype.toJSON = function() {
        return {
            type: "Buffer",
            data: Array.prototype.slice.call(this._arr || this, 0)
        }
    }
    ;
    function Dt(an, Kt, Gt) {
        return Kt === 0 && Gt === an.length ? $.fromByteArray(an) : $.fromByteArray(an.slice(Kt, Gt))
    }
    function jt(an, Kt, Gt) {
        Gt = Math.min(an.length, Gt);
        const fn = [];
        let En = Kt;
        for (; En < Gt; ) {
            const vn = an[En];
            let Tn = null
              , sr = vn > 239 ? 4 : vn > 223 ? 3 : vn > 191 ? 2 : 1;
            if (En + sr <= Gt) {
                let lr, wn, Pn, Cn;
                switch (sr) {
                case 1:
                    vn < 128 && (Tn = vn);
                    break;
                case 2:
                    lr = an[En + 1],
                    (lr & 192) === 128 && (Cn = (vn & 31) << 6 | lr & 63,
                    Cn > 127 && (Tn = Cn));
                    break;
                case 3:
                    lr = an[En + 1],
                    wn = an[En + 2],
                    (lr & 192) === 128 && (wn & 192) === 128 && (Cn = (vn & 15) << 12 | (lr & 63) << 6 | wn & 63,
                    Cn > 2047 && (Cn < 55296 || Cn > 57343) && (Tn = Cn));
                    break;
                case 4:
                    lr = an[En + 1],
                    wn = an[En + 2],
                    Pn = an[En + 3],
                    (lr & 192) === 128 && (wn & 192) === 128 && (Pn & 192) === 128 && (Cn = (vn & 15) << 18 | (lr & 63) << 12 | (wn & 63) << 6 | Pn & 63,
                    Cn > 65535 && Cn < 1114112 && (Tn = Cn))
                }
            }
            Tn === null ? (Tn = 65533,
            sr = 1) : Tn > 65535 && (Tn -= 65536,
            fn.push(Tn >>> 10 & 1023 | 55296),
            Tn = 56320 | Tn & 1023),
            fn.push(Tn),
            En += sr
        }
        return Ht(fn)
    }
    const Ft = 4096;
    function Ht(an) {
        const Kt = an.length;
        if (Kt <= Ft)
            return String.fromCharCode.apply(String, an);
        let Gt = ""
          , fn = 0;
        for (; fn < Kt; )
            Gt += String.fromCharCode.apply(String, an.slice(fn, fn += Ft));
        return Gt
    }
    function qt(an, Kt, Gt) {
        let fn = "";
        Gt = Math.min(an.length, Gt);
        for (let En = Kt; En < Gt; ++En)
            fn += String.fromCharCode(an[En] & 127);
        return fn
    }
    function Wt(an, Kt, Gt) {
        let fn = "";
        Gt = Math.min(an.length, Gt);
        for (let En = Kt; En < Gt; ++En)
            fn += String.fromCharCode(an[En]);
        return fn
    }
    function Mt(an, Kt, Gt) {
        const fn = an.length;
        (!Kt || Kt < 0) && (Kt = 0),
        (!Gt || Gt < 0 || Gt > fn) && (Gt = fn);
        let En = "";
        for (let vn = Kt; vn < Gt; ++vn)
            En += ir[an[vn]];
        return En
    }
    function Yt(an, Kt, Gt) {
        const fn = an.slice(Kt, Gt);
        let En = "";
        for (let vn = 0; vn < fn.length - 1; vn += 2)
            En += String.fromCharCode(fn[vn] + fn[vn + 1] * 256);
        return En
    }
    ct.prototype.slice = function(Kt, Gt) {
        const fn = this.length;
        Kt = ~~Kt,
        Gt = Gt === void 0 ? fn : ~~Gt,
        Kt < 0 ? (Kt += fn,
        Kt < 0 && (Kt = 0)) : Kt > fn && (Kt = fn),
        Gt < 0 ? (Gt += fn,
        Gt < 0 && (Gt = 0)) : Gt > fn && (Gt = fn),
        Gt < Kt && (Gt = Kt);
        const En = this.subarray(Kt, Gt);
        return Object.setPrototypeOf(En, ct.prototype),
        En
    }
    ;
    function un(an, Kt, Gt) {
        if (an % 1 !== 0 || an < 0)
            throw new RangeError("offset is not uint");
        if (an + Kt > Gt)
            throw new RangeError("Trying to access beyond buffer length")
    }
    ct.prototype.readUintLE = ct.prototype.readUIntLE = function(Kt, Gt, fn) {
        Kt = Kt >>> 0,
        Gt = Gt >>> 0,
        fn || un(Kt, Gt, this.length);
        let En = this[Kt]
          , vn = 1
          , Tn = 0;
        for (; ++Tn < Gt && (vn *= 256); )
            En += this[Kt + Tn] * vn;
        return En
    }
    ,
    ct.prototype.readUintBE = ct.prototype.readUIntBE = function(Kt, Gt, fn) {
        Kt = Kt >>> 0,
        Gt = Gt >>> 0,
        fn || un(Kt, Gt, this.length);
        let En = this[Kt + --Gt]
          , vn = 1;
        for (; Gt > 0 && (vn *= 256); )
            En += this[Kt + --Gt] * vn;
        return En
    }
    ,
    ct.prototype.readUint8 = ct.prototype.readUInt8 = function(Kt, Gt) {
        return Kt = Kt >>> 0,
        Gt || un(Kt, 1, this.length),
        this[Kt]
    }
    ,
    ct.prototype.readUint16LE = ct.prototype.readUInt16LE = function(Kt, Gt) {
        return Kt = Kt >>> 0,
        Gt || un(Kt, 2, this.length),
        this[Kt] | this[Kt + 1] << 8
    }
    ,
    ct.prototype.readUint16BE = ct.prototype.readUInt16BE = function(Kt, Gt) {
        return Kt = Kt >>> 0,
        Gt || un(Kt, 2, this.length),
        this[Kt] << 8 | this[Kt + 1]
    }
    ,
    ct.prototype.readUint32LE = ct.prototype.readUInt32LE = function(Kt, Gt) {
        return Kt = Kt >>> 0,
        Gt || un(Kt, 4, this.length),
        (this[Kt] | this[Kt + 1] << 8 | this[Kt + 2] << 16) + this[Kt + 3] * 16777216
    }
    ,
    ct.prototype.readUint32BE = ct.prototype.readUInt32BE = function(Kt, Gt) {
        return Kt = Kt >>> 0,
        Gt || un(Kt, 4, this.length),
        this[Kt] * 16777216 + (this[Kt + 1] << 16 | this[Kt + 2] << 8 | this[Kt + 3])
    }
    ,
    ct.prototype.readBigUInt64LE = Cr(function(Kt) {
        Kt = Kt >>> 0,
        rr(Kt, "offset");
        const Gt = this[Kt]
          , fn = this[Kt + 7];
        (Gt === void 0 || fn === void 0) && Zn(Kt, this.length - 8);
        const En = Gt + this[++Kt] * 2 ** 8 + this[++Kt] * 2 ** 16 + this[++Kt] * 2 ** 24
          , vn = this[++Kt] + this[++Kt] * 2 ** 8 + this[++Kt] * 2 ** 16 + fn * 2 ** 24;
        return BigInt(En) + (BigInt(vn) << BigInt(32))
    }),
    ct.prototype.readBigUInt64BE = Cr(function(Kt) {
        Kt = Kt >>> 0,
        rr(Kt, "offset");
        const Gt = this[Kt]
          , fn = this[Kt + 7];
        (Gt === void 0 || fn === void 0) && Zn(Kt, this.length - 8);
        const En = Gt * 2 ** 24 + this[++Kt] * 2 ** 16 + this[++Kt] * 2 ** 8 + this[++Kt]
          , vn = this[++Kt] * 2 ** 24 + this[++Kt] * 2 ** 16 + this[++Kt] * 2 ** 8 + fn;
        return (BigInt(En) << BigInt(32)) + BigInt(vn)
    }),
    ct.prototype.readIntLE = function(Kt, Gt, fn) {
        Kt = Kt >>> 0,
        Gt = Gt >>> 0,
        fn || un(Kt, Gt, this.length);
        let En = this[Kt]
          , vn = 1
          , Tn = 0;
        for (; ++Tn < Gt && (vn *= 256); )
            En += this[Kt + Tn] * vn;
        return vn *= 128,
        En >= vn && (En -= Math.pow(2, 8 * Gt)),
        En
    }
    ,
    ct.prototype.readIntBE = function(Kt, Gt, fn) {
        Kt = Kt >>> 0,
        Gt = Gt >>> 0,
        fn || un(Kt, Gt, this.length);
        let En = Gt
          , vn = 1
          , Tn = this[Kt + --En];
        for (; En > 0 && (vn *= 256); )
            Tn += this[Kt + --En] * vn;
        return vn *= 128,
        Tn >= vn && (Tn -= Math.pow(2, 8 * Gt)),
        Tn
    }
    ,
    ct.prototype.readInt8 = function(Kt, Gt) {
        return Kt = Kt >>> 0,
        Gt || un(Kt, 1, this.length),
        this[Kt] & 128 ? (255 - this[Kt] + 1) * -1 : this[Kt]
    }
    ,
    ct.prototype.readInt16LE = function(Kt, Gt) {
        Kt = Kt >>> 0,
        Gt || un(Kt, 2, this.length);
        const fn = this[Kt] | this[Kt + 1] << 8;
        return fn & 32768 ? fn | 4294901760 : fn
    }
    ,
    ct.prototype.readInt16BE = function(Kt, Gt) {
        Kt = Kt >>> 0,
        Gt || un(Kt, 2, this.length);
        const fn = this[Kt + 1] | this[Kt] << 8;
        return fn & 32768 ? fn | 4294901760 : fn
    }
    ,
    ct.prototype.readInt32LE = function(Kt, Gt) {
        return Kt = Kt >>> 0,
        Gt || un(Kt, 4, this.length),
        this[Kt] | this[Kt + 1] << 8 | this[Kt + 2] << 16 | this[Kt + 3] << 24
    }
    ,
    ct.prototype.readInt32BE = function(Kt, Gt) {
        return Kt = Kt >>> 0,
        Gt || un(Kt, 4, this.length),
        this[Kt] << 24 | this[Kt + 1] << 16 | this[Kt + 2] << 8 | this[Kt + 3]
    }
    ,
    ct.prototype.readBigInt64LE = Cr(function(Kt) {
        Kt = Kt >>> 0,
        rr(Kt, "offset");
        const Gt = this[Kt]
          , fn = this[Kt + 7];
        (Gt === void 0 || fn === void 0) && Zn(Kt, this.length - 8);
        const En = this[Kt + 4] + this[Kt + 5] * 2 ** 8 + this[Kt + 6] * 2 ** 16 + (fn << 24);
        return (BigInt(En) << BigInt(32)) + BigInt(Gt + this[++Kt] * 2 ** 8 + this[++Kt] * 2 ** 16 + this[++Kt] * 2 ** 24)
    }),
    ct.prototype.readBigInt64BE = Cr(function(Kt) {
        Kt = Kt >>> 0,
        rr(Kt, "offset");
        const Gt = this[Kt]
          , fn = this[Kt + 7];
        (Gt === void 0 || fn === void 0) && Zn(Kt, this.length - 8);
        const En = (Gt << 24) + this[++Kt] * 2 ** 16 + this[++Kt] * 2 ** 8 + this[++Kt];
        return (BigInt(En) << BigInt(32)) + BigInt(this[++Kt] * 2 ** 24 + this[++Kt] * 2 ** 16 + this[++Kt] * 2 ** 8 + fn)
    }),
    ct.prototype.readFloatLE = function(Kt, Gt) {
        return Kt = Kt >>> 0,
        Gt || un(Kt, 4, this.length),
        et.read(this, Kt, !0, 23, 4)
    }
    ,
    ct.prototype.readFloatBE = function(Kt, Gt) {
        return Kt = Kt >>> 0,
        Gt || un(Kt, 4, this.length),
        et.read(this, Kt, !1, 23, 4)
    }
    ,
    ct.prototype.readDoubleLE = function(Kt, Gt) {
        return Kt = Kt >>> 0,
        Gt || un(Kt, 8, this.length),
        et.read(this, Kt, !0, 52, 8)
    }
    ,
    ct.prototype.readDoubleBE = function(Kt, Gt) {
        return Kt = Kt >>> 0,
        Gt || un(Kt, 8, this.length),
        et.read(this, Kt, !1, 52, 8)
    }
    ;
    function hn(an, Kt, Gt, fn, En, vn) {
        if (!ct.isBuffer(an))
            throw new TypeError('"buffer" argument must be a Buffer instance');
        if (Kt > En || Kt < vn)
            throw new RangeError('"value" argument is out of bounds');
        if (Gt + fn > an.length)
            throw new RangeError("Index out of range")
    }
    ct.prototype.writeUintLE = ct.prototype.writeUIntLE = function(Kt, Gt, fn, En) {
        if (Kt = +Kt,
        Gt = Gt >>> 0,
        fn = fn >>> 0,
        !En) {
            const sr = Math.pow(2, 8 * fn) - 1;
            hn(this, Kt, Gt, fn, sr, 0)
        }
        let vn = 1
          , Tn = 0;
        for (this[Gt] = Kt & 255; ++Tn < fn && (vn *= 256); )
            this[Gt + Tn] = Kt / vn & 255;
        return Gt + fn
    }
    ,
    ct.prototype.writeUintBE = ct.prototype.writeUIntBE = function(Kt, Gt, fn, En) {
        if (Kt = +Kt,
        Gt = Gt >>> 0,
        fn = fn >>> 0,
        !En) {
            const sr = Math.pow(2, 8 * fn) - 1;
            hn(this, Kt, Gt, fn, sr, 0)
        }
        let vn = fn - 1
          , Tn = 1;
        for (this[Gt + vn] = Kt & 255; --vn >= 0 && (Tn *= 256); )
            this[Gt + vn] = Kt / Tn & 255;
        return Gt + fn
    }
    ,
    ct.prototype.writeUint8 = ct.prototype.writeUInt8 = function(Kt, Gt, fn) {
        return Kt = +Kt,
        Gt = Gt >>> 0,
        fn || hn(this, Kt, Gt, 1, 255, 0),
        this[Gt] = Kt & 255,
        Gt + 1
    }
    ,
    ct.prototype.writeUint16LE = ct.prototype.writeUInt16LE = function(Kt, Gt, fn) {
        return Kt = +Kt,
        Gt = Gt >>> 0,
        fn || hn(this, Kt, Gt, 2, 65535, 0),
        this[Gt] = Kt & 255,
        this[Gt + 1] = Kt >>> 8,
        Gt + 2
    }
    ,
    ct.prototype.writeUint16BE = ct.prototype.writeUInt16BE = function(Kt, Gt, fn) {
        return Kt = +Kt,
        Gt = Gt >>> 0,
        fn || hn(this, Kt, Gt, 2, 65535, 0),
        this[Gt] = Kt >>> 8,
        this[Gt + 1] = Kt & 255,
        Gt + 2
    }
    ,
    ct.prototype.writeUint32LE = ct.prototype.writeUInt32LE = function(Kt, Gt, fn) {
        return Kt = +Kt,
        Gt = Gt >>> 0,
        fn || hn(this, Kt, Gt, 4, 4294967295, 0),
        this[Gt + 3] = Kt >>> 24,
        this[Gt + 2] = Kt >>> 16,
        this[Gt + 1] = Kt >>> 8,
        this[Gt] = Kt & 255,
        Gt + 4
    }
    ,
    ct.prototype.writeUint32BE = ct.prototype.writeUInt32BE = function(Kt, Gt, fn) {
        return Kt = +Kt,
        Gt = Gt >>> 0,
        fn || hn(this, Kt, Gt, 4, 4294967295, 0),
        this[Gt] = Kt >>> 24,
        this[Gt + 1] = Kt >>> 16,
        this[Gt + 2] = Kt >>> 8,
        this[Gt + 3] = Kt & 255,
        Gt + 4
    }
    ;
    function _n(an, Kt, Gt, fn, En) {
        Mn(Kt, fn, En, an, Gt, 7);
        let vn = Number(Kt & BigInt(4294967295));
        an[Gt++] = vn,
        vn = vn >> 8,
        an[Gt++] = vn,
        vn = vn >> 8,
        an[Gt++] = vn,
        vn = vn >> 8,
        an[Gt++] = vn;
        let Tn = Number(Kt >> BigInt(32) & BigInt(4294967295));
        return an[Gt++] = Tn,
        Tn = Tn >> 8,
        an[Gt++] = Tn,
        Tn = Tn >> 8,
        an[Gt++] = Tn,
        Tn = Tn >> 8,
        an[Gt++] = Tn,
        Gt
    }
    function kn(an, Kt, Gt, fn, En) {
        Mn(Kt, fn, En, an, Gt, 7);
        let vn = Number(Kt & BigInt(4294967295));
        an[Gt + 7] = vn,
        vn = vn >> 8,
        an[Gt + 6] = vn,
        vn = vn >> 8,
        an[Gt + 5] = vn,
        vn = vn >> 8,
        an[Gt + 4] = vn;
        let Tn = Number(Kt >> BigInt(32) & BigInt(4294967295));
        return an[Gt + 3] = Tn,
        Tn = Tn >> 8,
        an[Gt + 2] = Tn,
        Tn = Tn >> 8,
        an[Gt + 1] = Tn,
        Tn = Tn >> 8,
        an[Gt] = Tn,
        Gt + 8
    }
    ct.prototype.writeBigUInt64LE = Cr(function(Kt, Gt=0) {
        return _n(this, Kt, Gt, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    ct.prototype.writeBigUInt64BE = Cr(function(Kt, Gt=0) {
        return kn(this, Kt, Gt, BigInt(0), BigInt("0xffffffffffffffff"))
    }),
    ct.prototype.writeIntLE = function(Kt, Gt, fn, En) {
        if (Kt = +Kt,
        Gt = Gt >>> 0,
        !En) {
            const lr = Math.pow(2, 8 * fn - 1);
            hn(this, Kt, Gt, fn, lr - 1, -lr)
        }
        let vn = 0
          , Tn = 1
          , sr = 0;
        for (this[Gt] = Kt & 255; ++vn < fn && (Tn *= 256); )
            Kt < 0 && sr === 0 && this[Gt + vn - 1] !== 0 && (sr = 1),
            this[Gt + vn] = (Kt / Tn >> 0) - sr & 255;
        return Gt + fn
    }
    ,
    ct.prototype.writeIntBE = function(Kt, Gt, fn, En) {
        if (Kt = +Kt,
        Gt = Gt >>> 0,
        !En) {
            const lr = Math.pow(2, 8 * fn - 1);
            hn(this, Kt, Gt, fn, lr - 1, -lr)
        }
        let vn = fn - 1
          , Tn = 1
          , sr = 0;
        for (this[Gt + vn] = Kt & 255; --vn >= 0 && (Tn *= 256); )
            Kt < 0 && sr === 0 && this[Gt + vn + 1] !== 0 && (sr = 1),
            this[Gt + vn] = (Kt / Tn >> 0) - sr & 255;
        return Gt + fn
    }
    ,
    ct.prototype.writeInt8 = function(Kt, Gt, fn) {
        return Kt = +Kt,
        Gt = Gt >>> 0,
        fn || hn(this, Kt, Gt, 1, 127, -128),
        Kt < 0 && (Kt = 255 + Kt + 1),
        this[Gt] = Kt & 255,
        Gt + 1
    }
    ,
    ct.prototype.writeInt16LE = function(Kt, Gt, fn) {
        return Kt = +Kt,
        Gt = Gt >>> 0,
        fn || hn(this, Kt, Gt, 2, 32767, -32768),
        this[Gt] = Kt & 255,
        this[Gt + 1] = Kt >>> 8,
        Gt + 2
    }
    ,
    ct.prototype.writeInt16BE = function(Kt, Gt, fn) {
        return Kt = +Kt,
        Gt = Gt >>> 0,
        fn || hn(this, Kt, Gt, 2, 32767, -32768),
        this[Gt] = Kt >>> 8,
        this[Gt + 1] = Kt & 255,
        Gt + 2
    }
    ,
    ct.prototype.writeInt32LE = function(Kt, Gt, fn) {
        return Kt = +Kt,
        Gt = Gt >>> 0,
        fn || hn(this, Kt, Gt, 4, 2147483647, -2147483648),
        this[Gt] = Kt & 255,
        this[Gt + 1] = Kt >>> 8,
        this[Gt + 2] = Kt >>> 16,
        this[Gt + 3] = Kt >>> 24,
        Gt + 4
    }
    ,
    ct.prototype.writeInt32BE = function(Kt, Gt, fn) {
        return Kt = +Kt,
        Gt = Gt >>> 0,
        fn || hn(this, Kt, Gt, 4, 2147483647, -2147483648),
        Kt < 0 && (Kt = 4294967295 + Kt + 1),
        this[Gt] = Kt >>> 24,
        this[Gt + 1] = Kt >>> 16,
        this[Gt + 2] = Kt >>> 8,
        this[Gt + 3] = Kt & 255,
        Gt + 4
    }
    ,
    ct.prototype.writeBigInt64LE = Cr(function(Kt, Gt=0) {
        return _n(this, Kt, Gt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    }),
    ct.prototype.writeBigInt64BE = Cr(function(Kt, Gt=0) {
        return kn(this, Kt, Gt, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"))
    });
    function Dn(an, Kt, Gt, fn, En, vn) {
        if (Gt + fn > an.length)
            throw new RangeError("Index out of range");
        if (Gt < 0)
            throw new RangeError("Index out of range")
    }
    function jn(an, Kt, Gt, fn, En) {
        return Kt = +Kt,
        Gt = Gt >>> 0,
        En || Dn(an, Kt, Gt, 4),
        et.write(an, Kt, Gt, fn, 23, 4),
        Gt + 4
    }
    ct.prototype.writeFloatLE = function(Kt, Gt, fn) {
        return jn(this, Kt, Gt, !0, fn)
    }
    ,
    ct.prototype.writeFloatBE = function(Kt, Gt, fn) {
        return jn(this, Kt, Gt, !1, fn)
    }
    ;
    function Bn(an, Kt, Gt, fn, En) {
        return Kt = +Kt,
        Gt = Gt >>> 0,
        En || Dn(an, Kt, Gt, 8),
        et.write(an, Kt, Gt, fn, 52, 8),
        Gt + 8
    }
    ct.prototype.writeDoubleLE = function(Kt, Gt, fn) {
        return Bn(this, Kt, Gt, !0, fn)
    }
    ,
    ct.prototype.writeDoubleBE = function(Kt, Gt, fn) {
        return Bn(this, Kt, Gt, !1, fn)
    }
    ,
    ct.prototype.copy = function(Kt, Gt, fn, En) {
        if (!ct.isBuffer(Kt))
            throw new TypeError("argument should be a Buffer");
        if (fn || (fn = 0),
        !En && En !== 0 && (En = this.length),
        Gt >= Kt.length && (Gt = Kt.length),
        Gt || (Gt = 0),
        En > 0 && En < fn && (En = fn),
        En === fn || Kt.length === 0 || this.length === 0)
            return 0;
        if (Gt < 0)
            throw new RangeError("targetStart out of bounds");
        if (fn < 0 || fn >= this.length)
            throw new RangeError("Index out of range");
        if (En < 0)
            throw new RangeError("sourceEnd out of bounds");
        En > this.length && (En = this.length),
        Kt.length - Gt < En - fn && (En = Kt.length - Gt + fn);
        const vn = En - fn;
        return this === Kt && typeof rt.prototype.copyWithin == "function" ? this.copyWithin(Gt, fn, En) : rt.prototype.set.call(Kt, this.subarray(fn, En), Gt),
        vn
    }
    ,
    ct.prototype.fill = function(Kt, Gt, fn, En) {
        if (typeof Kt == "string") {
            if (typeof Gt == "string" ? (En = Gt,
            Gt = 0,
            fn = this.length) : typeof fn == "string" && (En = fn,
            fn = this.length),
            En !== void 0 && typeof En != "string")
                throw new TypeError("encoding must be a string");
            if (typeof En == "string" && !ct.isEncoding(En))
                throw new TypeError("Unknown encoding: " + En);
            if (Kt.length === 1) {
                const Tn = Kt.charCodeAt(0);
                (En === "utf8" && Tn < 128 || En === "latin1") && (Kt = Tn)
            }
        } else
            typeof Kt == "number" ? Kt = Kt & 255 : typeof Kt == "boolean" && (Kt = Number(Kt));
        if (Gt < 0 || this.length < Gt || this.length < fn)
            throw new RangeError("Out of range index");
        if (fn <= Gt)
            return this;
        Gt = Gt >>> 0,
        fn = fn === void 0 ? this.length : fn >>> 0,
        Kt || (Kt = 0);
        let vn;
        if (typeof Kt == "number")
            for (vn = Gt; vn < fn; ++vn)
                this[vn] = Kt;
        else {
            const Tn = ct.isBuffer(Kt) ? Kt : ct.from(Kt, En)
              , sr = Tn.length;
            if (sr === 0)
                throw new TypeError('The value "' + Kt + '" is invalid for argument "value"');
            for (vn = 0; vn < fn - Gt; ++vn)
                this[vn + Gt] = Tn[vn % sr]
        }
        return this
    }
    ;
    const Un = {};
    function Hn(an, Kt, Gt) {
        Un[an] = class extends Gt {
            constructor() {
                super(),
                Object.defineProperty(this, "message", {
                    value: Kt.apply(this, arguments),
                    writable: !0,
                    configurable: !0
                }),
                this.name = `${this.name} [${an}]`,
                this.stack,
                delete this.name
            }
            get code() {
                return an
            }
            set code(En) {
                Object.defineProperty(this, "code", {
                    configurable: !0,
                    enumerable: !0,
                    value: En,
                    writable: !0
                })
            }
            toString() {
                return `${this.name} [${an}]: ${this.message}`
            }
        }
    }
    Hn("ERR_BUFFER_OUT_OF_BOUNDS", function(an) {
        return an ? `${an} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds"
    }, RangeError),
    Hn("ERR_INVALID_ARG_TYPE", function(an, Kt) {
        return `The "${an}" argument must be of type number. Received type ${typeof Kt}`
    }, TypeError),
    Hn("ERR_OUT_OF_RANGE", function(an, Kt, Gt) {
        let fn = `The value of "${an}" is out of range.`
          , En = Gt;
        return Number.isInteger(Gt) && Math.abs(Gt) > 2 ** 32 ? En = cr(String(Gt)) : typeof Gt == "bigint" && (En = String(Gt),
        (Gt > BigInt(2) ** BigInt(32) || Gt < -(BigInt(2) ** BigInt(32))) && (En = cr(En)),
        En += "n"),
        fn += ` It must be ${Kt}. Received ${En}`,
        fn
    }, RangeError);
    function cr(an) {
        let Kt = ""
          , Gt = an.length;
        const fn = an[0] === "-" ? 1 : 0;
        for (; Gt >= fn + 4; Gt -= 3)
            Kt = `_${an.slice(Gt - 3, Gt)}${Kt}`;
        return `${an.slice(0, Gt)}${Kt}`
    }
    function Gn(an, Kt, Gt) {
        rr(Kt, "offset"),
        (an[Kt] === void 0 || an[Kt + Gt] === void 0) && Zn(Kt, an.length - (Gt + 1))
    }
    function Mn(an, Kt, Gt, fn, En, vn) {
        if (an > Gt || an < Kt) {
            const Tn = typeof Kt == "bigint" ? "n" : "";
            let sr;
            throw Kt === 0 || Kt === BigInt(0) ? sr = `>= 0${Tn} and < 2${Tn} ** ${(vn + 1) * 8}${Tn}` : sr = `>= -(2${Tn} ** ${(vn + 1) * 8 - 1}${Tn}) and < 2 ** ${(vn + 1) * 8 - 1}${Tn}`,
            new Un.ERR_OUT_OF_RANGE("value",sr,an)
        }
        Gn(fn, En, vn)
    }
    function rr(an, Kt) {
        if (typeof an != "number")
            throw new Un.ERR_INVALID_ARG_TYPE(Kt,"number",an)
    }
    function Zn(an, Kt, Gt) {
        throw Math.floor(an) !== an ? (rr(an, Gt),
        new Un.ERR_OUT_OF_RANGE("offset","an integer",an)) : Kt < 0 ? new Un.ERR_BUFFER_OUT_OF_BOUNDS : new Un.ERR_OUT_OF_RANGE("offset",`>= 0 and <= ${Kt}`,an)
    }
    const pr = /[^+/0-9A-Za-z-_]/g;
    function Ur(an) {
        if (an = an.split("=")[0],
        an = an.trim().replace(pr, ""),
        an.length < 2)
            return "";
        for (; an.length % 4 !== 0; )
            an = an + "=";
        return an
    }
    function xr(an, Kt) {
        Kt = Kt || 1 / 0;
        let Gt;
        const fn = an.length;
        let En = null;
        const vn = [];
        for (let Tn = 0; Tn < fn; ++Tn) {
            if (Gt = an.charCodeAt(Tn),
            Gt > 55295 && Gt < 57344) {
                if (!En) {
                    if (Gt > 56319) {
                        (Kt -= 3) > -1 && vn.push(239, 191, 189);
                        continue
                    } else if (Tn + 1 === fn) {
                        (Kt -= 3) > -1 && vn.push(239, 191, 189);
                        continue
                    }
                    En = Gt;
                    continue
                }
                if (Gt < 56320) {
                    (Kt -= 3) > -1 && vn.push(239, 191, 189),
                    En = Gt;
                    continue
                }
                Gt = (En - 55296 << 10 | Gt - 56320) + 65536
            } else
                En && (Kt -= 3) > -1 && vn.push(239, 191, 189);
            if (En = null,
            Gt < 128) {
                if ((Kt -= 1) < 0)
                    break;
                vn.push(Gt)
            } else if (Gt < 2048) {
                if ((Kt -= 2) < 0)
                    break;
                vn.push(Gt >> 6 | 192, Gt & 63 | 128)
            } else if (Gt < 65536) {
                if ((Kt -= 3) < 0)
                    break;
                vn.push(Gt >> 12 | 224, Gt >> 6 & 63 | 128, Gt & 63 | 128)
            } else if (Gt < 1114112) {
                if ((Kt -= 4) < 0)
                    break;
                vn.push(Gt >> 18 | 240, Gt >> 12 & 63 | 128, Gt >> 6 & 63 | 128, Gt & 63 | 128)
            } else
                throw new Error("Invalid code point")
        }
        return vn
    }
    function wr(an) {
        const Kt = [];
        for (let Gt = 0; Gt < an.length; ++Gt)
            Kt.push(an.charCodeAt(Gt) & 255);
        return Kt
    }
    function Rn(an, Kt) {
        let Gt, fn, En;
        const vn = [];
        for (let Tn = 0; Tn < an.length && !((Kt -= 2) < 0); ++Tn)
            Gt = an.charCodeAt(Tn),
            fn = Gt >> 8,
            En = Gt % 256,
            vn.push(En),
            vn.push(fn);
        return vn
    }
    function Vn(an) {
        return $.toByteArray(Ur(an))
    }
    function qn(an, Kt, Gt, fn) {
        let En;
        for (En = 0; En < fn && !(En + Gt >= Kt.length || En >= an.length); ++En)
            Kt[En + Gt] = an[En];
        return En
    }
    function dr(an, Kt) {
        return an instanceof Kt || an != null && an.constructor != null && an.constructor.name != null && an.constructor.name === Kt.name
    }
    function or(an) {
        return an !== an
    }
    const ir = function() {
        const an = "0123456789abcdef"
          , Kt = new Array(256);
        for (let Gt = 0; Gt < 16; ++Gt) {
            const fn = Gt * 16;
            for (let En = 0; En < 16; ++En)
                Kt[fn + En] = an[Gt] + an[En]
        }
        return Kt
    }();
    function Cr(an) {
        return typeof BigInt > "u" ? br : an
    }
    function br() {
        throw new Error("BigInt not supported")
    }
}
)(buffer);
const Buffer$2 = buffer.Buffer
  , Blob$4 = buffer.Blob
  , BlobOptions = buffer.BlobOptions
  , Buffer$1$1 = buffer.Buffer
  , File = buffer.File
  , FileOptions = buffer.FileOptions
  , INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES
  , SlowBuffer = buffer.SlowBuffer
  , TranscodeEncoding = buffer.TranscodeEncoding
  , atob = buffer.atob
  , btoa$1 = buffer.btoa
  , constants$1 = buffer.constants
  , isAscii = buffer.isAscii
  , isUtf8 = buffer.isUtf8
  , kMaxLength = buffer.kMaxLength
  , kStringMaxLength = buffer.kStringMaxLength
  , resolveObjectURL = buffer.resolveObjectURL
  , transcode = buffer.transcode
  , dist$5 = Object.freeze(Object.defineProperty({
    __proto__: null,
    Blob: Blob$4,
    BlobOptions,
    Buffer: Buffer$1$1,
    File,
    FileOptions,
    INSPECT_MAX_BYTES,
    SlowBuffer,
    TranscodeEncoding,
    atob,
    btoa: btoa$1,
    constants: constants$1,
    default: Buffer$2,
    isAscii,
    isUtf8,
    kMaxLength,
    kStringMaxLength,
    resolveObjectURL,
    transcode
}, Symbol.toStringTag, {
    value: "Module"
}));
function anumber(_e) {
    if (!Number.isSafeInteger(_e) || _e < 0)
        throw new Error("positive integer expected, got " + _e)
}
function isBytes$1(_e) {
    return _e instanceof Uint8Array || ArrayBuffer.isView(_e) && _e.constructor.name === "Uint8Array"
}
function abytes$1(_e, ...$) {
    if (!isBytes$1(_e))
        throw new Error("Uint8Array expected");
    if ($.length > 0 && !$.includes(_e.length))
        throw new Error("Uint8Array expected of length " + $ + ", got length=" + _e.length)
}
function ahash(_e) {
    if (typeof _e != "function" || typeof _e.create != "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
    anumber(_e.outputLen),
    anumber(_e.blockLen)
}
function aexists(_e, $=!0) {
    if (_e.destroyed)
        throw new Error("Hash instance has been destroyed");
    if ($ && _e.finished)
        throw new Error("Hash#digest() has already been called")
}
function aoutput(_e, $) {
    abytes$1(_e);
    const et = $.outputLen;
    if (_e.length < et)
        throw new Error("digestInto() expects output buffer of length at least " + et)
}
const crypto$1 = typeof globalThis == "object" && "crypto"in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function u32$2(_e) {
    return new Uint32Array(_e.buffer,_e.byteOffset,Math.floor(_e.byteLength / 4))
}
function createView(_e) {
    return new DataView(_e.buffer,_e.byteOffset,_e.byteLength)
}
function rotr(_e, $) {
    return _e << 32 - $ | _e >>> $
}
const isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function byteSwap(_e) {
    return _e << 24 & 4278190080 | _e << 8 & 16711680 | _e >>> 8 & 65280 | _e >>> 24 & 255
}
function byteSwap32(_e) {
    for (let $ = 0; $ < _e.length; $++)
        _e[$] = byteSwap(_e[$])
}
function utf8ToBytes$1(_e) {
    if (typeof _e != "string")
        throw new Error("utf8ToBytes expected string, got " + typeof _e);
    return new Uint8Array(new TextEncoder().encode(_e))
}
function toBytes(_e) {
    return typeof _e == "string" && (_e = utf8ToBytes$1(_e)),
    abytes$1(_e),
    _e
}
function concatBytes$1(..._e) {
    let $ = 0;
    for (let tt = 0; tt < _e.length; tt++) {
        const nt = _e[tt];
        abytes$1(nt),
        $ += nt.length
    }
    const et = new Uint8Array($);
    for (let tt = 0, nt = 0; tt < _e.length; tt++) {
        const rt = _e[tt];
        et.set(rt, nt),
        nt += rt.length
    }
    return et
}
let Hash$3 = class {
    clone() {
        return this._cloneInto()
    }
}
;
function wrapConstructor(_e) {
    const $ = tt => _e().update(toBytes(tt)).digest()
      , et = _e();
    return $.outputLen = et.outputLen,
    $.blockLen = et.blockLen,
    $.create = () => _e(),
    $
}
function randomBytes(_e=32) {
    if (crypto$1 && typeof crypto$1.getRandomValues == "function")
        return crypto$1.getRandomValues(new Uint8Array(_e));
    if (crypto$1 && typeof crypto$1.randomBytes == "function")
        return crypto$1.randomBytes(_e);
    throw new Error("crypto.getRandomValues must be defined")
}
function setBigUint64(_e, $, et, tt) {
    if (typeof _e.setBigUint64 == "function")
        return _e.setBigUint64($, et, tt);
    const nt = BigInt(32)
      , rt = BigInt(4294967295)
      , it = Number(et >> nt & rt)
      , ot = Number(et & rt)
      , st = tt ? 4 : 0
      , lt = tt ? 0 : 4;
    _e.setUint32($ + st, it, tt),
    _e.setUint32($ + lt, ot, tt)
}
function Chi(_e, $, et) {
    return _e & $ ^ ~_e & et
}
function Maj(_e, $, et) {
    return _e & $ ^ _e & et ^ $ & et
}
class HashMD extends Hash$3 {
    constructor($, et, tt, nt) {
        super(),
        this.blockLen = $,
        this.outputLen = et,
        this.padOffset = tt,
        this.isLE = nt,
        this.finished = !1,
        this.length = 0,
        this.pos = 0,
        this.destroyed = !1,
        this.buffer = new Uint8Array($),
        this.view = createView(this.buffer)
    }
    update($) {
        aexists(this);
        const {view: et, buffer: tt, blockLen: nt} = this;
        $ = toBytes($);
        const rt = $.length;
        for (let it = 0; it < rt; ) {
            const ot = Math.min(nt - this.pos, rt - it);
            if (ot === nt) {
                const st = createView($);
                for (; nt <= rt - it; it += nt)
                    this.process(st, it);
                continue
            }
            tt.set($.subarray(it, it + ot), this.pos),
            this.pos += ot,
            it += ot,
            this.pos === nt && (this.process(et, 0),
            this.pos = 0)
        }
        return this.length += $.length,
        this.roundClean(),
        this
    }
    digestInto($) {
        aexists(this),
        aoutput($, this),
        this.finished = !0;
        const {buffer: et, view: tt, blockLen: nt, isLE: rt} = this;
        let {pos: it} = this;
        et[it++] = 128,
        this.buffer.subarray(it).fill(0),
        this.padOffset > nt - it && (this.process(tt, 0),
        it = 0);
        for (let dt = it; dt < nt; dt++)
            et[dt] = 0;
        setBigUint64(tt, nt - 8, BigInt(this.length * 8), rt),
        this.process(tt, 0);
        const ot = createView($)
          , st = this.outputLen;
        if (st % 4)
            throw new Error("_sha2: outputLen should be aligned to 32bit");
        const lt = st / 4
          , ct = this.get();
        if (lt > ct.length)
            throw new Error("_sha2: outputLen bigger than state");
        for (let dt = 0; dt < lt; dt++)
            ot.setUint32(4 * dt, ct[dt], rt)
    }
    digest() {
        const {buffer: $, outputLen: et} = this;
        this.digestInto($);
        const tt = $.slice(0, et);
        return this.destroy(),
        tt
    }
    _cloneInto($) {
        $ || ($ = new this.constructor),
        $.set(...this.get());
        const {blockLen: et, buffer: tt, length: nt, finished: rt, destroyed: it, pos: ot} = this;
        return $.length = nt,
        $.pos = ot,
        $.finished = rt,
        $.destroyed = it,
        nt % et && $.buffer.set(tt),
        $
    }
}
const U32_MASK64 = BigInt(2 ** 32 - 1)
  , _32n = BigInt(32);
function fromBig(_e, $=!1) {
    return $ ? {
        h: Number(_e & U32_MASK64),
        l: Number(_e >> _32n & U32_MASK64)
    } : {
        h: Number(_e >> _32n & U32_MASK64) | 0,
        l: Number(_e & U32_MASK64) | 0
    }
}
function split$1(_e, $=!1) {
    let et = new Uint32Array(_e.length)
      , tt = new Uint32Array(_e.length);
    for (let nt = 0; nt < _e.length; nt++) {
        const {h: rt, l: it} = fromBig(_e[nt], $);
        [et[nt],tt[nt]] = [rt, it]
    }
    return [et, tt]
}
const toBig = (_e, $) => BigInt(_e >>> 0) << _32n | BigInt($ >>> 0)
  , shrSH = (_e, $, et) => _e >>> et
  , shrSL = (_e, $, et) => _e << 32 - et | $ >>> et
  , rotrSH = (_e, $, et) => _e >>> et | $ << 32 - et
  , rotrSL = (_e, $, et) => _e << 32 - et | $ >>> et
  , rotrBH = (_e, $, et) => _e << 64 - et | $ >>> et - 32
  , rotrBL = (_e, $, et) => _e >>> et - 32 | $ << 64 - et
  , rotr32H = (_e, $) => $
  , rotr32L = (_e, $) => _e
  , rotlSH = (_e, $, et) => _e << et | $ >>> 32 - et
  , rotlSL = (_e, $, et) => $ << et | _e >>> 32 - et
  , rotlBH = (_e, $, et) => $ << et - 32 | _e >>> 64 - et
  , rotlBL = (_e, $, et) => _e << et - 32 | $ >>> 64 - et;
function add$1(_e, $, et, tt) {
    const nt = ($ >>> 0) + (tt >>> 0);
    return {
        h: _e + et + (nt / 2 ** 32 | 0) | 0,
        l: nt | 0
    }
}
const add3L = (_e, $, et) => (_e >>> 0) + ($ >>> 0) + (et >>> 0)
  , add3H = (_e, $, et, tt) => $ + et + tt + (_e / 2 ** 32 | 0) | 0
  , add4L = (_e, $, et, tt) => (_e >>> 0) + ($ >>> 0) + (et >>> 0) + (tt >>> 0)
  , add4H = (_e, $, et, tt, nt) => $ + et + tt + nt + (_e / 2 ** 32 | 0) | 0
  , add5L = (_e, $, et, tt, nt) => (_e >>> 0) + ($ >>> 0) + (et >>> 0) + (tt >>> 0) + (nt >>> 0)
  , add5H = (_e, $, et, tt, nt, rt) => $ + et + tt + nt + rt + (_e / 2 ** 32 | 0) | 0
  , u64$3 = {
    fromBig,
    split: split$1,
    toBig,
    shrSH,
    shrSL,
    rotrSH,
    rotrSL,
    rotrBH,
    rotrBL,
    rotr32H,
    rotr32L,
    rotlSH,
    rotlSL,
    rotlBH,
    rotlBL,
    add: add$1,
    add3L,
    add3H,
    add4L,
    add4H,
    add5H,
    add5L
}
  , [SHA512_Kh,SHA512_Kl] = u64$3.split(["0x428a2f98d728ae22", "0x7137449123ef65cd", "0xb5c0fbcfec4d3b2f", "0xe9b5dba58189dbbc", "0x3956c25bf348b538", "0x59f111f1b605d019", "0x923f82a4af194f9b", "0xab1c5ed5da6d8118", "0xd807aa98a3030242", "0x12835b0145706fbe", "0x243185be4ee4b28c", "0x550c7dc3d5ffb4e2", "0x72be5d74f27b896f", "0x80deb1fe3b1696b1", "0x9bdc06a725c71235", "0xc19bf174cf692694", "0xe49b69c19ef14ad2", "0xefbe4786384f25e3", "0x0fc19dc68b8cd5b5", "0x240ca1cc77ac9c65", "0x2de92c6f592b0275", "0x4a7484aa6ea6e483", "0x5cb0a9dcbd41fbd4", "0x76f988da831153b5", "0x983e5152ee66dfab", "0xa831c66d2db43210", "0xb00327c898fb213f", "0xbf597fc7beef0ee4", "0xc6e00bf33da88fc2", "0xd5a79147930aa725", "0x06ca6351e003826f", "0x142929670a0e6e70", "0x27b70a8546d22ffc", "0x2e1b21385c26c926", "0x4d2c6dfc5ac42aed", "0x53380d139d95b3df", "0x650a73548baf63de", "0x766a0abb3c77b2a8", "0x81c2c92e47edaee6", "0x92722c851482353b", "0xa2bfe8a14cf10364", "0xa81a664bbc423001", "0xc24b8b70d0f89791", "0xc76c51a30654be30", "0xd192e819d6ef5218", "0xd69906245565a910", "0xf40e35855771202a", "0x106aa07032bbd1b8", "0x19a4c116b8d2d0c8", "0x1e376c085141ab53", "0x2748774cdf8eeb99", "0x34b0bcb5e19b48a8", "0x391c0cb3c5c95a63", "0x4ed8aa4ae3418acb", "0x5b9cca4f7763e373", "0x682e6ff3d6b2b8a3", "0x748f82ee5defb2fc", "0x78a5636f43172f60", "0x84c87814a1f0ab72", "0x8cc702081a6439ec", "0x90befffa23631e28", "0xa4506cebde82bde9", "0xbef9a3f7b2c67915", "0xc67178f2e372532b", "0xca273eceea26619c", "0xd186b8c721c0c207", "0xeada7dd6cde0eb1e", "0xf57d4f7fee6ed178", "0x06f067aa72176fba", "0x0a637dc5a2c898a6", "0x113f9804bef90dae", "0x1b710b35131c471b", "0x28db77f523047d84", "0x32caab7b40c72493", "0x3c9ebe0a15c9bebc", "0x431d67c49c100d4c", "0x4cc5d4becb3e42b6", "0x597f299cfc657e2a", "0x5fcb6fab3ad6faec", "0x6c44198c4a475817"].map(_e => BigInt(_e)))
  , SHA512_W_H = new Uint32Array(80)
  , SHA512_W_L = new Uint32Array(80);
class SHA512 extends HashMD {
    constructor() {
        super(128, 64, 16, !1),
        this.Ah = 1779033703,
        this.Al = -205731576,
        this.Bh = -1150833019,
        this.Bl = -2067093701,
        this.Ch = 1013904242,
        this.Cl = -23791573,
        this.Dh = -1521486534,
        this.Dl = 1595750129,
        this.Eh = 1359893119,
        this.El = -1377402159,
        this.Fh = -1694144372,
        this.Fl = 725511199,
        this.Gh = 528734635,
        this.Gl = -79577749,
        this.Hh = 1541459225,
        this.Hl = 327033209
    }
    get() {
        const {Ah: $, Al: et, Bh: tt, Bl: nt, Ch: rt, Cl: it, Dh: ot, Dl: st, Eh: lt, El: ct, Fh: dt, Fl: pt, Gh: ht, Gl: mt, Hh: yt, Hl: Et} = this;
        return [$, et, tt, nt, rt, it, ot, st, lt, ct, dt, pt, ht, mt, yt, Et]
    }
    set($, et, tt, nt, rt, it, ot, st, lt, ct, dt, pt, ht, mt, yt, Et) {
        this.Ah = $ | 0,
        this.Al = et | 0,
        this.Bh = tt | 0,
        this.Bl = nt | 0,
        this.Ch = rt | 0,
        this.Cl = it | 0,
        this.Dh = ot | 0,
        this.Dl = st | 0,
        this.Eh = lt | 0,
        this.El = ct | 0,
        this.Fh = dt | 0,
        this.Fl = pt | 0,
        this.Gh = ht | 0,
        this.Gl = mt | 0,
        this.Hh = yt | 0,
        this.Hl = Et | 0
    }
    process($, et) {
        for (let St = 0; St < 16; St++,
        et += 4)
            SHA512_W_H[St] = $.getUint32(et),
            SHA512_W_L[St] = $.getUint32(et += 4);
        for (let St = 16; St < 80; St++) {
            const Ct = SHA512_W_H[St - 15] | 0
              , Nt = SHA512_W_L[St - 15] | 0
              , Lt = u64$3.rotrSH(Ct, Nt, 1) ^ u64$3.rotrSH(Ct, Nt, 8) ^ u64$3.shrSH(Ct, Nt, 7)
              , kt = u64$3.rotrSL(Ct, Nt, 1) ^ u64$3.rotrSL(Ct, Nt, 8) ^ u64$3.shrSL(Ct, Nt, 7)
              , Ut = SHA512_W_H[St - 2] | 0
              , Jt = SHA512_W_L[St - 2] | 0
              , Pt = u64$3.rotrSH(Ut, Jt, 19) ^ u64$3.rotrBH(Ut, Jt, 61) ^ u64$3.shrSH(Ut, Jt, 6)
              , Xt = u64$3.rotrSL(Ut, Jt, 19) ^ u64$3.rotrBL(Ut, Jt, 61) ^ u64$3.shrSL(Ut, Jt, 6)
              , rn = u64$3.add4L(kt, Xt, SHA512_W_L[St - 7], SHA512_W_L[St - 16])
              , zt = u64$3.add4H(rn, Lt, Pt, SHA512_W_H[St - 7], SHA512_W_H[St - 16]);
            SHA512_W_H[St] = zt | 0,
            SHA512_W_L[St] = rn | 0
        }
        let {Ah: tt, Al: nt, Bh: rt, Bl: it, Ch: ot, Cl: st, Dh: lt, Dl: ct, Eh: dt, El: pt, Fh: ht, Fl: mt, Gh: yt, Gl: Et, Hh: _t, Hl: wt} = this;
        for (let St = 0; St < 80; St++) {
            const Ct = u64$3.rotrSH(dt, pt, 14) ^ u64$3.rotrSH(dt, pt, 18) ^ u64$3.rotrBH(dt, pt, 41)
              , Nt = u64$3.rotrSL(dt, pt, 14) ^ u64$3.rotrSL(dt, pt, 18) ^ u64$3.rotrBL(dt, pt, 41)
              , Lt = dt & ht ^ ~dt & yt
              , kt = pt & mt ^ ~pt & Et
              , Ut = u64$3.add5L(wt, Nt, kt, SHA512_Kl[St], SHA512_W_L[St])
              , Jt = u64$3.add5H(Ut, _t, Ct, Lt, SHA512_Kh[St], SHA512_W_H[St])
              , Pt = Ut | 0
              , Xt = u64$3.rotrSH(tt, nt, 28) ^ u64$3.rotrBH(tt, nt, 34) ^ u64$3.rotrBH(tt, nt, 39)
              , rn = u64$3.rotrSL(tt, nt, 28) ^ u64$3.rotrBL(tt, nt, 34) ^ u64$3.rotrBL(tt, nt, 39)
              , zt = tt & rt ^ tt & ot ^ rt & ot
              , xt = nt & it ^ nt & st ^ it & st;
            _t = yt | 0,
            wt = Et | 0,
            yt = ht | 0,
            Et = mt | 0,
            ht = dt | 0,
            mt = pt | 0,
            {h: dt, l: pt} = u64$3.add(lt | 0, ct | 0, Jt | 0, Pt | 0),
            lt = ot | 0,
            ct = st | 0,
            ot = rt | 0,
            st = it | 0,
            rt = tt | 0,
            it = nt | 0;
            const $t = u64$3.add3L(Pt, rn, xt);
            tt = u64$3.add3H($t, Jt, Xt, zt),
            nt = $t | 0
        }
        ({h: tt, l: nt} = u64$3.add(this.Ah | 0, this.Al | 0, tt | 0, nt | 0)),
        {h: rt, l: it} = u64$3.add(this.Bh | 0, this.Bl | 0, rt | 0, it | 0),
        {h: ot, l: st} = u64$3.add(this.Ch | 0, this.Cl | 0, ot | 0, st | 0),
        {h: lt, l: ct} = u64$3.add(this.Dh | 0, this.Dl | 0, lt | 0, ct | 0),
        {h: dt, l: pt} = u64$3.add(this.Eh | 0, this.El | 0, dt | 0, pt | 0),
        {h: ht, l: mt} = u64$3.add(this.Fh | 0, this.Fl | 0, ht | 0, mt | 0),
        {h: yt, l: Et} = u64$3.add(this.Gh | 0, this.Gl | 0, yt | 0, Et | 0),
        {h: _t, l: wt} = u64$3.add(this.Hh | 0, this.Hl | 0, _t | 0, wt | 0),
        this.set(tt, nt, rt, it, ot, st, lt, ct, dt, pt, ht, mt, yt, Et, _t, wt)
    }
    roundClean() {
        SHA512_W_H.fill(0),
        SHA512_W_L.fill(0)
    }
    destroy() {
        this.buffer.fill(0),
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    }
}
const sha512 = wrapConstructor( () => new SHA512);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$5 = BigInt(0)
  , _1n$7 = BigInt(1)
  , _2n$5 = BigInt(2);
function isBytes(_e) {
    return _e instanceof Uint8Array || ArrayBuffer.isView(_e) && _e.constructor.name === "Uint8Array"
}
function abytes(_e) {
    if (!isBytes(_e))
        throw new Error("Uint8Array expected")
}
function abool(_e, $) {
    if (typeof $ != "boolean")
        throw new Error(_e + " boolean expected, got " + $)
}
const hexes = Array.from({
    length: 256
}, (_e, $) => $.toString(16).padStart(2, "0"));
function bytesToHex(_e) {
    abytes(_e);
    let $ = "";
    for (let et = 0; et < _e.length; et++)
        $ += hexes[_e[et]];
    return $
}
function numberToHexUnpadded(_e) {
    const $ = _e.toString(16);
    return $.length & 1 ? "0" + $ : $
}
function hexToNumber(_e) {
    if (typeof _e != "string")
        throw new Error("hex string expected, got " + typeof _e);
    return _e === "" ? _0n$5 : BigInt("0x" + _e)
}
const asciis = {
    _0: 48,
    _9: 57,
    A: 65,
    F: 70,
    a: 97,
    f: 102
};
function asciiToBase16(_e) {
    if (_e >= asciis._0 && _e <= asciis._9)
        return _e - asciis._0;
    if (_e >= asciis.A && _e <= asciis.F)
        return _e - (asciis.A - 10);
    if (_e >= asciis.a && _e <= asciis.f)
        return _e - (asciis.a - 10)
}
function hexToBytes(_e) {
    if (typeof _e != "string")
        throw new Error("hex string expected, got " + typeof _e);
    const $ = _e.length
      , et = $ / 2;
    if ($ % 2)
        throw new Error("hex string expected, got unpadded hex of length " + $);
    const tt = new Uint8Array(et);
    for (let nt = 0, rt = 0; nt < et; nt++,
    rt += 2) {
        const it = asciiToBase16(_e.charCodeAt(rt))
          , ot = asciiToBase16(_e.charCodeAt(rt + 1));
        if (it === void 0 || ot === void 0) {
            const st = _e[rt] + _e[rt + 1];
            throw new Error('hex string expected, got non-hex character "' + st + '" at index ' + rt)
        }
        tt[nt] = it * 16 + ot
    }
    return tt
}
function bytesToNumberBE(_e) {
    return hexToNumber(bytesToHex(_e))
}
function bytesToNumberLE(_e) {
    return abytes(_e),
    hexToNumber(bytesToHex(Uint8Array.from(_e).reverse()))
}
function numberToBytesBE(_e, $) {
    return hexToBytes(_e.toString(16).padStart($ * 2, "0"))
}
function numberToBytesLE(_e, $) {
    return numberToBytesBE(_e, $).reverse()
}
function numberToVarBytesBE(_e) {
    return hexToBytes(numberToHexUnpadded(_e))
}
function ensureBytes(_e, $, et) {
    let tt;
    if (typeof $ == "string")
        try {
            tt = hexToBytes($)
        } catch (rt) {
            throw new Error(_e + " must be hex string or Uint8Array, cause: " + rt)
        }
    else if (isBytes($))
        tt = Uint8Array.from($);
    else
        throw new Error(_e + " must be hex string or Uint8Array");
    const nt = tt.length;
    if (typeof et == "number" && nt !== et)
        throw new Error(_e + " of length " + et + " expected, got " + nt);
    return tt
}
function concatBytes(..._e) {
    let $ = 0;
    for (let tt = 0; tt < _e.length; tt++) {
        const nt = _e[tt];
        abytes(nt),
        $ += nt.length
    }
    const et = new Uint8Array($);
    for (let tt = 0, nt = 0; tt < _e.length; tt++) {
        const rt = _e[tt];
        et.set(rt, nt),
        nt += rt.length
    }
    return et
}
function equalBytes(_e, $) {
    if (_e.length !== $.length)
        return !1;
    let et = 0;
    for (let tt = 0; tt < _e.length; tt++)
        et |= _e[tt] ^ $[tt];
    return et === 0
}
function utf8ToBytes(_e) {
    if (typeof _e != "string")
        throw new Error("string expected");
    return new Uint8Array(new TextEncoder().encode(_e))
}
const isPosBig = _e => typeof _e == "bigint" && _0n$5 <= _e;
function inRange$1(_e, $, et) {
    return isPosBig(_e) && isPosBig($) && isPosBig(et) && $ <= _e && _e < et
}
function aInRange(_e, $, et, tt) {
    if (!inRange$1($, et, tt))
        throw new Error("expected valid " + _e + ": " + et + " <= n < " + tt + ", got " + $)
}
function bitLen(_e) {
    let $;
    for ($ = 0; _e > _0n$5; _e >>= _1n$7,
    $ += 1)
        ;
    return $
}
function bitGet(_e, $) {
    return _e >> BigInt($) & _1n$7
}
function bitSet(_e, $, et) {
    return _e | (et ? _1n$7 : _0n$5) << BigInt($)
}
const bitMask = _e => (_2n$5 << BigInt(_e - 1)) - _1n$7
  , u8n = _e => new Uint8Array(_e)
  , u8fr = _e => Uint8Array.from(_e);
function createHmacDrbg(_e, $, et) {
    if (typeof _e != "number" || _e < 2)
        throw new Error("hashLen must be a number");
    if (typeof $ != "number" || $ < 2)
        throw new Error("qByteLen must be a number");
    if (typeof et != "function")
        throw new Error("hmacFn must be a function");
    let tt = u8n(_e)
      , nt = u8n(_e)
      , rt = 0;
    const it = () => {
        tt.fill(1),
        nt.fill(0),
        rt = 0
    }
      , ot = (...dt) => et(nt, tt, ...dt)
      , st = (dt=u8n()) => {
        nt = ot(u8fr([0]), dt),
        tt = ot(),
        dt.length !== 0 && (nt = ot(u8fr([1]), dt),
        tt = ot())
    }
      , lt = () => {
        if (rt++ >= 1e3)
            throw new Error("drbg: tried 1000 values");
        let dt = 0;
        const pt = [];
        for (; dt < $; ) {
            tt = ot();
            const ht = tt.slice();
            pt.push(ht),
            dt += tt.length
        }
        return concatBytes(...pt)
    }
    ;
    return (dt, pt) => {
        it(),
        st(dt);
        let ht;
        for (; !(ht = pt(lt())); )
            st();
        return it(),
        ht
    }
}
const validatorFns = {
    bigint: _e => typeof _e == "bigint",
    function: _e => typeof _e == "function",
    boolean: _e => typeof _e == "boolean",
    string: _e => typeof _e == "string",
    stringOrUint8Array: _e => typeof _e == "string" || isBytes(_e),
    isSafeInteger: _e => Number.isSafeInteger(_e),
    array: _e => Array.isArray(_e),
    field: (_e, $) => $.Fp.isValid(_e),
    hash: _e => typeof _e == "function" && Number.isSafeInteger(_e.outputLen)
};
function validateObject(_e, $, et={}) {
    const tt = (nt, rt, it) => {
        const ot = validatorFns[rt];
        if (typeof ot != "function")
            throw new Error("invalid validator function");
        const st = _e[nt];
        if (!(it && st === void 0) && !ot(st, _e))
            throw new Error("param " + String(nt) + " is invalid. Expected " + rt + ", got " + st)
    }
    ;
    for (const [nt,rt] of Object.entries($))
        tt(nt, rt, !1);
    for (const [nt,rt] of Object.entries(et))
        tt(nt, rt, !0);
    return _e
}
const notImplemented = () => {
    throw new Error("not implemented")
}
;
function memoized(_e) {
    const $ = new WeakMap;
    return (et, ...tt) => {
        const nt = $.get(et);
        if (nt !== void 0)
            return nt;
        const rt = _e(et, ...tt);
        return $.set(et, rt),
        rt
    }
}
const ut = Object.freeze(Object.defineProperty({
    __proto__: null,
    aInRange,
    abool,
    abytes,
    bitGet,
    bitLen,
    bitMask,
    bitSet,
    bytesToHex,
    bytesToNumberBE,
    bytesToNumberLE,
    concatBytes,
    createHmacDrbg,
    ensureBytes,
    equalBytes,
    hexToBytes,
    hexToNumber,
    inRange: inRange$1,
    isBytes,
    memoized,
    notImplemented,
    numberToBytesBE,
    numberToBytesLE,
    numberToHexUnpadded,
    numberToVarBytesBE,
    utf8ToBytes,
    validateObject
}, Symbol.toStringTag, {
    value: "Module"
}));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$4 = BigInt(0)
  , _1n$6 = BigInt(1)
  , _2n$4 = BigInt(2)
  , _3n$1 = BigInt(3)
  , _4n = BigInt(4)
  , _5n$1 = BigInt(5)
  , _8n$2 = BigInt(8);
function mod$1(_e, $) {
    const et = _e % $;
    return et >= _0n$4 ? et : $ + et
}
function pow$2(_e, $, et) {
    if ($ < _0n$4)
        throw new Error("invalid exponent, negatives unsupported");
    if (et <= _0n$4)
        throw new Error("invalid modulus");
    if (et === _1n$6)
        return _0n$4;
    let tt = _1n$6;
    for (; $ > _0n$4; )
        $ & _1n$6 && (tt = tt * _e % et),
        _e = _e * _e % et,
        $ >>= _1n$6;
    return tt
}
function pow2(_e, $, et) {
    let tt = _e;
    for (; $-- > _0n$4; )
        tt *= tt,
        tt %= et;
    return tt
}
function invert(_e, $) {
    if (_e === _0n$4)
        throw new Error("invert: expected non-zero number");
    if ($ <= _0n$4)
        throw new Error("invert: expected positive modulus, got " + $);
    let et = mod$1(_e, $)
      , tt = $
      , nt = _0n$4
      , rt = _1n$6;
    for (; et !== _0n$4; ) {
        const ot = tt / et
          , st = tt % et
          , lt = nt - rt * ot;
        tt = et,
        et = st,
        nt = rt,
        rt = lt
    }
    if (tt !== _1n$6)
        throw new Error("invert: does not exist");
    return mod$1(nt, $)
}
function tonelliShanks(_e) {
    const $ = (_e - _1n$6) / _2n$4;
    let et, tt, nt;
    for (et = _e - _1n$6,
    tt = 0; et % _2n$4 === _0n$4; et /= _2n$4,
    tt++)
        ;
    for (nt = _2n$4; nt < _e && pow$2(nt, $, _e) !== _e - _1n$6; nt++)
        if (nt > 1e3)
            throw new Error("Cannot find square root: likely non-prime P");
    if (tt === 1) {
        const it = (_e + _1n$6) / _4n;
        return function(st, lt) {
            const ct = st.pow(lt, it);
            if (!st.eql(st.sqr(ct), lt))
                throw new Error("Cannot find square root");
            return ct
        }
    }
    const rt = (et + _1n$6) / _2n$4;
    return function(ot, st) {
        if (ot.pow(st, $) === ot.neg(ot.ONE))
            throw new Error("Cannot find square root");
        let lt = tt
          , ct = ot.pow(ot.mul(ot.ONE, nt), et)
          , dt = ot.pow(st, rt)
          , pt = ot.pow(st, et);
        for (; !ot.eql(pt, ot.ONE); ) {
            if (ot.eql(pt, ot.ZERO))
                return ot.ZERO;
            let ht = 1;
            for (let yt = ot.sqr(pt); ht < lt && !ot.eql(yt, ot.ONE); ht++)
                yt = ot.sqr(yt);
            const mt = ot.pow(ct, _1n$6 << BigInt(lt - ht - 1));
            ct = ot.sqr(mt),
            dt = ot.mul(dt, mt),
            pt = ot.mul(pt, ct),
            lt = ht
        }
        return dt
    }
}
function FpSqrt(_e) {
    if (_e % _4n === _3n$1) {
        const $ = (_e + _1n$6) / _4n;
        return function(tt, nt) {
            const rt = tt.pow(nt, $);
            if (!tt.eql(tt.sqr(rt), nt))
                throw new Error("Cannot find square root");
            return rt
        }
    }
    if (_e % _8n$2 === _5n$1) {
        const $ = (_e - _5n$1) / _8n$2;
        return function(tt, nt) {
            const rt = tt.mul(nt, _2n$4)
              , it = tt.pow(rt, $)
              , ot = tt.mul(nt, it)
              , st = tt.mul(tt.mul(ot, _2n$4), it)
              , lt = tt.mul(ot, tt.sub(st, tt.ONE));
            if (!tt.eql(tt.sqr(lt), nt))
                throw new Error("Cannot find square root");
            return lt
        }
    }
    return tonelliShanks(_e)
}
const isNegativeLE = (_e, $) => (mod$1(_e, $) & _1n$6) === _1n$6
  , FIELD_FIELDS = ["create", "isValid", "is0", "neg", "inv", "sqrt", "sqr", "eql", "add", "sub", "mul", "pow", "div", "addN", "subN", "mulN", "sqrN"];
function validateField(_e) {
    const $ = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
    }
      , et = FIELD_FIELDS.reduce( (tt, nt) => (tt[nt] = "function",
    tt), $);
    return validateObject(_e, et)
}
function FpPow(_e, $, et) {
    if (et < _0n$4)
        throw new Error("invalid exponent, negatives unsupported");
    if (et === _0n$4)
        return _e.ONE;
    if (et === _1n$6)
        return $;
    let tt = _e.ONE
      , nt = $;
    for (; et > _0n$4; )
        et & _1n$6 && (tt = _e.mul(tt, nt)),
        nt = _e.sqr(nt),
        et >>= _1n$6;
    return tt
}
function FpInvertBatch(_e, $) {
    const et = new Array($.length)
      , tt = $.reduce( (rt, it, ot) => _e.is0(it) ? rt : (et[ot] = rt,
    _e.mul(rt, it)), _e.ONE)
      , nt = _e.inv(tt);
    return $.reduceRight( (rt, it, ot) => _e.is0(it) ? rt : (et[ot] = _e.mul(rt, et[ot]),
    _e.mul(rt, it)), nt),
    et
}
function nLength(_e, $) {
    const et = $ !== void 0 ? $ : _e.toString(2).length
      , tt = Math.ceil(et / 8);
    return {
        nBitLength: et,
        nByteLength: tt
    }
}
function Field(_e, $, et=!1, tt={}) {
    if (_e <= _0n$4)
        throw new Error("invalid field: expected ORDER > 0, got " + _e);
    const {nBitLength: nt, nByteLength: rt} = nLength(_e, $);
    if (rt > 2048)
        throw new Error("invalid field: expected ORDER of <= 2048 bytes");
    let it;
    const ot = Object.freeze({
        ORDER: _e,
        isLE: et,
        BITS: nt,
        BYTES: rt,
        MASK: bitMask(nt),
        ZERO: _0n$4,
        ONE: _1n$6,
        create: st => mod$1(st, _e),
        isValid: st => {
            if (typeof st != "bigint")
                throw new Error("invalid field element: expected bigint, got " + typeof st);
            return _0n$4 <= st && st < _e
        }
        ,
        is0: st => st === _0n$4,
        isOdd: st => (st & _1n$6) === _1n$6,
        neg: st => mod$1(-st, _e),
        eql: (st, lt) => st === lt,
        sqr: st => mod$1(st * st, _e),
        add: (st, lt) => mod$1(st + lt, _e),
        sub: (st, lt) => mod$1(st - lt, _e),
        mul: (st, lt) => mod$1(st * lt, _e),
        pow: (st, lt) => FpPow(ot, st, lt),
        div: (st, lt) => mod$1(st * invert(lt, _e), _e),
        sqrN: st => st * st,
        addN: (st, lt) => st + lt,
        subN: (st, lt) => st - lt,
        mulN: (st, lt) => st * lt,
        inv: st => invert(st, _e),
        sqrt: tt.sqrt || (st => (it || (it = FpSqrt(_e)),
        it(ot, st))),
        invertBatch: st => FpInvertBatch(ot, st),
        cmov: (st, lt, ct) => ct ? lt : st,
        toBytes: st => et ? numberToBytesLE(st, rt) : numberToBytesBE(st, rt),
        fromBytes: st => {
            if (st.length !== rt)
                throw new Error("Field.fromBytes: expected " + rt + " bytes, got " + st.length);
            return et ? bytesToNumberLE(st) : bytesToNumberBE(st)
        }
    });
    return Object.freeze(ot)
}
function getFieldBytesLength(_e) {
    if (typeof _e != "bigint")
        throw new Error("field order must be bigint");
    const $ = _e.toString(2).length;
    return Math.ceil($ / 8)
}
function getMinHashLength(_e) {
    const $ = getFieldBytesLength(_e);
    return $ + Math.ceil($ / 2)
}
function mapHashToField(_e, $, et=!1) {
    const tt = _e.length
      , nt = getFieldBytesLength($)
      , rt = getMinHashLength($);
    if (tt < 16 || tt < rt || tt > 1024)
        throw new Error("expected " + rt + "-1024 bytes of input, got " + tt);
    const it = et ? bytesToNumberLE(_e) : bytesToNumberBE(_e)
      , ot = mod$1(it, $ - _1n$6) + _1n$6;
    return et ? numberToBytesLE(ot, nt) : numberToBytesBE(ot, nt)
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$3 = BigInt(0)
  , _1n$5 = BigInt(1);
function constTimeNegate(_e, $) {
    const et = $.negate();
    return _e ? et : $
}
function validateW(_e, $) {
    if (!Number.isSafeInteger(_e) || _e <= 0 || _e > $)
        throw new Error("invalid window size, expected [1.." + $ + "], got W=" + _e)
}
function calcWOpts(_e, $) {
    validateW(_e, $);
    const et = Math.ceil($ / _e) + 1
      , tt = 2 ** (_e - 1);
    return {
        windows: et,
        windowSize: tt
    }
}
function validateMSMPoints(_e, $) {
    if (!Array.isArray(_e))
        throw new Error("array expected");
    _e.forEach( (et, tt) => {
        if (!(et instanceof $))
            throw new Error("invalid point at index " + tt)
    }
    )
}
function validateMSMScalars(_e, $) {
    if (!Array.isArray(_e))
        throw new Error("array of scalars expected");
    _e.forEach( (et, tt) => {
        if (!$.isValid(et))
            throw new Error("invalid scalar at index " + tt)
    }
    )
}
const pointPrecomputes = new WeakMap
  , pointWindowSizes = new WeakMap;
function getW(_e) {
    return pointWindowSizes.get(_e) || 1
}
function wNAF(_e, $) {
    return {
        constTimeNegate,
        hasPrecomputes(et) {
            return getW(et) !== 1
        },
        unsafeLadder(et, tt, nt=_e.ZERO) {
            let rt = et;
            for (; tt > _0n$3; )
                tt & _1n$5 && (nt = nt.add(rt)),
                rt = rt.double(),
                tt >>= _1n$5;
            return nt
        },
        precomputeWindow(et, tt) {
            const {windows: nt, windowSize: rt} = calcWOpts(tt, $)
              , it = [];
            let ot = et
              , st = ot;
            for (let lt = 0; lt < nt; lt++) {
                st = ot,
                it.push(st);
                for (let ct = 1; ct < rt; ct++)
                    st = st.add(ot),
                    it.push(st);
                ot = st.double()
            }
            return it
        },
        wNAF(et, tt, nt) {
            const {windows: rt, windowSize: it} = calcWOpts(et, $);
            let ot = _e.ZERO
              , st = _e.BASE;
            const lt = BigInt(2 ** et - 1)
              , ct = 2 ** et
              , dt = BigInt(et);
            for (let pt = 0; pt < rt; pt++) {
                const ht = pt * it;
                let mt = Number(nt & lt);
                nt >>= dt,
                mt > it && (mt -= ct,
                nt += _1n$5);
                const yt = ht
                  , Et = ht + Math.abs(mt) - 1
                  , _t = pt % 2 !== 0
                  , wt = mt < 0;
                mt === 0 ? st = st.add(constTimeNegate(_t, tt[yt])) : ot = ot.add(constTimeNegate(wt, tt[Et]))
            }
            return {
                p: ot,
                f: st
            }
        },
        wNAFUnsafe(et, tt, nt, rt=_e.ZERO) {
            const {windows: it, windowSize: ot} = calcWOpts(et, $)
              , st = BigInt(2 ** et - 1)
              , lt = 2 ** et
              , ct = BigInt(et);
            for (let dt = 0; dt < it; dt++) {
                const pt = dt * ot;
                if (nt === _0n$3)
                    break;
                let ht = Number(nt & st);
                if (nt >>= ct,
                ht > ot && (ht -= lt,
                nt += _1n$5),
                ht === 0)
                    continue;
                let mt = tt[pt + Math.abs(ht) - 1];
                ht < 0 && (mt = mt.negate()),
                rt = rt.add(mt)
            }
            return rt
        },
        getPrecomputes(et, tt, nt) {
            let rt = pointPrecomputes.get(tt);
            return rt || (rt = this.precomputeWindow(tt, et),
            et !== 1 && pointPrecomputes.set(tt, nt(rt))),
            rt
        },
        wNAFCached(et, tt, nt) {
            const rt = getW(et);
            return this.wNAF(rt, this.getPrecomputes(rt, et, nt), tt)
        },
        wNAFCachedUnsafe(et, tt, nt, rt) {
            const it = getW(et);
            return it === 1 ? this.unsafeLadder(et, tt, rt) : this.wNAFUnsafe(it, this.getPrecomputes(it, et, nt), tt, rt)
        },
        setWindowSize(et, tt) {
            validateW(tt, $),
            pointWindowSizes.set(et, tt),
            pointPrecomputes.delete(et)
        }
    }
}
function pippenger(_e, $, et, tt) {
    if (validateMSMPoints(et, _e),
    validateMSMScalars(tt, $),
    et.length !== tt.length)
        throw new Error("arrays of points and scalars must have equal length");
    const nt = _e.ZERO
      , rt = bitLen(BigInt(et.length))
      , it = rt > 12 ? rt - 3 : rt > 4 ? rt - 2 : rt ? 2 : 1
      , ot = (1 << it) - 1
      , st = new Array(ot + 1).fill(nt)
      , lt = Math.floor(($.BITS - 1) / it) * it;
    let ct = nt;
    for (let dt = lt; dt >= 0; dt -= it) {
        st.fill(nt);
        for (let ht = 0; ht < tt.length; ht++) {
            const mt = tt[ht]
              , yt = Number(mt >> BigInt(dt) & BigInt(ot));
            st[yt] = st[yt].add(et[ht])
        }
        let pt = nt;
        for (let ht = st.length - 1, mt = nt; ht > 0; ht--)
            mt = mt.add(st[ht]),
            pt = pt.add(mt);
        if (ct = ct.add(pt),
        dt !== 0)
            for (let ht = 0; ht < it; ht++)
                ct = ct.double()
    }
    return ct
}
function validateBasic(_e) {
    return validateField(_e.Fp),
    validateObject(_e, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
    }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
    }),
    Object.freeze({
        ...nLength(_e.n, _e.nBitLength),
        ..._e,
        p: _e.Fp.ORDER
    })
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const _0n$2 = BigInt(0)
  , _1n$4 = BigInt(1)
  , _2n$3 = BigInt(2)
  , _8n$1 = BigInt(8)
  , VERIFY_DEFAULT = {
    zip215: !0
};
function validateOpts$1(_e) {
    const $ = validateBasic(_e);
    return validateObject(_e, {
        hash: "function",
        a: "bigint",
        d: "bigint",
        randomBytes: "function"
    }, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
    }),
    Object.freeze({
        ...$
    })
}
function twistedEdwards(_e) {
    const $ = validateOpts$1(_e)
      , {Fp: et, n: tt, prehash: nt, hash: rt, randomBytes: it, nByteLength: ot, h: st} = $
      , lt = _2n$3 << BigInt(ot * 8) - _1n$4
      , ct = et.create
      , dt = Field($.n, $.nBitLength)
      , pt = $.uvRatio || ( (Dt, jt) => {
        try {
            return {
                isValid: !0,
                value: et.sqrt(Dt * et.inv(jt))
            }
        } catch {
            return {
                isValid: !1,
                value: _0n$2
            }
        }
    }
    )
      , ht = $.adjustScalarBytes || (Dt => Dt)
      , mt = $.domain || ( (Dt, jt, Ft) => {
        if (abool("phflag", Ft),
        jt.length || Ft)
            throw new Error("Contexts/pre-hash are not supported");
        return Dt
    }
    );
    function yt(Dt, jt) {
        aInRange("coordinate " + Dt, jt, _0n$2, lt)
    }
    function Et(Dt) {
        if (!(Dt instanceof St))
            throw new Error("ExtendedPoint expected")
    }
    const _t = memoized( (Dt, jt) => {
        const {ex: Ft, ey: Ht, ez: qt} = Dt
          , Wt = Dt.is0();
        jt == null && (jt = Wt ? _8n$1 : et.inv(qt));
        const Mt = ct(Ft * jt)
          , Yt = ct(Ht * jt)
          , un = ct(qt * jt);
        if (Wt)
            return {
                x: _0n$2,
                y: _1n$4
            };
        if (un !== _1n$4)
            throw new Error("invZ was invalid");
        return {
            x: Mt,
            y: Yt
        }
    }
    )
      , wt = memoized(Dt => {
        const {a: jt, d: Ft} = $;
        if (Dt.is0())
            throw new Error("bad point: ZERO");
        const {ex: Ht, ey: qt, ez: Wt, et: Mt} = Dt
          , Yt = ct(Ht * Ht)
          , un = ct(qt * qt)
          , hn = ct(Wt * Wt)
          , _n = ct(hn * hn)
          , kn = ct(Yt * jt)
          , Dn = ct(hn * ct(kn + un))
          , jn = ct(_n + ct(Ft * ct(Yt * un)));
        if (Dn !== jn)
            throw new Error("bad point: equation left != right (1)");
        const Bn = ct(Ht * qt)
          , Un = ct(Wt * Mt);
        if (Bn !== Un)
            throw new Error("bad point: equation left != right (2)");
        return !0
    }
    );
    class St {
        constructor(jt, Ft, Ht, qt) {
            this.ex = jt,
            this.ey = Ft,
            this.ez = Ht,
            this.et = qt,
            yt("x", jt),
            yt("y", Ft),
            yt("z", Ht),
            yt("t", qt),
            Object.freeze(this)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static fromAffine(jt) {
            if (jt instanceof St)
                throw new Error("extended point not allowed");
            const {x: Ft, y: Ht} = jt || {};
            return yt("x", Ft),
            yt("y", Ht),
            new St(Ft,Ht,_1n$4,ct(Ft * Ht))
        }
        static normalizeZ(jt) {
            const Ft = et.invertBatch(jt.map(Ht => Ht.ez));
            return jt.map( (Ht, qt) => Ht.toAffine(Ft[qt])).map(St.fromAffine)
        }
        static msm(jt, Ft) {
            return pippenger(St, dt, jt, Ft)
        }
        _setWindowSize(jt) {
            Lt.setWindowSize(this, jt)
        }
        assertValidity() {
            wt(this)
        }
        equals(jt) {
            Et(jt);
            const {ex: Ft, ey: Ht, ez: qt} = this
              , {ex: Wt, ey: Mt, ez: Yt} = jt
              , un = ct(Ft * Yt)
              , hn = ct(Wt * qt)
              , _n = ct(Ht * Yt)
              , kn = ct(Mt * qt);
            return un === hn && _n === kn
        }
        is0() {
            return this.equals(St.ZERO)
        }
        negate() {
            return new St(ct(-this.ex),this.ey,this.ez,ct(-this.et))
        }
        double() {
            const {a: jt} = $
              , {ex: Ft, ey: Ht, ez: qt} = this
              , Wt = ct(Ft * Ft)
              , Mt = ct(Ht * Ht)
              , Yt = ct(_2n$3 * ct(qt * qt))
              , un = ct(jt * Wt)
              , hn = Ft + Ht
              , _n = ct(ct(hn * hn) - Wt - Mt)
              , kn = un + Mt
              , Dn = kn - Yt
              , jn = un - Mt
              , Bn = ct(_n * Dn)
              , Un = ct(kn * jn)
              , Hn = ct(_n * jn)
              , cr = ct(Dn * kn);
            return new St(Bn,Un,cr,Hn)
        }
        add(jt) {
            Et(jt);
            const {a: Ft, d: Ht} = $
              , {ex: qt, ey: Wt, ez: Mt, et: Yt} = this
              , {ex: un, ey: hn, ez: _n, et: kn} = jt;
            if (Ft === BigInt(-1)) {
                const xr = ct((Wt - qt) * (hn + un))
                  , wr = ct((Wt + qt) * (hn - un))
                  , Rn = ct(wr - xr);
                if (Rn === _0n$2)
                    return this.double();
                const Vn = ct(Mt * _2n$3 * kn)
                  , qn = ct(Yt * _2n$3 * _n)
                  , dr = qn + Vn
                  , or = wr + xr
                  , ir = qn - Vn
                  , Cr = ct(dr * Rn)
                  , br = ct(or * ir)
                  , an = ct(dr * ir)
                  , Kt = ct(Rn * or);
                return new St(Cr,br,Kt,an)
            }
            const Dn = ct(qt * un)
              , jn = ct(Wt * hn)
              , Bn = ct(Yt * Ht * kn)
              , Un = ct(Mt * _n)
              , Hn = ct((qt + Wt) * (un + hn) - Dn - jn)
              , cr = Un - Bn
              , Gn = Un + Bn
              , Mn = ct(jn - Ft * Dn)
              , rr = ct(Hn * cr)
              , Zn = ct(Gn * Mn)
              , pr = ct(Hn * Mn)
              , Ur = ct(cr * Gn);
            return new St(rr,Zn,Ur,pr)
        }
        subtract(jt) {
            return this.add(jt.negate())
        }
        wNAF(jt) {
            return Lt.wNAFCached(this, jt, St.normalizeZ)
        }
        multiply(jt) {
            const Ft = jt;
            aInRange("scalar", Ft, _1n$4, tt);
            const {p: Ht, f: qt} = this.wNAF(Ft);
            return St.normalizeZ([Ht, qt])[0]
        }
        multiplyUnsafe(jt, Ft=St.ZERO) {
            const Ht = jt;
            return aInRange("scalar", Ht, _0n$2, tt),
            Ht === _0n$2 ? Nt : this.is0() || Ht === _1n$4 ? this : Lt.wNAFCachedUnsafe(this, Ht, St.normalizeZ, Ft)
        }
        isSmallOrder() {
            return this.multiplyUnsafe(st).is0()
        }
        isTorsionFree() {
            return Lt.unsafeLadder(this, tt).is0()
        }
        toAffine(jt) {
            return _t(this, jt)
        }
        clearCofactor() {
            const {h: jt} = $;
            return jt === _1n$4 ? this : this.multiplyUnsafe(jt)
        }
        static fromHex(jt, Ft=!1) {
            const {d: Ht, a: qt} = $
              , Wt = et.BYTES;
            jt = ensureBytes("pointHex", jt, Wt),
            abool("zip215", Ft);
            const Mt = jt.slice()
              , Yt = jt[Wt - 1];
            Mt[Wt - 1] = Yt & -129;
            const un = bytesToNumberLE(Mt)
              , hn = Ft ? lt : et.ORDER;
            aInRange("pointHex.y", un, _0n$2, hn);
            const _n = ct(un * un)
              , kn = ct(_n - _1n$4)
              , Dn = ct(Ht * _n - qt);
            let {isValid: jn, value: Bn} = pt(kn, Dn);
            if (!jn)
                throw new Error("Point.fromHex: invalid y coordinate");
            const Un = (Bn & _1n$4) === _1n$4
              , Hn = (Yt & 128) !== 0;
            if (!Ft && Bn === _0n$2 && Hn)
                throw new Error("Point.fromHex: x=0 and x_0=1");
            return Hn !== Un && (Bn = ct(-Bn)),
            St.fromAffine({
                x: Bn,
                y: un
            })
        }
        static fromPrivateKey(jt) {
            return Jt(jt).point
        }
        toRawBytes() {
            const {x: jt, y: Ft} = this.toAffine()
              , Ht = numberToBytesLE(Ft, et.BYTES);
            return Ht[Ht.length - 1] |= jt & _1n$4 ? 128 : 0,
            Ht
        }
        toHex() {
            return bytesToHex(this.toRawBytes())
        }
    }
    St.BASE = new St($.Gx,$.Gy,_1n$4,ct($.Gx * $.Gy)),
    St.ZERO = new St(_0n$2,_1n$4,_1n$4,_0n$2);
    const {BASE: Ct, ZERO: Nt} = St
      , Lt = wNAF(St, ot * 8);
    function kt(Dt) {
        return mod$1(Dt, tt)
    }
    function Ut(Dt) {
        return kt(bytesToNumberLE(Dt))
    }
    function Jt(Dt) {
        const jt = et.BYTES;
        Dt = ensureBytes("private key", Dt, jt);
        const Ft = ensureBytes("hashed private key", rt(Dt), 2 * jt)
          , Ht = ht(Ft.slice(0, jt))
          , qt = Ft.slice(jt, 2 * jt)
          , Wt = Ut(Ht)
          , Mt = Ct.multiply(Wt)
          , Yt = Mt.toRawBytes();
        return {
            head: Ht,
            prefix: qt,
            scalar: Wt,
            point: Mt,
            pointBytes: Yt
        }
    }
    function Pt(Dt) {
        return Jt(Dt).pointBytes
    }
    function Xt(Dt=new Uint8Array, ...jt) {
        const Ft = concatBytes(...jt);
        return Ut(rt(mt(Ft, ensureBytes("context", Dt), !!nt)))
    }
    function rn(Dt, jt, Ft={}) {
        Dt = ensureBytes("message", Dt),
        nt && (Dt = nt(Dt));
        const {prefix: Ht, scalar: qt, pointBytes: Wt} = Jt(jt)
          , Mt = Xt(Ft.context, Ht, Dt)
          , Yt = Ct.multiply(Mt).toRawBytes()
          , un = Xt(Ft.context, Yt, Wt, Dt)
          , hn = kt(Mt + un * qt);
        aInRange("signature.s", hn, _0n$2, tt);
        const _n = concatBytes(Yt, numberToBytesLE(hn, et.BYTES));
        return ensureBytes("result", _n, et.BYTES * 2)
    }
    const zt = VERIFY_DEFAULT;
    function xt(Dt, jt, Ft, Ht=zt) {
        const {context: qt, zip215: Wt} = Ht
          , Mt = et.BYTES;
        Dt = ensureBytes("signature", Dt, 2 * Mt),
        jt = ensureBytes("message", jt),
        Ft = ensureBytes("publicKey", Ft, Mt),
        Wt !== void 0 && abool("zip215", Wt),
        nt && (jt = nt(jt));
        const Yt = bytesToNumberLE(Dt.slice(Mt, 2 * Mt));
        let un, hn, _n;
        try {
            un = St.fromHex(Ft, Wt),
            hn = St.fromHex(Dt.slice(0, Mt), Wt),
            _n = Ct.multiplyUnsafe(Yt)
        } catch {
            return !1
        }
        if (!Wt && un.isSmallOrder())
            return !1;
        const kn = Xt(qt, hn.toRawBytes(), un.toRawBytes(), jt);
        return hn.add(un.multiplyUnsafe(kn)).subtract(_n).clearCofactor().equals(St.ZERO)
    }
    return Ct._setWindowSize(8),
    {
        CURVE: $,
        getPublicKey: Pt,
        sign: rn,
        verify: xt,
        ExtendedPoint: St,
        utils: {
            getExtendedPublicKey: Jt,
            randomPrivateKey: () => it(et.BYTES),
            precompute(Dt=8, jt=St.BASE) {
                return jt._setWindowSize(Dt),
                jt.multiply(BigInt(3)),
                jt
            }
        }
    }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949")
  , ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const _1n$3 = BigInt(1)
  , _2n$2 = BigInt(2);
BigInt(3);
const _5n = BigInt(5)
  , _8n = BigInt(8);
function ed25519_pow_2_252_3(_e) {
    const $ = BigInt(10)
      , et = BigInt(20)
      , tt = BigInt(40)
      , nt = BigInt(80)
      , rt = ED25519_P
      , ot = _e * _e % rt * _e % rt
      , st = pow2(ot, _2n$2, rt) * ot % rt
      , lt = pow2(st, _1n$3, rt) * _e % rt
      , ct = pow2(lt, _5n, rt) * lt % rt
      , dt = pow2(ct, $, rt) * ct % rt
      , pt = pow2(dt, et, rt) * dt % rt
      , ht = pow2(pt, tt, rt) * pt % rt
      , mt = pow2(ht, nt, rt) * ht % rt
      , yt = pow2(mt, nt, rt) * ht % rt
      , Et = pow2(yt, $, rt) * ct % rt;
    return {
        pow_p_5_8: pow2(Et, _2n$2, rt) * _e % rt,
        b2: ot
    }
}
function adjustScalarBytes(_e) {
    return _e[0] &= 248,
    _e[31] &= 127,
    _e[31] |= 64,
    _e
}
function uvRatio(_e, $) {
    const et = ED25519_P
      , tt = mod$1($ * $ * $, et)
      , nt = mod$1(tt * tt * $, et)
      , rt = ed25519_pow_2_252_3(_e * nt).pow_p_5_8;
    let it = mod$1(_e * tt * rt, et);
    const ot = mod$1($ * it * it, et)
      , st = it
      , lt = mod$1(it * ED25519_SQRT_M1, et)
      , ct = ot === _e
      , dt = ot === mod$1(-_e, et)
      , pt = ot === mod$1(-_e * ED25519_SQRT_M1, et);
    return ct && (it = st),
    (dt || pt) && (it = lt),
    isNegativeLE(it, et) && (it = mod$1(-it, et)),
    {
        isValid: ct || dt,
        value: it
    }
}
const Fp = Field(ED25519_P, void 0, !0)
  , ed25519Defaults = {
    a: BigInt(-1),
    d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
    Fp,
    n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
    h: _8n,
    Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
    Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
    hash: sha512,
    randomBytes,
    adjustScalarBytes,
    uvRatio
}
  , ed25519 = twistedEdwards(ed25519Defaults);
var bn = {
    exports: {}
};
const require$$2$1 = getAugmentedNamespace(dist$5);
bn.exports;
(function(_e) {
    (function($, et) {
        function tt(zt, xt) {
            if (!zt)
                throw new Error(xt || "Assertion failed")
        }
        function nt(zt, xt) {
            zt.super_ = xt;
            var $t = function() {};
            $t.prototype = xt.prototype,
            zt.prototype = new $t,
            zt.prototype.constructor = zt
        }
        function rt(zt, xt, $t) {
            if (rt.isBN(zt))
                return zt;
            this.negative = 0,
            this.words = null,
            this.length = 0,
            this.red = null,
            zt !== null && ((xt === "le" || xt === "be") && ($t = xt,
            xt = 10),
            this._init(zt || 0, xt || 10, $t || "be"))
        }
        typeof $ == "object" ? $.exports = rt : et.BN = rt,
        rt.BN = rt,
        rt.wordSize = 26;
        var it;
        try {
            typeof window < "u" && typeof window.Buffer < "u" ? it = window.Buffer : it = require$$2$1.Buffer
        } catch {}
        rt.isBN = function(xt) {
            return xt instanceof rt ? !0 : xt !== null && typeof xt == "object" && xt.constructor.wordSize === rt.wordSize && Array.isArray(xt.words)
        }
        ,
        rt.max = function(xt, $t) {
            return xt.cmp($t) > 0 ? xt : $t
        }
        ,
        rt.min = function(xt, $t) {
            return xt.cmp($t) < 0 ? xt : $t
        }
        ,
        rt.prototype._init = function(xt, $t, Dt) {
            if (typeof xt == "number")
                return this._initNumber(xt, $t, Dt);
            if (typeof xt == "object")
                return this._initArray(xt, $t, Dt);
            $t === "hex" && ($t = 16),
            tt($t === ($t | 0) && $t >= 2 && $t <= 36),
            xt = xt.toString().replace(/\s+/g, "");
            var jt = 0;
            xt[0] === "-" && (jt++,
            this.negative = 1),
            jt < xt.length && ($t === 16 ? this._parseHex(xt, jt, Dt) : (this._parseBase(xt, $t, jt),
            Dt === "le" && this._initArray(this.toArray(), $t, Dt)))
        }
        ,
        rt.prototype._initNumber = function(xt, $t, Dt) {
            xt < 0 && (this.negative = 1,
            xt = -xt),
            xt < 67108864 ? (this.words = [xt & 67108863],
            this.length = 1) : xt < 4503599627370496 ? (this.words = [xt & 67108863, xt / 67108864 & 67108863],
            this.length = 2) : (tt(xt < 9007199254740992),
            this.words = [xt & 67108863, xt / 67108864 & 67108863, 1],
            this.length = 3),
            Dt === "le" && this._initArray(this.toArray(), $t, Dt)
        }
        ,
        rt.prototype._initArray = function(xt, $t, Dt) {
            if (tt(typeof xt.length == "number"),
            xt.length <= 0)
                return this.words = [0],
                this.length = 1,
                this;
            this.length = Math.ceil(xt.length / 3),
            this.words = new Array(this.length);
            for (var jt = 0; jt < this.length; jt++)
                this.words[jt] = 0;
            var Ft, Ht, qt = 0;
            if (Dt === "be")
                for (jt = xt.length - 1,
                Ft = 0; jt >= 0; jt -= 3)
                    Ht = xt[jt] | xt[jt - 1] << 8 | xt[jt - 2] << 16,
                    this.words[Ft] |= Ht << qt & 67108863,
                    this.words[Ft + 1] = Ht >>> 26 - qt & 67108863,
                    qt += 24,
                    qt >= 26 && (qt -= 26,
                    Ft++);
            else if (Dt === "le")
                for (jt = 0,
                Ft = 0; jt < xt.length; jt += 3)
                    Ht = xt[jt] | xt[jt + 1] << 8 | xt[jt + 2] << 16,
                    this.words[Ft] |= Ht << qt & 67108863,
                    this.words[Ft + 1] = Ht >>> 26 - qt & 67108863,
                    qt += 24,
                    qt >= 26 && (qt -= 26,
                    Ft++);
            return this._strip()
        }
        ;
        function ot(zt, xt) {
            var $t = zt.charCodeAt(xt);
            if ($t >= 48 && $t <= 57)
                return $t - 48;
            if ($t >= 65 && $t <= 70)
                return $t - 55;
            if ($t >= 97 && $t <= 102)
                return $t - 87;
            tt(!1, "Invalid character in " + zt)
        }
        function st(zt, xt, $t) {
            var Dt = ot(zt, $t);
            return $t - 1 >= xt && (Dt |= ot(zt, $t - 1) << 4),
            Dt
        }
        rt.prototype._parseHex = function(xt, $t, Dt) {
            this.length = Math.ceil((xt.length - $t) / 6),
            this.words = new Array(this.length);
            for (var jt = 0; jt < this.length; jt++)
                this.words[jt] = 0;
            var Ft = 0, Ht = 0, qt;
            if (Dt === "be")
                for (jt = xt.length - 1; jt >= $t; jt -= 2)
                    qt = st(xt, $t, jt) << Ft,
                    this.words[Ht] |= qt & 67108863,
                    Ft >= 18 ? (Ft -= 18,
                    Ht += 1,
                    this.words[Ht] |= qt >>> 26) : Ft += 8;
            else {
                var Wt = xt.length - $t;
                for (jt = Wt % 2 === 0 ? $t + 1 : $t; jt < xt.length; jt += 2)
                    qt = st(xt, $t, jt) << Ft,
                    this.words[Ht] |= qt & 67108863,
                    Ft >= 18 ? (Ft -= 18,
                    Ht += 1,
                    this.words[Ht] |= qt >>> 26) : Ft += 8
            }
            this._strip()
        }
        ;
        function lt(zt, xt, $t, Dt) {
            for (var jt = 0, Ft = 0, Ht = Math.min(zt.length, $t), qt = xt; qt < Ht; qt++) {
                var Wt = zt.charCodeAt(qt) - 48;
                jt *= Dt,
                Wt >= 49 ? Ft = Wt - 49 + 10 : Wt >= 17 ? Ft = Wt - 17 + 10 : Ft = Wt,
                tt(Wt >= 0 && Ft < Dt, "Invalid character"),
                jt += Ft
            }
            return jt
        }
        rt.prototype._parseBase = function(xt, $t, Dt) {
            this.words = [0],
            this.length = 1;
            for (var jt = 0, Ft = 1; Ft <= 67108863; Ft *= $t)
                jt++;
            jt--,
            Ft = Ft / $t | 0;
            for (var Ht = xt.length - Dt, qt = Ht % jt, Wt = Math.min(Ht, Ht - qt) + Dt, Mt = 0, Yt = Dt; Yt < Wt; Yt += jt)
                Mt = lt(xt, Yt, Yt + jt, $t),
                this.imuln(Ft),
                this.words[0] + Mt < 67108864 ? this.words[0] += Mt : this._iaddn(Mt);
            if (qt !== 0) {
                var un = 1;
                for (Mt = lt(xt, Yt, xt.length, $t),
                Yt = 0; Yt < qt; Yt++)
                    un *= $t;
                this.imuln(un),
                this.words[0] + Mt < 67108864 ? this.words[0] += Mt : this._iaddn(Mt)
            }
            this._strip()
        }
        ,
        rt.prototype.copy = function(xt) {
            xt.words = new Array(this.length);
            for (var $t = 0; $t < this.length; $t++)
                xt.words[$t] = this.words[$t];
            xt.length = this.length,
            xt.negative = this.negative,
            xt.red = this.red
        }
        ;
        function ct(zt, xt) {
            zt.words = xt.words,
            zt.length = xt.length,
            zt.negative = xt.negative,
            zt.red = xt.red
        }
        if (rt.prototype._move = function(xt) {
            ct(xt, this)
        }
        ,
        rt.prototype.clone = function() {
            var xt = new rt(null);
            return this.copy(xt),
            xt
        }
        ,
        rt.prototype._expand = function(xt) {
            for (; this.length < xt; )
                this.words[this.length++] = 0;
            return this
        }
        ,
        rt.prototype._strip = function() {
            for (; this.length > 1 && this.words[this.length - 1] === 0; )
                this.length--;
            return this._normSign()
        }
        ,
        rt.prototype._normSign = function() {
            return this.length === 1 && this.words[0] === 0 && (this.negative = 0),
            this
        }
        ,
        typeof Symbol < "u" && typeof Symbol.for == "function")
            try {
                rt.prototype[Symbol.for("nodejs.util.inspect.custom")] = dt
            } catch {
                rt.prototype.inspect = dt
            }
        else
            rt.prototype.inspect = dt;
        function dt() {
            return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">"
        }
        var pt = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"]
          , ht = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]
          , mt = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];
        rt.prototype.toString = function(xt, $t) {
            xt = xt || 10,
            $t = $t | 0 || 1;
            var Dt;
            if (xt === 16 || xt === "hex") {
                Dt = "";
                for (var jt = 0, Ft = 0, Ht = 0; Ht < this.length; Ht++) {
                    var qt = this.words[Ht]
                      , Wt = ((qt << jt | Ft) & 16777215).toString(16);
                    Ft = qt >>> 24 - jt & 16777215,
                    jt += 2,
                    jt >= 26 && (jt -= 26,
                    Ht--),
                    Ft !== 0 || Ht !== this.length - 1 ? Dt = pt[6 - Wt.length] + Wt + Dt : Dt = Wt + Dt
                }
                for (Ft !== 0 && (Dt = Ft.toString(16) + Dt); Dt.length % $t !== 0; )
                    Dt = "0" + Dt;
                return this.negative !== 0 && (Dt = "-" + Dt),
                Dt
            }
            if (xt === (xt | 0) && xt >= 2 && xt <= 36) {
                var Mt = ht[xt]
                  , Yt = mt[xt];
                Dt = "";
                var un = this.clone();
                for (un.negative = 0; !un.isZero(); ) {
                    var hn = un.modrn(Yt).toString(xt);
                    un = un.idivn(Yt),
                    un.isZero() ? Dt = hn + Dt : Dt = pt[Mt - hn.length] + hn + Dt
                }
                for (this.isZero() && (Dt = "0" + Dt); Dt.length % $t !== 0; )
                    Dt = "0" + Dt;
                return this.negative !== 0 && (Dt = "-" + Dt),
                Dt
            }
            tt(!1, "Base should be between 2 and 36")
        }
        ,
        rt.prototype.toNumber = function() {
            var xt = this.words[0];
            return this.length === 2 ? xt += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? xt += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && tt(!1, "Number can only safely store up to 53 bits"),
            this.negative !== 0 ? -xt : xt
        }
        ,
        rt.prototype.toJSON = function() {
            return this.toString(16, 2)
        }
        ,
        it && (rt.prototype.toBuffer = function(xt, $t) {
            return this.toArrayLike(it, xt, $t)
        }
        ),
        rt.prototype.toArray = function(xt, $t) {
            return this.toArrayLike(Array, xt, $t)
        }
        ;
        var yt = function(xt, $t) {
            return xt.allocUnsafe ? xt.allocUnsafe($t) : new xt($t)
        };
        rt.prototype.toArrayLike = function(xt, $t, Dt) {
            this._strip();
            var jt = this.byteLength()
              , Ft = Dt || Math.max(1, jt);
            tt(jt <= Ft, "byte array longer than desired length"),
            tt(Ft > 0, "Requested array length <= 0");
            var Ht = yt(xt, Ft)
              , qt = $t === "le" ? "LE" : "BE";
            return this["_toArrayLike" + qt](Ht, jt),
            Ht
        }
        ,
        rt.prototype._toArrayLikeLE = function(xt, $t) {
            for (var Dt = 0, jt = 0, Ft = 0, Ht = 0; Ft < this.length; Ft++) {
                var qt = this.words[Ft] << Ht | jt;
                xt[Dt++] = qt & 255,
                Dt < xt.length && (xt[Dt++] = qt >> 8 & 255),
                Dt < xt.length && (xt[Dt++] = qt >> 16 & 255),
                Ht === 6 ? (Dt < xt.length && (xt[Dt++] = qt >> 24 & 255),
                jt = 0,
                Ht = 0) : (jt = qt >>> 24,
                Ht += 2)
            }
            if (Dt < xt.length)
                for (xt[Dt++] = jt; Dt < xt.length; )
                    xt[Dt++] = 0
        }
        ,
        rt.prototype._toArrayLikeBE = function(xt, $t) {
            for (var Dt = xt.length - 1, jt = 0, Ft = 0, Ht = 0; Ft < this.length; Ft++) {
                var qt = this.words[Ft] << Ht | jt;
                xt[Dt--] = qt & 255,
                Dt >= 0 && (xt[Dt--] = qt >> 8 & 255),
                Dt >= 0 && (xt[Dt--] = qt >> 16 & 255),
                Ht === 6 ? (Dt >= 0 && (xt[Dt--] = qt >> 24 & 255),
                jt = 0,
                Ht = 0) : (jt = qt >>> 24,
                Ht += 2)
            }
            if (Dt >= 0)
                for (xt[Dt--] = jt; Dt >= 0; )
                    xt[Dt--] = 0
        }
        ,
        Math.clz32 ? rt.prototype._countBits = function(xt) {
            return 32 - Math.clz32(xt)
        }
        : rt.prototype._countBits = function(xt) {
            var $t = xt
              , Dt = 0;
            return $t >= 4096 && (Dt += 13,
            $t >>>= 13),
            $t >= 64 && (Dt += 7,
            $t >>>= 7),
            $t >= 8 && (Dt += 4,
            $t >>>= 4),
            $t >= 2 && (Dt += 2,
            $t >>>= 2),
            Dt + $t
        }
        ,
        rt.prototype._zeroBits = function(xt) {
            if (xt === 0)
                return 26;
            var $t = xt
              , Dt = 0;
            return $t & 8191 || (Dt += 13,
            $t >>>= 13),
            $t & 127 || (Dt += 7,
            $t >>>= 7),
            $t & 15 || (Dt += 4,
            $t >>>= 4),
            $t & 3 || (Dt += 2,
            $t >>>= 2),
            $t & 1 || Dt++,
            Dt
        }
        ,
        rt.prototype.bitLength = function() {
            var xt = this.words[this.length - 1]
              , $t = this._countBits(xt);
            return (this.length - 1) * 26 + $t
        }
        ;
        function Et(zt) {
            for (var xt = new Array(zt.bitLength()), $t = 0; $t < xt.length; $t++) {
                var Dt = $t / 26 | 0
                  , jt = $t % 26;
                xt[$t] = zt.words[Dt] >>> jt & 1
            }
            return xt
        }
        rt.prototype.zeroBits = function() {
            if (this.isZero())
                return 0;
            for (var xt = 0, $t = 0; $t < this.length; $t++) {
                var Dt = this._zeroBits(this.words[$t]);
                if (xt += Dt,
                Dt !== 26)
                    break
            }
            return xt
        }
        ,
        rt.prototype.byteLength = function() {
            return Math.ceil(this.bitLength() / 8)
        }
        ,
        rt.prototype.toTwos = function(xt) {
            return this.negative !== 0 ? this.abs().inotn(xt).iaddn(1) : this.clone()
        }
        ,
        rt.prototype.fromTwos = function(xt) {
            return this.testn(xt - 1) ? this.notn(xt).iaddn(1).ineg() : this.clone()
        }
        ,
        rt.prototype.isNeg = function() {
            return this.negative !== 0
        }
        ,
        rt.prototype.neg = function() {
            return this.clone().ineg()
        }
        ,
        rt.prototype.ineg = function() {
            return this.isZero() || (this.negative ^= 1),
            this
        }
        ,
        rt.prototype.iuor = function(xt) {
            for (; this.length < xt.length; )
                this.words[this.length++] = 0;
            for (var $t = 0; $t < xt.length; $t++)
                this.words[$t] = this.words[$t] | xt.words[$t];
            return this._strip()
        }
        ,
        rt.prototype.ior = function(xt) {
            return tt((this.negative | xt.negative) === 0),
            this.iuor(xt)
        }
        ,
        rt.prototype.or = function(xt) {
            return this.length > xt.length ? this.clone().ior(xt) : xt.clone().ior(this)
        }
        ,
        rt.prototype.uor = function(xt) {
            return this.length > xt.length ? this.clone().iuor(xt) : xt.clone().iuor(this)
        }
        ,
        rt.prototype.iuand = function(xt) {
            var $t;
            this.length > xt.length ? $t = xt : $t = this;
            for (var Dt = 0; Dt < $t.length; Dt++)
                this.words[Dt] = this.words[Dt] & xt.words[Dt];
            return this.length = $t.length,
            this._strip()
        }
        ,
        rt.prototype.iand = function(xt) {
            return tt((this.negative | xt.negative) === 0),
            this.iuand(xt)
        }
        ,
        rt.prototype.and = function(xt) {
            return this.length > xt.length ? this.clone().iand(xt) : xt.clone().iand(this)
        }
        ,
        rt.prototype.uand = function(xt) {
            return this.length > xt.length ? this.clone().iuand(xt) : xt.clone().iuand(this)
        }
        ,
        rt.prototype.iuxor = function(xt) {
            var $t, Dt;
            this.length > xt.length ? ($t = this,
            Dt = xt) : ($t = xt,
            Dt = this);
            for (var jt = 0; jt < Dt.length; jt++)
                this.words[jt] = $t.words[jt] ^ Dt.words[jt];
            if (this !== $t)
                for (; jt < $t.length; jt++)
                    this.words[jt] = $t.words[jt];
            return this.length = $t.length,
            this._strip()
        }
        ,
        rt.prototype.ixor = function(xt) {
            return tt((this.negative | xt.negative) === 0),
            this.iuxor(xt)
        }
        ,
        rt.prototype.xor = function(xt) {
            return this.length > xt.length ? this.clone().ixor(xt) : xt.clone().ixor(this)
        }
        ,
        rt.prototype.uxor = function(xt) {
            return this.length > xt.length ? this.clone().iuxor(xt) : xt.clone().iuxor(this)
        }
        ,
        rt.prototype.inotn = function(xt) {
            tt(typeof xt == "number" && xt >= 0);
            var $t = Math.ceil(xt / 26) | 0
              , Dt = xt % 26;
            this._expand($t),
            Dt > 0 && $t--;
            for (var jt = 0; jt < $t; jt++)
                this.words[jt] = ~this.words[jt] & 67108863;
            return Dt > 0 && (this.words[jt] = ~this.words[jt] & 67108863 >> 26 - Dt),
            this._strip()
        }
        ,
        rt.prototype.notn = function(xt) {
            return this.clone().inotn(xt)
        }
        ,
        rt.prototype.setn = function(xt, $t) {
            tt(typeof xt == "number" && xt >= 0);
            var Dt = xt / 26 | 0
              , jt = xt % 26;
            return this._expand(Dt + 1),
            $t ? this.words[Dt] = this.words[Dt] | 1 << jt : this.words[Dt] = this.words[Dt] & ~(1 << jt),
            this._strip()
        }
        ,
        rt.prototype.iadd = function(xt) {
            var $t;
            if (this.negative !== 0 && xt.negative === 0)
                return this.negative = 0,
                $t = this.isub(xt),
                this.negative ^= 1,
                this._normSign();
            if (this.negative === 0 && xt.negative !== 0)
                return xt.negative = 0,
                $t = this.isub(xt),
                xt.negative = 1,
                $t._normSign();
            var Dt, jt;
            this.length > xt.length ? (Dt = this,
            jt = xt) : (Dt = xt,
            jt = this);
            for (var Ft = 0, Ht = 0; Ht < jt.length; Ht++)
                $t = (Dt.words[Ht] | 0) + (jt.words[Ht] | 0) + Ft,
                this.words[Ht] = $t & 67108863,
                Ft = $t >>> 26;
            for (; Ft !== 0 && Ht < Dt.length; Ht++)
                $t = (Dt.words[Ht] | 0) + Ft,
                this.words[Ht] = $t & 67108863,
                Ft = $t >>> 26;
            if (this.length = Dt.length,
            Ft !== 0)
                this.words[this.length] = Ft,
                this.length++;
            else if (Dt !== this)
                for (; Ht < Dt.length; Ht++)
                    this.words[Ht] = Dt.words[Ht];
            return this
        }
        ,
        rt.prototype.add = function(xt) {
            var $t;
            return xt.negative !== 0 && this.negative === 0 ? (xt.negative = 0,
            $t = this.sub(xt),
            xt.negative ^= 1,
            $t) : xt.negative === 0 && this.negative !== 0 ? (this.negative = 0,
            $t = xt.sub(this),
            this.negative = 1,
            $t) : this.length > xt.length ? this.clone().iadd(xt) : xt.clone().iadd(this)
        }
        ,
        rt.prototype.isub = function(xt) {
            if (xt.negative !== 0) {
                xt.negative = 0;
                var $t = this.iadd(xt);
                return xt.negative = 1,
                $t._normSign()
            } else if (this.negative !== 0)
                return this.negative = 0,
                this.iadd(xt),
                this.negative = 1,
                this._normSign();
            var Dt = this.cmp(xt);
            if (Dt === 0)
                return this.negative = 0,
                this.length = 1,
                this.words[0] = 0,
                this;
            var jt, Ft;
            Dt > 0 ? (jt = this,
            Ft = xt) : (jt = xt,
            Ft = this);
            for (var Ht = 0, qt = 0; qt < Ft.length; qt++)
                $t = (jt.words[qt] | 0) - (Ft.words[qt] | 0) + Ht,
                Ht = $t >> 26,
                this.words[qt] = $t & 67108863;
            for (; Ht !== 0 && qt < jt.length; qt++)
                $t = (jt.words[qt] | 0) + Ht,
                Ht = $t >> 26,
                this.words[qt] = $t & 67108863;
            if (Ht === 0 && qt < jt.length && jt !== this)
                for (; qt < jt.length; qt++)
                    this.words[qt] = jt.words[qt];
            return this.length = Math.max(this.length, qt),
            jt !== this && (this.negative = 1),
            this._strip()
        }
        ,
        rt.prototype.sub = function(xt) {
            return this.clone().isub(xt)
        }
        ;
        function _t(zt, xt, $t) {
            $t.negative = xt.negative ^ zt.negative;
            var Dt = zt.length + xt.length | 0;
            $t.length = Dt,
            Dt = Dt - 1 | 0;
            var jt = zt.words[0] | 0
              , Ft = xt.words[0] | 0
              , Ht = jt * Ft
              , qt = Ht & 67108863
              , Wt = Ht / 67108864 | 0;
            $t.words[0] = qt;
            for (var Mt = 1; Mt < Dt; Mt++) {
                for (var Yt = Wt >>> 26, un = Wt & 67108863, hn = Math.min(Mt, xt.length - 1), _n = Math.max(0, Mt - zt.length + 1); _n <= hn; _n++) {
                    var kn = Mt - _n | 0;
                    jt = zt.words[kn] | 0,
                    Ft = xt.words[_n] | 0,
                    Ht = jt * Ft + un,
                    Yt += Ht / 67108864 | 0,
                    un = Ht & 67108863
                }
                $t.words[Mt] = un | 0,
                Wt = Yt | 0
            }
            return Wt !== 0 ? $t.words[Mt] = Wt | 0 : $t.length--,
            $t._strip()
        }
        var wt = function(xt, $t, Dt) {
            var jt = xt.words, Ft = $t.words, Ht = Dt.words, qt = 0, Wt, Mt, Yt, un = jt[0] | 0, hn = un & 8191, _n = un >>> 13, kn = jt[1] | 0, Dn = kn & 8191, jn = kn >>> 13, Bn = jt[2] | 0, Un = Bn & 8191, Hn = Bn >>> 13, cr = jt[3] | 0, Gn = cr & 8191, Mn = cr >>> 13, rr = jt[4] | 0, Zn = rr & 8191, pr = rr >>> 13, Ur = jt[5] | 0, xr = Ur & 8191, wr = Ur >>> 13, Rn = jt[6] | 0, Vn = Rn & 8191, qn = Rn >>> 13, dr = jt[7] | 0, or = dr & 8191, ir = dr >>> 13, Cr = jt[8] | 0, br = Cr & 8191, an = Cr >>> 13, Kt = jt[9] | 0, Gt = Kt & 8191, fn = Kt >>> 13, En = Ft[0] | 0, vn = En & 8191, Tn = En >>> 13, sr = Ft[1] | 0, lr = sr & 8191, wn = sr >>> 13, Pn = Ft[2] | 0, Cn = Pn & 8191, zn = Pn >>> 13, ur = Ft[3] | 0, hr = ur & 8191, Ir = ur >>> 13, _o = Ft[4] | 0, Xr = _o & 8191, jr = _o >>> 13, zs = Ft[5] | 0, bo = zs & 8191, Jr = zs >>> 13, Zo = Ft[6] | 0, ro = Zo & 8191, go = Zo >>> 13, Sl = Ft[7] | 0, xo = Sl & 8191, To = Sl >>> 13, Cl = Ft[8] | 0, mo = Cl & 8191, Ro = Cl >>> 13, lu = Ft[9] | 0, yo = lu & 8191, Io = lu >>> 13;
            Dt.negative = xt.negative ^ $t.negative,
            Dt.length = 19,
            Wt = Math.imul(hn, vn),
            Mt = Math.imul(hn, Tn),
            Mt = Mt + Math.imul(_n, vn) | 0,
            Yt = Math.imul(_n, Tn);
            var ws = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (ws >>> 26) | 0,
            ws &= 67108863,
            Wt = Math.imul(Dn, vn),
            Mt = Math.imul(Dn, Tn),
            Mt = Mt + Math.imul(jn, vn) | 0,
            Yt = Math.imul(jn, Tn),
            Wt = Wt + Math.imul(hn, lr) | 0,
            Mt = Mt + Math.imul(hn, wn) | 0,
            Mt = Mt + Math.imul(_n, lr) | 0,
            Yt = Yt + Math.imul(_n, wn) | 0;
            var Os = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (Os >>> 26) | 0,
            Os &= 67108863,
            Wt = Math.imul(Un, vn),
            Mt = Math.imul(Un, Tn),
            Mt = Mt + Math.imul(Hn, vn) | 0,
            Yt = Math.imul(Hn, Tn),
            Wt = Wt + Math.imul(Dn, lr) | 0,
            Mt = Mt + Math.imul(Dn, wn) | 0,
            Mt = Mt + Math.imul(jn, lr) | 0,
            Yt = Yt + Math.imul(jn, wn) | 0,
            Wt = Wt + Math.imul(hn, Cn) | 0,
            Mt = Mt + Math.imul(hn, zn) | 0,
            Mt = Mt + Math.imul(_n, Cn) | 0,
            Yt = Yt + Math.imul(_n, zn) | 0;
            var Ws = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (Ws >>> 26) | 0,
            Ws &= 67108863,
            Wt = Math.imul(Gn, vn),
            Mt = Math.imul(Gn, Tn),
            Mt = Mt + Math.imul(Mn, vn) | 0,
            Yt = Math.imul(Mn, Tn),
            Wt = Wt + Math.imul(Un, lr) | 0,
            Mt = Mt + Math.imul(Un, wn) | 0,
            Mt = Mt + Math.imul(Hn, lr) | 0,
            Yt = Yt + Math.imul(Hn, wn) | 0,
            Wt = Wt + Math.imul(Dn, Cn) | 0,
            Mt = Mt + Math.imul(Dn, zn) | 0,
            Mt = Mt + Math.imul(jn, Cn) | 0,
            Yt = Yt + Math.imul(jn, zn) | 0,
            Wt = Wt + Math.imul(hn, hr) | 0,
            Mt = Mt + Math.imul(hn, Ir) | 0,
            Mt = Mt + Math.imul(_n, hr) | 0,
            Yt = Yt + Math.imul(_n, Ir) | 0;
            var Hs = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (Hs >>> 26) | 0,
            Hs &= 67108863,
            Wt = Math.imul(Zn, vn),
            Mt = Math.imul(Zn, Tn),
            Mt = Mt + Math.imul(pr, vn) | 0,
            Yt = Math.imul(pr, Tn),
            Wt = Wt + Math.imul(Gn, lr) | 0,
            Mt = Mt + Math.imul(Gn, wn) | 0,
            Mt = Mt + Math.imul(Mn, lr) | 0,
            Yt = Yt + Math.imul(Mn, wn) | 0,
            Wt = Wt + Math.imul(Un, Cn) | 0,
            Mt = Mt + Math.imul(Un, zn) | 0,
            Mt = Mt + Math.imul(Hn, Cn) | 0,
            Yt = Yt + Math.imul(Hn, zn) | 0,
            Wt = Wt + Math.imul(Dn, hr) | 0,
            Mt = Mt + Math.imul(Dn, Ir) | 0,
            Mt = Mt + Math.imul(jn, hr) | 0,
            Yt = Yt + Math.imul(jn, Ir) | 0,
            Wt = Wt + Math.imul(hn, Xr) | 0,
            Mt = Mt + Math.imul(hn, jr) | 0,
            Mt = Mt + Math.imul(_n, Xr) | 0,
            Yt = Yt + Math.imul(_n, jr) | 0;
            var xs = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (xs >>> 26) | 0,
            xs &= 67108863,
            Wt = Math.imul(xr, vn),
            Mt = Math.imul(xr, Tn),
            Mt = Mt + Math.imul(wr, vn) | 0,
            Yt = Math.imul(wr, Tn),
            Wt = Wt + Math.imul(Zn, lr) | 0,
            Mt = Mt + Math.imul(Zn, wn) | 0,
            Mt = Mt + Math.imul(pr, lr) | 0,
            Yt = Yt + Math.imul(pr, wn) | 0,
            Wt = Wt + Math.imul(Gn, Cn) | 0,
            Mt = Mt + Math.imul(Gn, zn) | 0,
            Mt = Mt + Math.imul(Mn, Cn) | 0,
            Yt = Yt + Math.imul(Mn, zn) | 0,
            Wt = Wt + Math.imul(Un, hr) | 0,
            Mt = Mt + Math.imul(Un, Ir) | 0,
            Mt = Mt + Math.imul(Hn, hr) | 0,
            Yt = Yt + Math.imul(Hn, Ir) | 0,
            Wt = Wt + Math.imul(Dn, Xr) | 0,
            Mt = Mt + Math.imul(Dn, jr) | 0,
            Mt = Mt + Math.imul(jn, Xr) | 0,
            Yt = Yt + Math.imul(jn, jr) | 0,
            Wt = Wt + Math.imul(hn, bo) | 0,
            Mt = Mt + Math.imul(hn, Jr) | 0,
            Mt = Mt + Math.imul(_n, bo) | 0,
            Yt = Yt + Math.imul(_n, Jr) | 0;
            var Ss = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (Ss >>> 26) | 0,
            Ss &= 67108863,
            Wt = Math.imul(Vn, vn),
            Mt = Math.imul(Vn, Tn),
            Mt = Mt + Math.imul(qn, vn) | 0,
            Yt = Math.imul(qn, Tn),
            Wt = Wt + Math.imul(xr, lr) | 0,
            Mt = Mt + Math.imul(xr, wn) | 0,
            Mt = Mt + Math.imul(wr, lr) | 0,
            Yt = Yt + Math.imul(wr, wn) | 0,
            Wt = Wt + Math.imul(Zn, Cn) | 0,
            Mt = Mt + Math.imul(Zn, zn) | 0,
            Mt = Mt + Math.imul(pr, Cn) | 0,
            Yt = Yt + Math.imul(pr, zn) | 0,
            Wt = Wt + Math.imul(Gn, hr) | 0,
            Mt = Mt + Math.imul(Gn, Ir) | 0,
            Mt = Mt + Math.imul(Mn, hr) | 0,
            Yt = Yt + Math.imul(Mn, Ir) | 0,
            Wt = Wt + Math.imul(Un, Xr) | 0,
            Mt = Mt + Math.imul(Un, jr) | 0,
            Mt = Mt + Math.imul(Hn, Xr) | 0,
            Yt = Yt + Math.imul(Hn, jr) | 0,
            Wt = Wt + Math.imul(Dn, bo) | 0,
            Mt = Mt + Math.imul(Dn, Jr) | 0,
            Mt = Mt + Math.imul(jn, bo) | 0,
            Yt = Yt + Math.imul(jn, Jr) | 0,
            Wt = Wt + Math.imul(hn, ro) | 0,
            Mt = Mt + Math.imul(hn, go) | 0,
            Mt = Mt + Math.imul(_n, ro) | 0,
            Yt = Yt + Math.imul(_n, go) | 0;
            var Nu = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (Nu >>> 26) | 0,
            Nu &= 67108863,
            Wt = Math.imul(or, vn),
            Mt = Math.imul(or, Tn),
            Mt = Mt + Math.imul(ir, vn) | 0,
            Yt = Math.imul(ir, Tn),
            Wt = Wt + Math.imul(Vn, lr) | 0,
            Mt = Mt + Math.imul(Vn, wn) | 0,
            Mt = Mt + Math.imul(qn, lr) | 0,
            Yt = Yt + Math.imul(qn, wn) | 0,
            Wt = Wt + Math.imul(xr, Cn) | 0,
            Mt = Mt + Math.imul(xr, zn) | 0,
            Mt = Mt + Math.imul(wr, Cn) | 0,
            Yt = Yt + Math.imul(wr, zn) | 0,
            Wt = Wt + Math.imul(Zn, hr) | 0,
            Mt = Mt + Math.imul(Zn, Ir) | 0,
            Mt = Mt + Math.imul(pr, hr) | 0,
            Yt = Yt + Math.imul(pr, Ir) | 0,
            Wt = Wt + Math.imul(Gn, Xr) | 0,
            Mt = Mt + Math.imul(Gn, jr) | 0,
            Mt = Mt + Math.imul(Mn, Xr) | 0,
            Yt = Yt + Math.imul(Mn, jr) | 0,
            Wt = Wt + Math.imul(Un, bo) | 0,
            Mt = Mt + Math.imul(Un, Jr) | 0,
            Mt = Mt + Math.imul(Hn, bo) | 0,
            Yt = Yt + Math.imul(Hn, Jr) | 0,
            Wt = Wt + Math.imul(Dn, ro) | 0,
            Mt = Mt + Math.imul(Dn, go) | 0,
            Mt = Mt + Math.imul(jn, ro) | 0,
            Yt = Yt + Math.imul(jn, go) | 0,
            Wt = Wt + Math.imul(hn, xo) | 0,
            Mt = Mt + Math.imul(hn, To) | 0,
            Mt = Mt + Math.imul(_n, xo) | 0,
            Yt = Yt + Math.imul(_n, To) | 0;
            var $l = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + ($l >>> 26) | 0,
            $l &= 67108863,
            Wt = Math.imul(br, vn),
            Mt = Math.imul(br, Tn),
            Mt = Mt + Math.imul(an, vn) | 0,
            Yt = Math.imul(an, Tn),
            Wt = Wt + Math.imul(or, lr) | 0,
            Mt = Mt + Math.imul(or, wn) | 0,
            Mt = Mt + Math.imul(ir, lr) | 0,
            Yt = Yt + Math.imul(ir, wn) | 0,
            Wt = Wt + Math.imul(Vn, Cn) | 0,
            Mt = Mt + Math.imul(Vn, zn) | 0,
            Mt = Mt + Math.imul(qn, Cn) | 0,
            Yt = Yt + Math.imul(qn, zn) | 0,
            Wt = Wt + Math.imul(xr, hr) | 0,
            Mt = Mt + Math.imul(xr, Ir) | 0,
            Mt = Mt + Math.imul(wr, hr) | 0,
            Yt = Yt + Math.imul(wr, Ir) | 0,
            Wt = Wt + Math.imul(Zn, Xr) | 0,
            Mt = Mt + Math.imul(Zn, jr) | 0,
            Mt = Mt + Math.imul(pr, Xr) | 0,
            Yt = Yt + Math.imul(pr, jr) | 0,
            Wt = Wt + Math.imul(Gn, bo) | 0,
            Mt = Mt + Math.imul(Gn, Jr) | 0,
            Mt = Mt + Math.imul(Mn, bo) | 0,
            Yt = Yt + Math.imul(Mn, Jr) | 0,
            Wt = Wt + Math.imul(Un, ro) | 0,
            Mt = Mt + Math.imul(Un, go) | 0,
            Mt = Mt + Math.imul(Hn, ro) | 0,
            Yt = Yt + Math.imul(Hn, go) | 0,
            Wt = Wt + Math.imul(Dn, xo) | 0,
            Mt = Mt + Math.imul(Dn, To) | 0,
            Mt = Mt + Math.imul(jn, xo) | 0,
            Yt = Yt + Math.imul(jn, To) | 0,
            Wt = Wt + Math.imul(hn, mo) | 0,
            Mt = Mt + Math.imul(hn, Ro) | 0,
            Mt = Mt + Math.imul(_n, mo) | 0,
            Yt = Yt + Math.imul(_n, Ro) | 0;
            var Mu = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (Mu >>> 26) | 0,
            Mu &= 67108863,
            Wt = Math.imul(Gt, vn),
            Mt = Math.imul(Gt, Tn),
            Mt = Mt + Math.imul(fn, vn) | 0,
            Yt = Math.imul(fn, Tn),
            Wt = Wt + Math.imul(br, lr) | 0,
            Mt = Mt + Math.imul(br, wn) | 0,
            Mt = Mt + Math.imul(an, lr) | 0,
            Yt = Yt + Math.imul(an, wn) | 0,
            Wt = Wt + Math.imul(or, Cn) | 0,
            Mt = Mt + Math.imul(or, zn) | 0,
            Mt = Mt + Math.imul(ir, Cn) | 0,
            Yt = Yt + Math.imul(ir, zn) | 0,
            Wt = Wt + Math.imul(Vn, hr) | 0,
            Mt = Mt + Math.imul(Vn, Ir) | 0,
            Mt = Mt + Math.imul(qn, hr) | 0,
            Yt = Yt + Math.imul(qn, Ir) | 0,
            Wt = Wt + Math.imul(xr, Xr) | 0,
            Mt = Mt + Math.imul(xr, jr) | 0,
            Mt = Mt + Math.imul(wr, Xr) | 0,
            Yt = Yt + Math.imul(wr, jr) | 0,
            Wt = Wt + Math.imul(Zn, bo) | 0,
            Mt = Mt + Math.imul(Zn, Jr) | 0,
            Mt = Mt + Math.imul(pr, bo) | 0,
            Yt = Yt + Math.imul(pr, Jr) | 0,
            Wt = Wt + Math.imul(Gn, ro) | 0,
            Mt = Mt + Math.imul(Gn, go) | 0,
            Mt = Mt + Math.imul(Mn, ro) | 0,
            Yt = Yt + Math.imul(Mn, go) | 0,
            Wt = Wt + Math.imul(Un, xo) | 0,
            Mt = Mt + Math.imul(Un, To) | 0,
            Mt = Mt + Math.imul(Hn, xo) | 0,
            Yt = Yt + Math.imul(Hn, To) | 0,
            Wt = Wt + Math.imul(Dn, mo) | 0,
            Mt = Mt + Math.imul(Dn, Ro) | 0,
            Mt = Mt + Math.imul(jn, mo) | 0,
            Yt = Yt + Math.imul(jn, Ro) | 0,
            Wt = Wt + Math.imul(hn, yo) | 0,
            Mt = Mt + Math.imul(hn, Io) | 0,
            Mt = Mt + Math.imul(_n, yo) | 0,
            Yt = Yt + Math.imul(_n, Io) | 0;
            var Pu = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (Pu >>> 26) | 0,
            Pu &= 67108863,
            Wt = Math.imul(Gt, lr),
            Mt = Math.imul(Gt, wn),
            Mt = Mt + Math.imul(fn, lr) | 0,
            Yt = Math.imul(fn, wn),
            Wt = Wt + Math.imul(br, Cn) | 0,
            Mt = Mt + Math.imul(br, zn) | 0,
            Mt = Mt + Math.imul(an, Cn) | 0,
            Yt = Yt + Math.imul(an, zn) | 0,
            Wt = Wt + Math.imul(or, hr) | 0,
            Mt = Mt + Math.imul(or, Ir) | 0,
            Mt = Mt + Math.imul(ir, hr) | 0,
            Yt = Yt + Math.imul(ir, Ir) | 0,
            Wt = Wt + Math.imul(Vn, Xr) | 0,
            Mt = Mt + Math.imul(Vn, jr) | 0,
            Mt = Mt + Math.imul(qn, Xr) | 0,
            Yt = Yt + Math.imul(qn, jr) | 0,
            Wt = Wt + Math.imul(xr, bo) | 0,
            Mt = Mt + Math.imul(xr, Jr) | 0,
            Mt = Mt + Math.imul(wr, bo) | 0,
            Yt = Yt + Math.imul(wr, Jr) | 0,
            Wt = Wt + Math.imul(Zn, ro) | 0,
            Mt = Mt + Math.imul(Zn, go) | 0,
            Mt = Mt + Math.imul(pr, ro) | 0,
            Yt = Yt + Math.imul(pr, go) | 0,
            Wt = Wt + Math.imul(Gn, xo) | 0,
            Mt = Mt + Math.imul(Gn, To) | 0,
            Mt = Mt + Math.imul(Mn, xo) | 0,
            Yt = Yt + Math.imul(Mn, To) | 0,
            Wt = Wt + Math.imul(Un, mo) | 0,
            Mt = Mt + Math.imul(Un, Ro) | 0,
            Mt = Mt + Math.imul(Hn, mo) | 0,
            Yt = Yt + Math.imul(Hn, Ro) | 0,
            Wt = Wt + Math.imul(Dn, yo) | 0,
            Mt = Mt + Math.imul(Dn, Io) | 0,
            Mt = Mt + Math.imul(jn, yo) | 0,
            Yt = Yt + Math.imul(jn, Io) | 0;
            var Du = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (Du >>> 26) | 0,
            Du &= 67108863,
            Wt = Math.imul(Gt, Cn),
            Mt = Math.imul(Gt, zn),
            Mt = Mt + Math.imul(fn, Cn) | 0,
            Yt = Math.imul(fn, zn),
            Wt = Wt + Math.imul(br, hr) | 0,
            Mt = Mt + Math.imul(br, Ir) | 0,
            Mt = Mt + Math.imul(an, hr) | 0,
            Yt = Yt + Math.imul(an, Ir) | 0,
            Wt = Wt + Math.imul(or, Xr) | 0,
            Mt = Mt + Math.imul(or, jr) | 0,
            Mt = Mt + Math.imul(ir, Xr) | 0,
            Yt = Yt + Math.imul(ir, jr) | 0,
            Wt = Wt + Math.imul(Vn, bo) | 0,
            Mt = Mt + Math.imul(Vn, Jr) | 0,
            Mt = Mt + Math.imul(qn, bo) | 0,
            Yt = Yt + Math.imul(qn, Jr) | 0,
            Wt = Wt + Math.imul(xr, ro) | 0,
            Mt = Mt + Math.imul(xr, go) | 0,
            Mt = Mt + Math.imul(wr, ro) | 0,
            Yt = Yt + Math.imul(wr, go) | 0,
            Wt = Wt + Math.imul(Zn, xo) | 0,
            Mt = Mt + Math.imul(Zn, To) | 0,
            Mt = Mt + Math.imul(pr, xo) | 0,
            Yt = Yt + Math.imul(pr, To) | 0,
            Wt = Wt + Math.imul(Gn, mo) | 0,
            Mt = Mt + Math.imul(Gn, Ro) | 0,
            Mt = Mt + Math.imul(Mn, mo) | 0,
            Yt = Yt + Math.imul(Mn, Ro) | 0,
            Wt = Wt + Math.imul(Un, yo) | 0,
            Mt = Mt + Math.imul(Un, Io) | 0,
            Mt = Mt + Math.imul(Hn, yo) | 0,
            Yt = Yt + Math.imul(Hn, Io) | 0;
            var cu = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (cu >>> 26) | 0,
            cu &= 67108863,
            Wt = Math.imul(Gt, hr),
            Mt = Math.imul(Gt, Ir),
            Mt = Mt + Math.imul(fn, hr) | 0,
            Yt = Math.imul(fn, Ir),
            Wt = Wt + Math.imul(br, Xr) | 0,
            Mt = Mt + Math.imul(br, jr) | 0,
            Mt = Mt + Math.imul(an, Xr) | 0,
            Yt = Yt + Math.imul(an, jr) | 0,
            Wt = Wt + Math.imul(or, bo) | 0,
            Mt = Mt + Math.imul(or, Jr) | 0,
            Mt = Mt + Math.imul(ir, bo) | 0,
            Yt = Yt + Math.imul(ir, Jr) | 0,
            Wt = Wt + Math.imul(Vn, ro) | 0,
            Mt = Mt + Math.imul(Vn, go) | 0,
            Mt = Mt + Math.imul(qn, ro) | 0,
            Yt = Yt + Math.imul(qn, go) | 0,
            Wt = Wt + Math.imul(xr, xo) | 0,
            Mt = Mt + Math.imul(xr, To) | 0,
            Mt = Mt + Math.imul(wr, xo) | 0,
            Yt = Yt + Math.imul(wr, To) | 0,
            Wt = Wt + Math.imul(Zn, mo) | 0,
            Mt = Mt + Math.imul(Zn, Ro) | 0,
            Mt = Mt + Math.imul(pr, mo) | 0,
            Yt = Yt + Math.imul(pr, Ro) | 0,
            Wt = Wt + Math.imul(Gn, yo) | 0,
            Mt = Mt + Math.imul(Gn, Io) | 0,
            Mt = Mt + Math.imul(Mn, yo) | 0,
            Yt = Yt + Math.imul(Mn, Io) | 0;
            var uu = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (uu >>> 26) | 0,
            uu &= 67108863,
            Wt = Math.imul(Gt, Xr),
            Mt = Math.imul(Gt, jr),
            Mt = Mt + Math.imul(fn, Xr) | 0,
            Yt = Math.imul(fn, jr),
            Wt = Wt + Math.imul(br, bo) | 0,
            Mt = Mt + Math.imul(br, Jr) | 0,
            Mt = Mt + Math.imul(an, bo) | 0,
            Yt = Yt + Math.imul(an, Jr) | 0,
            Wt = Wt + Math.imul(or, ro) | 0,
            Mt = Mt + Math.imul(or, go) | 0,
            Mt = Mt + Math.imul(ir, ro) | 0,
            Yt = Yt + Math.imul(ir, go) | 0,
            Wt = Wt + Math.imul(Vn, xo) | 0,
            Mt = Mt + Math.imul(Vn, To) | 0,
            Mt = Mt + Math.imul(qn, xo) | 0,
            Yt = Yt + Math.imul(qn, To) | 0,
            Wt = Wt + Math.imul(xr, mo) | 0,
            Mt = Mt + Math.imul(xr, Ro) | 0,
            Mt = Mt + Math.imul(wr, mo) | 0,
            Yt = Yt + Math.imul(wr, Ro) | 0,
            Wt = Wt + Math.imul(Zn, yo) | 0,
            Mt = Mt + Math.imul(Zn, Io) | 0,
            Mt = Mt + Math.imul(pr, yo) | 0,
            Yt = Yt + Math.imul(pr, Io) | 0;
            var du = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (du >>> 26) | 0,
            du &= 67108863,
            Wt = Math.imul(Gt, bo),
            Mt = Math.imul(Gt, Jr),
            Mt = Mt + Math.imul(fn, bo) | 0,
            Yt = Math.imul(fn, Jr),
            Wt = Wt + Math.imul(br, ro) | 0,
            Mt = Mt + Math.imul(br, go) | 0,
            Mt = Mt + Math.imul(an, ro) | 0,
            Yt = Yt + Math.imul(an, go) | 0,
            Wt = Wt + Math.imul(or, xo) | 0,
            Mt = Mt + Math.imul(or, To) | 0,
            Mt = Mt + Math.imul(ir, xo) | 0,
            Yt = Yt + Math.imul(ir, To) | 0,
            Wt = Wt + Math.imul(Vn, mo) | 0,
            Mt = Mt + Math.imul(Vn, Ro) | 0,
            Mt = Mt + Math.imul(qn, mo) | 0,
            Yt = Yt + Math.imul(qn, Ro) | 0,
            Wt = Wt + Math.imul(xr, yo) | 0,
            Mt = Mt + Math.imul(xr, Io) | 0,
            Mt = Mt + Math.imul(wr, yo) | 0,
            Yt = Yt + Math.imul(wr, Io) | 0;
            var gp = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (gp >>> 26) | 0,
            gp &= 67108863,
            Wt = Math.imul(Gt, ro),
            Mt = Math.imul(Gt, go),
            Mt = Mt + Math.imul(fn, ro) | 0,
            Yt = Math.imul(fn, go),
            Wt = Wt + Math.imul(br, xo) | 0,
            Mt = Mt + Math.imul(br, To) | 0,
            Mt = Mt + Math.imul(an, xo) | 0,
            Yt = Yt + Math.imul(an, To) | 0,
            Wt = Wt + Math.imul(or, mo) | 0,
            Mt = Mt + Math.imul(or, Ro) | 0,
            Mt = Mt + Math.imul(ir, mo) | 0,
            Yt = Yt + Math.imul(ir, Ro) | 0,
            Wt = Wt + Math.imul(Vn, yo) | 0,
            Mt = Mt + Math.imul(Vn, Io) | 0,
            Mt = Mt + Math.imul(qn, yo) | 0,
            Yt = Yt + Math.imul(qn, Io) | 0;
            var mp = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (mp >>> 26) | 0,
            mp &= 67108863,
            Wt = Math.imul(Gt, xo),
            Mt = Math.imul(Gt, To),
            Mt = Mt + Math.imul(fn, xo) | 0,
            Yt = Math.imul(fn, To),
            Wt = Wt + Math.imul(br, mo) | 0,
            Mt = Mt + Math.imul(br, Ro) | 0,
            Mt = Mt + Math.imul(an, mo) | 0,
            Yt = Yt + Math.imul(an, Ro) | 0,
            Wt = Wt + Math.imul(or, yo) | 0,
            Mt = Mt + Math.imul(or, Io) | 0,
            Mt = Mt + Math.imul(ir, yo) | 0,
            Yt = Yt + Math.imul(ir, Io) | 0;
            var Bu = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (Bu >>> 26) | 0,
            Bu &= 67108863,
            Wt = Math.imul(Gt, mo),
            Mt = Math.imul(Gt, Ro),
            Mt = Mt + Math.imul(fn, mo) | 0,
            Yt = Math.imul(fn, Ro),
            Wt = Wt + Math.imul(br, yo) | 0,
            Mt = Mt + Math.imul(br, Io) | 0,
            Mt = Mt + Math.imul(an, yo) | 0,
            Yt = Yt + Math.imul(an, Io) | 0;
            var yp = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            qt = (Yt + (Mt >>> 13) | 0) + (yp >>> 26) | 0,
            yp &= 67108863,
            Wt = Math.imul(Gt, yo),
            Mt = Math.imul(Gt, Io),
            Mt = Mt + Math.imul(fn, yo) | 0,
            Yt = Math.imul(fn, Io);
            var Uu = (qt + Wt | 0) + ((Mt & 8191) << 13) | 0;
            return qt = (Yt + (Mt >>> 13) | 0) + (Uu >>> 26) | 0,
            Uu &= 67108863,
            Ht[0] = ws,
            Ht[1] = Os,
            Ht[2] = Ws,
            Ht[3] = Hs,
            Ht[4] = xs,
            Ht[5] = Ss,
            Ht[6] = Nu,
            Ht[7] = $l,
            Ht[8] = Mu,
            Ht[9] = Pu,
            Ht[10] = Du,
            Ht[11] = cu,
            Ht[12] = uu,
            Ht[13] = du,
            Ht[14] = gp,
            Ht[15] = mp,
            Ht[16] = Bu,
            Ht[17] = yp,
            Ht[18] = Uu,
            qt !== 0 && (Ht[19] = qt,
            Dt.length++),
            Dt
        };
        Math.imul || (wt = _t);
        function St(zt, xt, $t) {
            $t.negative = xt.negative ^ zt.negative,
            $t.length = zt.length + xt.length;
            for (var Dt = 0, jt = 0, Ft = 0; Ft < $t.length - 1; Ft++) {
                var Ht = jt;
                jt = 0;
                for (var qt = Dt & 67108863, Wt = Math.min(Ft, xt.length - 1), Mt = Math.max(0, Ft - zt.length + 1); Mt <= Wt; Mt++) {
                    var Yt = Ft - Mt
                      , un = zt.words[Yt] | 0
                      , hn = xt.words[Mt] | 0
                      , _n = un * hn
                      , kn = _n & 67108863;
                    Ht = Ht + (_n / 67108864 | 0) | 0,
                    kn = kn + qt | 0,
                    qt = kn & 67108863,
                    Ht = Ht + (kn >>> 26) | 0,
                    jt += Ht >>> 26,
                    Ht &= 67108863
                }
                $t.words[Ft] = qt,
                Dt = Ht,
                Ht = jt
            }
            return Dt !== 0 ? $t.words[Ft] = Dt : $t.length--,
            $t._strip()
        }
        function Ct(zt, xt, $t) {
            return St(zt, xt, $t)
        }
        rt.prototype.mulTo = function(xt, $t) {
            var Dt, jt = this.length + xt.length;
            return this.length === 10 && xt.length === 10 ? Dt = wt(this, xt, $t) : jt < 63 ? Dt = _t(this, xt, $t) : jt < 1024 ? Dt = St(this, xt, $t) : Dt = Ct(this, xt, $t),
            Dt
        }
        ,
        rt.prototype.mul = function(xt) {
            var $t = new rt(null);
            return $t.words = new Array(this.length + xt.length),
            this.mulTo(xt, $t)
        }
        ,
        rt.prototype.mulf = function(xt) {
            var $t = new rt(null);
            return $t.words = new Array(this.length + xt.length),
            Ct(this, xt, $t)
        }
        ,
        rt.prototype.imul = function(xt) {
            return this.clone().mulTo(xt, this)
        }
        ,
        rt.prototype.imuln = function(xt) {
            var $t = xt < 0;
            $t && (xt = -xt),
            tt(typeof xt == "number"),
            tt(xt < 67108864);
            for (var Dt = 0, jt = 0; jt < this.length; jt++) {
                var Ft = (this.words[jt] | 0) * xt
                  , Ht = (Ft & 67108863) + (Dt & 67108863);
                Dt >>= 26,
                Dt += Ft / 67108864 | 0,
                Dt += Ht >>> 26,
                this.words[jt] = Ht & 67108863
            }
            return Dt !== 0 && (this.words[jt] = Dt,
            this.length++),
            $t ? this.ineg() : this
        }
        ,
        rt.prototype.muln = function(xt) {
            return this.clone().imuln(xt)
        }
        ,
        rt.prototype.sqr = function() {
            return this.mul(this)
        }
        ,
        rt.prototype.isqr = function() {
            return this.imul(this.clone())
        }
        ,
        rt.prototype.pow = function(xt) {
            var $t = Et(xt);
            if ($t.length === 0)
                return new rt(1);
            for (var Dt = this, jt = 0; jt < $t.length && $t[jt] === 0; jt++,
            Dt = Dt.sqr())
                ;
            if (++jt < $t.length)
                for (var Ft = Dt.sqr(); jt < $t.length; jt++,
                Ft = Ft.sqr())
                    $t[jt] !== 0 && (Dt = Dt.mul(Ft));
            return Dt
        }
        ,
        rt.prototype.iushln = function(xt) {
            tt(typeof xt == "number" && xt >= 0);
            var $t = xt % 26, Dt = (xt - $t) / 26, jt = 67108863 >>> 26 - $t << 26 - $t, Ft;
            if ($t !== 0) {
                var Ht = 0;
                for (Ft = 0; Ft < this.length; Ft++) {
                    var qt = this.words[Ft] & jt
                      , Wt = (this.words[Ft] | 0) - qt << $t;
                    this.words[Ft] = Wt | Ht,
                    Ht = qt >>> 26 - $t
                }
                Ht && (this.words[Ft] = Ht,
                this.length++)
            }
            if (Dt !== 0) {
                for (Ft = this.length - 1; Ft >= 0; Ft--)
                    this.words[Ft + Dt] = this.words[Ft];
                for (Ft = 0; Ft < Dt; Ft++)
                    this.words[Ft] = 0;
                this.length += Dt
            }
            return this._strip()
        }
        ,
        rt.prototype.ishln = function(xt) {
            return tt(this.negative === 0),
            this.iushln(xt)
        }
        ,
        rt.prototype.iushrn = function(xt, $t, Dt) {
            tt(typeof xt == "number" && xt >= 0);
            var jt;
            $t ? jt = ($t - $t % 26) / 26 : jt = 0;
            var Ft = xt % 26
              , Ht = Math.min((xt - Ft) / 26, this.length)
              , qt = 67108863 ^ 67108863 >>> Ft << Ft
              , Wt = Dt;
            if (jt -= Ht,
            jt = Math.max(0, jt),
            Wt) {
                for (var Mt = 0; Mt < Ht; Mt++)
                    Wt.words[Mt] = this.words[Mt];
                Wt.length = Ht
            }
            if (Ht !== 0)
                if (this.length > Ht)
                    for (this.length -= Ht,
                    Mt = 0; Mt < this.length; Mt++)
                        this.words[Mt] = this.words[Mt + Ht];
                else
                    this.words[0] = 0,
                    this.length = 1;
            var Yt = 0;
            for (Mt = this.length - 1; Mt >= 0 && (Yt !== 0 || Mt >= jt); Mt--) {
                var un = this.words[Mt] | 0;
                this.words[Mt] = Yt << 26 - Ft | un >>> Ft,
                Yt = un & qt
            }
            return Wt && Yt !== 0 && (Wt.words[Wt.length++] = Yt),
            this.length === 0 && (this.words[0] = 0,
            this.length = 1),
            this._strip()
        }
        ,
        rt.prototype.ishrn = function(xt, $t, Dt) {
            return tt(this.negative === 0),
            this.iushrn(xt, $t, Dt)
        }
        ,
        rt.prototype.shln = function(xt) {
            return this.clone().ishln(xt)
        }
        ,
        rt.prototype.ushln = function(xt) {
            return this.clone().iushln(xt)
        }
        ,
        rt.prototype.shrn = function(xt) {
            return this.clone().ishrn(xt)
        }
        ,
        rt.prototype.ushrn = function(xt) {
            return this.clone().iushrn(xt)
        }
        ,
        rt.prototype.testn = function(xt) {
            tt(typeof xt == "number" && xt >= 0);
            var $t = xt % 26
              , Dt = (xt - $t) / 26
              , jt = 1 << $t;
            if (this.length <= Dt)
                return !1;
            var Ft = this.words[Dt];
            return !!(Ft & jt)
        }
        ,
        rt.prototype.imaskn = function(xt) {
            tt(typeof xt == "number" && xt >= 0);
            var $t = xt % 26
              , Dt = (xt - $t) / 26;
            if (tt(this.negative === 0, "imaskn works only with positive numbers"),
            this.length <= Dt)
                return this;
            if ($t !== 0 && Dt++,
            this.length = Math.min(Dt, this.length),
            $t !== 0) {
                var jt = 67108863 ^ 67108863 >>> $t << $t;
                this.words[this.length - 1] &= jt
            }
            return this._strip()
        }
        ,
        rt.prototype.maskn = function(xt) {
            return this.clone().imaskn(xt)
        }
        ,
        rt.prototype.iaddn = function(xt) {
            return tt(typeof xt == "number"),
            tt(xt < 67108864),
            xt < 0 ? this.isubn(-xt) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= xt ? (this.words[0] = xt - (this.words[0] | 0),
            this.negative = 0,
            this) : (this.negative = 0,
            this.isubn(xt),
            this.negative = 1,
            this) : this._iaddn(xt)
        }
        ,
        rt.prototype._iaddn = function(xt) {
            this.words[0] += xt;
            for (var $t = 0; $t < this.length && this.words[$t] >= 67108864; $t++)
                this.words[$t] -= 67108864,
                $t === this.length - 1 ? this.words[$t + 1] = 1 : this.words[$t + 1]++;
            return this.length = Math.max(this.length, $t + 1),
            this
        }
        ,
        rt.prototype.isubn = function(xt) {
            if (tt(typeof xt == "number"),
            tt(xt < 67108864),
            xt < 0)
                return this.iaddn(-xt);
            if (this.negative !== 0)
                return this.negative = 0,
                this.iaddn(xt),
                this.negative = 1,
                this;
            if (this.words[0] -= xt,
            this.length === 1 && this.words[0] < 0)
                this.words[0] = -this.words[0],
                this.negative = 1;
            else
                for (var $t = 0; $t < this.length && this.words[$t] < 0; $t++)
                    this.words[$t] += 67108864,
                    this.words[$t + 1] -= 1;
            return this._strip()
        }
        ,
        rt.prototype.addn = function(xt) {
            return this.clone().iaddn(xt)
        }
        ,
        rt.prototype.subn = function(xt) {
            return this.clone().isubn(xt)
        }
        ,
        rt.prototype.iabs = function() {
            return this.negative = 0,
            this
        }
        ,
        rt.prototype.abs = function() {
            return this.clone().iabs()
        }
        ,
        rt.prototype._ishlnsubmul = function(xt, $t, Dt) {
            var jt = xt.length + Dt, Ft;
            this._expand(jt);
            var Ht, qt = 0;
            for (Ft = 0; Ft < xt.length; Ft++) {
                Ht = (this.words[Ft + Dt] | 0) + qt;
                var Wt = (xt.words[Ft] | 0) * $t;
                Ht -= Wt & 67108863,
                qt = (Ht >> 26) - (Wt / 67108864 | 0),
                this.words[Ft + Dt] = Ht & 67108863
            }
            for (; Ft < this.length - Dt; Ft++)
                Ht = (this.words[Ft + Dt] | 0) + qt,
                qt = Ht >> 26,
                this.words[Ft + Dt] = Ht & 67108863;
            if (qt === 0)
                return this._strip();
            for (tt(qt === -1),
            qt = 0,
            Ft = 0; Ft < this.length; Ft++)
                Ht = -(this.words[Ft] | 0) + qt,
                qt = Ht >> 26,
                this.words[Ft] = Ht & 67108863;
            return this.negative = 1,
            this._strip()
        }
        ,
        rt.prototype._wordDiv = function(xt, $t) {
            var Dt = this.length - xt.length
              , jt = this.clone()
              , Ft = xt
              , Ht = Ft.words[Ft.length - 1] | 0
              , qt = this._countBits(Ht);
            Dt = 26 - qt,
            Dt !== 0 && (Ft = Ft.ushln(Dt),
            jt.iushln(Dt),
            Ht = Ft.words[Ft.length - 1] | 0);
            var Wt = jt.length - Ft.length, Mt;
            if ($t !== "mod") {
                Mt = new rt(null),
                Mt.length = Wt + 1,
                Mt.words = new Array(Mt.length);
                for (var Yt = 0; Yt < Mt.length; Yt++)
                    Mt.words[Yt] = 0
            }
            var un = jt.clone()._ishlnsubmul(Ft, 1, Wt);
            un.negative === 0 && (jt = un,
            Mt && (Mt.words[Wt] = 1));
            for (var hn = Wt - 1; hn >= 0; hn--) {
                var _n = (jt.words[Ft.length + hn] | 0) * 67108864 + (jt.words[Ft.length + hn - 1] | 0);
                for (_n = Math.min(_n / Ht | 0, 67108863),
                jt._ishlnsubmul(Ft, _n, hn); jt.negative !== 0; )
                    _n--,
                    jt.negative = 0,
                    jt._ishlnsubmul(Ft, 1, hn),
                    jt.isZero() || (jt.negative ^= 1);
                Mt && (Mt.words[hn] = _n)
            }
            return Mt && Mt._strip(),
            jt._strip(),
            $t !== "div" && Dt !== 0 && jt.iushrn(Dt),
            {
                div: Mt || null,
                mod: jt
            }
        }
        ,
        rt.prototype.divmod = function(xt, $t, Dt) {
            if (tt(!xt.isZero()),
            this.isZero())
                return {
                    div: new rt(0),
                    mod: new rt(0)
                };
            var jt, Ft, Ht;
            return this.negative !== 0 && xt.negative === 0 ? (Ht = this.neg().divmod(xt, $t),
            $t !== "mod" && (jt = Ht.div.neg()),
            $t !== "div" && (Ft = Ht.mod.neg(),
            Dt && Ft.negative !== 0 && Ft.iadd(xt)),
            {
                div: jt,
                mod: Ft
            }) : this.negative === 0 && xt.negative !== 0 ? (Ht = this.divmod(xt.neg(), $t),
            $t !== "mod" && (jt = Ht.div.neg()),
            {
                div: jt,
                mod: Ht.mod
            }) : this.negative & xt.negative ? (Ht = this.neg().divmod(xt.neg(), $t),
            $t !== "div" && (Ft = Ht.mod.neg(),
            Dt && Ft.negative !== 0 && Ft.isub(xt)),
            {
                div: Ht.div,
                mod: Ft
            }) : xt.length > this.length || this.cmp(xt) < 0 ? {
                div: new rt(0),
                mod: this
            } : xt.length === 1 ? $t === "div" ? {
                div: this.divn(xt.words[0]),
                mod: null
            } : $t === "mod" ? {
                div: null,
                mod: new rt(this.modrn(xt.words[0]))
            } : {
                div: this.divn(xt.words[0]),
                mod: new rt(this.modrn(xt.words[0]))
            } : this._wordDiv(xt, $t)
        }
        ,
        rt.prototype.div = function(xt) {
            return this.divmod(xt, "div", !1).div
        }
        ,
        rt.prototype.mod = function(xt) {
            return this.divmod(xt, "mod", !1).mod
        }
        ,
        rt.prototype.umod = function(xt) {
            return this.divmod(xt, "mod", !0).mod
        }
        ,
        rt.prototype.divRound = function(xt) {
            var $t = this.divmod(xt);
            if ($t.mod.isZero())
                return $t.div;
            var Dt = $t.div.negative !== 0 ? $t.mod.isub(xt) : $t.mod
              , jt = xt.ushrn(1)
              , Ft = xt.andln(1)
              , Ht = Dt.cmp(jt);
            return Ht < 0 || Ft === 1 && Ht === 0 ? $t.div : $t.div.negative !== 0 ? $t.div.isubn(1) : $t.div.iaddn(1)
        }
        ,
        rt.prototype.modrn = function(xt) {
            var $t = xt < 0;
            $t && (xt = -xt),
            tt(xt <= 67108863);
            for (var Dt = (1 << 26) % xt, jt = 0, Ft = this.length - 1; Ft >= 0; Ft--)
                jt = (Dt * jt + (this.words[Ft] | 0)) % xt;
            return $t ? -jt : jt
        }
        ,
        rt.prototype.modn = function(xt) {
            return this.modrn(xt)
        }
        ,
        rt.prototype.idivn = function(xt) {
            var $t = xt < 0;
            $t && (xt = -xt),
            tt(xt <= 67108863);
            for (var Dt = 0, jt = this.length - 1; jt >= 0; jt--) {
                var Ft = (this.words[jt] | 0) + Dt * 67108864;
                this.words[jt] = Ft / xt | 0,
                Dt = Ft % xt
            }
            return this._strip(),
            $t ? this.ineg() : this
        }
        ,
        rt.prototype.divn = function(xt) {
            return this.clone().idivn(xt)
        }
        ,
        rt.prototype.egcd = function(xt) {
            tt(xt.negative === 0),
            tt(!xt.isZero());
            var $t = this
              , Dt = xt.clone();
            $t.negative !== 0 ? $t = $t.umod(xt) : $t = $t.clone();
            for (var jt = new rt(1), Ft = new rt(0), Ht = new rt(0), qt = new rt(1), Wt = 0; $t.isEven() && Dt.isEven(); )
                $t.iushrn(1),
                Dt.iushrn(1),
                ++Wt;
            for (var Mt = Dt.clone(), Yt = $t.clone(); !$t.isZero(); ) {
                for (var un = 0, hn = 1; !($t.words[0] & hn) && un < 26; ++un,
                hn <<= 1)
                    ;
                if (un > 0)
                    for ($t.iushrn(un); un-- > 0; )
                        (jt.isOdd() || Ft.isOdd()) && (jt.iadd(Mt),
                        Ft.isub(Yt)),
                        jt.iushrn(1),
                        Ft.iushrn(1);
                for (var _n = 0, kn = 1; !(Dt.words[0] & kn) && _n < 26; ++_n,
                kn <<= 1)
                    ;
                if (_n > 0)
                    for (Dt.iushrn(_n); _n-- > 0; )
                        (Ht.isOdd() || qt.isOdd()) && (Ht.iadd(Mt),
                        qt.isub(Yt)),
                        Ht.iushrn(1),
                        qt.iushrn(1);
                $t.cmp(Dt) >= 0 ? ($t.isub(Dt),
                jt.isub(Ht),
                Ft.isub(qt)) : (Dt.isub($t),
                Ht.isub(jt),
                qt.isub(Ft))
            }
            return {
                a: Ht,
                b: qt,
                gcd: Dt.iushln(Wt)
            }
        }
        ,
        rt.prototype._invmp = function(xt) {
            tt(xt.negative === 0),
            tt(!xt.isZero());
            var $t = this
              , Dt = xt.clone();
            $t.negative !== 0 ? $t = $t.umod(xt) : $t = $t.clone();
            for (var jt = new rt(1), Ft = new rt(0), Ht = Dt.clone(); $t.cmpn(1) > 0 && Dt.cmpn(1) > 0; ) {
                for (var qt = 0, Wt = 1; !($t.words[0] & Wt) && qt < 26; ++qt,
                Wt <<= 1)
                    ;
                if (qt > 0)
                    for ($t.iushrn(qt); qt-- > 0; )
                        jt.isOdd() && jt.iadd(Ht),
                        jt.iushrn(1);
                for (var Mt = 0, Yt = 1; !(Dt.words[0] & Yt) && Mt < 26; ++Mt,
                Yt <<= 1)
                    ;
                if (Mt > 0)
                    for (Dt.iushrn(Mt); Mt-- > 0; )
                        Ft.isOdd() && Ft.iadd(Ht),
                        Ft.iushrn(1);
                $t.cmp(Dt) >= 0 ? ($t.isub(Dt),
                jt.isub(Ft)) : (Dt.isub($t),
                Ft.isub(jt))
            }
            var un;
            return $t.cmpn(1) === 0 ? un = jt : un = Ft,
            un.cmpn(0) < 0 && un.iadd(xt),
            un
        }
        ,
        rt.prototype.gcd = function(xt) {
            if (this.isZero())
                return xt.abs();
            if (xt.isZero())
                return this.abs();
            var $t = this.clone()
              , Dt = xt.clone();
            $t.negative = 0,
            Dt.negative = 0;
            for (var jt = 0; $t.isEven() && Dt.isEven(); jt++)
                $t.iushrn(1),
                Dt.iushrn(1);
            do {
                for (; $t.isEven(); )
                    $t.iushrn(1);
                for (; Dt.isEven(); )
                    Dt.iushrn(1);
                var Ft = $t.cmp(Dt);
                if (Ft < 0) {
                    var Ht = $t;
                    $t = Dt,
                    Dt = Ht
                } else if (Ft === 0 || Dt.cmpn(1) === 0)
                    break;
                $t.isub(Dt)
            } while (!0);
            return Dt.iushln(jt)
        }
        ,
        rt.prototype.invm = function(xt) {
            return this.egcd(xt).a.umod(xt)
        }
        ,
        rt.prototype.isEven = function() {
            return (this.words[0] & 1) === 0
        }
        ,
        rt.prototype.isOdd = function() {
            return (this.words[0] & 1) === 1
        }
        ,
        rt.prototype.andln = function(xt) {
            return this.words[0] & xt
        }
        ,
        rt.prototype.bincn = function(xt) {
            tt(typeof xt == "number");
            var $t = xt % 26
              , Dt = (xt - $t) / 26
              , jt = 1 << $t;
            if (this.length <= Dt)
                return this._expand(Dt + 1),
                this.words[Dt] |= jt,
                this;
            for (var Ft = jt, Ht = Dt; Ft !== 0 && Ht < this.length; Ht++) {
                var qt = this.words[Ht] | 0;
                qt += Ft,
                Ft = qt >>> 26,
                qt &= 67108863,
                this.words[Ht] = qt
            }
            return Ft !== 0 && (this.words[Ht] = Ft,
            this.length++),
            this
        }
        ,
        rt.prototype.isZero = function() {
            return this.length === 1 && this.words[0] === 0
        }
        ,
        rt.prototype.cmpn = function(xt) {
            var $t = xt < 0;
            if (this.negative !== 0 && !$t)
                return -1;
            if (this.negative === 0 && $t)
                return 1;
            this._strip();
            var Dt;
            if (this.length > 1)
                Dt = 1;
            else {
                $t && (xt = -xt),
                tt(xt <= 67108863, "Number is too big");
                var jt = this.words[0] | 0;
                Dt = jt === xt ? 0 : jt < xt ? -1 : 1
            }
            return this.negative !== 0 ? -Dt | 0 : Dt
        }
        ,
        rt.prototype.cmp = function(xt) {
            if (this.negative !== 0 && xt.negative === 0)
                return -1;
            if (this.negative === 0 && xt.negative !== 0)
                return 1;
            var $t = this.ucmp(xt);
            return this.negative !== 0 ? -$t | 0 : $t
        }
        ,
        rt.prototype.ucmp = function(xt) {
            if (this.length > xt.length)
                return 1;
            if (this.length < xt.length)
                return -1;
            for (var $t = 0, Dt = this.length - 1; Dt >= 0; Dt--) {
                var jt = this.words[Dt] | 0
                  , Ft = xt.words[Dt] | 0;
                if (jt !== Ft) {
                    jt < Ft ? $t = -1 : jt > Ft && ($t = 1);
                    break
                }
            }
            return $t
        }
        ,
        rt.prototype.gtn = function(xt) {
            return this.cmpn(xt) === 1
        }
        ,
        rt.prototype.gt = function(xt) {
            return this.cmp(xt) === 1
        }
        ,
        rt.prototype.gten = function(xt) {
            return this.cmpn(xt) >= 0
        }
        ,
        rt.prototype.gte = function(xt) {
            return this.cmp(xt) >= 0
        }
        ,
        rt.prototype.ltn = function(xt) {
            return this.cmpn(xt) === -1
        }
        ,
        rt.prototype.lt = function(xt) {
            return this.cmp(xt) === -1
        }
        ,
        rt.prototype.lten = function(xt) {
            return this.cmpn(xt) <= 0
        }
        ,
        rt.prototype.lte = function(xt) {
            return this.cmp(xt) <= 0
        }
        ,
        rt.prototype.eqn = function(xt) {
            return this.cmpn(xt) === 0
        }
        ,
        rt.prototype.eq = function(xt) {
            return this.cmp(xt) === 0
        }
        ,
        rt.red = function(xt) {
            return new Xt(xt)
        }
        ,
        rt.prototype.toRed = function(xt) {
            return tt(!this.red, "Already a number in reduction context"),
            tt(this.negative === 0, "red works only with positives"),
            xt.convertTo(this)._forceRed(xt)
        }
        ,
        rt.prototype.fromRed = function() {
            return tt(this.red, "fromRed works only with numbers in reduction context"),
            this.red.convertFrom(this)
        }
        ,
        rt.prototype._forceRed = function(xt) {
            return this.red = xt,
            this
        }
        ,
        rt.prototype.forceRed = function(xt) {
            return tt(!this.red, "Already a number in reduction context"),
            this._forceRed(xt)
        }
        ,
        rt.prototype.redAdd = function(xt) {
            return tt(this.red, "redAdd works only with red numbers"),
            this.red.add(this, xt)
        }
        ,
        rt.prototype.redIAdd = function(xt) {
            return tt(this.red, "redIAdd works only with red numbers"),
            this.red.iadd(this, xt)
        }
        ,
        rt.prototype.redSub = function(xt) {
            return tt(this.red, "redSub works only with red numbers"),
            this.red.sub(this, xt)
        }
        ,
        rt.prototype.redISub = function(xt) {
            return tt(this.red, "redISub works only with red numbers"),
            this.red.isub(this, xt)
        }
        ,
        rt.prototype.redShl = function(xt) {
            return tt(this.red, "redShl works only with red numbers"),
            this.red.shl(this, xt)
        }
        ,
        rt.prototype.redMul = function(xt) {
            return tt(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, xt),
            this.red.mul(this, xt)
        }
        ,
        rt.prototype.redIMul = function(xt) {
            return tt(this.red, "redMul works only with red numbers"),
            this.red._verify2(this, xt),
            this.red.imul(this, xt)
        }
        ,
        rt.prototype.redSqr = function() {
            return tt(this.red, "redSqr works only with red numbers"),
            this.red._verify1(this),
            this.red.sqr(this)
        }
        ,
        rt.prototype.redISqr = function() {
            return tt(this.red, "redISqr works only with red numbers"),
            this.red._verify1(this),
            this.red.isqr(this)
        }
        ,
        rt.prototype.redSqrt = function() {
            return tt(this.red, "redSqrt works only with red numbers"),
            this.red._verify1(this),
            this.red.sqrt(this)
        }
        ,
        rt.prototype.redInvm = function() {
            return tt(this.red, "redInvm works only with red numbers"),
            this.red._verify1(this),
            this.red.invm(this)
        }
        ,
        rt.prototype.redNeg = function() {
            return tt(this.red, "redNeg works only with red numbers"),
            this.red._verify1(this),
            this.red.neg(this)
        }
        ,
        rt.prototype.redPow = function(xt) {
            return tt(this.red && !xt.red, "redPow(normalNum)"),
            this.red._verify1(this),
            this.red.pow(this, xt)
        }
        ;
        var Nt = {
            k256: null,
            p224: null,
            p192: null,
            p25519: null
        };
        function Lt(zt, xt) {
            this.name = zt,
            this.p = new rt(xt,16),
            this.n = this.p.bitLength(),
            this.k = new rt(1).iushln(this.n).isub(this.p),
            this.tmp = this._tmp()
        }
        Lt.prototype._tmp = function() {
            var xt = new rt(null);
            return xt.words = new Array(Math.ceil(this.n / 13)),
            xt
        }
        ,
        Lt.prototype.ireduce = function(xt) {
            var $t = xt, Dt;
            do
                this.split($t, this.tmp),
                $t = this.imulK($t),
                $t = $t.iadd(this.tmp),
                Dt = $t.bitLength();
            while (Dt > this.n);
            var jt = Dt < this.n ? -1 : $t.ucmp(this.p);
            return jt === 0 ? ($t.words[0] = 0,
            $t.length = 1) : jt > 0 ? $t.isub(this.p) : $t.strip !== void 0 ? $t.strip() : $t._strip(),
            $t
        }
        ,
        Lt.prototype.split = function(xt, $t) {
            xt.iushrn(this.n, 0, $t)
        }
        ,
        Lt.prototype.imulK = function(xt) {
            return xt.imul(this.k)
        }
        ;
        function kt() {
            Lt.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f")
        }
        nt(kt, Lt),
        kt.prototype.split = function(xt, $t) {
            for (var Dt = 4194303, jt = Math.min(xt.length, 9), Ft = 0; Ft < jt; Ft++)
                $t.words[Ft] = xt.words[Ft];
            if ($t.length = jt,
            xt.length <= 9) {
                xt.words[0] = 0,
                xt.length = 1;
                return
            }
            var Ht = xt.words[9];
            for ($t.words[$t.length++] = Ht & Dt,
            Ft = 10; Ft < xt.length; Ft++) {
                var qt = xt.words[Ft] | 0;
                xt.words[Ft - 10] = (qt & Dt) << 4 | Ht >>> 22,
                Ht = qt
            }
            Ht >>>= 22,
            xt.words[Ft - 10] = Ht,
            Ht === 0 && xt.length > 10 ? xt.length -= 10 : xt.length -= 9
        }
        ,
        kt.prototype.imulK = function(xt) {
            xt.words[xt.length] = 0,
            xt.words[xt.length + 1] = 0,
            xt.length += 2;
            for (var $t = 0, Dt = 0; Dt < xt.length; Dt++) {
                var jt = xt.words[Dt] | 0;
                $t += jt * 977,
                xt.words[Dt] = $t & 67108863,
                $t = jt * 64 + ($t / 67108864 | 0)
            }
            return xt.words[xt.length - 1] === 0 && (xt.length--,
            xt.words[xt.length - 1] === 0 && xt.length--),
            xt
        }
        ;
        function Ut() {
            Lt.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001")
        }
        nt(Ut, Lt);
        function Jt() {
            Lt.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff")
        }
        nt(Jt, Lt);
        function Pt() {
            Lt.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed")
        }
        nt(Pt, Lt),
        Pt.prototype.imulK = function(xt) {
            for (var $t = 0, Dt = 0; Dt < xt.length; Dt++) {
                var jt = (xt.words[Dt] | 0) * 19 + $t
                  , Ft = jt & 67108863;
                jt >>>= 26,
                xt.words[Dt] = Ft,
                $t = jt
            }
            return $t !== 0 && (xt.words[xt.length++] = $t),
            xt
        }
        ,
        rt._prime = function(xt) {
            if (Nt[xt])
                return Nt[xt];
            var $t;
            if (xt === "k256")
                $t = new kt;
            else if (xt === "p224")
                $t = new Ut;
            else if (xt === "p192")
                $t = new Jt;
            else if (xt === "p25519")
                $t = new Pt;
            else
                throw new Error("Unknown prime " + xt);
            return Nt[xt] = $t,
            $t
        }
        ;
        function Xt(zt) {
            if (typeof zt == "string") {
                var xt = rt._prime(zt);
                this.m = xt.p,
                this.prime = xt
            } else
                tt(zt.gtn(1), "modulus must be greater than 1"),
                this.m = zt,
                this.prime = null
        }
        Xt.prototype._verify1 = function(xt) {
            tt(xt.negative === 0, "red works only with positives"),
            tt(xt.red, "red works only with red numbers")
        }
        ,
        Xt.prototype._verify2 = function(xt, $t) {
            tt((xt.negative | $t.negative) === 0, "red works only with positives"),
            tt(xt.red && xt.red === $t.red, "red works only with red numbers")
        }
        ,
        Xt.prototype.imod = function(xt) {
            return this.prime ? this.prime.ireduce(xt)._forceRed(this) : (ct(xt, xt.umod(this.m)._forceRed(this)),
            xt)
        }
        ,
        Xt.prototype.neg = function(xt) {
            return xt.isZero() ? xt.clone() : this.m.sub(xt)._forceRed(this)
        }
        ,
        Xt.prototype.add = function(xt, $t) {
            this._verify2(xt, $t);
            var Dt = xt.add($t);
            return Dt.cmp(this.m) >= 0 && Dt.isub(this.m),
            Dt._forceRed(this)
        }
        ,
        Xt.prototype.iadd = function(xt, $t) {
            this._verify2(xt, $t);
            var Dt = xt.iadd($t);
            return Dt.cmp(this.m) >= 0 && Dt.isub(this.m),
            Dt
        }
        ,
        Xt.prototype.sub = function(xt, $t) {
            this._verify2(xt, $t);
            var Dt = xt.sub($t);
            return Dt.cmpn(0) < 0 && Dt.iadd(this.m),
            Dt._forceRed(this)
        }
        ,
        Xt.prototype.isub = function(xt, $t) {
            this._verify2(xt, $t);
            var Dt = xt.isub($t);
            return Dt.cmpn(0) < 0 && Dt.iadd(this.m),
            Dt
        }
        ,
        Xt.prototype.shl = function(xt, $t) {
            return this._verify1(xt),
            this.imod(xt.ushln($t))
        }
        ,
        Xt.prototype.imul = function(xt, $t) {
            return this._verify2(xt, $t),
            this.imod(xt.imul($t))
        }
        ,
        Xt.prototype.mul = function(xt, $t) {
            return this._verify2(xt, $t),
            this.imod(xt.mul($t))
        }
        ,
        Xt.prototype.isqr = function(xt) {
            return this.imul(xt, xt.clone())
        }
        ,
        Xt.prototype.sqr = function(xt) {
            return this.mul(xt, xt)
        }
        ,
        Xt.prototype.sqrt = function(xt) {
            if (xt.isZero())
                return xt.clone();
            var $t = this.m.andln(3);
            if (tt($t % 2 === 1),
            $t === 3) {
                var Dt = this.m.add(new rt(1)).iushrn(2);
                return this.pow(xt, Dt)
            }
            for (var jt = this.m.subn(1), Ft = 0; !jt.isZero() && jt.andln(1) === 0; )
                Ft++,
                jt.iushrn(1);
            tt(!jt.isZero());
            var Ht = new rt(1).toRed(this)
              , qt = Ht.redNeg()
              , Wt = this.m.subn(1).iushrn(1)
              , Mt = this.m.bitLength();
            for (Mt = new rt(2 * Mt * Mt).toRed(this); this.pow(Mt, Wt).cmp(qt) !== 0; )
                Mt.redIAdd(qt);
            for (var Yt = this.pow(Mt, jt), un = this.pow(xt, jt.addn(1).iushrn(1)), hn = this.pow(xt, jt), _n = Ft; hn.cmp(Ht) !== 0; ) {
                for (var kn = hn, Dn = 0; kn.cmp(Ht) !== 0; Dn++)
                    kn = kn.redSqr();
                tt(Dn < _n);
                var jn = this.pow(Yt, new rt(1).iushln(_n - Dn - 1));
                un = un.redMul(jn),
                Yt = jn.redSqr(),
                hn = hn.redMul(Yt),
                _n = Dn
            }
            return un
        }
        ,
        Xt.prototype.invm = function(xt) {
            var $t = xt._invmp(this.m);
            return $t.negative !== 0 ? ($t.negative = 0,
            this.imod($t).redNeg()) : this.imod($t)
        }
        ,
        Xt.prototype.pow = function(xt, $t) {
            if ($t.isZero())
                return new rt(1).toRed(this);
            if ($t.cmpn(1) === 0)
                return xt.clone();
            var Dt = 4
              , jt = new Array(1 << Dt);
            jt[0] = new rt(1).toRed(this),
            jt[1] = xt;
            for (var Ft = 2; Ft < jt.length; Ft++)
                jt[Ft] = this.mul(jt[Ft - 1], xt);
            var Ht = jt[0]
              , qt = 0
              , Wt = 0
              , Mt = $t.bitLength() % 26;
            for (Mt === 0 && (Mt = 26),
            Ft = $t.length - 1; Ft >= 0; Ft--) {
                for (var Yt = $t.words[Ft], un = Mt - 1; un >= 0; un--) {
                    var hn = Yt >> un & 1;
                    if (Ht !== jt[0] && (Ht = this.sqr(Ht)),
                    hn === 0 && qt === 0) {
                        Wt = 0;
                        continue
                    }
                    qt <<= 1,
                    qt |= hn,
                    Wt++,
                    !(Wt !== Dt && (Ft !== 0 || un !== 0)) && (Ht = this.mul(Ht, jt[qt]),
                    Wt = 0,
                    qt = 0)
                }
                Mt = 26
            }
            return Ht
        }
        ,
        Xt.prototype.convertTo = function(xt) {
            var $t = xt.umod(this.m);
            return $t === xt ? $t.clone() : $t
        }
        ,
        Xt.prototype.convertFrom = function(xt) {
            var $t = xt.clone();
            return $t.red = null,
            $t
        }
        ,
        rt.mont = function(xt) {
            return new rn(xt)
        }
        ;
        function rn(zt) {
            Xt.call(this, zt),
            this.shift = this.m.bitLength(),
            this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26),
            this.r = new rt(1).iushln(this.shift),
            this.r2 = this.imod(this.r.sqr()),
            this.rinv = this.r._invmp(this.m),
            this.minv = this.rinv.mul(this.r).isubn(1).div(this.m),
            this.minv = this.minv.umod(this.r),
            this.minv = this.r.sub(this.minv)
        }
        nt(rn, Xt),
        rn.prototype.convertTo = function(xt) {
            return this.imod(xt.ushln(this.shift))
        }
        ,
        rn.prototype.convertFrom = function(xt) {
            var $t = this.imod(xt.mul(this.rinv));
            return $t.red = null,
            $t
        }
        ,
        rn.prototype.imul = function(xt, $t) {
            if (xt.isZero() || $t.isZero())
                return xt.words[0] = 0,
                xt.length = 1,
                xt;
            var Dt = xt.imul($t)
              , jt = Dt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , Ft = Dt.isub(jt).iushrn(this.shift)
              , Ht = Ft;
            return Ft.cmp(this.m) >= 0 ? Ht = Ft.isub(this.m) : Ft.cmpn(0) < 0 && (Ht = Ft.iadd(this.m)),
            Ht._forceRed(this)
        }
        ,
        rn.prototype.mul = function(xt, $t) {
            if (xt.isZero() || $t.isZero())
                return new rt(0)._forceRed(this);
            var Dt = xt.mul($t)
              , jt = Dt.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m)
              , Ft = Dt.isub(jt).iushrn(this.shift)
              , Ht = Ft;
            return Ft.cmp(this.m) >= 0 ? Ht = Ft.isub(this.m) : Ft.cmpn(0) < 0 && (Ht = Ft.iadd(this.m)),
            Ht._forceRed(this)
        }
        ,
        rn.prototype.invm = function(xt) {
            var $t = this.imod(xt._invmp(this.m).mul(this.r2));
            return $t._forceRed(this)
        }
    }
    )(_e, commonjsGlobal$1)
}
)(bn);
var bnExports = bn.exports;
const BN = getDefaultExportFromCjs$2(bnExports);
var safeBuffer = {
    exports: {}
};
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(_e, $) {
    var et = require$$2$1
      , tt = et.Buffer;
    function nt(it, ot) {
        for (var st in it)
            ot[st] = it[st]
    }
    tt.from && tt.alloc && tt.allocUnsafe && tt.allocUnsafeSlow ? _e.exports = et : (nt(et, $),
    $.Buffer = rt);
    function rt(it, ot, st) {
        return tt(it, ot, st)
    }
    rt.prototype = Object.create(tt.prototype),
    nt(tt, rt),
    rt.from = function(it, ot, st) {
        if (typeof it == "number")
            throw new TypeError("Argument must not be a number");
        return tt(it, ot, st)
    }
    ,
    rt.alloc = function(it, ot, st) {
        if (typeof it != "number")
            throw new TypeError("Argument must be a number");
        var lt = tt(it);
        return ot !== void 0 ? typeof st == "string" ? lt.fill(ot, st) : lt.fill(ot) : lt.fill(0),
        lt
    }
    ,
    rt.allocUnsafe = function(it) {
        if (typeof it != "number")
            throw new TypeError("Argument must be a number");
        return tt(it)
    }
    ,
    rt.allocUnsafeSlow = function(it) {
        if (typeof it != "number")
            throw new TypeError("Argument must be a number");
        return et.SlowBuffer(it)
    }
}
)(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports
  , _Buffer = safeBufferExports.Buffer;
function base$2(_e) {
    if (_e.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var $ = new Uint8Array(256), et = 0; et < $.length; et++)
        $[et] = 255;
    for (var tt = 0; tt < _e.length; tt++) {
        var nt = _e.charAt(tt)
          , rt = nt.charCodeAt(0);
        if ($[rt] !== 255)
            throw new TypeError(nt + " is ambiguous");
        $[rt] = tt
    }
    var it = _e.length
      , ot = _e.charAt(0)
      , st = Math.log(it) / Math.log(256)
      , lt = Math.log(256) / Math.log(it);
    function ct(ht) {
        if ((Array.isArray(ht) || ht instanceof Uint8Array) && (ht = _Buffer.from(ht)),
        !_Buffer.isBuffer(ht))
            throw new TypeError("Expected Buffer");
        if (ht.length === 0)
            return "";
        for (var mt = 0, yt = 0, Et = 0, _t = ht.length; Et !== _t && ht[Et] === 0; )
            Et++,
            mt++;
        for (var wt = (_t - Et) * lt + 1 >>> 0, St = new Uint8Array(wt); Et !== _t; ) {
            for (var Ct = ht[Et], Nt = 0, Lt = wt - 1; (Ct !== 0 || Nt < yt) && Lt !== -1; Lt--,
            Nt++)
                Ct += 256 * St[Lt] >>> 0,
                St[Lt] = Ct % it >>> 0,
                Ct = Ct / it >>> 0;
            if (Ct !== 0)
                throw new Error("Non-zero carry");
            yt = Nt,
            Et++
        }
        for (var kt = wt - yt; kt !== wt && St[kt] === 0; )
            kt++;
        for (var Ut = ot.repeat(mt); kt < wt; ++kt)
            Ut += _e.charAt(St[kt]);
        return Ut
    }
    function dt(ht) {
        if (typeof ht != "string")
            throw new TypeError("Expected String");
        if (ht.length === 0)
            return _Buffer.alloc(0);
        for (var mt = 0, yt = 0, Et = 0; ht[mt] === ot; )
            yt++,
            mt++;
        for (var _t = (ht.length - mt) * st + 1 >>> 0, wt = new Uint8Array(_t); mt < ht.length; ) {
            var St = $[ht.charCodeAt(mt)];
            if (St === 255)
                return;
            for (var Ct = 0, Nt = _t - 1; (St !== 0 || Ct < Et) && Nt !== -1; Nt--,
            Ct++)
                St += it * wt[Nt] >>> 0,
                wt[Nt] = St % 256 >>> 0,
                St = St / 256 >>> 0;
            if (St !== 0)
                throw new Error("Non-zero carry");
            Et = Ct,
            mt++
        }
        for (var Lt = _t - Et; Lt !== _t && wt[Lt] === 0; )
            Lt++;
        var kt = _Buffer.allocUnsafe(yt + (_t - Lt));
        kt.fill(0, 0, yt);
        for (var Ut = yt; Lt !== _t; )
            kt[Ut++] = wt[Lt++];
        return kt
    }
    function pt(ht) {
        var mt = dt(ht);
        if (mt)
            return mt;
        throw new Error("Non-base" + it + " character")
    }
    return {
        encode: ct,
        decodeUnsafe: dt,
        decode: pt
    }
}
var src$1 = base$2
  , basex$1 = src$1
  , ALPHABET$3 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
  , bs58$2 = basex$1(ALPHABET$3);
const bs58$3 = getDefaultExportFromCjs$2(bs58$2)
  , SHA256_K = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298])
  , SHA256_IV = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225])
  , SHA256_W = new Uint32Array(64);
class SHA256 extends HashMD {
    constructor() {
        super(64, 32, 8, !1),
        this.A = SHA256_IV[0] | 0,
        this.B = SHA256_IV[1] | 0,
        this.C = SHA256_IV[2] | 0,
        this.D = SHA256_IV[3] | 0,
        this.E = SHA256_IV[4] | 0,
        this.F = SHA256_IV[5] | 0,
        this.G = SHA256_IV[6] | 0,
        this.H = SHA256_IV[7] | 0
    }
    get() {
        const {A: $, B: et, C: tt, D: nt, E: rt, F: it, G: ot, H: st} = this;
        return [$, et, tt, nt, rt, it, ot, st]
    }
    set($, et, tt, nt, rt, it, ot, st) {
        this.A = $ | 0,
        this.B = et | 0,
        this.C = tt | 0,
        this.D = nt | 0,
        this.E = rt | 0,
        this.F = it | 0,
        this.G = ot | 0,
        this.H = st | 0
    }
    process($, et) {
        for (let dt = 0; dt < 16; dt++,
        et += 4)
            SHA256_W[dt] = $.getUint32(et, !1);
        for (let dt = 16; dt < 64; dt++) {
            const pt = SHA256_W[dt - 15]
              , ht = SHA256_W[dt - 2]
              , mt = rotr(pt, 7) ^ rotr(pt, 18) ^ pt >>> 3
              , yt = rotr(ht, 17) ^ rotr(ht, 19) ^ ht >>> 10;
            SHA256_W[dt] = yt + SHA256_W[dt - 7] + mt + SHA256_W[dt - 16] | 0
        }
        let {A: tt, B: nt, C: rt, D: it, E: ot, F: st, G: lt, H: ct} = this;
        for (let dt = 0; dt < 64; dt++) {
            const pt = rotr(ot, 6) ^ rotr(ot, 11) ^ rotr(ot, 25)
              , ht = ct + pt + Chi(ot, st, lt) + SHA256_K[dt] + SHA256_W[dt] | 0
              , yt = (rotr(tt, 2) ^ rotr(tt, 13) ^ rotr(tt, 22)) + Maj(tt, nt, rt) | 0;
            ct = lt,
            lt = st,
            st = ot,
            ot = it + ht | 0,
            it = rt,
            rt = nt,
            nt = tt,
            tt = ht + yt | 0
        }
        tt = tt + this.A | 0,
        nt = nt + this.B | 0,
        rt = rt + this.C | 0,
        it = it + this.D | 0,
        ot = ot + this.E | 0,
        st = st + this.F | 0,
        lt = lt + this.G | 0,
        ct = ct + this.H | 0,
        this.set(tt, nt, rt, it, ot, st, lt, ct)
    }
    roundClean() {
        SHA256_W.fill(0)
    }
    destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0),
        this.buffer.fill(0)
    }
}
const sha256 = wrapConstructor( () => new SHA256);
var lib = {};
function inRange(_e, $, et) {
    return $ <= _e && _e <= et
}
function ToDictionary(_e) {
    if (_e === void 0)
        return {};
    if (_e === Object(_e))
        return _e;
    throw TypeError("Could not convert argument to dictionary")
}
function stringToCodePoints(_e) {
    for (var $ = String(_e), et = $.length, tt = 0, nt = []; tt < et; ) {
        var rt = $.charCodeAt(tt);
        if (rt < 55296 || rt > 57343)
            nt.push(rt);
        else if (56320 <= rt && rt <= 57343)
            nt.push(65533);
        else if (55296 <= rt && rt <= 56319)
            if (tt === et - 1)
                nt.push(65533);
            else {
                var it = _e.charCodeAt(tt + 1);
                if (56320 <= it && it <= 57343) {
                    var ot = rt & 1023
                      , st = it & 1023;
                    nt.push(65536 + (ot << 10) + st),
                    tt += 1
                } else
                    nt.push(65533)
            }
        tt += 1
    }
    return nt
}
function codePointsToString(_e) {
    for (var $ = "", et = 0; et < _e.length; ++et) {
        var tt = _e[et];
        tt <= 65535 ? $ += String.fromCharCode(tt) : (tt -= 65536,
        $ += String.fromCharCode((tt >> 10) + 55296, (tt & 1023) + 56320))
    }
    return $
}
var end_of_stream = -1;
function Stream(_e) {
    this.tokens = [].slice.call(_e)
}
Stream.prototype = {
    endOfStream: function() {
        return !this.tokens.length
    },
    read: function() {
        return this.tokens.length ? this.tokens.shift() : end_of_stream
    },
    prepend: function(_e) {
        if (Array.isArray(_e))
            for (var $ = _e; $.length; )
                this.tokens.unshift($.pop());
        else
            this.tokens.unshift(_e)
    },
    push: function(_e) {
        if (Array.isArray(_e))
            for (var $ = _e; $.length; )
                this.tokens.push($.shift());
        else
            this.tokens.push(_e)
    }
};
var finished = -1;
function decoderError(_e, $) {
    if (_e)
        throw TypeError("Decoder error");
    return $ || 65533
}
var DEFAULT_ENCODING = "utf-8";
function TextDecoder$1(_e, $) {
    if (!(this instanceof TextDecoder$1))
        return new TextDecoder$1(_e,$);
    if (_e = _e !== void 0 ? String(_e).toLowerCase() : DEFAULT_ENCODING,
    _e !== DEFAULT_ENCODING)
        throw new Error("Encoding not supported. Only utf-8 is supported");
    $ = ToDictionary($),
    this._streaming = !1,
    this._BOMseen = !1,
    this._decoder = null,
    this._fatal = !!$.fatal,
    this._ignoreBOM = !!$.ignoreBOM,
    Object.defineProperty(this, "encoding", {
        value: "utf-8"
    }),
    Object.defineProperty(this, "fatal", {
        value: this._fatal
    }),
    Object.defineProperty(this, "ignoreBOM", {
        value: this._ignoreBOM
    })
}
TextDecoder$1.prototype = {
    decode: function($, et) {
        var tt;
        typeof $ == "object" && $ instanceof ArrayBuffer ? tt = new Uint8Array($) : typeof $ == "object" && "buffer"in $ && $.buffer instanceof ArrayBuffer ? tt = new Uint8Array($.buffer,$.byteOffset,$.byteLength) : tt = new Uint8Array(0),
        et = ToDictionary(et),
        this._streaming || (this._decoder = new UTF8Decoder({
            fatal: this._fatal
        }),
        this._BOMseen = !1),
        this._streaming = !!et.stream;
        for (var nt = new Stream(tt), rt = [], it; !nt.endOfStream() && (it = this._decoder.handler(nt, nt.read()),
        it !== finished); )
            it !== null && (Array.isArray(it) ? rt.push.apply(rt, it) : rt.push(it));
        if (!this._streaming) {
            do {
                if (it = this._decoder.handler(nt, nt.read()),
                it === finished)
                    break;
                it !== null && (Array.isArray(it) ? rt.push.apply(rt, it) : rt.push(it))
            } while (!nt.endOfStream());
            this._decoder = null
        }
        return rt.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (rt[0] === 65279 ? (this._BOMseen = !0,
        rt.shift()) : this._BOMseen = !0),
        codePointsToString(rt)
    }
};
function TextEncoder$1(_e, $) {
    if (!(this instanceof TextEncoder$1))
        return new TextEncoder$1(_e,$);
    if (_e = _e !== void 0 ? String(_e).toLowerCase() : DEFAULT_ENCODING,
    _e !== DEFAULT_ENCODING)
        throw new Error("Encoding not supported. Only utf-8 is supported");
    $ = ToDictionary($),
    this._streaming = !1,
    this._encoder = null,
    this._options = {
        fatal: !!$.fatal
    },
    Object.defineProperty(this, "encoding", {
        value: "utf-8"
    })
}
TextEncoder$1.prototype = {
    encode: function($, et) {
        $ = $ ? String($) : "",
        et = ToDictionary(et),
        this._streaming || (this._encoder = new UTF8Encoder(this._options)),
        this._streaming = !!et.stream;
        for (var tt = [], nt = new Stream(stringToCodePoints($)), rt; !nt.endOfStream() && (rt = this._encoder.handler(nt, nt.read()),
        rt !== finished); )
            Array.isArray(rt) ? tt.push.apply(tt, rt) : tt.push(rt);
        if (!this._streaming) {
            for (; rt = this._encoder.handler(nt, nt.read()),
            rt !== finished; )
                Array.isArray(rt) ? tt.push.apply(tt, rt) : tt.push(rt);
            this._encoder = null
        }
        return new Uint8Array(tt)
    }
};
function UTF8Decoder(_e) {
    var $ = _e.fatal
      , et = 0
      , tt = 0
      , nt = 0
      , rt = 128
      , it = 191;
    this.handler = function(ot, st) {
        if (st === end_of_stream && nt !== 0)
            return nt = 0,
            decoderError($);
        if (st === end_of_stream)
            return finished;
        if (nt === 0) {
            if (inRange(st, 0, 127))
                return st;
            if (inRange(st, 194, 223))
                nt = 1,
                et = st - 192;
            else if (inRange(st, 224, 239))
                st === 224 && (rt = 160),
                st === 237 && (it = 159),
                nt = 2,
                et = st - 224;
            else if (inRange(st, 240, 244))
                st === 240 && (rt = 144),
                st === 244 && (it = 143),
                nt = 3,
                et = st - 240;
            else
                return decoderError($);
            return et = et << 6 * nt,
            null
        }
        if (!inRange(st, rt, it))
            return et = nt = tt = 0,
            rt = 128,
            it = 191,
            ot.prepend(st),
            decoderError($);
        if (rt = 128,
        it = 191,
        tt += 1,
        et += st - 128 << 6 * (nt - tt),
        tt !== nt)
            return null;
        var lt = et;
        return et = nt = tt = 0,
        lt
    }
}
function UTF8Encoder(_e) {
    _e.fatal,
    this.handler = function($, et) {
        if (et === end_of_stream)
            return finished;
        if (inRange(et, 0, 127))
            return et;
        var tt, nt;
        inRange(et, 128, 2047) ? (tt = 1,
        nt = 192) : inRange(et, 2048, 65535) ? (tt = 2,
        nt = 224) : inRange(et, 65536, 1114111) && (tt = 3,
        nt = 240);
        for (var rt = [(et >> 6 * tt) + nt]; tt > 0; ) {
            var it = et >> 6 * (tt - 1);
            rt.push(128 | it & 63),
            tt -= 1
        }
        return rt
    }
}
const encoding$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    TextDecoder: TextDecoder$1,
    TextEncoder: TextEncoder$1
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$2 = getAugmentedNamespace(encoding$1);
var __createBinding = commonjsGlobal$1 && commonjsGlobal$1.__createBinding || (Object.create ? function(_e, $, et, tt) {
    tt === void 0 && (tt = et),
    Object.defineProperty(_e, tt, {
        enumerable: !0,
        get: function() {
            return $[et]
        }
    })
}
: function(_e, $, et, tt) {
    tt === void 0 && (tt = et),
    _e[tt] = $[et]
}
)
  , __setModuleDefault = commonjsGlobal$1 && commonjsGlobal$1.__setModuleDefault || (Object.create ? function(_e, $) {
    Object.defineProperty(_e, "default", {
        enumerable: !0,
        value: $
    })
}
: function(_e, $) {
    _e.default = $
}
)
  , __decorate = commonjsGlobal$1 && commonjsGlobal$1.__decorate || function(_e, $, et, tt) {
    var nt = arguments.length, rt = nt < 3 ? $ : tt === null ? tt = Object.getOwnPropertyDescriptor($, et) : tt, it;
    if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
        rt = Reflect.decorate(_e, $, et, tt);
    else
        for (var ot = _e.length - 1; ot >= 0; ot--)
            (it = _e[ot]) && (rt = (nt < 3 ? it(rt) : nt > 3 ? it($, et, rt) : it($, et)) || rt);
    return nt > 3 && rt && Object.defineProperty($, et, rt),
    rt
}
  , __importStar = commonjsGlobal$1 && commonjsGlobal$1.__importStar || function(_e) {
    if (_e && _e.__esModule)
        return _e;
    var $ = {};
    if (_e != null)
        for (var et in _e)
            et !== "default" && Object.hasOwnProperty.call(_e, et) && __createBinding($, _e, et);
    return __setModuleDefault($, _e),
    $
}
  , __importDefault$1 = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(_e) {
    return _e && _e.__esModule ? _e : {
        default: _e
    }
}
;
Object.defineProperty(lib, "__esModule", {
    value: !0
});
var deserializeUnchecked_1 = lib.deserializeUnchecked = deserialize_1 = lib.deserialize = serialize_1 = lib.serialize = lib.BinaryReader = lib.BinaryWriter = lib.BorshError = lib.baseDecode = lib.baseEncode = void 0;
const bn_js_1 = __importDefault$1(bnExports)
  , bs58_1 = __importDefault$1(bs58$2)
  , encoding = __importStar(require$$2)
  , ResolvedTextDecoder = typeof TextDecoder != "function" ? encoding.TextDecoder : TextDecoder
  , textDecoder = new ResolvedTextDecoder("utf-8",{
    fatal: !0
});
function baseEncode(_e) {
    return typeof _e == "string" && (_e = Buffer$2.from(_e, "utf8")),
    bs58_1.default.encode(Buffer$2.from(_e))
}
lib.baseEncode = baseEncode;
function baseDecode(_e) {
    return Buffer$2.from(bs58_1.default.decode(_e))
}
lib.baseDecode = baseDecode;
const INITIAL_LENGTH = 1024;
class BorshError extends Error {
    constructor($) {
        super($),
        this.fieldPath = [],
        this.originalMessage = $
    }
    addToFieldPath($) {
        this.fieldPath.splice(0, 0, $),
        this.message = this.originalMessage + ": " + this.fieldPath.join(".")
    }
}
lib.BorshError = BorshError;
class BinaryWriter {
    constructor() {
        this.buf = Buffer$2.alloc(INITIAL_LENGTH),
        this.length = 0
    }
    maybeResize() {
        this.buf.length < 16 + this.length && (this.buf = Buffer$2.concat([this.buf, Buffer$2.alloc(INITIAL_LENGTH)]))
    }
    writeU8($) {
        this.maybeResize(),
        this.buf.writeUInt8($, this.length),
        this.length += 1
    }
    writeU16($) {
        this.maybeResize(),
        this.buf.writeUInt16LE($, this.length),
        this.length += 2
    }
    writeU32($) {
        this.maybeResize(),
        this.buf.writeUInt32LE($, this.length),
        this.length += 4
    }
    writeU64($) {
        this.maybeResize(),
        this.writeBuffer(Buffer$2.from(new bn_js_1.default($).toArray("le", 8)))
    }
    writeU128($) {
        this.maybeResize(),
        this.writeBuffer(Buffer$2.from(new bn_js_1.default($).toArray("le", 16)))
    }
    writeU256($) {
        this.maybeResize(),
        this.writeBuffer(Buffer$2.from(new bn_js_1.default($).toArray("le", 32)))
    }
    writeU512($) {
        this.maybeResize(),
        this.writeBuffer(Buffer$2.from(new bn_js_1.default($).toArray("le", 64)))
    }
    writeBuffer($) {
        this.buf = Buffer$2.concat([Buffer$2.from(this.buf.subarray(0, this.length)), $, Buffer$2.alloc(INITIAL_LENGTH)]),
        this.length += $.length
    }
    writeString($) {
        this.maybeResize();
        const et = Buffer$2.from($, "utf8");
        this.writeU32(et.length),
        this.writeBuffer(et)
    }
    writeFixedArray($) {
        this.writeBuffer(Buffer$2.from($))
    }
    writeArray($, et) {
        this.maybeResize(),
        this.writeU32($.length);
        for (const tt of $)
            this.maybeResize(),
            et(tt)
    }
    toArray() {
        return this.buf.subarray(0, this.length)
    }
}
lib.BinaryWriter = BinaryWriter;
function handlingRangeError(_e, $, et) {
    const tt = et.value;
    et.value = function(...nt) {
        try {
            return tt.apply(this, nt)
        } catch (rt) {
            if (rt instanceof RangeError) {
                const it = rt.code;
                if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(it) >= 0)
                    throw new BorshError("Reached the end of buffer when deserializing")
            }
            throw rt
        }
    }
}
class BinaryReader {
    constructor($) {
        this.buf = $,
        this.offset = 0
    }
    readU8() {
        const $ = this.buf.readUInt8(this.offset);
        return this.offset += 1,
        $
    }
    readU16() {
        const $ = this.buf.readUInt16LE(this.offset);
        return this.offset += 2,
        $
    }
    readU32() {
        const $ = this.buf.readUInt32LE(this.offset);
        return this.offset += 4,
        $
    }
    readU64() {
        const $ = this.readBuffer(8);
        return new bn_js_1.default($,"le")
    }
    readU128() {
        const $ = this.readBuffer(16);
        return new bn_js_1.default($,"le")
    }
    readU256() {
        const $ = this.readBuffer(32);
        return new bn_js_1.default($,"le")
    }
    readU512() {
        const $ = this.readBuffer(64);
        return new bn_js_1.default($,"le")
    }
    readBuffer($) {
        if (this.offset + $ > this.buf.length)
            throw new BorshError(`Expected buffer length ${$} isn't within bounds`);
        const et = this.buf.slice(this.offset, this.offset + $);
        return this.offset += $,
        et
    }
    readString() {
        const $ = this.readU32()
          , et = this.readBuffer($);
        try {
            return textDecoder.decode(et)
        } catch (tt) {
            throw new BorshError(`Error decoding UTF-8 string: ${tt}`)
        }
    }
    readFixedArray($) {
        return new Uint8Array(this.readBuffer($))
    }
    readArray($) {
        const et = this.readU32()
          , tt = Array();
        for (let nt = 0; nt < et; ++nt)
            tt.push($());
        return tt
    }
}
__decorate([handlingRangeError], BinaryReader.prototype, "readU8", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readU16", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readU32", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readU64", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readU128", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readU256", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readU512", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readString", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readFixedArray", null);
__decorate([handlingRangeError], BinaryReader.prototype, "readArray", null);
lib.BinaryReader = BinaryReader;
function capitalizeFirstLetter(_e) {
    return _e.charAt(0).toUpperCase() + _e.slice(1)
}
function serializeField(_e, $, et, tt, nt) {
    try {
        if (typeof tt == "string")
            nt[`write${capitalizeFirstLetter(tt)}`](et);
        else if (tt instanceof Array)
            if (typeof tt[0] == "number") {
                if (et.length !== tt[0])
                    throw new BorshError(`Expecting byte array of length ${tt[0]}, but got ${et.length} bytes`);
                nt.writeFixedArray(et)
            } else if (tt.length === 2 && typeof tt[1] == "number") {
                if (et.length !== tt[1])
                    throw new BorshError(`Expecting byte array of length ${tt[1]}, but got ${et.length} bytes`);
                for (let rt = 0; rt < tt[1]; rt++)
                    serializeField(_e, null, et[rt], tt[0], nt)
            } else
                nt.writeArray(et, rt => {
                    serializeField(_e, $, rt, tt[0], nt)
                }
                );
        else if (tt.kind !== void 0)
            switch (tt.kind) {
            case "option":
                {
                    et == null ? nt.writeU8(0) : (nt.writeU8(1),
                    serializeField(_e, $, et, tt.type, nt));
                    break
                }
            case "map":
                {
                    nt.writeU32(et.size),
                    et.forEach( (rt, it) => {
                        serializeField(_e, $, it, tt.key, nt),
                        serializeField(_e, $, rt, tt.value, nt)
                    }
                    );
                    break
                }
            default:
                throw new BorshError(`FieldType ${tt} unrecognized`)
            }
        else
            serializeStruct(_e, et, nt)
    } catch (rt) {
        throw rt instanceof BorshError && rt.addToFieldPath($),
        rt
    }
}
function serializeStruct(_e, $, et) {
    if (typeof $.borshSerialize == "function") {
        $.borshSerialize(et);
        return
    }
    const tt = _e.get($.constructor);
    if (!tt)
        throw new BorshError(`Class ${$.constructor.name} is missing in schema`);
    if (tt.kind === "struct")
        tt.fields.map( ([nt,rt]) => {
            serializeField(_e, nt, $[nt], rt, et)
        }
        );
    else if (tt.kind === "enum") {
        const nt = $[tt.field];
        for (let rt = 0; rt < tt.values.length; ++rt) {
            const [it,ot] = tt.values[rt];
            if (it === nt) {
                et.writeU8(rt),
                serializeField(_e, it, $[it], ot, et);
                break
            }
        }
    } else
        throw new BorshError(`Unexpected schema kind: ${tt.kind} for ${$.constructor.name}`)
}
function serialize$1(_e, $, et=BinaryWriter) {
    const tt = new et;
    return serializeStruct(_e, $, tt),
    tt.toArray()
}
var serialize_1 = lib.serialize = serialize$1;
function deserializeField(_e, $, et, tt) {
    try {
        if (typeof et == "string")
            return tt[`read${capitalizeFirstLetter(et)}`]();
        if (et instanceof Array) {
            if (typeof et[0] == "number")
                return tt.readFixedArray(et[0]);
            if (typeof et[1] == "number") {
                const nt = [];
                for (let rt = 0; rt < et[1]; rt++)
                    nt.push(deserializeField(_e, null, et[0], tt));
                return nt
            } else
                return tt.readArray( () => deserializeField(_e, $, et[0], tt))
        }
        if (et.kind === "option")
            return tt.readU8() ? deserializeField(_e, $, et.type, tt) : void 0;
        if (et.kind === "map") {
            let nt = new Map;
            const rt = tt.readU32();
            for (let it = 0; it < rt; it++) {
                const ot = deserializeField(_e, $, et.key, tt)
                  , st = deserializeField(_e, $, et.value, tt);
                nt.set(ot, st)
            }
            return nt
        }
        return deserializeStruct(_e, et, tt)
    } catch (nt) {
        throw nt instanceof BorshError && nt.addToFieldPath($),
        nt
    }
}
function deserializeStruct(_e, $, et) {
    if (typeof $.borshDeserialize == "function")
        return $.borshDeserialize(et);
    const tt = _e.get($);
    if (!tt)
        throw new BorshError(`Class ${$.name} is missing in schema`);
    if (tt.kind === "struct") {
        const nt = {};
        for (const [rt,it] of _e.get($).fields)
            nt[rt] = deserializeField(_e, rt, it, et);
        return new $(nt)
    }
    if (tt.kind === "enum") {
        const nt = et.readU8();
        if (nt >= tt.values.length)
            throw new BorshError(`Enum index: ${nt} is out of range`);
        const [rt,it] = tt.values[nt]
          , ot = deserializeField(_e, rt, it, et);
        return new $({
            [rt]: ot
        })
    }
    throw new BorshError(`Unexpected schema kind: ${tt.kind} for ${$.constructor.name}`)
}
function deserialize(_e, $, et, tt=BinaryReader) {
    const nt = new tt(et)
      , rt = deserializeStruct(_e, $, nt);
    if (nt.offset < et.length)
        throw new BorshError(`Unexpected ${et.length - nt.offset} bytes after deserialized data`);
    return rt
}
var deserialize_1 = lib.deserialize = deserialize;
function deserializeUnchecked(_e, $, et, tt=BinaryReader) {
    const nt = new tt(et);
    return deserializeStruct(_e, $, nt)
}
deserializeUnchecked_1 = lib.deserializeUnchecked = deserializeUnchecked;
var Layout$4 = {};
Object.defineProperty(Layout$4, "__esModule", {
    value: !0
});
var s16 = Layout$4.s16 = Layout$4.s8 = Layout$4.nu64be = Layout$4.u48be = Layout$4.u40be = Layout$4.u32be = Layout$4.u24be = Layout$4.u16be = nu64$1 = Layout$4.nu64 = Layout$4.u48 = Layout$4.u40 = u32$1 = Layout$4.u32 = Layout$4.u24 = u16 = Layout$4.u16 = u8$1 = Layout$4.u8 = offset$1 = Layout$4.offset = greedy = Layout$4.greedy = Layout$4.Constant = Layout$4.UTF8 = Layout$4.CString = Layout$4.Blob = Layout$4.Boolean = Layout$4.BitField = Layout$4.BitStructure = Layout$4.VariantLayout = Layout$4.Union = Layout$4.UnionLayoutDiscriminator = Layout$4.UnionDiscriminator = Layout$4.Structure = Layout$4.Sequence = Layout$4.DoubleBE = Layout$4.Double = Layout$4.FloatBE = Layout$4.Float = Layout$4.NearInt64BE = Layout$4.NearInt64 = Layout$4.NearUInt64BE = Layout$4.NearUInt64 = Layout$4.IntBE = Layout$4.Int = Layout$4.UIntBE = Layout$4.UInt = Layout$4.OffsetLayout = Layout$4.GreedyCount = Layout$4.ExternalLayout = Layout$4.bindConstructorLayout = Layout$4.nameWithProperty = Layout$4.Layout = Layout$4.uint8ArrayToBuffer = Layout$4.checkUint8Array = void 0;
Layout$4.constant = Layout$4.utf8 = Layout$4.cstr = blob$1 = Layout$4.blob = Layout$4.unionLayoutDiscriminator = Layout$4.union = seq = Layout$4.seq = Layout$4.bits = struct$1 = Layout$4.struct = Layout$4.f64be = f64 = Layout$4.f64 = Layout$4.f32be = Layout$4.f32 = Layout$4.ns64be = Layout$4.s48be = Layout$4.s40be = Layout$4.s32be = Layout$4.s24be = Layout$4.s16be = ns64$1 = Layout$4.ns64 = Layout$4.s48 = Layout$4.s40 = Layout$4.s32 = Layout$4.s24 = void 0;
const buffer_1 = require$$2$1;
function checkUint8Array(_e) {
    if (!(_e instanceof Uint8Array))
        throw new TypeError("b must be a Uint8Array")
}
Layout$4.checkUint8Array = checkUint8Array;
function uint8ArrayToBuffer(_e) {
    return checkUint8Array(_e),
    buffer_1.Buffer.from(_e.buffer, _e.byteOffset, _e.length)
}
Layout$4.uint8ArrayToBuffer = uint8ArrayToBuffer;
let Layout$3 = class {
    constructor($, et) {
        if (!Number.isInteger($))
            throw new TypeError("span must be an integer");
        this.span = $,
        this.property = et
    }
    makeDestinationObject() {
        return {}
    }
    getSpan($, et) {
        if (0 > this.span)
            throw new RangeError("indeterminate span");
        return this.span
    }
    replicate($) {
        const et = Object.create(this.constructor.prototype);
        return Object.assign(et, this),
        et.property = $,
        et
    }
    fromArray($) {}
}
;
Layout$4.Layout = Layout$3;
function nameWithProperty$2(_e, $) {
    return $.property ? _e + "[" + $.property + "]" : _e
}
Layout$4.nameWithProperty = nameWithProperty$2;
function bindConstructorLayout$1(_e, $) {
    if (typeof _e != "function")
        throw new TypeError("Class must be constructor");
    if (Object.prototype.hasOwnProperty.call(_e, "layout_"))
        throw new Error("Class is already bound to a layout");
    if (!($ && $ instanceof Layout$3))
        throw new TypeError("layout must be a Layout");
    if (Object.prototype.hasOwnProperty.call($, "boundConstructor_"))
        throw new Error("layout is already bound to a constructor");
    _e.layout_ = $,
    $.boundConstructor_ = _e,
    $.makeDestinationObject = () => new _e,
    Object.defineProperty(_e.prototype, "encode", {
        value(et, tt) {
            return $.encode(this, et, tt)
        },
        writable: !0
    }),
    Object.defineProperty(_e, "decode", {
        value(et, tt) {
            return $.decode(et, tt)
        },
        writable: !0
    })
}
Layout$4.bindConstructorLayout = bindConstructorLayout$1;
let ExternalLayout$2 = class extends Layout$3 {
    isCount() {
        throw new Error("ExternalLayout is abstract")
    }
}
;
Layout$4.ExternalLayout = ExternalLayout$2;
let GreedyCount$1 = class extends ExternalLayout$2 {
    constructor($=1, et) {
        if (!Number.isInteger($) || 0 >= $)
            throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, et),
        this.elementSpan = $
    }
    isCount() {
        return !0
    }
    decode($, et=0) {
        checkUint8Array($);
        const tt = $.length - et;
        return Math.floor(tt / this.elementSpan)
    }
    encode($, et, tt) {
        return 0
    }
}
;
Layout$4.GreedyCount = GreedyCount$1;
let OffsetLayout$2 = class extends ExternalLayout$2 {
    constructor($, et=0, tt) {
        if (!($ instanceof Layout$3))
            throw new TypeError("layout must be a Layout");
        if (!Number.isInteger(et))
            throw new TypeError("offset must be integer or undefined");
        super($.span, tt || $.property),
        this.layout = $,
        this.offset = et
    }
    isCount() {
        return this.layout instanceof UInt$2 || this.layout instanceof UIntBE$2
    }
    decode($, et=0) {
        return this.layout.decode($, et + this.offset)
    }
    encode($, et, tt=0) {
        return this.layout.encode($, et, tt + this.offset)
    }
}
;
Layout$4.OffsetLayout = OffsetLayout$2;
let UInt$2 = class extends Layout$3 {
    constructor($, et) {
        if (super($, et),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode($, et=0) {
        return uint8ArrayToBuffer($).readUIntLE(et, this.span)
    }
    encode($, et, tt=0) {
        return uint8ArrayToBuffer(et).writeUIntLE($, tt, this.span),
        this.span
    }
}
;
Layout$4.UInt = UInt$2;
let UIntBE$2 = class extends Layout$3 {
    constructor($, et) {
        if (super($, et),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode($, et=0) {
        return uint8ArrayToBuffer($).readUIntBE(et, this.span)
    }
    encode($, et, tt=0) {
        return uint8ArrayToBuffer(et).writeUIntBE($, tt, this.span),
        this.span
    }
}
;
Layout$4.UIntBE = UIntBE$2;
let Int$1 = class extends Layout$3 {
    constructor($, et) {
        if (super($, et),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode($, et=0) {
        return uint8ArrayToBuffer($).readIntLE(et, this.span)
    }
    encode($, et, tt=0) {
        return uint8ArrayToBuffer(et).writeIntLE($, tt, this.span),
        this.span
    }
}
;
Layout$4.Int = Int$1;
let IntBE$1 = class extends Layout$3 {
    constructor($, et) {
        if (super($, et),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode($, et=0) {
        return uint8ArrayToBuffer($).readIntBE(et, this.span)
    }
    encode($, et, tt=0) {
        return uint8ArrayToBuffer(et).writeIntBE($, tt, this.span),
        this.span
    }
}
;
Layout$4.IntBE = IntBE$1;
const V2E32$2 = Math.pow(2, 32);
function divmodInt64$2(_e) {
    const $ = Math.floor(_e / V2E32$2)
      , et = _e - $ * V2E32$2;
    return {
        hi32: $,
        lo32: et
    }
}
function roundedInt64$2(_e, $) {
    return _e * V2E32$2 + $
}
let NearUInt64$2 = class extends Layout$3 {
    constructor($) {
        super(8, $)
    }
    decode($, et=0) {
        const tt = uint8ArrayToBuffer($)
          , nt = tt.readUInt32LE(et)
          , rt = tt.readUInt32LE(et + 4);
        return roundedInt64$2(rt, nt)
    }
    encode($, et, tt=0) {
        const nt = divmodInt64$2($)
          , rt = uint8ArrayToBuffer(et);
        return rt.writeUInt32LE(nt.lo32, tt),
        rt.writeUInt32LE(nt.hi32, tt + 4),
        8
    }
}
;
Layout$4.NearUInt64 = NearUInt64$2;
let NearUInt64BE$1 = class extends Layout$3 {
    constructor($) {
        super(8, $)
    }
    decode($, et=0) {
        const tt = uint8ArrayToBuffer($)
          , nt = tt.readUInt32BE(et)
          , rt = tt.readUInt32BE(et + 4);
        return roundedInt64$2(nt, rt)
    }
    encode($, et, tt=0) {
        const nt = divmodInt64$2($)
          , rt = uint8ArrayToBuffer(et);
        return rt.writeUInt32BE(nt.hi32, tt),
        rt.writeUInt32BE(nt.lo32, tt + 4),
        8
    }
}
;
Layout$4.NearUInt64BE = NearUInt64BE$1;
let NearInt64$2 = class extends Layout$3 {
    constructor($) {
        super(8, $)
    }
    decode($, et=0) {
        const tt = uint8ArrayToBuffer($)
          , nt = tt.readUInt32LE(et)
          , rt = tt.readInt32LE(et + 4);
        return roundedInt64$2(rt, nt)
    }
    encode($, et, tt=0) {
        const nt = divmodInt64$2($)
          , rt = uint8ArrayToBuffer(et);
        return rt.writeUInt32LE(nt.lo32, tt),
        rt.writeInt32LE(nt.hi32, tt + 4),
        8
    }
}
;
Layout$4.NearInt64 = NearInt64$2;
let NearInt64BE$1 = class extends Layout$3 {
    constructor($) {
        super(8, $)
    }
    decode($, et=0) {
        const tt = uint8ArrayToBuffer($)
          , nt = tt.readInt32BE(et)
          , rt = tt.readUInt32BE(et + 4);
        return roundedInt64$2(nt, rt)
    }
    encode($, et, tt=0) {
        const nt = divmodInt64$2($)
          , rt = uint8ArrayToBuffer(et);
        return rt.writeInt32BE(nt.hi32, tt),
        rt.writeUInt32BE(nt.lo32, tt + 4),
        8
    }
}
;
Layout$4.NearInt64BE = NearInt64BE$1;
let Float$1 = class extends Layout$3 {
    constructor($) {
        super(4, $)
    }
    decode($, et=0) {
        return uint8ArrayToBuffer($).readFloatLE(et)
    }
    encode($, et, tt=0) {
        return uint8ArrayToBuffer(et).writeFloatLE($, tt),
        4
    }
}
;
Layout$4.Float = Float$1;
let FloatBE$1 = class extends Layout$3 {
    constructor($) {
        super(4, $)
    }
    decode($, et=0) {
        return uint8ArrayToBuffer($).readFloatBE(et)
    }
    encode($, et, tt=0) {
        return uint8ArrayToBuffer(et).writeFloatBE($, tt),
        4
    }
}
;
Layout$4.FloatBE = FloatBE$1;
let Double$1 = class extends Layout$3 {
    constructor($) {
        super(8, $)
    }
    decode($, et=0) {
        return uint8ArrayToBuffer($).readDoubleLE(et)
    }
    encode($, et, tt=0) {
        return uint8ArrayToBuffer(et).writeDoubleLE($, tt),
        8
    }
}
;
Layout$4.Double = Double$1;
let DoubleBE$1 = class extends Layout$3 {
    constructor($) {
        super(8, $)
    }
    decode($, et=0) {
        return uint8ArrayToBuffer($).readDoubleBE(et)
    }
    encode($, et, tt=0) {
        return uint8ArrayToBuffer(et).writeDoubleBE($, tt),
        8
    }
}
;
Layout$4.DoubleBE = DoubleBE$1;
let Sequence$1 = class extends Layout$3 {
    constructor($, et, tt) {
        if (!($ instanceof Layout$3))
            throw new TypeError("elementLayout must be a Layout");
        if (!(et instanceof ExternalLayout$2 && et.isCount() || Number.isInteger(et) && 0 <= et))
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        let nt = -1;
        !(et instanceof ExternalLayout$2) && 0 < $.span && (nt = et * $.span),
        super(nt, tt),
        this.elementLayout = $,
        this.count = et
    }
    getSpan($, et=0) {
        if (0 <= this.span)
            return this.span;
        let tt = 0
          , nt = this.count;
        if (nt instanceof ExternalLayout$2 && (nt = nt.decode($, et)),
        0 < this.elementLayout.span)
            tt = nt * this.elementLayout.span;
        else {
            let rt = 0;
            for (; rt < nt; )
                tt += this.elementLayout.getSpan($, et + tt),
                ++rt
        }
        return tt
    }
    decode($, et=0) {
        const tt = [];
        let nt = 0
          , rt = this.count;
        for (rt instanceof ExternalLayout$2 && (rt = rt.decode($, et)); nt < rt; )
            tt.push(this.elementLayout.decode($, et)),
            et += this.elementLayout.getSpan($, et),
            nt += 1;
        return tt
    }
    encode($, et, tt=0) {
        const nt = this.elementLayout
          , rt = $.reduce( (it, ot) => it + nt.encode(ot, et, tt + it), 0);
        return this.count instanceof ExternalLayout$2 && this.count.encode($.length, et, tt),
        rt
    }
}
;
Layout$4.Sequence = Sequence$1;
let Structure$2 = class extends Layout$3 {
    constructor($, et, tt) {
        if (!(Array.isArray($) && $.reduce( (rt, it) => rt && it instanceof Layout$3, !0)))
            throw new TypeError("fields must be array of Layout instances");
        typeof et == "boolean" && tt === void 0 && (tt = et,
        et = void 0);
        for (const rt of $)
            if (0 > rt.span && rt.property === void 0)
                throw new Error("fields cannot contain unnamed variable-length layout");
        let nt = -1;
        try {
            nt = $.reduce( (rt, it) => rt + it.getSpan(), 0)
        } catch {}
        super(nt, et),
        this.fields = $,
        this.decodePrefixes = !!tt
    }
    getSpan($, et=0) {
        if (0 <= this.span)
            return this.span;
        let tt = 0;
        try {
            tt = this.fields.reduce( (nt, rt) => {
                const it = rt.getSpan($, et);
                return et += it,
                nt + it
            }
            , 0)
        } catch {
            throw new RangeError("indeterminate span")
        }
        return tt
    }
    decode($, et=0) {
        checkUint8Array($);
        const tt = this.makeDestinationObject();
        for (const nt of this.fields)
            if (nt.property !== void 0 && (tt[nt.property] = nt.decode($, et)),
            et += nt.getSpan($, et),
            this.decodePrefixes && $.length === et)
                break;
        return tt
    }
    encode($, et, tt=0) {
        const nt = tt;
        let rt = 0
          , it = 0;
        for (const ot of this.fields) {
            let st = ot.span;
            if (it = 0 < st ? st : 0,
            ot.property !== void 0) {
                const lt = $[ot.property];
                lt !== void 0 && (it = ot.encode(lt, et, tt),
                0 > st && (st = ot.getSpan(et, tt)))
            }
            rt = tt,
            tt += st
        }
        return rt + it - nt
    }
    fromArray($) {
        const et = this.makeDestinationObject();
        for (const tt of this.fields)
            tt.property !== void 0 && 0 < $.length && (et[tt.property] = $.shift());
        return et
    }
    layoutFor($) {
        if (typeof $ != "string")
            throw new TypeError("property must be string");
        for (const et of this.fields)
            if (et.property === $)
                return et
    }
    offsetOf($) {
        if (typeof $ != "string")
            throw new TypeError("property must be string");
        let et = 0;
        for (const tt of this.fields) {
            if (tt.property === $)
                return et;
            0 > tt.span ? et = -1 : 0 <= et && (et += tt.span)
        }
    }
}
;
Layout$4.Structure = Structure$2;
let UnionDiscriminator$2 = class {
    constructor($) {
        this.property = $
    }
    decode($, et) {
        throw new Error("UnionDiscriminator is abstract")
    }
    encode($, et, tt) {
        throw new Error("UnionDiscriminator is abstract")
    }
}
;
Layout$4.UnionDiscriminator = UnionDiscriminator$2;
let UnionLayoutDiscriminator$2 = class extends UnionDiscriminator$2 {
    constructor($, et) {
        if (!($ instanceof ExternalLayout$2 && $.isCount()))
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
        super(et || $.property || "variant"),
        this.layout = $
    }
    decode($, et) {
        return this.layout.decode($, et)
    }
    encode($, et, tt) {
        return this.layout.encode($, et, tt)
    }
}
;
Layout$4.UnionLayoutDiscriminator = UnionLayoutDiscriminator$2;
let Union$2 = class extends Layout$3 {
    constructor($, et, tt) {
        let nt;
        if ($ instanceof UInt$2 || $ instanceof UIntBE$2)
            nt = new UnionLayoutDiscriminator$2(new OffsetLayout$2($));
        else if ($ instanceof ExternalLayout$2 && $.isCount())
            nt = new UnionLayoutDiscriminator$2($);
        else if ($ instanceof UnionDiscriminator$2)
            nt = $;
        else
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        if (et === void 0 && (et = null),
        !(et === null || et instanceof Layout$3))
            throw new TypeError("defaultLayout must be null or a Layout");
        if (et !== null) {
            if (0 > et.span)
                throw new Error("defaultLayout must have constant span");
            et.property === void 0 && (et = et.replicate("content"))
        }
        let rt = -1;
        et && (rt = et.span,
        0 <= rt && ($ instanceof UInt$2 || $ instanceof UIntBE$2) && (rt += nt.layout.span)),
        super(rt, tt),
        this.discriminator = nt,
        this.usesPrefixDiscriminator = $ instanceof UInt$2 || $ instanceof UIntBE$2,
        this.defaultLayout = et,
        this.registry = {};
        let it = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(ot) {
            return it(ot)
        }
        ,
        this.configGetSourceVariant = function(ot) {
            it = ot.bind(this)
        }
    }
    getSpan($, et=0) {
        if (0 <= this.span)
            return this.span;
        const tt = this.getVariant($, et);
        if (!tt)
            throw new Error("unable to determine span for unrecognized variant");
        return tt.getSpan($, et)
    }
    defaultGetSourceVariant($) {
        if (Object.prototype.hasOwnProperty.call($, this.discriminator.property)) {
            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call($, this.defaultLayout.property))
                return;
            const et = this.registry[$[this.discriminator.property]];
            if (et && (!et.layout || et.property && Object.prototype.hasOwnProperty.call($, et.property)))
                return et
        } else
            for (const et in this.registry) {
                const tt = this.registry[et];
                if (tt.property && Object.prototype.hasOwnProperty.call($, tt.property))
                    return tt
            }
        throw new Error("unable to infer src variant")
    }
    decode($, et=0) {
        let tt;
        const nt = this.discriminator
          , rt = nt.decode($, et)
          , it = this.registry[rt];
        if (it === void 0) {
            const ot = this.defaultLayout;
            let st = 0;
            this.usesPrefixDiscriminator && (st = nt.layout.span),
            tt = this.makeDestinationObject(),
            tt[nt.property] = rt,
            tt[ot.property] = ot.decode($, et + st)
        } else
            tt = it.decode($, et);
        return tt
    }
    encode($, et, tt=0) {
        const nt = this.getSourceVariant($);
        if (nt === void 0) {
            const rt = this.discriminator
              , it = this.defaultLayout;
            let ot = 0;
            return this.usesPrefixDiscriminator && (ot = rt.layout.span),
            rt.encode($[rt.property], et, tt),
            ot + it.encode($[it.property], et, tt + ot)
        }
        return nt.encode($, et, tt)
    }
    addVariant($, et, tt) {
        const nt = new VariantLayout$2(this,$,et,tt);
        return this.registry[$] = nt,
        nt
    }
    getVariant($, et=0) {
        let tt;
        return $ instanceof Uint8Array ? tt = this.discriminator.decode($, et) : tt = $,
        this.registry[tt]
    }
}
;
Layout$4.Union = Union$2;
let VariantLayout$2 = class extends Layout$3 {
    constructor($, et, tt, nt) {
        if (!($ instanceof Union$2))
            throw new TypeError("union must be a Union");
        if (!Number.isInteger(et) || 0 > et)
            throw new TypeError("variant must be a (non-negative) integer");
        if (typeof tt == "string" && nt === void 0 && (nt = tt,
        tt = null),
        tt) {
            if (!(tt instanceof Layout$3))
                throw new TypeError("layout must be a Layout");
            if ($.defaultLayout !== null && 0 <= tt.span && tt.span > $.defaultLayout.span)
                throw new Error("variant span exceeds span of containing union");
            if (typeof nt != "string")
                throw new TypeError("variant must have a String property")
        }
        let rt = $.span;
        0 > $.span && (rt = tt ? tt.span : 0,
        0 <= rt && $.usesPrefixDiscriminator && (rt += $.discriminator.layout.span)),
        super(rt, nt),
        this.union = $,
        this.variant = et,
        this.layout = tt || null
    }
    getSpan($, et=0) {
        if (0 <= this.span)
            return this.span;
        let tt = 0;
        this.union.usesPrefixDiscriminator && (tt = this.union.discriminator.layout.span);
        let nt = 0;
        return this.layout && (nt = this.layout.getSpan($, et + tt)),
        tt + nt
    }
    decode($, et=0) {
        const tt = this.makeDestinationObject();
        if (this !== this.union.getVariant($, et))
            throw new Error("variant mismatch");
        let nt = 0;
        return this.union.usesPrefixDiscriminator && (nt = this.union.discriminator.layout.span),
        this.layout ? tt[this.property] = this.layout.decode($, et + nt) : this.property ? tt[this.property] = !0 : this.union.usesPrefixDiscriminator && (tt[this.union.discriminator.property] = this.variant),
        tt
    }
    encode($, et, tt=0) {
        let nt = 0;
        if (this.union.usesPrefixDiscriminator && (nt = this.union.discriminator.layout.span),
        this.layout && !Object.prototype.hasOwnProperty.call($, this.property))
            throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, et, tt);
        let rt = nt;
        if (this.layout && (this.layout.encode($[this.property], et, tt + nt),
        rt += this.layout.getSpan(et, tt + nt),
        0 <= this.union.span && rt > this.union.span))
            throw new Error("encoded variant overruns containing union");
        return rt
    }
    fromArray($) {
        if (this.layout)
            return this.layout.fromArray($)
    }
}
;
Layout$4.VariantLayout = VariantLayout$2;
function fixBitwiseResult$1(_e) {
    return 0 > _e && (_e += 4294967296),
    _e
}
let BitStructure$1 = class extends Layout$3 {
    constructor($, et, tt) {
        if (!($ instanceof UInt$2 || $ instanceof UIntBE$2))
            throw new TypeError("word must be a UInt or UIntBE layout");
        if (typeof et == "string" && tt === void 0 && (tt = et,
        et = !1),
        4 < $.span)
            throw new RangeError("word cannot exceed 32 bits");
        super($.span, tt),
        this.word = $,
        this.msb = !!et,
        this.fields = [];
        let nt = 0;
        this._packedSetValue = function(rt) {
            return nt = fixBitwiseResult$1(rt),
            this
        }
        ,
        this._packedGetValue = function() {
            return nt
        }
    }
    decode($, et=0) {
        const tt = this.makeDestinationObject()
          , nt = this.word.decode($, et);
        this._packedSetValue(nt);
        for (const rt of this.fields)
            rt.property !== void 0 && (tt[rt.property] = rt.decode($));
        return tt
    }
    encode($, et, tt=0) {
        const nt = this.word.decode(et, tt);
        this._packedSetValue(nt);
        for (const rt of this.fields)
            if (rt.property !== void 0) {
                const it = $[rt.property];
                it !== void 0 && rt.encode(it)
            }
        return this.word.encode(this._packedGetValue(), et, tt)
    }
    addField($, et) {
        const tt = new BitField$1(this,$,et);
        return this.fields.push(tt),
        tt
    }
    addBoolean($) {
        const et = new Boolean$2(this,$);
        return this.fields.push(et),
        et
    }
    fieldFor($) {
        if (typeof $ != "string")
            throw new TypeError("property must be string");
        for (const et of this.fields)
            if (et.property === $)
                return et
    }
}
;
Layout$4.BitStructure = BitStructure$1;
let BitField$1 = class {
    constructor($, et, tt) {
        if (!($ instanceof BitStructure$1))
            throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(et) || 0 >= et)
            throw new TypeError("bits must be positive integer");
        const nt = 8 * $.span
          , rt = $.fields.reduce( (it, ot) => it + ot.bits, 0);
        if (et + rt > nt)
            throw new Error("bits too long for span remainder (" + (nt - rt) + " of " + nt + " remain)");
        this.container = $,
        this.bits = et,
        this.valueMask = (1 << et) - 1,
        et === 32 && (this.valueMask = 4294967295),
        this.start = rt,
        this.container.msb && (this.start = nt - rt - et),
        this.wordMask = fixBitwiseResult$1(this.valueMask << this.start),
        this.property = tt
    }
    decode($, et) {
        const tt = this.container._packedGetValue();
        return fixBitwiseResult$1(tt & this.wordMask) >>> this.start
    }
    encode($) {
        if (typeof $ != "number" || !Number.isInteger($) || $ !== fixBitwiseResult$1($ & this.valueMask))
            throw new TypeError(nameWithProperty$2("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        const et = this.container._packedGetValue()
          , tt = fixBitwiseResult$1($ << this.start);
        this.container._packedSetValue(fixBitwiseResult$1(et & ~this.wordMask) | tt)
    }
}
;
Layout$4.BitField = BitField$1;
let Boolean$2 = class extends BitField$1 {
    constructor($, et) {
        super($, 1, et)
    }
    decode($, et) {
        return !!super.decode($, et)
    }
    encode($) {
        typeof $ == "boolean" && ($ = +$),
        super.encode($)
    }
}
;
Layout$4.Boolean = Boolean$2;
let Blob$3 = class extends Layout$3 {
    constructor($, et) {
        if (!($ instanceof ExternalLayout$2 && $.isCount() || Number.isInteger($) && 0 <= $))
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        let tt = -1;
        $ instanceof ExternalLayout$2 || (tt = $),
        super(tt, et),
        this.length = $
    }
    getSpan($, et) {
        let tt = this.span;
        return 0 > tt && (tt = this.length.decode($, et)),
        tt
    }
    decode($, et=0) {
        let tt = this.span;
        return 0 > tt && (tt = this.length.decode($, et)),
        uint8ArrayToBuffer($).slice(et, et + tt)
    }
    encode($, et, tt) {
        let nt = this.length;
        if (this.length instanceof ExternalLayout$2 && (nt = $.length),
        !($ instanceof Uint8Array && nt === $.length))
            throw new TypeError(nameWithProperty$2("Blob.encode", this) + " requires (length " + nt + ") Uint8Array as src");
        if (tt + nt > et.length)
            throw new RangeError("encoding overruns Uint8Array");
        const rt = uint8ArrayToBuffer($);
        return uint8ArrayToBuffer(et).write(rt.toString("hex"), tt, nt, "hex"),
        this.length instanceof ExternalLayout$2 && this.length.encode(nt, et, tt),
        nt
    }
}
;
Layout$4.Blob = Blob$3;
let CString$1 = class extends Layout$3 {
    constructor($) {
        super(-1, $)
    }
    getSpan($, et=0) {
        checkUint8Array($);
        let tt = et;
        for (; tt < $.length && $[tt] !== 0; )
            tt += 1;
        return 1 + tt - et
    }
    decode($, et=0) {
        const tt = this.getSpan($, et);
        return uint8ArrayToBuffer($).slice(et, et + tt - 1).toString("utf-8")
    }
    encode($, et, tt=0) {
        typeof $ != "string" && ($ = String($));
        const nt = buffer_1.Buffer.from($, "utf8")
          , rt = nt.length;
        if (tt + rt > et.length)
            throw new RangeError("encoding overruns Buffer");
        const it = uint8ArrayToBuffer(et);
        return nt.copy(it, tt),
        it[tt + rt] = 0,
        rt + 1
    }
}
;
Layout$4.CString = CString$1;
let UTF8$1 = class extends Layout$3 {
    constructor($, et) {
        if (typeof $ == "string" && et === void 0 && (et = $,
        $ = void 0),
        $ === void 0)
            $ = -1;
        else if (!Number.isInteger($))
            throw new TypeError("maxSpan must be an integer");
        super(-1, et),
        this.maxSpan = $
    }
    getSpan($, et=0) {
        return checkUint8Array($),
        $.length - et
    }
    decode($, et=0) {
        const tt = this.getSpan($, et);
        if (0 <= this.maxSpan && this.maxSpan < tt)
            throw new RangeError("text length exceeds maxSpan");
        return uint8ArrayToBuffer($).slice(et, et + tt).toString("utf-8")
    }
    encode($, et, tt=0) {
        typeof $ != "string" && ($ = String($));
        const nt = buffer_1.Buffer.from($, "utf8")
          , rt = nt.length;
        if (0 <= this.maxSpan && this.maxSpan < rt)
            throw new RangeError("text length exceeds maxSpan");
        if (tt + rt > et.length)
            throw new RangeError("encoding overruns Buffer");
        return nt.copy(uint8ArrayToBuffer(et), tt),
        rt
    }
}
;
Layout$4.UTF8 = UTF8$1;
let Constant$1 = class extends Layout$3 {
    constructor($, et) {
        super(0, et),
        this.value = $
    }
    decode($, et) {
        return this.value
    }
    encode($, et, tt) {
        return 0
    }
}
;
Layout$4.Constant = Constant$1;
var greedy = Layout$4.greedy = (_e, $) => new GreedyCount$1(_e,$)
  , offset$1 = Layout$4.offset = (_e, $, et) => new OffsetLayout$2(_e,$,et)
  , u8$1 = Layout$4.u8 = _e => new UInt$2(1,_e)
  , u16 = Layout$4.u16 = _e => new UInt$2(2,_e);
Layout$4.u24 = _e => new UInt$2(3,_e);
var u32$1 = Layout$4.u32 = _e => new UInt$2(4,_e);
Layout$4.u40 = _e => new UInt$2(5,_e);
Layout$4.u48 = _e => new UInt$2(6,_e);
var nu64$1 = Layout$4.nu64 = _e => new NearUInt64$2(_e);
Layout$4.u16be = _e => new UIntBE$2(2,_e);
Layout$4.u24be = _e => new UIntBE$2(3,_e);
Layout$4.u32be = _e => new UIntBE$2(4,_e);
Layout$4.u40be = _e => new UIntBE$2(5,_e);
Layout$4.u48be = _e => new UIntBE$2(6,_e);
Layout$4.nu64be = _e => new NearUInt64BE$1(_e);
Layout$4.s8 = _e => new Int$1(1,_e);
s16 = Layout$4.s16 = _e => new Int$1(2,_e);
Layout$4.s24 = _e => new Int$1(3,_e);
Layout$4.s32 = _e => new Int$1(4,_e);
Layout$4.s40 = _e => new Int$1(5,_e);
Layout$4.s48 = _e => new Int$1(6,_e);
var ns64$1 = Layout$4.ns64 = _e => new NearInt64$2(_e);
Layout$4.s16be = _e => new IntBE$1(2,_e);
Layout$4.s24be = _e => new IntBE$1(3,_e);
Layout$4.s32be = _e => new IntBE$1(4,_e);
Layout$4.s40be = _e => new IntBE$1(5,_e);
Layout$4.s48be = _e => new IntBE$1(6,_e);
Layout$4.ns64be = _e => new NearInt64BE$1(_e);
Layout$4.f32 = _e => new Float$1(_e);
Layout$4.f32be = _e => new FloatBE$1(_e);
var f64 = Layout$4.f64 = _e => new Double$1(_e);
Layout$4.f64be = _e => new DoubleBE$1(_e);
var struct$1 = Layout$4.struct = (_e, $, et) => new Structure$2(_e,$,et);
Layout$4.bits = (_e, $, et) => new BitStructure$1(_e,$,et);
var seq = Layout$4.seq = (_e, $, et) => new Sequence$1(_e,$,et);
Layout$4.union = (_e, $, et) => new Union$2(_e,$,et);
Layout$4.unionLayoutDiscriminator = (_e, $) => new UnionLayoutDiscriminator$2(_e,$);
var blob$1 = Layout$4.blob = (_e, $) => new Blob$3(_e,$);
Layout$4.cstr = _e => new CString$1(_e);
Layout$4.utf8 = (_e, $) => new UTF8$1(_e,$);
Layout$4.constant = (_e, $) => new Constant$1(_e,$);
var browser$3 = {};
Object.defineProperty(browser$3, "__esModule", {
    value: !0
});
function toBigIntLE(_e) {
    {
        const $ = Buffer$2.from(_e);
        $.reverse();
        const et = $.toString("hex");
        return et.length === 0 ? BigInt(0) : BigInt(`0x${et}`)
    }
}
var toBigIntLE_1 = browser$3.toBigIntLE = toBigIntLE;
function toBigIntBE(_e) {
    {
        const $ = _e.toString("hex");
        return $.length === 0 ? BigInt(0) : BigInt(`0x${$}`)
    }
}
browser$3.toBigIntBE = toBigIntBE;
function toBufferLE(_e, $) {
    {
        const et = _e.toString(16)
          , tt = Buffer$2.from(et.padStart($ * 2, "0").slice(0, $ * 2), "hex");
        return tt.reverse(),
        tt
    }
}
var toBufferLE_1 = browser$3.toBufferLE = toBufferLE;
function toBufferBE(_e, $) {
    {
        const et = _e.toString(16);
        return Buffer$2.from(et.padStart($ * 2, "0").slice(0, $ * 2), "hex")
    }
}
browser$3.toBufferBE = toBufferBE;
let StructError$1 = class extends TypeError {
    constructor($, et) {
        let tt;
        const {message: nt, explanation: rt, ...it} = $
          , {path: ot} = $
          , st = ot.length === 0 ? nt : `At path: ${ot.join(".")} -- ${nt}`;
        super(rt ?? st),
        rt != null && (this.cause = st),
        Object.assign(this, it),
        this.name = this.constructor.name,
        this.failures = () => tt ?? (tt = [$, ...et()])
    }
}
;
function isIterable$1(_e) {
    return isObject$l(_e) && typeof _e[Symbol.iterator] == "function"
}
function isObject$l(_e) {
    return typeof _e == "object" && _e != null
}
function isNonArrayObject(_e) {
    return isObject$l(_e) && !Array.isArray(_e)
}
function print$1(_e) {
    return typeof _e == "symbol" ? _e.toString() : typeof _e == "string" ? JSON.stringify(_e) : `${_e}`
}
function shiftIterator$1(_e) {
    const {done: $, value: et} = _e.next();
    return $ ? void 0 : et
}
function toFailure$1(_e, $, et, tt) {
    if (_e === !0)
        return;
    _e === !1 ? _e = {} : typeof _e == "string" && (_e = {
        message: _e
    });
    const {path: nt, branch: rt} = $
      , {type: it} = et
      , {refinement: ot, message: st=`Expected a value of type \`${it}\`${ot ? ` with refinement \`${ot}\`` : ""}, but received: \`${print$1(tt)}\``} = _e;
    return {
        value: tt,
        type: it,
        refinement: ot,
        key: nt[nt.length - 1],
        path: nt,
        branch: rt,
        ..._e,
        message: st
    }
}
function *toFailures$1(_e, $, et, tt) {
    isIterable$1(_e) || (_e = [_e]);
    for (const nt of _e) {
        const rt = toFailure$1(nt, $, et, tt);
        rt && (yield rt)
    }
}
function *run$1(_e, $, et={}) {
    const {path: tt=[], branch: nt=[_e], coerce: rt=!1, mask: it=!1} = et
      , ot = {
        path: tt,
        branch: nt,
        mask: it
    };
    rt && (_e = $.coercer(_e, ot));
    let st = "valid";
    for (const lt of $.validator(_e, ot))
        lt.explanation = et.message,
        st = "not_valid",
        yield[lt, void 0];
    for (let[lt,ct,dt] of $.entries(_e, ot)) {
        const pt = run$1(ct, dt, {
            path: lt === void 0 ? tt : [...tt, lt],
            branch: lt === void 0 ? nt : [...nt, ct],
            coerce: rt,
            mask: it,
            message: et.message
        });
        for (const ht of pt)
            ht[0] ? (st = ht[0].refinement != null ? "not_refined" : "not_valid",
            yield[ht[0], void 0]) : rt && (ct = ht[1],
            lt === void 0 ? _e = ct : _e instanceof Map ? _e.set(lt, ct) : _e instanceof Set ? _e.add(ct) : isObject$l(_e) && (ct !== void 0 || lt in _e) && (_e[lt] = ct))
    }
    if (st !== "not_valid")
        for (const lt of $.refiner(_e, ot))
            lt.explanation = et.message,
            st = "not_refined",
            yield[lt, void 0];
    st === "valid" && (yield[void 0, _e])
}
let Struct$2 = class {
    constructor($) {
        const {type: et, schema: tt, validator: nt, refiner: rt, coercer: it=st => st, entries: ot=function*() {}
        } = $;
        this.type = et,
        this.schema = tt,
        this.entries = ot,
        this.coercer = it,
        nt ? this.validator = (st, lt) => {
            const ct = nt(st, lt);
            return toFailures$1(ct, lt, this, st)
        }
        : this.validator = () => [],
        rt ? this.refiner = (st, lt) => {
            const ct = rt(st, lt);
            return toFailures$1(ct, lt, this, st)
        }
        : this.refiner = () => []
    }
    assert($, et) {
        return assert$2($, this, et)
    }
    create($, et) {
        return create$4($, this, et)
    }
    is($) {
        return is$1($, this)
    }
    mask($, et) {
        return mask$1($, this, et)
    }
    validate($, et={}) {
        return validate$2($, this, et)
    }
}
;
function assert$2(_e, $, et) {
    const tt = validate$2(_e, $, {
        message: et
    });
    if (tt[0])
        throw tt[0]
}
function create$4(_e, $, et) {
    const tt = validate$2(_e, $, {
        coerce: !0,
        message: et
    });
    if (tt[0])
        throw tt[0];
    return tt[1]
}
function mask$1(_e, $, et) {
    const tt = validate$2(_e, $, {
        coerce: !0,
        mask: !0,
        message: et
    });
    if (tt[0])
        throw tt[0];
    return tt[1]
}
function is$1(_e, $) {
    return !validate$2(_e, $)[0]
}
function validate$2(_e, $, et={}) {
    const tt = run$1(_e, $, et)
      , nt = shiftIterator$1(tt);
    return nt[0] ? [new StructError$1(nt[0],function*() {
        for (const it of tt)
            it[0] && (yield it[0])
    }
    ), void 0] : [void 0, nt[1]]
}
function define$2(_e, $) {
    return new Struct$2({
        type: _e,
        schema: null,
        validator: $
    })
}
function any$1() {
    return define$2("any", () => !0)
}
function array$2(_e) {
    return new Struct$2({
        type: "array",
        schema: _e,
        *entries($) {
            if (_e && Array.isArray($))
                for (const [et,tt] of $.entries())
                    yield[et, tt, _e]
        },
        coercer($) {
            return Array.isArray($) ? $.slice() : $
        },
        validator($) {
            return Array.isArray($) || `Expected an array value, but received: ${print$1($)}`
        }
    })
}
function boolean$2() {
    return define$2("boolean", _e => typeof _e == "boolean")
}
function instance(_e) {
    return define$2("instance", $ => $ instanceof _e || `Expected a \`${_e.name}\` instance, but received: ${print$1($)}`)
}
function literal$1(_e) {
    const $ = print$1(_e)
      , et = typeof _e;
    return new Struct$2({
        type: "literal",
        schema: et === "string" || et === "number" || et === "boolean" ? _e : null,
        validator(tt) {
            return tt === _e || `Expected the literal \`${$}\`, but received: ${print$1(tt)}`
        }
    })
}
function never() {
    return define$2("never", () => !1)
}
function nullable$1(_e) {
    return new Struct$2({
        ..._e,
        validator: ($, et) => $ === null || _e.validator($, et),
        refiner: ($, et) => $ === null || _e.refiner($, et)
    })
}
function number$3() {
    return define$2("number", _e => typeof _e == "number" && !isNaN(_e) || `Expected a number, but received: ${print$1(_e)}`)
}
function optional$1(_e) {
    return new Struct$2({
        ..._e,
        validator: ($, et) => $ === void 0 || _e.validator($, et),
        refiner: ($, et) => $ === void 0 || _e.refiner($, et)
    })
}
function record(_e, $) {
    return new Struct$2({
        type: "record",
        schema: null,
        *entries(et) {
            if (isObject$l(et))
                for (const tt in et) {
                    const nt = et[tt];
                    yield[tt, tt, _e],
                    yield[tt, nt, $]
                }
        },
        validator(et) {
            return isNonArrayObject(et) || `Expected an object, but received: ${print$1(et)}`
        },
        coercer(et) {
            return isNonArrayObject(et) ? {
                ...et
            } : et
        }
    })
}
function string$2() {
    return define$2("string", _e => typeof _e == "string" || `Expected a string, but received: ${print$1(_e)}`)
}
function tuple$1(_e) {
    const $ = never();
    return new Struct$2({
        type: "tuple",
        schema: null,
        *entries(et) {
            if (Array.isArray(et)) {
                const tt = Math.max(_e.length, et.length);
                for (let nt = 0; nt < tt; nt++)
                    yield[nt, et[nt], _e[nt] || $]
            }
        },
        validator(et) {
            return Array.isArray(et) || `Expected an array, but received: ${print$1(et)}`
        },
        coercer(et) {
            return Array.isArray(et) ? et.slice() : et
        }
    })
}
function type$1(_e) {
    const $ = Object.keys(_e);
    return new Struct$2({
        type: "type",
        schema: _e,
        *entries(et) {
            if (isObject$l(et))
                for (const tt of $)
                    yield[tt, et[tt], _e[tt]]
        },
        validator(et) {
            return isNonArrayObject(et) || `Expected an object, but received: ${print$1(et)}`
        },
        coercer(et) {
            return isNonArrayObject(et) ? {
                ...et
            } : et
        }
    })
}
function union$2(_e) {
    const $ = _e.map(et => et.type).join(" | ");
    return new Struct$2({
        type: "union",
        schema: null,
        coercer(et, tt) {
            for (const nt of _e) {
                const [rt,it] = nt.validate(et, {
                    coerce: !0,
                    mask: tt.mask
                });
                if (!rt)
                    return it
            }
            return et
        },
        validator(et, tt) {
            const nt = [];
            for (const rt of _e) {
                const [...it] = run$1(et, rt, tt)
                  , [ot] = it;
                if (ot[0])
                    for (const [st] of it)
                        st && nt.push(st);
                else
                    return []
            }
            return [`Expected the value to satisfy a union of \`${$}\`, but received: ${print$1(et)}`, ...nt]
        }
    })
}
function unknown$2() {
    return define$2("unknown", () => !0)
}
function coerce$1(_e, $, et) {
    return new Struct$2({
        ..._e,
        coercer: (tt, nt) => is$1(tt, $) ? _e.coercer(et(tt, nt), nt) : _e.coercer(tt, nt)
    })
}
var getRandomValues, rnds8 = new Uint8Array(16);
function rng() {
    if (!getRandomValues && (getRandomValues = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto),
    !getRandomValues))
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    return getRandomValues(rnds8)
}
const REGEX = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function validate$1(_e) {
    return typeof _e == "string" && REGEX.test(_e)
}
var byteToHex = [];
for (var i$3 = 0; i$3 < 256; ++i$3)
    byteToHex.push((i$3 + 256).toString(16).substr(1));
function stringify$1(_e) {
    var $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0
      , et = (byteToHex[_e[$ + 0]] + byteToHex[_e[$ + 1]] + byteToHex[_e[$ + 2]] + byteToHex[_e[$ + 3]] + "-" + byteToHex[_e[$ + 4]] + byteToHex[_e[$ + 5]] + "-" + byteToHex[_e[$ + 6]] + byteToHex[_e[$ + 7]] + "-" + byteToHex[_e[$ + 8]] + byteToHex[_e[$ + 9]] + "-" + byteToHex[_e[$ + 10]] + byteToHex[_e[$ + 11]] + byteToHex[_e[$ + 12]] + byteToHex[_e[$ + 13]] + byteToHex[_e[$ + 14]] + byteToHex[_e[$ + 15]]).toLowerCase();
    if (!validate$1(et))
        throw TypeError("Stringified UUID is invalid");
    return et
}
var _nodeId, _clockseq, _lastMSecs = 0, _lastNSecs = 0;
function v1(_e, $, et) {
    var tt = $ && et || 0
      , nt = $ || new Array(16);
    _e = _e || {};
    var rt = _e.node || _nodeId
      , it = _e.clockseq !== void 0 ? _e.clockseq : _clockseq;
    if (rt == null || it == null) {
        var ot = _e.random || (_e.rng || rng)();
        rt == null && (rt = _nodeId = [ot[0] | 1, ot[1], ot[2], ot[3], ot[4], ot[5]]),
        it == null && (it = _clockseq = (ot[6] << 8 | ot[7]) & 16383)
    }
    var st = _e.msecs !== void 0 ? _e.msecs : Date.now()
      , lt = _e.nsecs !== void 0 ? _e.nsecs : _lastNSecs + 1
      , ct = st - _lastMSecs + (lt - _lastNSecs) / 1e4;
    if (ct < 0 && _e.clockseq === void 0 && (it = it + 1 & 16383),
    (ct < 0 || st > _lastMSecs) && _e.nsecs === void 0 && (lt = 0),
    lt >= 1e4)
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    _lastMSecs = st,
    _lastNSecs = lt,
    _clockseq = it,
    st += 122192928e5;
    var dt = ((st & 268435455) * 1e4 + lt) % 4294967296;
    nt[tt++] = dt >>> 24 & 255,
    nt[tt++] = dt >>> 16 & 255,
    nt[tt++] = dt >>> 8 & 255,
    nt[tt++] = dt & 255;
    var pt = st / 4294967296 * 1e4 & 268435455;
    nt[tt++] = pt >>> 8 & 255,
    nt[tt++] = pt & 255,
    nt[tt++] = pt >>> 24 & 15 | 16,
    nt[tt++] = pt >>> 16 & 255,
    nt[tt++] = it >>> 8 | 128,
    nt[tt++] = it & 255;
    for (var ht = 0; ht < 6; ++ht)
        nt[tt + ht] = rt[ht];
    return $ || stringify$1(nt)
}
function parse$2(_e) {
    if (!validate$1(_e))
        throw TypeError("Invalid UUID");
    var $, et = new Uint8Array(16);
    return et[0] = ($ = parseInt(_e.slice(0, 8), 16)) >>> 24,
    et[1] = $ >>> 16 & 255,
    et[2] = $ >>> 8 & 255,
    et[3] = $ & 255,
    et[4] = ($ = parseInt(_e.slice(9, 13), 16)) >>> 8,
    et[5] = $ & 255,
    et[6] = ($ = parseInt(_e.slice(14, 18), 16)) >>> 8,
    et[7] = $ & 255,
    et[8] = ($ = parseInt(_e.slice(19, 23), 16)) >>> 8,
    et[9] = $ & 255,
    et[10] = ($ = parseInt(_e.slice(24, 36), 16)) / 1099511627776 & 255,
    et[11] = $ / 4294967296 & 255,
    et[12] = $ >>> 24 & 255,
    et[13] = $ >>> 16 & 255,
    et[14] = $ >>> 8 & 255,
    et[15] = $ & 255,
    et
}
function stringToBytes(_e) {
    _e = unescape(encodeURIComponent(_e));
    for (var $ = [], et = 0; et < _e.length; ++et)
        $.push(_e.charCodeAt(et));
    return $
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8"
  , URL$1 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(_e, $, et) {
    function tt(nt, rt, it, ot) {
        if (typeof nt == "string" && (nt = stringToBytes(nt)),
        typeof rt == "string" && (rt = parse$2(rt)),
        rt.length !== 16)
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        var st = new Uint8Array(16 + nt.length);
        if (st.set(rt),
        st.set(nt, rt.length),
        st = et(st),
        st[6] = st[6] & 15 | $,
        st[8] = st[8] & 63 | 128,
        it) {
            ot = ot || 0;
            for (var lt = 0; lt < 16; ++lt)
                it[ot + lt] = st[lt];
            return it
        }
        return stringify$1(st)
    }
    try {
        tt.name = _e
    } catch {}
    return tt.DNS = DNS,
    tt.URL = URL$1,
    tt
}
function md5(_e) {
    if (typeof _e == "string") {
        var $ = unescape(encodeURIComponent(_e));
        _e = new Uint8Array($.length);
        for (var et = 0; et < $.length; ++et)
            _e[et] = $.charCodeAt(et)
    }
    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(_e), _e.length * 8))
}
function md5ToHexEncodedArray(_e) {
    for (var $ = [], et = _e.length * 32, tt = "0123456789abcdef", nt = 0; nt < et; nt += 8) {
        var rt = _e[nt >> 5] >>> nt % 32 & 255
          , it = parseInt(tt.charAt(rt >>> 4 & 15) + tt.charAt(rt & 15), 16);
        $.push(it)
    }
    return $
}
function getOutputLength(_e) {
    return (_e + 64 >>> 9 << 4) + 14 + 1
}
function wordsToMd5(_e, $) {
    _e[$ >> 5] |= 128 << $ % 32,
    _e[getOutputLength($) - 1] = $;
    for (var et = 1732584193, tt = -271733879, nt = -1732584194, rt = 271733878, it = 0; it < _e.length; it += 16) {
        var ot = et
          , st = tt
          , lt = nt
          , ct = rt;
        et = md5ff(et, tt, nt, rt, _e[it], 7, -680876936),
        rt = md5ff(rt, et, tt, nt, _e[it + 1], 12, -389564586),
        nt = md5ff(nt, rt, et, tt, _e[it + 2], 17, 606105819),
        tt = md5ff(tt, nt, rt, et, _e[it + 3], 22, -1044525330),
        et = md5ff(et, tt, nt, rt, _e[it + 4], 7, -176418897),
        rt = md5ff(rt, et, tt, nt, _e[it + 5], 12, 1200080426),
        nt = md5ff(nt, rt, et, tt, _e[it + 6], 17, -1473231341),
        tt = md5ff(tt, nt, rt, et, _e[it + 7], 22, -45705983),
        et = md5ff(et, tt, nt, rt, _e[it + 8], 7, 1770035416),
        rt = md5ff(rt, et, tt, nt, _e[it + 9], 12, -1958414417),
        nt = md5ff(nt, rt, et, tt, _e[it + 10], 17, -42063),
        tt = md5ff(tt, nt, rt, et, _e[it + 11], 22, -1990404162),
        et = md5ff(et, tt, nt, rt, _e[it + 12], 7, 1804603682),
        rt = md5ff(rt, et, tt, nt, _e[it + 13], 12, -40341101),
        nt = md5ff(nt, rt, et, tt, _e[it + 14], 17, -1502002290),
        tt = md5ff(tt, nt, rt, et, _e[it + 15], 22, 1236535329),
        et = md5gg(et, tt, nt, rt, _e[it + 1], 5, -165796510),
        rt = md5gg(rt, et, tt, nt, _e[it + 6], 9, -1069501632),
        nt = md5gg(nt, rt, et, tt, _e[it + 11], 14, 643717713),
        tt = md5gg(tt, nt, rt, et, _e[it], 20, -373897302),
        et = md5gg(et, tt, nt, rt, _e[it + 5], 5, -701558691),
        rt = md5gg(rt, et, tt, nt, _e[it + 10], 9, 38016083),
        nt = md5gg(nt, rt, et, tt, _e[it + 15], 14, -660478335),
        tt = md5gg(tt, nt, rt, et, _e[it + 4], 20, -405537848),
        et = md5gg(et, tt, nt, rt, _e[it + 9], 5, 568446438),
        rt = md5gg(rt, et, tt, nt, _e[it + 14], 9, -1019803690),
        nt = md5gg(nt, rt, et, tt, _e[it + 3], 14, -187363961),
        tt = md5gg(tt, nt, rt, et, _e[it + 8], 20, 1163531501),
        et = md5gg(et, tt, nt, rt, _e[it + 13], 5, -1444681467),
        rt = md5gg(rt, et, tt, nt, _e[it + 2], 9, -51403784),
        nt = md5gg(nt, rt, et, tt, _e[it + 7], 14, 1735328473),
        tt = md5gg(tt, nt, rt, et, _e[it + 12], 20, -1926607734),
        et = md5hh(et, tt, nt, rt, _e[it + 5], 4, -378558),
        rt = md5hh(rt, et, tt, nt, _e[it + 8], 11, -2022574463),
        nt = md5hh(nt, rt, et, tt, _e[it + 11], 16, 1839030562),
        tt = md5hh(tt, nt, rt, et, _e[it + 14], 23, -35309556),
        et = md5hh(et, tt, nt, rt, _e[it + 1], 4, -1530992060),
        rt = md5hh(rt, et, tt, nt, _e[it + 4], 11, 1272893353),
        nt = md5hh(nt, rt, et, tt, _e[it + 7], 16, -155497632),
        tt = md5hh(tt, nt, rt, et, _e[it + 10], 23, -1094730640),
        et = md5hh(et, tt, nt, rt, _e[it + 13], 4, 681279174),
        rt = md5hh(rt, et, tt, nt, _e[it], 11, -358537222),
        nt = md5hh(nt, rt, et, tt, _e[it + 3], 16, -722521979),
        tt = md5hh(tt, nt, rt, et, _e[it + 6], 23, 76029189),
        et = md5hh(et, tt, nt, rt, _e[it + 9], 4, -640364487),
        rt = md5hh(rt, et, tt, nt, _e[it + 12], 11, -421815835),
        nt = md5hh(nt, rt, et, tt, _e[it + 15], 16, 530742520),
        tt = md5hh(tt, nt, rt, et, _e[it + 2], 23, -995338651),
        et = md5ii(et, tt, nt, rt, _e[it], 6, -198630844),
        rt = md5ii(rt, et, tt, nt, _e[it + 7], 10, 1126891415),
        nt = md5ii(nt, rt, et, tt, _e[it + 14], 15, -1416354905),
        tt = md5ii(tt, nt, rt, et, _e[it + 5], 21, -57434055),
        et = md5ii(et, tt, nt, rt, _e[it + 12], 6, 1700485571),
        rt = md5ii(rt, et, tt, nt, _e[it + 3], 10, -1894986606),
        nt = md5ii(nt, rt, et, tt, _e[it + 10], 15, -1051523),
        tt = md5ii(tt, nt, rt, et, _e[it + 1], 21, -2054922799),
        et = md5ii(et, tt, nt, rt, _e[it + 8], 6, 1873313359),
        rt = md5ii(rt, et, tt, nt, _e[it + 15], 10, -30611744),
        nt = md5ii(nt, rt, et, tt, _e[it + 6], 15, -1560198380),
        tt = md5ii(tt, nt, rt, et, _e[it + 13], 21, 1309151649),
        et = md5ii(et, tt, nt, rt, _e[it + 4], 6, -145523070),
        rt = md5ii(rt, et, tt, nt, _e[it + 11], 10, -1120210379),
        nt = md5ii(nt, rt, et, tt, _e[it + 2], 15, 718787259),
        tt = md5ii(tt, nt, rt, et, _e[it + 9], 21, -343485551),
        et = safeAdd(et, ot),
        tt = safeAdd(tt, st),
        nt = safeAdd(nt, lt),
        rt = safeAdd(rt, ct)
    }
    return [et, tt, nt, rt]
}
function bytesToWords(_e) {
    if (_e.length === 0)
        return [];
    for (var $ = _e.length * 8, et = new Uint32Array(getOutputLength($)), tt = 0; tt < $; tt += 8)
        et[tt >> 5] |= (_e[tt / 8] & 255) << tt % 32;
    return et
}
function safeAdd(_e, $) {
    var et = (_e & 65535) + ($ & 65535)
      , tt = (_e >> 16) + ($ >> 16) + (et >> 16);
    return tt << 16 | et & 65535
}
function bitRotateLeft(_e, $) {
    return _e << $ | _e >>> 32 - $
}
function md5cmn(_e, $, et, tt, nt, rt) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd($, _e), safeAdd(tt, rt)), nt), et)
}
function md5ff(_e, $, et, tt, nt, rt, it) {
    return md5cmn($ & et | ~$ & tt, _e, $, nt, rt, it)
}
function md5gg(_e, $, et, tt, nt, rt, it) {
    return md5cmn($ & tt | et & ~tt, _e, $, nt, rt, it)
}
function md5hh(_e, $, et, tt, nt, rt, it) {
    return md5cmn($ ^ et ^ tt, _e, $, nt, rt, it)
}
function md5ii(_e, $, et, tt, nt, rt, it) {
    return md5cmn(et ^ ($ | ~tt), _e, $, nt, rt, it)
}
var v3 = v35("v3", 48, md5);
function v4(_e, $, et) {
    _e = _e || {};
    var tt = _e.random || (_e.rng || rng)();
    if (tt[6] = tt[6] & 15 | 64,
    tt[8] = tt[8] & 63 | 128,
    $) {
        et = et || 0;
        for (var nt = 0; nt < 16; ++nt)
            $[et + nt] = tt[nt];
        return $
    }
    return stringify$1(tt)
}
function f$3(_e, $, et, tt) {
    switch (_e) {
    case 0:
        return $ & et ^ ~$ & tt;
    case 1:
        return $ ^ et ^ tt;
    case 2:
        return $ & et ^ $ & tt ^ et & tt;
    case 3:
        return $ ^ et ^ tt
    }
}
function ROTL(_e, $) {
    return _e << $ | _e >>> 32 - $
}
function sha1(_e) {
    var $ = [1518500249, 1859775393, 2400959708, 3395469782]
      , et = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    if (typeof _e == "string") {
        var tt = unescape(encodeURIComponent(_e));
        _e = [];
        for (var nt = 0; nt < tt.length; ++nt)
            _e.push(tt.charCodeAt(nt))
    } else
        Array.isArray(_e) || (_e = Array.prototype.slice.call(_e));
    _e.push(128);
    for (var rt = _e.length / 4 + 2, it = Math.ceil(rt / 16), ot = new Array(it), st = 0; st < it; ++st) {
        for (var lt = new Uint32Array(16), ct = 0; ct < 16; ++ct)
            lt[ct] = _e[st * 64 + ct * 4] << 24 | _e[st * 64 + ct * 4 + 1] << 16 | _e[st * 64 + ct * 4 + 2] << 8 | _e[st * 64 + ct * 4 + 3];
        ot[st] = lt
    }
    ot[it - 1][14] = (_e.length - 1) * 8 / Math.pow(2, 32),
    ot[it - 1][14] = Math.floor(ot[it - 1][14]),
    ot[it - 1][15] = (_e.length - 1) * 8 & 4294967295;
    for (var dt = 0; dt < it; ++dt) {
        for (var pt = new Uint32Array(80), ht = 0; ht < 16; ++ht)
            pt[ht] = ot[dt][ht];
        for (var mt = 16; mt < 80; ++mt)
            pt[mt] = ROTL(pt[mt - 3] ^ pt[mt - 8] ^ pt[mt - 14] ^ pt[mt - 16], 1);
        for (var yt = et[0], Et = et[1], _t = et[2], wt = et[3], St = et[4], Ct = 0; Ct < 80; ++Ct) {
            var Nt = Math.floor(Ct / 20)
              , Lt = ROTL(yt, 5) + f$3(Nt, Et, _t, wt) + St + $[Nt] + pt[Ct] >>> 0;
            St = wt,
            wt = _t,
            _t = ROTL(Et, 30) >>> 0,
            Et = yt,
            yt = Lt
        }
        et[0] = et[0] + yt >>> 0,
        et[1] = et[1] + Et >>> 0,
        et[2] = et[2] + _t >>> 0,
        et[3] = et[3] + wt >>> 0,
        et[4] = et[4] + St >>> 0
    }
    return [et[0] >> 24 & 255, et[0] >> 16 & 255, et[0] >> 8 & 255, et[0] & 255, et[1] >> 24 & 255, et[1] >> 16 & 255, et[1] >> 8 & 255, et[1] & 255, et[2] >> 24 & 255, et[2] >> 16 & 255, et[2] >> 8 & 255, et[2] & 255, et[3] >> 24 & 255, et[3] >> 16 & 255, et[3] >> 8 & 255, et[3] & 255, et[4] >> 24 & 255, et[4] >> 16 & 255, et[4] >> 8 & 255, et[4] & 255]
}
var v5 = v35("v5", 80, sha1);
const nil = "00000000-0000-0000-0000-000000000000";
function version$1(_e) {
    if (!validate$1(_e))
        throw TypeError("Invalid UUID");
    return parseInt(_e.substr(14, 1), 16)
}
const esmBrowser = Object.freeze(Object.defineProperty({
    __proto__: null,
    NIL: nil,
    parse: parse$2,
    stringify: stringify$1,
    v1,
    v3,
    v4,
    v5,
    validate: validate$1,
    version: version$1
}, Symbol.toStringTag, {
    value: "Module"
}))
  , require$$4 = getAugmentedNamespace(esmBrowser)
  , uuid$1 = require$$4.v4
  , generateRequest$1 = function(_e, $, et, tt) {
    if (typeof _e != "string")
        throw new TypeError(_e + " must be a string");
    tt = tt || {};
    const nt = typeof tt.version == "number" ? tt.version : 2;
    if (nt !== 1 && nt !== 2)
        throw new TypeError(nt + " must be 1 or 2");
    const rt = {
        method: _e
    };
    if (nt === 2 && (rt.jsonrpc = "2.0"),
    $) {
        if (typeof $ != "object" && !Array.isArray($))
            throw new TypeError($ + " must be an object, array or omitted");
        rt.params = $
    }
    if (typeof et > "u") {
        const it = typeof tt.generator == "function" ? tt.generator : function() {
            return uuid$1()
        }
        ;
        rt.id = it(rt, tt)
    } else
        nt === 2 && et === null ? tt.notificationIdNull && (rt.id = null) : rt.id = et;
    return rt
};
var generateRequest_1 = generateRequest$1;
const uuid = require$$4.v4
  , generateRequest = generateRequest_1
  , ClientBrowser = function(_e, $) {
    if (!(this instanceof ClientBrowser))
        return new ClientBrowser(_e,$);
    $ || ($ = {}),
    this.options = {
        reviver: typeof $.reviver < "u" ? $.reviver : null,
        replacer: typeof $.replacer < "u" ? $.replacer : null,
        generator: typeof $.generator < "u" ? $.generator : function() {
            return uuid()
        }
        ,
        version: typeof $.version < "u" ? $.version : 2,
        notificationIdNull: typeof $.notificationIdNull == "boolean" ? $.notificationIdNull : !1
    },
    this.callServer = _e
};
var browser$2 = ClientBrowser;
ClientBrowser.prototype.request = function(_e, $, et, tt) {
    const nt = this;
    let rt = null;
    const it = Array.isArray(_e) && typeof $ == "function";
    if (this.options.version === 1 && it)
        throw new TypeError("JSON-RPC 1.0 does not support batching");
    if (it || !it && _e && typeof _e == "object" && typeof $ == "function")
        tt = $,
        rt = _e;
    else {
        typeof et == "function" && (tt = et,
        et = void 0);
        const lt = typeof tt == "function";
        try {
            rt = generateRequest(_e, $, et, {
                generator: this.options.generator,
                version: this.options.version,
                notificationIdNull: this.options.notificationIdNull
            })
        } catch (ct) {
            if (lt)
                return tt(ct);
            throw ct
        }
        if (!lt)
            return rt
    }
    let st;
    try {
        st = JSON.stringify(rt, this.options.replacer)
    } catch (lt) {
        return tt(lt)
    }
    return this.callServer(st, function(lt, ct) {
        nt._parseResponse(lt, ct, tt)
    }),
    rt
}
;
ClientBrowser.prototype._parseResponse = function(_e, $, et) {
    if (_e) {
        et(_e);
        return
    }
    if (!$)
        return et();
    let tt;
    try {
        tt = JSON.parse($, this.options.reviver)
    } catch (nt) {
        return et(nt)
    }
    if (et.length === 3)
        if (Array.isArray(tt)) {
            const nt = function(it) {
                return typeof it.error < "u"
            }
              , rt = function(it) {
                return !nt(it)
            };
            return et(null, tt.filter(nt), tt.filter(rt))
        } else
            return et(null, tt.error, tt.result);
    et(null, tt)
}
;
const RpcClient = getDefaultExportFromCjs$2(browser$2);
var eventemitter3$1 = {
    exports: {}
};
(function(_e) {
    var $ = Object.prototype.hasOwnProperty
      , et = "~";
    function tt() {}
    Object.create && (tt.prototype = Object.create(null),
    new tt().__proto__ || (et = !1));
    function nt(st, lt, ct) {
        this.fn = st,
        this.context = lt,
        this.once = ct || !1
    }
    function rt(st, lt, ct, dt, pt) {
        if (typeof ct != "function")
            throw new TypeError("The listener must be a function");
        var ht = new nt(ct,dt || st,pt)
          , mt = et ? et + lt : lt;
        return st._events[mt] ? st._events[mt].fn ? st._events[mt] = [st._events[mt], ht] : st._events[mt].push(ht) : (st._events[mt] = ht,
        st._eventsCount++),
        st
    }
    function it(st, lt) {
        --st._eventsCount === 0 ? st._events = new tt : delete st._events[lt]
    }
    function ot() {
        this._events = new tt,
        this._eventsCount = 0
    }
    ot.prototype.eventNames = function() {
        var lt = [], ct, dt;
        if (this._eventsCount === 0)
            return lt;
        for (dt in ct = this._events)
            $.call(ct, dt) && lt.push(et ? dt.slice(1) : dt);
        return Object.getOwnPropertySymbols ? lt.concat(Object.getOwnPropertySymbols(ct)) : lt
    }
    ,
    ot.prototype.listeners = function(lt) {
        var ct = et ? et + lt : lt
          , dt = this._events[ct];
        if (!dt)
            return [];
        if (dt.fn)
            return [dt.fn];
        for (var pt = 0, ht = dt.length, mt = new Array(ht); pt < ht; pt++)
            mt[pt] = dt[pt].fn;
        return mt
    }
    ,
    ot.prototype.listenerCount = function(lt) {
        var ct = et ? et + lt : lt
          , dt = this._events[ct];
        return dt ? dt.fn ? 1 : dt.length : 0
    }
    ,
    ot.prototype.emit = function(lt, ct, dt, pt, ht, mt) {
        var yt = et ? et + lt : lt;
        if (!this._events[yt])
            return !1;
        var Et = this._events[yt], _t = arguments.length, wt, St;
        if (Et.fn) {
            switch (Et.once && this.removeListener(lt, Et.fn, void 0, !0),
            _t) {
            case 1:
                return Et.fn.call(Et.context),
                !0;
            case 2:
                return Et.fn.call(Et.context, ct),
                !0;
            case 3:
                return Et.fn.call(Et.context, ct, dt),
                !0;
            case 4:
                return Et.fn.call(Et.context, ct, dt, pt),
                !0;
            case 5:
                return Et.fn.call(Et.context, ct, dt, pt, ht),
                !0;
            case 6:
                return Et.fn.call(Et.context, ct, dt, pt, ht, mt),
                !0
            }
            for (St = 1,
            wt = new Array(_t - 1); St < _t; St++)
                wt[St - 1] = arguments[St];
            Et.fn.apply(Et.context, wt)
        } else {
            var Ct = Et.length, Nt;
            for (St = 0; St < Ct; St++)
                switch (Et[St].once && this.removeListener(lt, Et[St].fn, void 0, !0),
                _t) {
                case 1:
                    Et[St].fn.call(Et[St].context);
                    break;
                case 2:
                    Et[St].fn.call(Et[St].context, ct);
                    break;
                case 3:
                    Et[St].fn.call(Et[St].context, ct, dt);
                    break;
                case 4:
                    Et[St].fn.call(Et[St].context, ct, dt, pt);
                    break;
                default:
                    if (!wt)
                        for (Nt = 1,
                        wt = new Array(_t - 1); Nt < _t; Nt++)
                            wt[Nt - 1] = arguments[Nt];
                    Et[St].fn.apply(Et[St].context, wt)
                }
        }
        return !0
    }
    ,
    ot.prototype.on = function(lt, ct, dt) {
        return rt(this, lt, ct, dt, !1)
    }
    ,
    ot.prototype.once = function(lt, ct, dt) {
        return rt(this, lt, ct, dt, !0)
    }
    ,
    ot.prototype.removeListener = function(lt, ct, dt, pt) {
        var ht = et ? et + lt : lt;
        if (!this._events[ht])
            return this;
        if (!ct)
            return it(this, ht),
            this;
        var mt = this._events[ht];
        if (mt.fn)
            mt.fn === ct && (!pt || mt.once) && (!dt || mt.context === dt) && it(this, ht);
        else {
            for (var yt = 0, Et = [], _t = mt.length; yt < _t; yt++)
                (mt[yt].fn !== ct || pt && !mt[yt].once || dt && mt[yt].context !== dt) && Et.push(mt[yt]);
            Et.length ? this._events[ht] = Et.length === 1 ? Et[0] : Et : it(this, ht)
        }
        return this
    }
    ,
    ot.prototype.removeAllListeners = function(lt) {
        var ct;
        return lt ? (ct = et ? et + lt : lt,
        this._events[ct] && it(this, ct)) : (this._events = new tt,
        this._eventsCount = 0),
        this
    }
    ,
    ot.prototype.off = ot.prototype.removeListener,
    ot.prototype.addListener = ot.prototype.on,
    ot.prefixed = et,
    ot.EventEmitter = ot,
    _e.exports = ot
}
)(eventemitter3$1);
var eventemitter3Exports$1 = eventemitter3$1.exports;
const EventEmitter$2 = getDefaultExportFromCjs$2(eventemitter3Exports$1);
var WebSocketBrowserImpl = class extends EventEmitter$2 {
    constructor($, et, tt) {
        super();
        Br(this, "socket");
        this.socket = new window.WebSocket($,tt),
        this.socket.onopen = () => this.emit("open"),
        this.socket.onmessage = nt => this.emit("message", nt.data),
        this.socket.onerror = nt => this.emit("error", nt),
        this.socket.onclose = nt => {
            this.emit("close", nt.code, nt.reason)
        }
    }
    send($, et, tt) {
        const nt = tt || et;
        try {
            this.socket.send($),
            nt()
        } catch (rt) {
            nt(rt)
        }
    }
    close($, et) {
        this.socket.close($, et)
    }
    addEventListener($, et, tt) {
        this.socket.addEventListener($, et, tt)
    }
}
;
function WebSocket$1(_e, $) {
    return new WebSocketBrowserImpl(_e,$)
}
var DefaultDataPack = class {
    encode(_e) {
        return JSON.stringify(_e)
    }
    decode(_e) {
        return JSON.parse(_e)
    }
}
  , CommonClient = class extends EventEmitter$2 {
    constructor($, et="ws://localhost:8080", {autoconnect: tt=!0, reconnect: nt=!0, reconnect_interval: rt=1e3, max_reconnects: it=5, ...ot}={}, st, lt) {
        super();
        Br(this, "address");
        Br(this, "rpc_id");
        Br(this, "queue");
        Br(this, "options");
        Br(this, "autoconnect");
        Br(this, "ready");
        Br(this, "reconnect");
        Br(this, "reconnect_timer_id");
        Br(this, "reconnect_interval");
        Br(this, "max_reconnects");
        Br(this, "rest_options");
        Br(this, "current_reconnects");
        Br(this, "generate_request_id");
        Br(this, "socket");
        Br(this, "webSocketFactory");
        Br(this, "dataPack");
        this.webSocketFactory = $,
        this.queue = {},
        this.rpc_id = 0,
        this.address = et,
        this.autoconnect = tt,
        this.ready = !1,
        this.reconnect = nt,
        this.reconnect_timer_id = void 0,
        this.reconnect_interval = rt,
        this.max_reconnects = it,
        this.rest_options = ot,
        this.current_reconnects = 0,
        this.generate_request_id = st || ( () => ++this.rpc_id),
        lt ? this.dataPack = lt : this.dataPack = new DefaultDataPack,
        this.autoconnect && this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
        })
    }
    connect() {
        this.socket || this._connect(this.address, {
            autoconnect: this.autoconnect,
            reconnect: this.reconnect,
            reconnect_interval: this.reconnect_interval,
            max_reconnects: this.max_reconnects,
            ...this.rest_options
        })
    }
    call($, et, tt, nt) {
        return !nt && typeof tt == "object" && (nt = tt,
        tt = null),
        new Promise( (rt, it) => {
            if (!this.ready)
                return it(new Error("socket not ready"));
            const ot = this.generate_request_id($, et)
              , st = {
                jsonrpc: "2.0",
                method: $,
                params: et || void 0,
                id: ot
            };
            this.socket.send(this.dataPack.encode(st), nt, lt => {
                if (lt)
                    return it(lt);
                this.queue[ot] = {
                    promise: [rt, it]
                },
                tt && (this.queue[ot].timeout = setTimeout( () => {
                    delete this.queue[ot],
                    it(new Error("reply timeout"))
                }
                , tt))
            }
            )
        }
        )
    }
    async login($) {
        const et = await this.call("rpc.login", $);
        if (!et)
            throw new Error("authentication failed");
        return et
    }
    async listMethods() {
        return await this.call("__listMethods")
    }
    notify($, et) {
        return new Promise( (tt, nt) => {
            if (!this.ready)
                return nt(new Error("socket not ready"));
            const rt = {
                jsonrpc: "2.0",
                method: $,
                params: et
            };
            this.socket.send(this.dataPack.encode(rt), it => {
                if (it)
                    return nt(it);
                tt()
            }
            )
        }
        )
    }
    async subscribe($) {
        typeof $ == "string" && ($ = [$]);
        const et = await this.call("rpc.on", $);
        if (typeof $ == "string" && et[$] !== "ok")
            throw new Error("Failed subscribing to an event '" + $ + "' with: " + et[$]);
        return et
    }
    async unsubscribe($) {
        typeof $ == "string" && ($ = [$]);
        const et = await this.call("rpc.off", $);
        if (typeof $ == "string" && et[$] !== "ok")
            throw new Error("Failed unsubscribing from an event with: " + et);
        return et
    }
    close($, et) {
        this.socket.close($ || 1e3, et)
    }
    setAutoReconnect($) {
        this.reconnect = $
    }
    setReconnectInterval($) {
        this.reconnect_interval = $
    }
    setMaxReconnects($) {
        this.max_reconnects = $
    }
    _connect($, et) {
        clearTimeout(this.reconnect_timer_id),
        this.socket = this.webSocketFactory($, et),
        this.socket.addEventListener("open", () => {
            this.ready = !0,
            this.emit("open"),
            this.current_reconnects = 0
        }
        ),
        this.socket.addEventListener("message", ({data: tt}) => {
            tt instanceof ArrayBuffer && (tt = Buffer$1$1.from(tt).toString());
            try {
                tt = this.dataPack.decode(tt)
            } catch {
                return
            }
            if (tt.notification && this.listeners(tt.notification).length) {
                if (!Object.keys(tt.params).length)
                    return this.emit(tt.notification);
                const nt = [tt.notification];
                if (tt.params.constructor === Object)
                    nt.push(tt.params);
                else
                    for (let rt = 0; rt < tt.params.length; rt++)
                        nt.push(tt.params[rt]);
                return Promise.resolve().then( () => {
                    this.emit.apply(this, nt)
                }
                )
            }
            if (!this.queue[tt.id])
                return tt.method ? Promise.resolve().then( () => {
                    this.emit(tt.method, tt == null ? void 0 : tt.params)
                }
                ) : void 0;
            "error"in tt == "result"in tt && this.queue[tt.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')),
            this.queue[tt.id].timeout && clearTimeout(this.queue[tt.id].timeout),
            tt.error ? this.queue[tt.id].promise[1](tt.error) : this.queue[tt.id].promise[0](tt.result),
            delete this.queue[tt.id]
        }
        ),
        this.socket.addEventListener("error", tt => this.emit("error", tt)),
        this.socket.addEventListener("close", ({code: tt, reason: nt}) => {
            this.ready && setTimeout( () => this.emit("close", tt, nt), 0),
            this.ready = !1,
            this.socket = void 0,
            tt !== 1e3 && (this.current_reconnects++,
            this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0) && (this.reconnect_timer_id = setTimeout( () => this._connect($, et), this.reconnect_interval)))
        }
        )
    }
}
;
const SHA3_PI = []
  , SHA3_ROTL = []
  , _SHA3_IOTA = []
  , _0n$1 = BigInt(0)
  , _1n$2 = BigInt(1)
  , _2n$1 = BigInt(2)
  , _7n = BigInt(7)
  , _256n = BigInt(256)
  , _0x71n = BigInt(113);
for (let _e = 0, $ = _1n$2, et = 1, tt = 0; _e < 24; _e++) {
    [et,tt] = [tt, (2 * et + 3 * tt) % 5],
    SHA3_PI.push(2 * (5 * tt + et)),
    SHA3_ROTL.push((_e + 1) * (_e + 2) / 2 % 64);
    let nt = _0n$1;
    for (let rt = 0; rt < 7; rt++)
        $ = ($ << _1n$2 ^ ($ >> _7n) * _0x71n) % _256n,
        $ & _2n$1 && (nt ^= _1n$2 << (_1n$2 << BigInt(rt)) - _1n$2);
    _SHA3_IOTA.push(nt)
}
const [SHA3_IOTA_H,SHA3_IOTA_L] = split$1(_SHA3_IOTA, !0)
  , rotlH = (_e, $, et) => et > 32 ? rotlBH(_e, $, et) : rotlSH(_e, $, et)
  , rotlL = (_e, $, et) => et > 32 ? rotlBL(_e, $, et) : rotlSL(_e, $, et);
function keccakP(_e, $=24) {
    const et = new Uint32Array(10);
    for (let tt = 24 - $; tt < 24; tt++) {
        for (let it = 0; it < 10; it++)
            et[it] = _e[it] ^ _e[it + 10] ^ _e[it + 20] ^ _e[it + 30] ^ _e[it + 40];
        for (let it = 0; it < 10; it += 2) {
            const ot = (it + 8) % 10
              , st = (it + 2) % 10
              , lt = et[st]
              , ct = et[st + 1]
              , dt = rotlH(lt, ct, 1) ^ et[ot]
              , pt = rotlL(lt, ct, 1) ^ et[ot + 1];
            for (let ht = 0; ht < 50; ht += 10)
                _e[it + ht] ^= dt,
                _e[it + ht + 1] ^= pt
        }
        let nt = _e[2]
          , rt = _e[3];
        for (let it = 0; it < 24; it++) {
            const ot = SHA3_ROTL[it]
              , st = rotlH(nt, rt, ot)
              , lt = rotlL(nt, rt, ot)
              , ct = SHA3_PI[it];
            nt = _e[ct],
            rt = _e[ct + 1],
            _e[ct] = st,
            _e[ct + 1] = lt
        }
        for (let it = 0; it < 50; it += 10) {
            for (let ot = 0; ot < 10; ot++)
                et[ot] = _e[it + ot];
            for (let ot = 0; ot < 10; ot++)
                _e[it + ot] ^= ~et[(ot + 2) % 10] & et[(ot + 4) % 10]
        }
        _e[0] ^= SHA3_IOTA_H[tt],
        _e[1] ^= SHA3_IOTA_L[tt]
    }
    et.fill(0)
}
class Keccak extends Hash$3 {
    constructor($, et, tt, nt=!1, rt=24) {
        if (super(),
        this.blockLen = $,
        this.suffix = et,
        this.outputLen = tt,
        this.enableXOF = nt,
        this.rounds = rt,
        this.pos = 0,
        this.posOut = 0,
        this.finished = !1,
        this.destroyed = !1,
        anumber(tt),
        0 >= this.blockLen || this.blockLen >= 200)
            throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200),
        this.state32 = u32$2(this.state)
    }
    keccak() {
        isLE || byteSwap32(this.state32),
        keccakP(this.state32, this.rounds),
        isLE || byteSwap32(this.state32),
        this.posOut = 0,
        this.pos = 0
    }
    update($) {
        aexists(this);
        const {blockLen: et, state: tt} = this;
        $ = toBytes($);
        const nt = $.length;
        for (let rt = 0; rt < nt; ) {
            const it = Math.min(et - this.pos, nt - rt);
            for (let ot = 0; ot < it; ot++)
                tt[this.pos++] ^= $[rt++];
            this.pos === et && this.keccak()
        }
        return this
    }
    finish() {
        if (this.finished)
            return;
        this.finished = !0;
        const {state: $, suffix: et, pos: tt, blockLen: nt} = this;
        $[tt] ^= et,
        et & 128 && tt === nt - 1 && this.keccak(),
        $[nt - 1] ^= 128,
        this.keccak()
    }
    writeInto($) {
        aexists(this, !1),
        abytes$1($),
        this.finish();
        const et = this.state
          , {blockLen: tt} = this;
        for (let nt = 0, rt = $.length; nt < rt; ) {
            this.posOut >= tt && this.keccak();
            const it = Math.min(tt - this.posOut, rt - nt);
            $.set(et.subarray(this.posOut, this.posOut + it), nt),
            this.posOut += it,
            nt += it
        }
        return $
    }
    xofInto($) {
        if (!this.enableXOF)
            throw new Error("XOF is not possible for this instance");
        return this.writeInto($)
    }
    xof($) {
        return anumber($),
        this.xofInto(new Uint8Array($))
    }
    digestInto($) {
        if (aoutput($, this),
        this.finished)
            throw new Error("digest() was already called");
        return this.writeInto($),
        this.destroy(),
        $
    }
    digest() {
        return this.digestInto(new Uint8Array(this.outputLen))
    }
    destroy() {
        this.destroyed = !0,
        this.state.fill(0)
    }
    _cloneInto($) {
        const {blockLen: et, suffix: tt, outputLen: nt, rounds: rt, enableXOF: it} = this;
        return $ || ($ = new Keccak(et,tt,nt,it,rt)),
        $.state32.set(this.state32),
        $.pos = this.pos,
        $.posOut = this.posOut,
        $.finished = this.finished,
        $.rounds = rt,
        $.suffix = tt,
        $.outputLen = nt,
        $.enableXOF = it,
        $.destroyed = this.destroyed,
        $
    }
}
const gen = (_e, $, et) => wrapConstructor( () => new Keccak($,_e,et))
  , keccak_256 = gen(1, 136, 256 / 8);
class HMAC extends Hash$3 {
    constructor($, et) {
        super(),
        this.finished = !1,
        this.destroyed = !1,
        ahash($);
        const tt = toBytes(et);
        if (this.iHash = $.create(),
        typeof this.iHash.update != "function")
            throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen,
        this.outputLen = this.iHash.outputLen;
        const nt = this.blockLen
          , rt = new Uint8Array(nt);
        rt.set(tt.length > nt ? $.create().update(tt).digest() : tt);
        for (let it = 0; it < rt.length; it++)
            rt[it] ^= 54;
        this.iHash.update(rt),
        this.oHash = $.create();
        for (let it = 0; it < rt.length; it++)
            rt[it] ^= 106;
        this.oHash.update(rt),
        rt.fill(0)
    }
    update($) {
        return aexists(this),
        this.iHash.update($),
        this
    }
    digestInto($) {
        aexists(this),
        abytes$1($, this.outputLen),
        this.finished = !0,
        this.iHash.digestInto($),
        this.oHash.update($),
        this.oHash.digestInto($),
        this.destroy()
    }
    digest() {
        const $ = new Uint8Array(this.oHash.outputLen);
        return this.digestInto($),
        $
    }
    _cloneInto($) {
        $ || ($ = Object.create(Object.getPrototypeOf(this), {}));
        const {oHash: et, iHash: tt, finished: nt, destroyed: rt, blockLen: it, outputLen: ot} = this;
        return $ = $,
        $.finished = nt,
        $.destroyed = rt,
        $.blockLen = it,
        $.outputLen = ot,
        $.oHash = et._cloneInto($.oHash),
        $.iHash = tt._cloneInto($.iHash),
        $
    }
    destroy() {
        this.destroyed = !0,
        this.oHash.destroy(),
        this.iHash.destroy()
    }
}
const hmac = (_e, $, et) => new HMAC(_e,$).update(et).digest();
hmac.create = (_e, $) => new HMAC(_e,$);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function validateSigVerOpts(_e) {
    _e.lowS !== void 0 && abool("lowS", _e.lowS),
    _e.prehash !== void 0 && abool("prehash", _e.prehash)
}
function validatePointOpts(_e) {
    const $ = validateBasic(_e);
    validateObject($, {
        a: "field",
        b: "field"
    }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
    });
    const {endo: et, Fp: tt, a: nt} = $;
    if (et) {
        if (!tt.eql(nt, tt.ZERO))
            throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");
        if (typeof et != "object" || typeof et.beta != "bigint" || typeof et.splitScalar != "function")
            throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")
    }
    return Object.freeze({
        ...$
    })
}
const {bytesToNumberBE: b2n, hexToBytes: h2b} = ut;
class DERErr extends Error {
    constructor($="") {
        super($)
    }
}
const DER = {
    Err: DERErr,
    _tlv: {
        encode: (_e, $) => {
            const {Err: et} = DER;
            if (_e < 0 || _e > 256)
                throw new et("tlv.encode: wrong tag");
            if ($.length & 1)
                throw new et("tlv.encode: unpadded data");
            const tt = $.length / 2
              , nt = numberToHexUnpadded(tt);
            if (nt.length / 2 & 128)
                throw new et("tlv.encode: long form length too big");
            const rt = tt > 127 ? numberToHexUnpadded(nt.length / 2 | 128) : "";
            return numberToHexUnpadded(_e) + rt + nt + $
        }
        ,
        decode(_e, $) {
            const {Err: et} = DER;
            let tt = 0;
            if (_e < 0 || _e > 256)
                throw new et("tlv.encode: wrong tag");
            if ($.length < 2 || $[tt++] !== _e)
                throw new et("tlv.decode: wrong tlv");
            const nt = $[tt++]
              , rt = !!(nt & 128);
            let it = 0;
            if (!rt)
                it = nt;
            else {
                const st = nt & 127;
                if (!st)
                    throw new et("tlv.decode(long): indefinite length not supported");
                if (st > 4)
                    throw new et("tlv.decode(long): byte length is too big");
                const lt = $.subarray(tt, tt + st);
                if (lt.length !== st)
                    throw new et("tlv.decode: length bytes not complete");
                if (lt[0] === 0)
                    throw new et("tlv.decode(long): zero leftmost byte");
                for (const ct of lt)
                    it = it << 8 | ct;
                if (tt += st,
                it < 128)
                    throw new et("tlv.decode(long): not minimal encoding")
            }
            const ot = $.subarray(tt, tt + it);
            if (ot.length !== it)
                throw new et("tlv.decode: wrong value length");
            return {
                v: ot,
                l: $.subarray(tt + it)
            }
        }
    },
    _int: {
        encode(_e) {
            const {Err: $} = DER;
            if (_e < _0n)
                throw new $("integer: negative integers are not allowed");
            let et = numberToHexUnpadded(_e);
            if (Number.parseInt(et[0], 16) & 8 && (et = "00" + et),
            et.length & 1)
                throw new $("unexpected DER parsing assertion: unpadded hex");
            return et
        },
        decode(_e) {
            const {Err: $} = DER;
            if (_e[0] & 128)
                throw new $("invalid signature integer: negative");
            if (_e[0] === 0 && !(_e[1] & 128))
                throw new $("invalid signature integer: unnecessary leading zero");
            return b2n(_e)
        }
    },
    toSig(_e) {
        const {Err: $, _int: et, _tlv: tt} = DER
          , nt = typeof _e == "string" ? h2b(_e) : _e;
        abytes(nt);
        const {v: rt, l: it} = tt.decode(48, nt);
        if (it.length)
            throw new $("invalid signature: left bytes after parsing");
        const {v: ot, l: st} = tt.decode(2, rt)
          , {v: lt, l: ct} = tt.decode(2, st);
        if (ct.length)
            throw new $("invalid signature: left bytes after parsing");
        return {
            r: et.decode(ot),
            s: et.decode(lt)
        }
    },
    hexFromSig(_e) {
        const {_tlv: $, _int: et} = DER
          , tt = $.encode(2, et.encode(_e.r))
          , nt = $.encode(2, et.encode(_e.s))
          , rt = tt + nt;
        return $.encode(48, rt)
    }
}
  , _0n = BigInt(0)
  , _1n$1 = BigInt(1);
BigInt(2);
const _3n = BigInt(3);
BigInt(4);
function weierstrassPoints(_e) {
    const $ = validatePointOpts(_e)
      , {Fp: et} = $
      , tt = Field($.n, $.nBitLength)
      , nt = $.toBytes || ( (yt, Et, _t) => {
        const wt = Et.toAffine();
        return concatBytes(Uint8Array.from([4]), et.toBytes(wt.x), et.toBytes(wt.y))
    }
    )
      , rt = $.fromBytes || (yt => {
        const Et = yt.subarray(1)
          , _t = et.fromBytes(Et.subarray(0, et.BYTES))
          , wt = et.fromBytes(Et.subarray(et.BYTES, 2 * et.BYTES));
        return {
            x: _t,
            y: wt
        }
    }
    );
    function it(yt) {
        const {a: Et, b: _t} = $
          , wt = et.sqr(yt)
          , St = et.mul(wt, yt);
        return et.add(et.add(St, et.mul(yt, Et)), _t)
    }
    if (!et.eql(et.sqr($.Gy), it($.Gx)))
        throw new Error("bad generator point: equation left != right");
    function ot(yt) {
        return inRange$1(yt, _1n$1, $.n)
    }
    function st(yt) {
        const {allowedPrivateKeyLengths: Et, nByteLength: _t, wrapPrivateKey: wt, n: St} = $;
        if (Et && typeof yt != "bigint") {
            if (isBytes(yt) && (yt = bytesToHex(yt)),
            typeof yt != "string" || !Et.includes(yt.length))
                throw new Error("invalid private key");
            yt = yt.padStart(_t * 2, "0")
        }
        let Ct;
        try {
            Ct = typeof yt == "bigint" ? yt : bytesToNumberBE(ensureBytes("private key", yt, _t))
        } catch {
            throw new Error("invalid private key, expected hex or " + _t + " bytes, got " + typeof yt)
        }
        return wt && (Ct = mod$1(Ct, St)),
        aInRange("private key", Ct, _1n$1, St),
        Ct
    }
    function lt(yt) {
        if (!(yt instanceof pt))
            throw new Error("ProjectivePoint expected")
    }
    const ct = memoized( (yt, Et) => {
        const {px: _t, py: wt, pz: St} = yt;
        if (et.eql(St, et.ONE))
            return {
                x: _t,
                y: wt
            };
        const Ct = yt.is0();
        Et == null && (Et = Ct ? et.ONE : et.inv(St));
        const Nt = et.mul(_t, Et)
          , Lt = et.mul(wt, Et)
          , kt = et.mul(St, Et);
        if (Ct)
            return {
                x: et.ZERO,
                y: et.ZERO
            };
        if (!et.eql(kt, et.ONE))
            throw new Error("invZ was invalid");
        return {
            x: Nt,
            y: Lt
        }
    }
    )
      , dt = memoized(yt => {
        if (yt.is0()) {
            if ($.allowInfinityPoint && !et.is0(yt.py))
                return;
            throw new Error("bad point: ZERO")
        }
        const {x: Et, y: _t} = yt.toAffine();
        if (!et.isValid(Et) || !et.isValid(_t))
            throw new Error("bad point: x or y not FE");
        const wt = et.sqr(_t)
          , St = it(Et);
        if (!et.eql(wt, St))
            throw new Error("bad point: equation left != right");
        if (!yt.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        return !0
    }
    );
    class pt {
        constructor(Et, _t, wt) {
            if (this.px = Et,
            this.py = _t,
            this.pz = wt,
            Et == null || !et.isValid(Et))
                throw new Error("x required");
            if (_t == null || !et.isValid(_t))
                throw new Error("y required");
            if (wt == null || !et.isValid(wt))
                throw new Error("z required");
            Object.freeze(this)
        }
        static fromAffine(Et) {
            const {x: _t, y: wt} = Et || {};
            if (!Et || !et.isValid(_t) || !et.isValid(wt))
                throw new Error("invalid affine point");
            if (Et instanceof pt)
                throw new Error("projective point not allowed");
            const St = Ct => et.eql(Ct, et.ZERO);
            return St(_t) && St(wt) ? pt.ZERO : new pt(_t,wt,et.ONE)
        }
        get x() {
            return this.toAffine().x
        }
        get y() {
            return this.toAffine().y
        }
        static normalizeZ(Et) {
            const _t = et.invertBatch(Et.map(wt => wt.pz));
            return Et.map( (wt, St) => wt.toAffine(_t[St])).map(pt.fromAffine)
        }
        static fromHex(Et) {
            const _t = pt.fromAffine(rt(ensureBytes("pointHex", Et)));
            return _t.assertValidity(),
            _t
        }
        static fromPrivateKey(Et) {
            return pt.BASE.multiply(st(Et))
        }
        static msm(Et, _t) {
            return pippenger(pt, tt, Et, _t)
        }
        _setWindowSize(Et) {
            mt.setWindowSize(this, Et)
        }
        assertValidity() {
            dt(this)
        }
        hasEvenY() {
            const {y: Et} = this.toAffine();
            if (et.isOdd)
                return !et.isOdd(Et);
            throw new Error("Field doesn't support isOdd")
        }
        equals(Et) {
            lt(Et);
            const {px: _t, py: wt, pz: St} = this
              , {px: Ct, py: Nt, pz: Lt} = Et
              , kt = et.eql(et.mul(_t, Lt), et.mul(Ct, St))
              , Ut = et.eql(et.mul(wt, Lt), et.mul(Nt, St));
            return kt && Ut
        }
        negate() {
            return new pt(this.px,et.neg(this.py),this.pz)
        }
        double() {
            const {a: Et, b: _t} = $
              , wt = et.mul(_t, _3n)
              , {px: St, py: Ct, pz: Nt} = this;
            let Lt = et.ZERO
              , kt = et.ZERO
              , Ut = et.ZERO
              , Jt = et.mul(St, St)
              , Pt = et.mul(Ct, Ct)
              , Xt = et.mul(Nt, Nt)
              , rn = et.mul(St, Ct);
            return rn = et.add(rn, rn),
            Ut = et.mul(St, Nt),
            Ut = et.add(Ut, Ut),
            Lt = et.mul(Et, Ut),
            kt = et.mul(wt, Xt),
            kt = et.add(Lt, kt),
            Lt = et.sub(Pt, kt),
            kt = et.add(Pt, kt),
            kt = et.mul(Lt, kt),
            Lt = et.mul(rn, Lt),
            Ut = et.mul(wt, Ut),
            Xt = et.mul(Et, Xt),
            rn = et.sub(Jt, Xt),
            rn = et.mul(Et, rn),
            rn = et.add(rn, Ut),
            Ut = et.add(Jt, Jt),
            Jt = et.add(Ut, Jt),
            Jt = et.add(Jt, Xt),
            Jt = et.mul(Jt, rn),
            kt = et.add(kt, Jt),
            Xt = et.mul(Ct, Nt),
            Xt = et.add(Xt, Xt),
            Jt = et.mul(Xt, rn),
            Lt = et.sub(Lt, Jt),
            Ut = et.mul(Xt, Pt),
            Ut = et.add(Ut, Ut),
            Ut = et.add(Ut, Ut),
            new pt(Lt,kt,Ut)
        }
        add(Et) {
            lt(Et);
            const {px: _t, py: wt, pz: St} = this
              , {px: Ct, py: Nt, pz: Lt} = Et;
            let kt = et.ZERO
              , Ut = et.ZERO
              , Jt = et.ZERO;
            const Pt = $.a
              , Xt = et.mul($.b, _3n);
            let rn = et.mul(_t, Ct)
              , zt = et.mul(wt, Nt)
              , xt = et.mul(St, Lt)
              , $t = et.add(_t, wt)
              , Dt = et.add(Ct, Nt);
            $t = et.mul($t, Dt),
            Dt = et.add(rn, zt),
            $t = et.sub($t, Dt),
            Dt = et.add(_t, St);
            let jt = et.add(Ct, Lt);
            return Dt = et.mul(Dt, jt),
            jt = et.add(rn, xt),
            Dt = et.sub(Dt, jt),
            jt = et.add(wt, St),
            kt = et.add(Nt, Lt),
            jt = et.mul(jt, kt),
            kt = et.add(zt, xt),
            jt = et.sub(jt, kt),
            Jt = et.mul(Pt, Dt),
            kt = et.mul(Xt, xt),
            Jt = et.add(kt, Jt),
            kt = et.sub(zt, Jt),
            Jt = et.add(zt, Jt),
            Ut = et.mul(kt, Jt),
            zt = et.add(rn, rn),
            zt = et.add(zt, rn),
            xt = et.mul(Pt, xt),
            Dt = et.mul(Xt, Dt),
            zt = et.add(zt, xt),
            xt = et.sub(rn, xt),
            xt = et.mul(Pt, xt),
            Dt = et.add(Dt, xt),
            rn = et.mul(zt, Dt),
            Ut = et.add(Ut, rn),
            rn = et.mul(jt, Dt),
            kt = et.mul($t, kt),
            kt = et.sub(kt, rn),
            rn = et.mul($t, zt),
            Jt = et.mul(jt, Jt),
            Jt = et.add(Jt, rn),
            new pt(kt,Ut,Jt)
        }
        subtract(Et) {
            return this.add(Et.negate())
        }
        is0() {
            return this.equals(pt.ZERO)
        }
        wNAF(Et) {
            return mt.wNAFCached(this, Et, pt.normalizeZ)
        }
        multiplyUnsafe(Et) {
            const {endo: _t, n: wt} = $;
            aInRange("scalar", Et, _0n, wt);
            const St = pt.ZERO;
            if (Et === _0n)
                return St;
            if (this.is0() || Et === _1n$1)
                return this;
            if (!_t || mt.hasPrecomputes(this))
                return mt.wNAFCachedUnsafe(this, Et, pt.normalizeZ);
            let {k1neg: Ct, k1: Nt, k2neg: Lt, k2: kt} = _t.splitScalar(Et)
              , Ut = St
              , Jt = St
              , Pt = this;
            for (; Nt > _0n || kt > _0n; )
                Nt & _1n$1 && (Ut = Ut.add(Pt)),
                kt & _1n$1 && (Jt = Jt.add(Pt)),
                Pt = Pt.double(),
                Nt >>= _1n$1,
                kt >>= _1n$1;
            return Ct && (Ut = Ut.negate()),
            Lt && (Jt = Jt.negate()),
            Jt = new pt(et.mul(Jt.px, _t.beta),Jt.py,Jt.pz),
            Ut.add(Jt)
        }
        multiply(Et) {
            const {endo: _t, n: wt} = $;
            aInRange("scalar", Et, _1n$1, wt);
            let St, Ct;
            if (_t) {
                const {k1neg: Nt, k1: Lt, k2neg: kt, k2: Ut} = _t.splitScalar(Et);
                let {p: Jt, f: Pt} = this.wNAF(Lt)
                  , {p: Xt, f: rn} = this.wNAF(Ut);
                Jt = mt.constTimeNegate(Nt, Jt),
                Xt = mt.constTimeNegate(kt, Xt),
                Xt = new pt(et.mul(Xt.px, _t.beta),Xt.py,Xt.pz),
                St = Jt.add(Xt),
                Ct = Pt.add(rn)
            } else {
                const {p: Nt, f: Lt} = this.wNAF(Et);
                St = Nt,
                Ct = Lt
            }
            return pt.normalizeZ([St, Ct])[0]
        }
        multiplyAndAddUnsafe(Et, _t, wt) {
            const St = pt.BASE
              , Ct = (Lt, kt) => kt === _0n || kt === _1n$1 || !Lt.equals(St) ? Lt.multiplyUnsafe(kt) : Lt.multiply(kt)
              , Nt = Ct(this, _t).add(Ct(Et, wt));
            return Nt.is0() ? void 0 : Nt
        }
        toAffine(Et) {
            return ct(this, Et)
        }
        isTorsionFree() {
            const {h: Et, isTorsionFree: _t} = $;
            if (Et === _1n$1)
                return !0;
            if (_t)
                return _t(pt, this);
            throw new Error("isTorsionFree() has not been declared for the elliptic curve")
        }
        clearCofactor() {
            const {h: Et, clearCofactor: _t} = $;
            return Et === _1n$1 ? this : _t ? _t(pt, this) : this.multiplyUnsafe($.h)
        }
        toRawBytes(Et=!0) {
            return abool("isCompressed", Et),
            this.assertValidity(),
            nt(pt, this, Et)
        }
        toHex(Et=!0) {
            return abool("isCompressed", Et),
            bytesToHex(this.toRawBytes(Et))
        }
    }
    pt.BASE = new pt($.Gx,$.Gy,et.ONE),
    pt.ZERO = new pt(et.ZERO,et.ONE,et.ZERO);
    const ht = $.nBitLength
      , mt = wNAF(pt, $.endo ? Math.ceil(ht / 2) : ht);
    return {
        CURVE: $,
        ProjectivePoint: pt,
        normPrivateKeyToScalar: st,
        weierstrassEquation: it,
        isWithinCurveOrder: ot
    }
}
function validateOpts(_e) {
    const $ = validateBasic(_e);
    return validateObject($, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
    }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
    }),
    Object.freeze({
        lowS: !0,
        ...$
    })
}
function weierstrass(_e) {
    const $ = validateOpts(_e)
      , {Fp: et, n: tt} = $
      , nt = et.BYTES + 1
      , rt = 2 * et.BYTES + 1;
    function it(xt) {
        return mod$1(xt, tt)
    }
    function ot(xt) {
        return invert(xt, tt)
    }
    const {ProjectivePoint: st, normPrivateKeyToScalar: lt, weierstrassEquation: ct, isWithinCurveOrder: dt} = weierstrassPoints({
        ...$,
        toBytes(xt, $t, Dt) {
            const jt = $t.toAffine()
              , Ft = et.toBytes(jt.x)
              , Ht = concatBytes;
            return abool("isCompressed", Dt),
            Dt ? Ht(Uint8Array.from([$t.hasEvenY() ? 2 : 3]), Ft) : Ht(Uint8Array.from([4]), Ft, et.toBytes(jt.y))
        },
        fromBytes(xt) {
            const $t = xt.length
              , Dt = xt[0]
              , jt = xt.subarray(1);
            if ($t === nt && (Dt === 2 || Dt === 3)) {
                const Ft = bytesToNumberBE(jt);
                if (!inRange$1(Ft, _1n$1, et.ORDER))
                    throw new Error("Point is not on curve");
                const Ht = ct(Ft);
                let qt;
                try {
                    qt = et.sqrt(Ht)
                } catch (Yt) {
                    const un = Yt instanceof Error ? ": " + Yt.message : "";
                    throw new Error("Point is not on curve" + un)
                }
                const Wt = (qt & _1n$1) === _1n$1;
                return (Dt & 1) === 1 !== Wt && (qt = et.neg(qt)),
                {
                    x: Ft,
                    y: qt
                }
            } else if ($t === rt && Dt === 4) {
                const Ft = et.fromBytes(jt.subarray(0, et.BYTES))
                  , Ht = et.fromBytes(jt.subarray(et.BYTES, 2 * et.BYTES));
                return {
                    x: Ft,
                    y: Ht
                }
            } else {
                const Ft = nt
                  , Ht = rt;
                throw new Error("invalid Point, expected length of " + Ft + ", or uncompressed " + Ht + ", got " + $t)
            }
        }
    })
      , pt = xt => bytesToHex(numberToBytesBE(xt, $.nByteLength));
    function ht(xt) {
        const $t = tt >> _1n$1;
        return xt > $t
    }
    function mt(xt) {
        return ht(xt) ? it(-xt) : xt
    }
    const yt = (xt, $t, Dt) => bytesToNumberBE(xt.slice($t, Dt));
    class Et {
        constructor($t, Dt, jt) {
            this.r = $t,
            this.s = Dt,
            this.recovery = jt,
            this.assertValidity()
        }
        static fromCompact($t) {
            const Dt = $.nByteLength;
            return $t = ensureBytes("compactSignature", $t, Dt * 2),
            new Et(yt($t, 0, Dt),yt($t, Dt, 2 * Dt))
        }
        static fromDER($t) {
            const {r: Dt, s: jt} = DER.toSig(ensureBytes("DER", $t));
            return new Et(Dt,jt)
        }
        assertValidity() {
            aInRange("r", this.r, _1n$1, tt),
            aInRange("s", this.s, _1n$1, tt)
        }
        addRecoveryBit($t) {
            return new Et(this.r,this.s,$t)
        }
        recoverPublicKey($t) {
            const {r: Dt, s: jt, recovery: Ft} = this
              , Ht = Lt(ensureBytes("msgHash", $t));
            if (Ft == null || ![0, 1, 2, 3].includes(Ft))
                throw new Error("recovery id invalid");
            const qt = Ft === 2 || Ft === 3 ? Dt + $.n : Dt;
            if (qt >= et.ORDER)
                throw new Error("recovery id 2 or 3 invalid");
            const Wt = Ft & 1 ? "03" : "02"
              , Mt = st.fromHex(Wt + pt(qt))
              , Yt = ot(qt)
              , un = it(-Ht * Yt)
              , hn = it(jt * Yt)
              , _n = st.BASE.multiplyAndAddUnsafe(Mt, un, hn);
            if (!_n)
                throw new Error("point at infinify");
            return _n.assertValidity(),
            _n
        }
        hasHighS() {
            return ht(this.s)
        }
        normalizeS() {
            return this.hasHighS() ? new Et(this.r,it(-this.s),this.recovery) : this
        }
        toDERRawBytes() {
            return hexToBytes(this.toDERHex())
        }
        toDERHex() {
            return DER.hexFromSig({
                r: this.r,
                s: this.s
            })
        }
        toCompactRawBytes() {
            return hexToBytes(this.toCompactHex())
        }
        toCompactHex() {
            return pt(this.r) + pt(this.s)
        }
    }
    const _t = {
        isValidPrivateKey(xt) {
            try {
                return lt(xt),
                !0
            } catch {
                return !1
            }
        },
        normPrivateKeyToScalar: lt,
        randomPrivateKey: () => {
            const xt = getMinHashLength($.n);
            return mapHashToField($.randomBytes(xt), $.n)
        }
        ,
        precompute(xt=8, $t=st.BASE) {
            return $t._setWindowSize(xt),
            $t.multiply(BigInt(3)),
            $t
        }
    };
    function wt(xt, $t=!0) {
        return st.fromPrivateKey(xt).toRawBytes($t)
    }
    function St(xt) {
        const $t = isBytes(xt)
          , Dt = typeof xt == "string"
          , jt = ($t || Dt) && xt.length;
        return $t ? jt === nt || jt === rt : Dt ? jt === 2 * nt || jt === 2 * rt : xt instanceof st
    }
    function Ct(xt, $t, Dt=!0) {
        if (St(xt))
            throw new Error("first arg must be private key");
        if (!St($t))
            throw new Error("second arg must be public key");
        return st.fromHex($t).multiply(lt(xt)).toRawBytes(Dt)
    }
    const Nt = $.bits2int || function(xt) {
        if (xt.length > 8192)
            throw new Error("input is too large");
        const $t = bytesToNumberBE(xt)
          , Dt = xt.length * 8 - $.nBitLength;
        return Dt > 0 ? $t >> BigInt(Dt) : $t
    }
      , Lt = $.bits2int_modN || function(xt) {
        return it(Nt(xt))
    }
      , kt = bitMask($.nBitLength);
    function Ut(xt) {
        return aInRange("num < 2^" + $.nBitLength, xt, _0n, kt),
        numberToBytesBE(xt, $.nByteLength)
    }
    function Jt(xt, $t, Dt=Pt) {
        if (["recovered", "canonical"].some(Dn => Dn in Dt))
            throw new Error("sign() legacy options not supported");
        const {hash: jt, randomBytes: Ft} = $;
        let {lowS: Ht, prehash: qt, extraEntropy: Wt} = Dt;
        Ht == null && (Ht = !0),
        xt = ensureBytes("msgHash", xt),
        validateSigVerOpts(Dt),
        qt && (xt = ensureBytes("prehashed msgHash", jt(xt)));
        const Mt = Lt(xt)
          , Yt = lt($t)
          , un = [Ut(Yt), Ut(Mt)];
        if (Wt != null && Wt !== !1) {
            const Dn = Wt === !0 ? Ft(et.BYTES) : Wt;
            un.push(ensureBytes("extraEntropy", Dn))
        }
        const hn = concatBytes(...un)
          , _n = Mt;
        function kn(Dn) {
            const jn = Nt(Dn);
            if (!dt(jn))
                return;
            const Bn = ot(jn)
              , Un = st.BASE.multiply(jn).toAffine()
              , Hn = it(Un.x);
            if (Hn === _0n)
                return;
            const cr = it(Bn * it(_n + Hn * Yt));
            if (cr === _0n)
                return;
            let Gn = (Un.x === Hn ? 0 : 2) | Number(Un.y & _1n$1)
              , Mn = cr;
            return Ht && ht(cr) && (Mn = mt(cr),
            Gn ^= 1),
            new Et(Hn,Mn,Gn)
        }
        return {
            seed: hn,
            k2sig: kn
        }
    }
    const Pt = {
        lowS: $.lowS,
        prehash: !1
    }
      , Xt = {
        lowS: $.lowS,
        prehash: !1
    };
    function rn(xt, $t, Dt=Pt) {
        const {seed: jt, k2sig: Ft} = Jt(xt, $t, Dt)
          , Ht = $;
        return createHmacDrbg(Ht.hash.outputLen, Ht.nByteLength, Ht.hmac)(jt, Ft)
    }
    st.BASE._setWindowSize(8);
    function zt(xt, $t, Dt, jt=Xt) {
        var Gn;
        const Ft = xt;
        $t = ensureBytes("msgHash", $t),
        Dt = ensureBytes("publicKey", Dt);
        const {lowS: Ht, prehash: qt, format: Wt} = jt;
        if (validateSigVerOpts(jt),
        "strict"in jt)
            throw new Error("options.strict was renamed to lowS");
        if (Wt !== void 0 && Wt !== "compact" && Wt !== "der")
            throw new Error("format must be compact or der");
        const Mt = typeof Ft == "string" || isBytes(Ft)
          , Yt = !Mt && !Wt && typeof Ft == "object" && Ft !== null && typeof Ft.r == "bigint" && typeof Ft.s == "bigint";
        if (!Mt && !Yt)
            throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");
        let un, hn;
        try {
            if (Yt && (un = new Et(Ft.r,Ft.s)),
            Mt) {
                try {
                    Wt !== "compact" && (un = Et.fromDER(Ft))
                } catch (Mn) {
                    if (!(Mn instanceof DER.Err))
                        throw Mn
                }
                !un && Wt !== "der" && (un = Et.fromCompact(Ft))
            }
            hn = st.fromHex(Dt)
        } catch {
            return !1
        }
        if (!un || Ht && un.hasHighS())
            return !1;
        qt && ($t = $.hash($t));
        const {r: _n, s: kn} = un
          , Dn = Lt($t)
          , jn = ot(kn)
          , Bn = it(Dn * jn)
          , Un = it(_n * jn)
          , Hn = (Gn = st.BASE.multiplyAndAddUnsafe(hn, Bn, Un)) == null ? void 0 : Gn.toAffine();
        return Hn ? it(Hn.x) === _n : !1
    }
    return {
        CURVE: $,
        getPublicKey: wt,
        getSharedSecret: Ct,
        sign: rn,
        verify: zt,
        ProjectivePoint: st,
        Signature: Et,
        utils: _t
    }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function getHash(_e) {
    return {
        hash: _e,
        hmac: ($, ...et) => hmac(_e, $, concatBytes$1(...et)),
        randomBytes
    }
}
function createCurve(_e, $) {
    const et = tt => weierstrass({
        ..._e,
        ...getHash(tt)
    });
    return {
        ...et($),
        create: et
    }
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f")
  , secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141")
  , _1n = BigInt(1)
  , _2n = BigInt(2)
  , divNearest = (_e, $) => (_e + $ / _2n) / $;
function sqrtMod(_e) {
    const $ = secp256k1P
      , et = BigInt(3)
      , tt = BigInt(6)
      , nt = BigInt(11)
      , rt = BigInt(22)
      , it = BigInt(23)
      , ot = BigInt(44)
      , st = BigInt(88)
      , lt = _e * _e * _e % $
      , ct = lt * lt * _e % $
      , dt = pow2(ct, et, $) * ct % $
      , pt = pow2(dt, et, $) * ct % $
      , ht = pow2(pt, _2n, $) * lt % $
      , mt = pow2(ht, nt, $) * ht % $
      , yt = pow2(mt, rt, $) * mt % $
      , Et = pow2(yt, ot, $) * yt % $
      , _t = pow2(Et, st, $) * Et % $
      , wt = pow2(_t, ot, $) * yt % $
      , St = pow2(wt, et, $) * ct % $
      , Ct = pow2(St, it, $) * mt % $
      , Nt = pow2(Ct, tt, $) * lt % $
      , Lt = pow2(Nt, _2n, $);
    if (!Fpk1.eql(Fpk1.sqr(Lt), _e))
        throw new Error("Cannot find square root");
    return Lt
}
const Fpk1 = Field(secp256k1P, void 0, void 0, {
    sqrt: sqrtMod
})
  , secp256k1 = createCurve({
    a: BigInt(0),
    b: BigInt(7),
    Fp: Fpk1,
    n: secp256k1N,
    Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
    Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
    h: BigInt(1),
    lowS: !0,
    endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: _e => {
            const $ = secp256k1N
              , et = BigInt("0x3086d221a7d46bcde86c90e49284eb15")
              , tt = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3")
              , nt = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8")
              , rt = et
              , it = BigInt("0x100000000000000000000000000000000")
              , ot = divNearest(rt * _e, $)
              , st = divNearest(-tt * _e, $);
            let lt = mod$1(_e - ot * et - st * nt, $)
              , ct = mod$1(-ot * tt - st * rt, $);
            const dt = lt > it
              , pt = ct > it;
            if (dt && (lt = $ - lt),
            pt && (ct = $ - ct),
            lt > it || ct > it)
                throw new Error("splitScalar: Endomorphism failed, k=" + _e);
            return {
                k1neg: dt,
                k1: lt,
                k2neg: pt,
                k2: ct
            }
        }
    }
}, sha256);
BigInt(0);
secp256k1.ProjectivePoint;
const generatePrivateKey = ed25519.utils.randomPrivateKey
  , generateKeypair = () => {
    const _e = ed25519.utils.randomPrivateKey()
      , $ = getPublicKey(_e)
      , et = new Uint8Array(64);
    return et.set(_e),
    et.set($, 32),
    {
        publicKey: $,
        secretKey: et
    }
}
  , getPublicKey = ed25519.getPublicKey;
function isOnCurve(_e) {
    try {
        return ed25519.ExtendedPoint.fromHex(_e),
        !0
    } catch {
        return !1
    }
}
const sign$1 = (_e, $) => ed25519.sign(_e, $.slice(0, 32))
  , verify = ed25519.verify
  , toBuffer = _e => Buffer$1$1.isBuffer(_e) ? _e : _e instanceof Uint8Array ? Buffer$1$1.from(_e.buffer, _e.byteOffset, _e.byteLength) : Buffer$1$1.from(_e);
let Struct$1 = class {
    constructor($) {
        Object.assign(this, $)
    }
    encode() {
        return Buffer$1$1.from(serialize_1(SOLANA_SCHEMA, this))
    }
    static decode($) {
        return deserialize_1(SOLANA_SCHEMA, this, $)
    }
    static decodeUnchecked($) {
        return deserializeUnchecked_1(SOLANA_SCHEMA, this, $)
    }
}
;
class Enum extends Struct$1 {
    constructor($) {
        if (super($),
        this.enum = "",
        Object.keys($).length !== 1)
            throw new Error("Enum can only take single value");
        Object.keys($).map(et => {
            this.enum = et
        }
        )
    }
}
const SOLANA_SCHEMA = new Map;
var _PublicKey;
const MAX_SEED_LENGTH = 32
  , PUBLIC_KEY_LENGTH = 32;
function isPublicKeyData(_e) {
    return _e._bn !== void 0
}
let uniquePublicKeyCounter = 1;
class PublicKey extends Struct$1 {
    constructor($) {
        if (super({}),
        this._bn = void 0,
        isPublicKeyData($))
            this._bn = $._bn;
        else {
            if (typeof $ == "string") {
                const et = bs58$3.decode($);
                if (et.length != PUBLIC_KEY_LENGTH)
                    throw new Error("Invalid public key input");
                this._bn = new BN(et)
            } else
                this._bn = new BN($);
            if (this._bn.byteLength() > PUBLIC_KEY_LENGTH)
                throw new Error("Invalid public key input")
        }
    }
    static unique() {
        const $ = new PublicKey(uniquePublicKeyCounter);
        return uniquePublicKeyCounter += 1,
        new PublicKey($.toBuffer())
    }
    equals($) {
        return this._bn.eq($._bn)
    }
    toBase58() {
        return bs58$3.encode(this.toBytes())
    }
    toJSON() {
        return this.toBase58()
    }
    toBytes() {
        const $ = this.toBuffer();
        return new Uint8Array($.buffer,$.byteOffset,$.byteLength)
    }
    toBuffer() {
        const $ = this._bn.toArrayLike(Buffer$1$1);
        if ($.length === PUBLIC_KEY_LENGTH)
            return $;
        const et = Buffer$1$1.alloc(32);
        return $.copy(et, 32 - $.length),
        et
    }
    get[Symbol.toStringTag]() {
        return `PublicKey(${this.toString()})`
    }
    toString() {
        return this.toBase58()
    }
    static async createWithSeed($, et, tt) {
        const nt = Buffer$1$1.concat([$.toBuffer(), Buffer$1$1.from(et), tt.toBuffer()])
          , rt = sha256(nt);
        return new PublicKey(rt)
    }
    static createProgramAddressSync($, et) {
        let tt = Buffer$1$1.alloc(0);
        $.forEach(function(rt) {
            if (rt.length > MAX_SEED_LENGTH)
                throw new TypeError("Max seed length exceeded");
            tt = Buffer$1$1.concat([tt, toBuffer(rt)])
        }),
        tt = Buffer$1$1.concat([tt, et.toBuffer(), Buffer$1$1.from("ProgramDerivedAddress")]);
        const nt = sha256(tt);
        if (isOnCurve(nt))
            throw new Error("Invalid seeds, address must fall off the curve");
        return new PublicKey(nt)
    }
    static async createProgramAddress($, et) {
        return this.createProgramAddressSync($, et)
    }
    static findProgramAddressSync($, et) {
        let tt = 255, nt;
        for (; tt != 0; ) {
            try {
                const rt = $.concat(Buffer$1$1.from([tt]));
                nt = this.createProgramAddressSync(rt, et)
            } catch (rt) {
                if (rt instanceof TypeError)
                    throw rt;
                tt--;
                continue
            }
            return [nt, tt]
        }
        throw new Error("Unable to find a viable program address nonce")
    }
    static async findProgramAddress($, et) {
        return this.findProgramAddressSync($, et)
    }
    static isOnCurve($) {
        const et = new PublicKey($);
        return isOnCurve(et.toBytes())
    }
}
_PublicKey = PublicKey;
PublicKey.default = new _PublicKey("11111111111111111111111111111111");
SOLANA_SCHEMA.set(PublicKey, {
    kind: "struct",
    fields: [["_bn", "u256"]]
});
class Account {
    constructor($) {
        if (this._publicKey = void 0,
        this._secretKey = void 0,
        $) {
            const et = toBuffer($);
            if ($.length !== 64)
                throw new Error("bad secret key size");
            this._publicKey = et.slice(32, 64),
            this._secretKey = et.slice(0, 32)
        } else
            this._secretKey = toBuffer(generatePrivateKey()),
            this._publicKey = toBuffer(getPublicKey(this._secretKey))
    }
    get publicKey() {
        return new PublicKey(this._publicKey)
    }
    get secretKey() {
        return Buffer$1$1.concat([this._secretKey, this._publicKey], 64)
    }
}
const BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey("BPFLoader1111111111111111111111111111111111")
  , PACKET_DATA_SIZE = 1232
  , VERSION_PREFIX_MASK = 127
  , SIGNATURE_LENGTH_IN_BYTES = 64;
class TransactionExpiredBlockheightExceededError extends Error {
    constructor($) {
        super(`Signature ${$} has expired: block height exceeded.`),
        this.signature = void 0,
        this.signature = $
    }
}
Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, "name", {
    value: "TransactionExpiredBlockheightExceededError"
});
class TransactionExpiredTimeoutError extends Error {
    constructor($, et) {
        super(`Transaction was not confirmed in ${et.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${$} using the Solana Explorer or CLI tools.`),
        this.signature = void 0,
        this.signature = $
    }
}
Object.defineProperty(TransactionExpiredTimeoutError.prototype, "name", {
    value: "TransactionExpiredTimeoutError"
});
class TransactionExpiredNonceInvalidError extends Error {
    constructor($) {
        super(`Signature ${$} has expired: the nonce is no longer valid.`),
        this.signature = void 0,
        this.signature = $
    }
}
Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, "name", {
    value: "TransactionExpiredNonceInvalidError"
});
class MessageAccountKeys {
    constructor($, et) {
        this.staticAccountKeys = void 0,
        this.accountKeysFromLookups = void 0,
        this.staticAccountKeys = $,
        this.accountKeysFromLookups = et
    }
    keySegments() {
        const $ = [this.staticAccountKeys];
        return this.accountKeysFromLookups && ($.push(this.accountKeysFromLookups.writable),
        $.push(this.accountKeysFromLookups.readonly)),
        $
    }
    get($) {
        for (const et of this.keySegments()) {
            if ($ < et.length)
                return et[$];
            $ -= et.length
        }
    }
    get length() {
        return this.keySegments().flat().length
    }
    compileInstructions($) {
        if (this.length > 256)
            throw new Error("Account index overflow encountered during compilation");
        const tt = new Map;
        this.keySegments().flat().forEach( (rt, it) => {
            tt.set(rt.toBase58(), it)
        }
        );
        const nt = rt => {
            const it = tt.get(rt.toBase58());
            if (it === void 0)
                throw new Error("Encountered an unknown instruction account key during compilation");
            return it
        }
        ;
        return $.map(rt => ({
            programIdIndex: nt(rt.programId),
            accountKeyIndexes: rt.keys.map(it => nt(it.pubkey)),
            data: rt.data
        }))
    }
}
const publicKey$4 = (_e="publicKey") => blob$1(32, _e)
  , signature = (_e="signature") => blob$1(64, _e)
  , rustString = (_e="string") => {
    const $ = struct$1([u32$1("length"), u32$1("lengthPadding"), blob$1(offset$1(u32$1(), -8), "chars")], _e)
      , et = $.decode.bind($)
      , tt = $.encode.bind($)
      , nt = $;
    return nt.decode = (rt, it) => et(rt, it).chars.toString(),
    nt.encode = (rt, it, ot) => {
        const st = {
            chars: Buffer$1$1.from(rt, "utf8")
        };
        return tt(st, it, ot)
    }
    ,
    nt.alloc = rt => u32$1().span + u32$1().span + Buffer$1$1.from(rt, "utf8").length,
    nt
}
  , authorized = (_e="authorized") => struct$1([publicKey$4("staker"), publicKey$4("withdrawer")], _e)
  , lockup = (_e="lockup") => struct$1([ns64$1("unixTimestamp"), ns64$1("epoch"), publicKey$4("custodian")], _e)
  , voteInit = (_e="voteInit") => struct$1([publicKey$4("nodePubkey"), publicKey$4("authorizedVoter"), publicKey$4("authorizedWithdrawer"), u8$1("commission")], _e)
  , voteAuthorizeWithSeedArgs = (_e="voteAuthorizeWithSeedArgs") => struct$1([u32$1("voteAuthorizationType"), publicKey$4("currentAuthorityDerivedKeyOwnerPubkey"), rustString("currentAuthorityDerivedKeySeed"), publicKey$4("newAuthorized")], _e);
function getAlloc(_e, $) {
    const et = nt => {
        if (nt.span >= 0)
            return nt.span;
        if (typeof nt.alloc == "function")
            return nt.alloc($[nt.property]);
        if ("count"in nt && "elementLayout"in nt) {
            const rt = $[nt.property];
            if (Array.isArray(rt))
                return rt.length * et(nt.elementLayout)
        } else if ("fields"in nt)
            return getAlloc({
                layout: nt
            }, $[nt.property]);
        return 0
    }
    ;
    let tt = 0;
    return _e.layout.fields.forEach(nt => {
        tt += et(nt)
    }
    ),
    tt
}
function decodeLength(_e) {
    let $ = 0
      , et = 0;
    for (; ; ) {
        let tt = _e.shift();
        if ($ |= (tt & 127) << et * 7,
        et += 1,
        !(tt & 128))
            break
    }
    return $
}
function encodeLength(_e, $) {
    let et = $;
    for (; ; ) {
        let tt = et & 127;
        if (et >>= 7,
        et == 0) {
            _e.push(tt);
            break
        } else
            tt |= 128,
            _e.push(tt)
    }
}
function assert$1(_e, $) {
    if (!_e)
        throw new Error($ || "Assertion failed")
}
class CompiledKeys {
    constructor($, et) {
        this.payer = void 0,
        this.keyMetaMap = void 0,
        this.payer = $,
        this.keyMetaMap = et
    }
    static compile($, et) {
        const tt = new Map
          , nt = it => {
            const ot = it.toBase58();
            let st = tt.get(ot);
            return st === void 0 && (st = {
                isSigner: !1,
                isWritable: !1,
                isInvoked: !1
            },
            tt.set(ot, st)),
            st
        }
          , rt = nt(et);
        rt.isSigner = !0,
        rt.isWritable = !0;
        for (const it of $) {
            nt(it.programId).isInvoked = !0;
            for (const ot of it.keys) {
                const st = nt(ot.pubkey);
                st.isSigner || (st.isSigner = ot.isSigner),
                st.isWritable || (st.isWritable = ot.isWritable)
            }
        }
        return new CompiledKeys(et,tt)
    }
    getMessageComponents() {
        const $ = [...this.keyMetaMap.entries()];
        assert$1($.length <= 256, "Max static account keys length exceeded");
        const et = $.filter( ([,st]) => st.isSigner && st.isWritable)
          , tt = $.filter( ([,st]) => st.isSigner && !st.isWritable)
          , nt = $.filter( ([,st]) => !st.isSigner && st.isWritable)
          , rt = $.filter( ([,st]) => !st.isSigner && !st.isWritable)
          , it = {
            numRequiredSignatures: et.length + tt.length,
            numReadonlySignedAccounts: tt.length,
            numReadonlyUnsignedAccounts: rt.length
        };
        {
            assert$1(et.length > 0, "Expected at least one writable signer key");
            const [st] = et[0];
            assert$1(st === this.payer.toBase58(), "Expected first writable signer key to be the fee payer")
        }
        const ot = [...et.map( ([st]) => new PublicKey(st)), ...tt.map( ([st]) => new PublicKey(st)), ...nt.map( ([st]) => new PublicKey(st)), ...rt.map( ([st]) => new PublicKey(st))];
        return [it, ot]
    }
    extractTableLookup($) {
        const [et,tt] = this.drainKeysFoundInLookupTable($.state.addresses, it => !it.isSigner && !it.isInvoked && it.isWritable)
          , [nt,rt] = this.drainKeysFoundInLookupTable($.state.addresses, it => !it.isSigner && !it.isInvoked && !it.isWritable);
        if (!(et.length === 0 && nt.length === 0))
            return [{
                accountKey: $.key,
                writableIndexes: et,
                readonlyIndexes: nt
            }, {
                writable: tt,
                readonly: rt
            }]
    }
    drainKeysFoundInLookupTable($, et) {
        const tt = new Array
          , nt = new Array;
        for (const [rt,it] of this.keyMetaMap.entries())
            if (et(it)) {
                const ot = new PublicKey(rt)
                  , st = $.findIndex(lt => lt.equals(ot));
                st >= 0 && (assert$1(st < 256, "Max lookup table index exceeded"),
                tt.push(st),
                nt.push(ot),
                this.keyMetaMap.delete(rt))
            }
        return [tt, nt]
    }
}
const END_OF_BUFFER_ERROR_MESSAGE = "Reached end of buffer unexpectedly";
function guardedShift(_e) {
    if (_e.length === 0)
        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
    return _e.shift()
}
function guardedSplice(_e, ...$) {
    const [et] = $;
    if ($.length === 2 ? et + ($[1] ?? 0) > _e.length : et >= _e.length)
        throw new Error(END_OF_BUFFER_ERROR_MESSAGE);
    return _e.splice(...$)
}
class Message {
    constructor($) {
        this.header = void 0,
        this.accountKeys = void 0,
        this.recentBlockhash = void 0,
        this.instructions = void 0,
        this.indexToProgramIds = new Map,
        this.header = $.header,
        this.accountKeys = $.accountKeys.map(et => new PublicKey(et)),
        this.recentBlockhash = $.recentBlockhash,
        this.instructions = $.instructions,
        this.instructions.forEach(et => this.indexToProgramIds.set(et.programIdIndex, this.accountKeys[et.programIdIndex]))
    }
    get version() {
        return "legacy"
    }
    get staticAccountKeys() {
        return this.accountKeys
    }
    get compiledInstructions() {
        return this.instructions.map($ => ({
            programIdIndex: $.programIdIndex,
            accountKeyIndexes: $.accounts,
            data: bs58$3.decode($.data)
        }))
    }
    get addressTableLookups() {
        return []
    }
    getAccountKeys() {
        return new MessageAccountKeys(this.staticAccountKeys)
    }
    static compile($) {
        const et = CompiledKeys.compile($.instructions, $.payerKey)
          , [tt,nt] = et.getMessageComponents()
          , it = new MessageAccountKeys(nt).compileInstructions($.instructions).map(ot => ({
            programIdIndex: ot.programIdIndex,
            accounts: ot.accountKeyIndexes,
            data: bs58$3.encode(ot.data)
        }));
        return new Message({
            header: tt,
            accountKeys: nt,
            recentBlockhash: $.recentBlockhash,
            instructions: it
        })
    }
    isAccountSigner($) {
        return $ < this.header.numRequiredSignatures
    }
    isAccountWritable($) {
        const et = this.header.numRequiredSignatures;
        if ($ >= this.header.numRequiredSignatures) {
            const tt = $ - et
              , rt = this.accountKeys.length - et - this.header.numReadonlyUnsignedAccounts;
            return tt < rt
        } else {
            const tt = et - this.header.numReadonlySignedAccounts;
            return $ < tt
        }
    }
    isProgramId($) {
        return this.indexToProgramIds.has($)
    }
    programIds() {
        return [...this.indexToProgramIds.values()]
    }
    nonProgramIds() {
        return this.accountKeys.filter( ($, et) => !this.isProgramId(et))
    }
    serialize() {
        const $ = this.accountKeys.length;
        let et = [];
        encodeLength(et, $);
        const tt = this.instructions.map(dt => {
            const {accounts: pt, programIdIndex: ht} = dt
              , mt = Array.from(bs58$3.decode(dt.data));
            let yt = [];
            encodeLength(yt, pt.length);
            let Et = [];
            return encodeLength(Et, mt.length),
            {
                programIdIndex: ht,
                keyIndicesCount: Buffer$1$1.from(yt),
                keyIndices: pt,
                dataLength: Buffer$1$1.from(Et),
                data: mt
            }
        }
        );
        let nt = [];
        encodeLength(nt, tt.length);
        let rt = Buffer$1$1.alloc(PACKET_DATA_SIZE);
        Buffer$1$1.from(nt).copy(rt);
        let it = nt.length;
        tt.forEach(dt => {
            const ht = struct$1([u8$1("programIdIndex"), blob$1(dt.keyIndicesCount.length, "keyIndicesCount"), seq(u8$1("keyIndex"), dt.keyIndices.length, "keyIndices"), blob$1(dt.dataLength.length, "dataLength"), seq(u8$1("userdatum"), dt.data.length, "data")]).encode(dt, rt, it);
            it += ht
        }
        ),
        rt = rt.slice(0, it);
        const ot = struct$1([blob$1(1, "numRequiredSignatures"), blob$1(1, "numReadonlySignedAccounts"), blob$1(1, "numReadonlyUnsignedAccounts"), blob$1(et.length, "keyCount"), seq(publicKey$4("key"), $, "keys"), publicKey$4("recentBlockhash")])
          , st = {
            numRequiredSignatures: Buffer$1$1.from([this.header.numRequiredSignatures]),
            numReadonlySignedAccounts: Buffer$1$1.from([this.header.numReadonlySignedAccounts]),
            numReadonlyUnsignedAccounts: Buffer$1$1.from([this.header.numReadonlyUnsignedAccounts]),
            keyCount: Buffer$1$1.from(et),
            keys: this.accountKeys.map(dt => toBuffer(dt.toBytes())),
            recentBlockhash: bs58$3.decode(this.recentBlockhash)
        };
        let lt = Buffer$1$1.alloc(2048);
        const ct = ot.encode(st, lt);
        return rt.copy(lt, ct),
        lt.slice(0, ct + rt.length)
    }
    static from($) {
        let et = [...$];
        const tt = guardedShift(et);
        if (tt !== (tt & VERSION_PREFIX_MASK))
            throw new Error("Versioned messages must be deserialized with VersionedMessage.deserialize()");
        const nt = guardedShift(et)
          , rt = guardedShift(et)
          , it = decodeLength(et);
        let ot = [];
        for (let pt = 0; pt < it; pt++) {
            const ht = guardedSplice(et, 0, PUBLIC_KEY_LENGTH);
            ot.push(new PublicKey(Buffer$1$1.from(ht)))
        }
        const st = guardedSplice(et, 0, PUBLIC_KEY_LENGTH)
          , lt = decodeLength(et);
        let ct = [];
        for (let pt = 0; pt < lt; pt++) {
            const ht = guardedShift(et)
              , mt = decodeLength(et)
              , yt = guardedSplice(et, 0, mt)
              , Et = decodeLength(et)
              , _t = guardedSplice(et, 0, Et)
              , wt = bs58$3.encode(Buffer$1$1.from(_t));
            ct.push({
                programIdIndex: ht,
                accounts: yt,
                data: wt
            })
        }
        const dt = {
            header: {
                numRequiredSignatures: tt,
                numReadonlySignedAccounts: nt,
                numReadonlyUnsignedAccounts: rt
            },
            recentBlockhash: bs58$3.encode(Buffer$1$1.from(st)),
            accountKeys: ot,
            instructions: ct
        };
        return new Message(dt)
    }
}
class MessageV0 {
    constructor($) {
        this.header = void 0,
        this.staticAccountKeys = void 0,
        this.recentBlockhash = void 0,
        this.compiledInstructions = void 0,
        this.addressTableLookups = void 0,
        this.header = $.header,
        this.staticAccountKeys = $.staticAccountKeys,
        this.recentBlockhash = $.recentBlockhash,
        this.compiledInstructions = $.compiledInstructions,
        this.addressTableLookups = $.addressTableLookups
    }
    get version() {
        return 0
    }
    get numAccountKeysFromLookups() {
        let $ = 0;
        for (const et of this.addressTableLookups)
            $ += et.readonlyIndexes.length + et.writableIndexes.length;
        return $
    }
    getAccountKeys($) {
        let et;
        if ($ && "accountKeysFromLookups"in $ && $.accountKeysFromLookups) {
            if (this.numAccountKeysFromLookups != $.accountKeysFromLookups.writable.length + $.accountKeysFromLookups.readonly.length)
                throw new Error("Failed to get account keys because of a mismatch in the number of account keys from lookups");
            et = $.accountKeysFromLookups
        } else if ($ && "addressLookupTableAccounts"in $ && $.addressLookupTableAccounts)
            et = this.resolveAddressTableLookups($.addressLookupTableAccounts);
        else if (this.addressTableLookups.length > 0)
            throw new Error("Failed to get account keys because address table lookups were not resolved");
        return new MessageAccountKeys(this.staticAccountKeys,et)
    }
    isAccountSigner($) {
        return $ < this.header.numRequiredSignatures
    }
    isAccountWritable($) {
        const et = this.header.numRequiredSignatures
          , tt = this.staticAccountKeys.length;
        if ($ >= tt) {
            const nt = $ - tt
              , rt = this.addressTableLookups.reduce( (it, ot) => it + ot.writableIndexes.length, 0);
            return nt < rt
        } else if ($ >= this.header.numRequiredSignatures) {
            const nt = $ - et
              , it = tt - et - this.header.numReadonlyUnsignedAccounts;
            return nt < it
        } else {
            const nt = et - this.header.numReadonlySignedAccounts;
            return $ < nt
        }
    }
    resolveAddressTableLookups($) {
        const et = {
            writable: [],
            readonly: []
        };
        for (const tt of this.addressTableLookups) {
            const nt = $.find(rt => rt.key.equals(tt.accountKey));
            if (!nt)
                throw new Error(`Failed to find address lookup table account for table key ${tt.accountKey.toBase58()}`);
            for (const rt of tt.writableIndexes)
                if (rt < nt.state.addresses.length)
                    et.writable.push(nt.state.addresses[rt]);
                else
                    throw new Error(`Failed to find address for index ${rt} in address lookup table ${tt.accountKey.toBase58()}`);
            for (const rt of tt.readonlyIndexes)
                if (rt < nt.state.addresses.length)
                    et.readonly.push(nt.state.addresses[rt]);
                else
                    throw new Error(`Failed to find address for index ${rt} in address lookup table ${tt.accountKey.toBase58()}`)
        }
        return et
    }
    static compile($) {
        const et = CompiledKeys.compile($.instructions, $.payerKey)
          , tt = new Array
          , nt = {
            writable: new Array,
            readonly: new Array
        }
          , rt = $.addressLookupTableAccounts || [];
        for (const ct of rt) {
            const dt = et.extractTableLookup(ct);
            if (dt !== void 0) {
                const [pt,{writable: ht, readonly: mt}] = dt;
                tt.push(pt),
                nt.writable.push(...ht),
                nt.readonly.push(...mt)
            }
        }
        const [it,ot] = et.getMessageComponents()
          , lt = new MessageAccountKeys(ot,nt).compileInstructions($.instructions);
        return new MessageV0({
            header: it,
            staticAccountKeys: ot,
            recentBlockhash: $.recentBlockhash,
            compiledInstructions: lt,
            addressTableLookups: tt
        })
    }
    serialize() {
        const $ = Array();
        encodeLength($, this.staticAccountKeys.length);
        const et = this.serializeInstructions()
          , tt = Array();
        encodeLength(tt, this.compiledInstructions.length);
        const nt = this.serializeAddressTableLookups()
          , rt = Array();
        encodeLength(rt, this.addressTableLookups.length);
        const it = struct$1([u8$1("prefix"), struct$1([u8$1("numRequiredSignatures"), u8$1("numReadonlySignedAccounts"), u8$1("numReadonlyUnsignedAccounts")], "header"), blob$1($.length, "staticAccountKeysLength"), seq(publicKey$4(), this.staticAccountKeys.length, "staticAccountKeys"), publicKey$4("recentBlockhash"), blob$1(tt.length, "instructionsLength"), blob$1(et.length, "serializedInstructions"), blob$1(rt.length, "addressTableLookupsLength"), blob$1(nt.length, "serializedAddressTableLookups")])
          , ot = new Uint8Array(PACKET_DATA_SIZE)
          , lt = it.encode({
            prefix: 128,
            header: this.header,
            staticAccountKeysLength: new Uint8Array($),
            staticAccountKeys: this.staticAccountKeys.map(ct => ct.toBytes()),
            recentBlockhash: bs58$3.decode(this.recentBlockhash),
            instructionsLength: new Uint8Array(tt),
            serializedInstructions: et,
            addressTableLookupsLength: new Uint8Array(rt),
            serializedAddressTableLookups: nt
        }, ot);
        return ot.slice(0, lt)
    }
    serializeInstructions() {
        let $ = 0;
        const et = new Uint8Array(PACKET_DATA_SIZE);
        for (const tt of this.compiledInstructions) {
            const nt = Array();
            encodeLength(nt, tt.accountKeyIndexes.length);
            const rt = Array();
            encodeLength(rt, tt.data.length);
            const it = struct$1([u8$1("programIdIndex"), blob$1(nt.length, "encodedAccountKeyIndexesLength"), seq(u8$1(), tt.accountKeyIndexes.length, "accountKeyIndexes"), blob$1(rt.length, "encodedDataLength"), blob$1(tt.data.length, "data")]);
            $ += it.encode({
                programIdIndex: tt.programIdIndex,
                encodedAccountKeyIndexesLength: new Uint8Array(nt),
                accountKeyIndexes: tt.accountKeyIndexes,
                encodedDataLength: new Uint8Array(rt),
                data: tt.data
            }, et, $)
        }
        return et.slice(0, $)
    }
    serializeAddressTableLookups() {
        let $ = 0;
        const et = new Uint8Array(PACKET_DATA_SIZE);
        for (const tt of this.addressTableLookups) {
            const nt = Array();
            encodeLength(nt, tt.writableIndexes.length);
            const rt = Array();
            encodeLength(rt, tt.readonlyIndexes.length);
            const it = struct$1([publicKey$4("accountKey"), blob$1(nt.length, "encodedWritableIndexesLength"), seq(u8$1(), tt.writableIndexes.length, "writableIndexes"), blob$1(rt.length, "encodedReadonlyIndexesLength"), seq(u8$1(), tt.readonlyIndexes.length, "readonlyIndexes")]);
            $ += it.encode({
                accountKey: tt.accountKey.toBytes(),
                encodedWritableIndexesLength: new Uint8Array(nt),
                writableIndexes: tt.writableIndexes,
                encodedReadonlyIndexesLength: new Uint8Array(rt),
                readonlyIndexes: tt.readonlyIndexes
            }, et, $)
        }
        return et.slice(0, $)
    }
    static deserialize($) {
        let et = [...$];
        const tt = guardedShift(et)
          , nt = tt & VERSION_PREFIX_MASK;
        assert$1(tt !== nt, "Expected versioned message but received legacy message");
        const rt = nt;
        assert$1(rt === 0, `Expected versioned message with version 0 but found version ${rt}`);
        const it = {
            numRequiredSignatures: guardedShift(et),
            numReadonlySignedAccounts: guardedShift(et),
            numReadonlyUnsignedAccounts: guardedShift(et)
        }
          , ot = []
          , st = decodeLength(et);
        for (let mt = 0; mt < st; mt++)
            ot.push(new PublicKey(guardedSplice(et, 0, PUBLIC_KEY_LENGTH)));
        const lt = bs58$3.encode(guardedSplice(et, 0, PUBLIC_KEY_LENGTH))
          , ct = decodeLength(et)
          , dt = [];
        for (let mt = 0; mt < ct; mt++) {
            const yt = guardedShift(et)
              , Et = decodeLength(et)
              , _t = guardedSplice(et, 0, Et)
              , wt = decodeLength(et)
              , St = new Uint8Array(guardedSplice(et, 0, wt));
            dt.push({
                programIdIndex: yt,
                accountKeyIndexes: _t,
                data: St
            })
        }
        const pt = decodeLength(et)
          , ht = [];
        for (let mt = 0; mt < pt; mt++) {
            const yt = new PublicKey(guardedSplice(et, 0, PUBLIC_KEY_LENGTH))
              , Et = decodeLength(et)
              , _t = guardedSplice(et, 0, Et)
              , wt = decodeLength(et)
              , St = guardedSplice(et, 0, wt);
            ht.push({
                accountKey: yt,
                writableIndexes: _t,
                readonlyIndexes: St
            })
        }
        return new MessageV0({
            header: it,
            staticAccountKeys: ot,
            recentBlockhash: lt,
            compiledInstructions: dt,
            addressTableLookups: ht
        })
    }
}
const VersionedMessage = {
    deserializeMessageVersion(_e) {
        const $ = _e[0]
          , et = $ & VERSION_PREFIX_MASK;
        return et === $ ? "legacy" : et
    },
    deserialize: _e => {
        const $ = VersionedMessage.deserializeMessageVersion(_e);
        if ($ === "legacy")
            return Message.from(_e);
        if ($ === 0)
            return MessageV0.deserialize(_e);
        throw new Error(`Transaction message version ${$} deserialization is not supported`)
    }
};
let TransactionStatus = function(_e) {
    return _e[_e.BLOCKHEIGHT_EXCEEDED = 0] = "BLOCKHEIGHT_EXCEEDED",
    _e[_e.PROCESSED = 1] = "PROCESSED",
    _e[_e.TIMED_OUT = 2] = "TIMED_OUT",
    _e[_e.NONCE_INVALID = 3] = "NONCE_INVALID",
    _e
}({});
const DEFAULT_SIGNATURE = Buffer$1$1.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);
class TransactionInstruction {
    constructor($) {
        this.keys = void 0,
        this.programId = void 0,
        this.data = Buffer$1$1.alloc(0),
        this.programId = $.programId,
        this.keys = $.keys,
        $.data && (this.data = $.data)
    }
    toJSON() {
        return {
            keys: this.keys.map( ({pubkey: $, isSigner: et, isWritable: tt}) => ({
                pubkey: $.toJSON(),
                isSigner: et,
                isWritable: tt
            })),
            programId: this.programId.toJSON(),
            data: [...this.data]
        }
    }
}
class Transaction {
    get signature() {
        return this.signatures.length > 0 ? this.signatures[0].signature : null
    }
    constructor($) {
        if (this.signatures = [],
        this.feePayer = void 0,
        this.instructions = [],
        this.recentBlockhash = void 0,
        this.lastValidBlockHeight = void 0,
        this.nonceInfo = void 0,
        this.minNonceContextSlot = void 0,
        this._message = void 0,
        this._json = void 0,
        !!$)
            if ($.feePayer && (this.feePayer = $.feePayer),
            $.signatures && (this.signatures = $.signatures),
            Object.prototype.hasOwnProperty.call($, "nonceInfo")) {
                const {minContextSlot: et, nonceInfo: tt} = $;
                this.minNonceContextSlot = et,
                this.nonceInfo = tt
            } else if (Object.prototype.hasOwnProperty.call($, "lastValidBlockHeight")) {
                const {blockhash: et, lastValidBlockHeight: tt} = $;
                this.recentBlockhash = et,
                this.lastValidBlockHeight = tt
            } else {
                const {recentBlockhash: et, nonceInfo: tt} = $;
                tt && (this.nonceInfo = tt),
                this.recentBlockhash = et
            }
    }
    toJSON() {
        return {
            recentBlockhash: this.recentBlockhash || null,
            feePayer: this.feePayer ? this.feePayer.toJSON() : null,
            nonceInfo: this.nonceInfo ? {
                nonce: this.nonceInfo.nonce,
                nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()
            } : null,
            instructions: this.instructions.map($ => $.toJSON()),
            signers: this.signatures.map( ({publicKey: $}) => $.toJSON())
        }
    }
    add(...$) {
        if ($.length === 0)
            throw new Error("No instructions");
        return $.forEach(et => {
            "instructions"in et ? this.instructions = this.instructions.concat(et.instructions) : "data"in et && "programId"in et && "keys"in et ? this.instructions.push(et) : this.instructions.push(new TransactionInstruction(et))
        }
        ),
        this
    }
    compileMessage() {
        if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json))
            return this._message;
        let $, et;
        if (this.nonceInfo ? ($ = this.nonceInfo.nonce,
        this.instructions[0] != this.nonceInfo.nonceInstruction ? et = [this.nonceInfo.nonceInstruction, ...this.instructions] : et = this.instructions) : ($ = this.recentBlockhash,
        et = this.instructions),
        !$)
            throw new Error("Transaction recentBlockhash required");
        et.length < 1;
        let tt;
        if (this.feePayer)
            tt = this.feePayer;
        else if (this.signatures.length > 0 && this.signatures[0].publicKey)
            tt = this.signatures[0].publicKey;
        else
            throw new Error("Transaction fee payer required");
        for (let yt = 0; yt < et.length; yt++)
            if (et[yt].programId === void 0)
                throw new Error(`Transaction instruction index ${yt} has undefined program id`);
        const nt = []
          , rt = [];
        et.forEach(yt => {
            yt.keys.forEach(_t => {
                rt.push({
                    ..._t
                })
            }
            );
            const Et = yt.programId.toString();
            nt.includes(Et) || nt.push(Et)
        }
        ),
        nt.forEach(yt => {
            rt.push({
                pubkey: new PublicKey(yt),
                isSigner: !1,
                isWritable: !1
            })
        }
        );
        const it = [];
        rt.forEach(yt => {
            const Et = yt.pubkey.toString()
              , _t = it.findIndex(wt => wt.pubkey.toString() === Et);
            _t > -1 ? (it[_t].isWritable = it[_t].isWritable || yt.isWritable,
            it[_t].isSigner = it[_t].isSigner || yt.isSigner) : it.push(yt)
        }
        ),
        it.sort(function(yt, Et) {
            if (yt.isSigner !== Et.isSigner)
                return yt.isSigner ? -1 : 1;
            if (yt.isWritable !== Et.isWritable)
                return yt.isWritable ? -1 : 1;
            const _t = {
                localeMatcher: "best fit",
                usage: "sort",
                sensitivity: "variant",
                ignorePunctuation: !1,
                numeric: !1,
                caseFirst: "lower"
            };
            return yt.pubkey.toBase58().localeCompare(Et.pubkey.toBase58(), "en", _t)
        });
        const ot = it.findIndex(yt => yt.pubkey.equals(tt));
        if (ot > -1) {
            const [yt] = it.splice(ot, 1);
            yt.isSigner = !0,
            yt.isWritable = !0,
            it.unshift(yt)
        } else
            it.unshift({
                pubkey: tt,
                isSigner: !0,
                isWritable: !0
            });
        for (const yt of this.signatures) {
            const Et = it.findIndex(_t => _t.pubkey.equals(yt.publicKey));
            if (Et > -1)
                it[Et].isSigner || (it[Et].isSigner = !0);
            else
                throw new Error(`unknown signer: ${yt.publicKey.toString()}`)
        }
        let st = 0
          , lt = 0
          , ct = 0;
        const dt = []
          , pt = [];
        it.forEach( ({pubkey: yt, isSigner: Et, isWritable: _t}) => {
            Et ? (dt.push(yt.toString()),
            st += 1,
            _t || (lt += 1)) : (pt.push(yt.toString()),
            _t || (ct += 1))
        }
        );
        const ht = dt.concat(pt)
          , mt = et.map(yt => {
            const {data: Et, programId: _t} = yt;
            return {
                programIdIndex: ht.indexOf(_t.toString()),
                accounts: yt.keys.map(wt => ht.indexOf(wt.pubkey.toString())),
                data: bs58$3.encode(Et)
            }
        }
        );
        return mt.forEach(yt => {
            assert$1(yt.programIdIndex >= 0),
            yt.accounts.forEach(Et => assert$1(Et >= 0))
        }
        ),
        new Message({
            header: {
                numRequiredSignatures: st,
                numReadonlySignedAccounts: lt,
                numReadonlyUnsignedAccounts: ct
            },
            accountKeys: ht,
            recentBlockhash: $,
            instructions: mt
        })
    }
    _compile() {
        const $ = this.compileMessage()
          , et = $.accountKeys.slice(0, $.header.numRequiredSignatures);
        return this.signatures.length === et.length && this.signatures.every( (nt, rt) => et[rt].equals(nt.publicKey)) || (this.signatures = et.map(tt => ({
            signature: null,
            publicKey: tt
        }))),
        $
    }
    serializeMessage() {
        return this._compile().serialize()
    }
    async getEstimatedFee($) {
        return (await $.getFeeForMessage(this.compileMessage())).value
    }
    setSigners(...$) {
        if ($.length === 0)
            throw new Error("No signers");
        const et = new Set;
        this.signatures = $.filter(tt => {
            const nt = tt.toString();
            return et.has(nt) ? !1 : (et.add(nt),
            !0)
        }
        ).map(tt => ({
            signature: null,
            publicKey: tt
        }))
    }
    sign(...$) {
        if ($.length === 0)
            throw new Error("No signers");
        const et = new Set
          , tt = [];
        for (const rt of $) {
            const it = rt.publicKey.toString();
            et.has(it) || (et.add(it),
            tt.push(rt))
        }
        this.signatures = tt.map(rt => ({
            signature: null,
            publicKey: rt.publicKey
        }));
        const nt = this._compile();
        this._partialSign(nt, ...tt)
    }
    partialSign(...$) {
        if ($.length === 0)
            throw new Error("No signers");
        const et = new Set
          , tt = [];
        for (const rt of $) {
            const it = rt.publicKey.toString();
            et.has(it) || (et.add(it),
            tt.push(rt))
        }
        const nt = this._compile();
        this._partialSign(nt, ...tt)
    }
    _partialSign($, ...et) {
        const tt = $.serialize();
        et.forEach(nt => {
            const rt = sign$1(tt, nt.secretKey);
            this._addSignature(nt.publicKey, toBuffer(rt))
        }
        )
    }
    addSignature($, et) {
        this._compile(),
        this._addSignature($, et)
    }
    _addSignature($, et) {
        assert$1(et.length === 64);
        const tt = this.signatures.findIndex(nt => $.equals(nt.publicKey));
        if (tt < 0)
            throw new Error(`unknown signer: ${$.toString()}`);
        this.signatures[tt].signature = Buffer$1$1.from(et)
    }
    verifySignatures($=!0) {
        return !this._getMessageSignednessErrors(this.serializeMessage(), $)
    }
    _getMessageSignednessErrors($, et) {
        const tt = {};
        for (const {signature: nt, publicKey: rt} of this.signatures)
            nt === null ? et && (tt.missing || (tt.missing = [])).push(rt) : verify(nt, $, rt.toBytes()) || (tt.invalid || (tt.invalid = [])).push(rt);
        return tt.invalid || tt.missing ? tt : void 0
    }
    serialize($) {
        const {requireAllSignatures: et, verifySignatures: tt} = Object.assign({
            requireAllSignatures: !0,
            verifySignatures: !0
        }, $)
          , nt = this.serializeMessage();
        if (tt) {
            const rt = this._getMessageSignednessErrors(nt, et);
            if (rt) {
                let it = "Signature verification failed.";
                throw rt.invalid && (it += `
Invalid signature for public key${rt.invalid.length === 1 ? "" : "(s)"} [\`${rt.invalid.map(ot => ot.toBase58()).join("`, `")}\`].`),
                rt.missing && (it += `
Missing signature for public key${rt.missing.length === 1 ? "" : "(s)"} [\`${rt.missing.map(ot => ot.toBase58()).join("`, `")}\`].`),
                new Error(it)
            }
        }
        return this._serialize(nt)
    }
    _serialize($) {
        const {signatures: et} = this
          , tt = [];
        encodeLength(tt, et.length);
        const nt = tt.length + et.length * 64 + $.length
          , rt = Buffer$1$1.alloc(nt);
        return assert$1(et.length < 256),
        Buffer$1$1.from(tt).copy(rt, 0),
        et.forEach( ({signature: it}, ot) => {
            it !== null && (assert$1(it.length === 64, "signature has invalid length"),
            Buffer$1$1.from(it).copy(rt, tt.length + ot * 64))
        }
        ),
        $.copy(rt, tt.length + et.length * 64),
        assert$1(rt.length <= PACKET_DATA_SIZE, `Transaction too large: ${rt.length} > ${PACKET_DATA_SIZE}`),
        rt
    }
    get keys() {
        return assert$1(this.instructions.length === 1),
        this.instructions[0].keys.map($ => $.pubkey)
    }
    get programId() {
        return assert$1(this.instructions.length === 1),
        this.instructions[0].programId
    }
    get data() {
        return assert$1(this.instructions.length === 1),
        this.instructions[0].data
    }
    static from($) {
        let et = [...$];
        const tt = decodeLength(et);
        let nt = [];
        for (let rt = 0; rt < tt; rt++) {
            const it = guardedSplice(et, 0, SIGNATURE_LENGTH_IN_BYTES);
            nt.push(bs58$3.encode(Buffer$1$1.from(it)))
        }
        return Transaction.populate(Message.from(et), nt)
    }
    static populate($, et=[]) {
        const tt = new Transaction;
        return tt.recentBlockhash = $.recentBlockhash,
        $.header.numRequiredSignatures > 0 && (tt.feePayer = $.accountKeys[0]),
        et.forEach( (nt, rt) => {
            const it = {
                signature: nt == bs58$3.encode(DEFAULT_SIGNATURE) ? null : bs58$3.decode(nt),
                publicKey: $.accountKeys[rt]
            };
            tt.signatures.push(it)
        }
        ),
        $.instructions.forEach(nt => {
            const rt = nt.accounts.map(it => {
                const ot = $.accountKeys[it];
                return {
                    pubkey: ot,
                    isSigner: tt.signatures.some(st => st.publicKey.toString() === ot.toString()) || $.isAccountSigner(it),
                    isWritable: $.isAccountWritable(it)
                }
            }
            );
            tt.instructions.push(new TransactionInstruction({
                keys: rt,
                programId: $.accountKeys[nt.programIdIndex],
                data: bs58$3.decode(nt.data)
            }))
        }
        ),
        tt._message = $,
        tt._json = tt.toJSON(),
        tt
    }
}
class TransactionMessage {
    constructor($) {
        this.payerKey = void 0,
        this.instructions = void 0,
        this.recentBlockhash = void 0,
        this.payerKey = $.payerKey,
        this.instructions = $.instructions,
        this.recentBlockhash = $.recentBlockhash
    }
    static decompile($, et) {
        const {header: tt, compiledInstructions: nt, recentBlockhash: rt} = $
          , {numRequiredSignatures: it, numReadonlySignedAccounts: ot, numReadonlyUnsignedAccounts: st} = tt
          , lt = it - ot;
        assert$1(lt > 0, "Message header is invalid");
        const ct = $.staticAccountKeys.length - it - st;
        assert$1(ct >= 0, "Message header is invalid");
        const dt = $.getAccountKeys(et)
          , pt = dt.get(0);
        if (pt === void 0)
            throw new Error("Failed to decompile message because no account keys were found");
        const ht = [];
        for (const mt of nt) {
            const yt = [];
            for (const _t of mt.accountKeyIndexes) {
                const wt = dt.get(_t);
                if (wt === void 0)
                    throw new Error(`Failed to find key for account key index ${_t}`);
                const St = _t < it;
                let Ct;
                St ? Ct = _t < lt : _t < dt.staticAccountKeys.length ? Ct = _t - it < ct : Ct = _t - dt.staticAccountKeys.length < dt.accountKeysFromLookups.writable.length,
                yt.push({
                    pubkey: wt,
                    isSigner: _t < tt.numRequiredSignatures,
                    isWritable: Ct
                })
            }
            const Et = dt.get(mt.programIdIndex);
            if (Et === void 0)
                throw new Error(`Failed to find program id for program id index ${mt.programIdIndex}`);
            ht.push(new TransactionInstruction({
                programId: Et,
                data: toBuffer(mt.data),
                keys: yt
            }))
        }
        return new TransactionMessage({
            payerKey: pt,
            instructions: ht,
            recentBlockhash: rt
        })
    }
    compileToLegacyMessage() {
        return Message.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions
        })
    }
    compileToV0Message($) {
        return MessageV0.compile({
            payerKey: this.payerKey,
            recentBlockhash: this.recentBlockhash,
            instructions: this.instructions,
            addressLookupTableAccounts: $
        })
    }
}
class VersionedTransaction {
    get version() {
        return this.message.version
    }
    constructor($, et) {
        if (this.signatures = void 0,
        this.message = void 0,
        et !== void 0)
            assert$1(et.length === $.header.numRequiredSignatures, "Expected signatures length to be equal to the number of required signatures"),
            this.signatures = et;
        else {
            const tt = [];
            for (let nt = 0; nt < $.header.numRequiredSignatures; nt++)
                tt.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));
            this.signatures = tt
        }
        this.message = $
    }
    serialize() {
        const $ = this.message.serialize()
          , et = Array();
        encodeLength(et, this.signatures.length);
        const tt = struct$1([blob$1(et.length, "encodedSignaturesLength"), seq(signature(), this.signatures.length, "signatures"), blob$1($.length, "serializedMessage")])
          , nt = new Uint8Array(2048)
          , rt = tt.encode({
            encodedSignaturesLength: new Uint8Array(et),
            signatures: this.signatures,
            serializedMessage: $
        }, nt);
        return nt.slice(0, rt)
    }
    static deserialize($) {
        let et = [...$];
        const tt = []
          , nt = decodeLength(et);
        for (let it = 0; it < nt; it++)
            tt.push(new Uint8Array(guardedSplice(et, 0, SIGNATURE_LENGTH_IN_BYTES)));
        const rt = VersionedMessage.deserialize(new Uint8Array(et));
        return new VersionedTransaction(rt,tt)
    }
    sign($) {
        const et = this.message.serialize()
          , tt = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);
        for (const nt of $) {
            const rt = tt.findIndex(it => it.equals(nt.publicKey));
            assert$1(rt >= 0, `Cannot sign with non signer key ${nt.publicKey.toBase58()}`),
            this.signatures[rt] = sign$1(et, nt.secretKey)
        }
    }
    addSignature($, et) {
        assert$1(et.byteLength === 64, "Signature must be 64 bytes long");
        const nt = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures).findIndex(rt => rt.equals($));
        assert$1(nt >= 0, `Can not add signature; \`${$.toBase58()}\` is not required to sign this transaction`),
        this.signatures[nt] = et
    }
}
const NUM_TICKS_PER_SECOND = 160
  , DEFAULT_TICKS_PER_SLOT = 64
  , NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT
  , MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND
  , SYSVAR_CLOCK_PUBKEY = new PublicKey("SysvarC1ock11111111111111111111111111111111")
  , SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey("SysvarEpochSchedu1e111111111111111111111111")
  , SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey("Sysvar1nstructions1111111111111111111111111")
  , SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey("SysvarRecentB1ockHashes11111111111111111111")
  , SYSVAR_RENT_PUBKEY = new PublicKey("SysvarRent111111111111111111111111111111111")
  , SYSVAR_REWARDS_PUBKEY = new PublicKey("SysvarRewards111111111111111111111111111111")
  , SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey("SysvarS1otHashes111111111111111111111111111")
  , SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey("SysvarS1otHistory11111111111111111111111111")
  , SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey("SysvarStakeHistory1111111111111111111111111");
class SendTransactionError extends Error {
    constructor({action: $, signature: et, transactionMessage: tt, logs: nt}) {
        const rt = nt ? `Logs:
${JSON.stringify(nt.slice(-10), null, 2)}. ` : ""
          , it = "\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.";
        let ot;
        switch ($) {
        case "send":
            ot = `Transaction ${et} resulted in an error.
${tt}. ` + rt + it;
            break;
        case "simulate":
            ot = `Simulation failed.
Message: ${tt}.
` + rt + it;
            break;
        default:
            ot = `Unknown action '${(st => st)($)}'`
        }
        super(ot),
        this.signature = void 0,
        this.transactionMessage = void 0,
        this.transactionLogs = void 0,
        this.signature = et,
        this.transactionMessage = tt,
        this.transactionLogs = nt || void 0
    }
    get transactionError() {
        return {
            message: this.transactionMessage,
            logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0
        }
    }
    get logs() {
        const $ = this.transactionLogs;
        if (!($ != null && typeof $ == "object" && "then"in $))
            return $
    }
    async getLogs($) {
        return Array.isArray(this.transactionLogs) || (this.transactionLogs = new Promise( (et, tt) => {
            $.getTransaction(this.signature).then(nt => {
                if (nt && nt.meta && nt.meta.logMessages) {
                    const rt = nt.meta.logMessages;
                    this.transactionLogs = rt,
                    et(rt)
                } else
                    tt(new Error("Log messages not found"))
            }
            ).catch(tt)
        }
        )),
        await this.transactionLogs
    }
}
const SolanaJSONRPCErrorCode = {
    JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,
    JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,
    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,
    JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,
    JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,
    JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,
    JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,
    JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,
    JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,
    JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,
    JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,
    JSON_RPC_SCAN_ERROR: -32012,
    JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,
    JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,
    JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,
    JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016
};
class SolanaJSONRPCError extends Error {
    constructor({code: $, message: et, data: tt}, nt) {
        super(nt != null ? `${nt}: ${et}` : et),
        this.code = void 0,
        this.data = void 0,
        this.code = $,
        this.data = tt,
        this.name = "SolanaJSONRPCError"
    }
}
async function sendAndConfirmTransaction(_e, $, et, tt) {
    const nt = tt && {
        skipPreflight: tt.skipPreflight,
        preflightCommitment: tt.preflightCommitment || tt.commitment,
        maxRetries: tt.maxRetries,
        minContextSlot: tt.minContextSlot
    }
      , rt = await _e.sendTransaction($, et, nt);
    let it;
    if ($.recentBlockhash != null && $.lastValidBlockHeight != null)
        it = (await _e.confirmTransaction({
            abortSignal: tt == null ? void 0 : tt.abortSignal,
            signature: rt,
            blockhash: $.recentBlockhash,
            lastValidBlockHeight: $.lastValidBlockHeight
        }, tt && tt.commitment)).value;
    else if ($.minNonceContextSlot != null && $.nonceInfo != null) {
        const {nonceInstruction: ot} = $.nonceInfo
          , st = ot.keys[0].pubkey;
        it = (await _e.confirmTransaction({
            abortSignal: tt == null ? void 0 : tt.abortSignal,
            minContextSlot: $.minNonceContextSlot,
            nonceAccountPubkey: st,
            nonceValue: $.nonceInfo.nonce,
            signature: rt
        }, tt && tt.commitment)).value
    } else
        (tt == null ? void 0 : tt.abortSignal) != null,
        it = (await _e.confirmTransaction(rt, tt && tt.commitment)).value;
    if (it.err)
        throw rt != null ? new SendTransactionError({
            action: "send",
            signature: rt,
            transactionMessage: `Status: (${JSON.stringify(it)})`
        }) : new Error(`Transaction ${rt} failed (${JSON.stringify(it)})`);
    return rt
}
function sleep(_e) {
    return new Promise($ => setTimeout($, _e))
}
function encodeData(_e, $) {
    const et = _e.layout.span >= 0 ? _e.layout.span : getAlloc(_e, $)
      , tt = Buffer$1$1.alloc(et)
      , nt = Object.assign({
        instruction: _e.index
    }, $);
    return _e.layout.encode(nt, tt),
    tt
}
function decodeData$1(_e, $) {
    let et;
    try {
        et = _e.layout.decode($)
    } catch (tt) {
        throw new Error("invalid instruction; " + tt)
    }
    if (et.instruction !== _e.index)
        throw new Error(`invalid instruction; instruction index mismatch ${et.instruction} != ${_e.index}`);
    return et
}
const FeeCalculatorLayout = nu64$1("lamportsPerSignature")
  , NonceAccountLayout = struct$1([u32$1("version"), u32$1("state"), publicKey$4("authorizedPubkey"), publicKey$4("nonce"), struct$1([FeeCalculatorLayout], "feeCalculator")])
  , NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;
class NonceAccount {
    constructor($) {
        this.authorizedPubkey = void 0,
        this.nonce = void 0,
        this.feeCalculator = void 0,
        this.authorizedPubkey = $.authorizedPubkey,
        this.nonce = $.nonce,
        this.feeCalculator = $.feeCalculator
    }
    static fromAccountData($) {
        const et = NonceAccountLayout.decode(toBuffer($), 0);
        return new NonceAccount({
            authorizedPubkey: new PublicKey(et.authorizedPubkey),
            nonce: new PublicKey(et.nonce).toString(),
            feeCalculator: et.feeCalculator
        })
    }
}
const encodeDecode$1 = _e => {
    const $ = _e.decode.bind(_e)
      , et = _e.encode.bind(_e);
    return {
        decode: $,
        encode: et
    }
}
  , bigInt$1 = _e => $ => {
    const et = blob$1(_e, $)
      , {encode: tt, decode: nt} = encodeDecode$1(et)
      , rt = et;
    return rt.decode = (it, ot) => {
        const st = nt(it, ot);
        return toBigIntLE_1(Buffer$1$1.from(st))
    }
    ,
    rt.encode = (it, ot, st) => {
        const lt = toBufferLE_1(it, _e);
        return tt(lt, ot, st)
    }
    ,
    rt
}
  , u64$2 = bigInt$1(8);
class SystemInstruction {
    constructor() {}
    static decodeInstructionType($) {
        this.checkProgramId($.programId);
        const tt = u32$1("instruction").decode($.data);
        let nt;
        for (const [rt,it] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS))
            if (it.index == tt) {
                nt = rt;
                break
            }
        if (!nt)
            throw new Error("Instruction type incorrect; not a SystemInstruction");
        return nt
    }
    static decodeCreateAccount($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 2);
        const {lamports: et, space: tt, programId: nt} = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, $.data);
        return {
            fromPubkey: $.keys[0].pubkey,
            newAccountPubkey: $.keys[1].pubkey,
            lamports: et,
            space: tt,
            programId: new PublicKey(nt)
        }
    }
    static decodeTransfer($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 2);
        const {lamports: et} = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, $.data);
        return {
            fromPubkey: $.keys[0].pubkey,
            toPubkey: $.keys[1].pubkey,
            lamports: et
        }
    }
    static decodeTransferWithSeed($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 3);
        const {lamports: et, seed: tt, programId: nt} = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, $.data);
        return {
            fromPubkey: $.keys[0].pubkey,
            basePubkey: $.keys[1].pubkey,
            toPubkey: $.keys[2].pubkey,
            lamports: et,
            seed: tt,
            programId: new PublicKey(nt)
        }
    }
    static decodeAllocate($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 1);
        const {space: et} = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, $.data);
        return {
            accountPubkey: $.keys[0].pubkey,
            space: et
        }
    }
    static decodeAllocateWithSeed($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 1);
        const {base: et, seed: tt, space: nt, programId: rt} = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, $.data);
        return {
            accountPubkey: $.keys[0].pubkey,
            basePubkey: new PublicKey(et),
            seed: tt,
            space: nt,
            programId: new PublicKey(rt)
        }
    }
    static decodeAssign($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 1);
        const {programId: et} = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, $.data);
        return {
            accountPubkey: $.keys[0].pubkey,
            programId: new PublicKey(et)
        }
    }
    static decodeAssignWithSeed($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 1);
        const {base: et, seed: tt, programId: nt} = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, $.data);
        return {
            accountPubkey: $.keys[0].pubkey,
            basePubkey: new PublicKey(et),
            seed: tt,
            programId: new PublicKey(nt)
        }
    }
    static decodeCreateWithSeed($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 2);
        const {base: et, seed: tt, lamports: nt, space: rt, programId: it} = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, $.data);
        return {
            fromPubkey: $.keys[0].pubkey,
            newAccountPubkey: $.keys[1].pubkey,
            basePubkey: new PublicKey(et),
            seed: tt,
            lamports: nt,
            space: rt,
            programId: new PublicKey(it)
        }
    }
    static decodeNonceInitialize($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 3);
        const {authorized: et} = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, $.data);
        return {
            noncePubkey: $.keys[0].pubkey,
            authorizedPubkey: new PublicKey(et)
        }
    }
    static decodeNonceAdvance($) {
        return this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 3),
        decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, $.data),
        {
            noncePubkey: $.keys[0].pubkey,
            authorizedPubkey: $.keys[2].pubkey
        }
    }
    static decodeNonceWithdraw($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 5);
        const {lamports: et} = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, $.data);
        return {
            noncePubkey: $.keys[0].pubkey,
            toPubkey: $.keys[1].pubkey,
            authorizedPubkey: $.keys[4].pubkey,
            lamports: et
        }
    }
    static decodeNonceAuthorize($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 2);
        const {authorized: et} = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, $.data);
        return {
            noncePubkey: $.keys[0].pubkey,
            authorizedPubkey: $.keys[1].pubkey,
            newAuthorizedPubkey: new PublicKey(et)
        }
    }
    static checkProgramId($) {
        if (!$.equals(SystemProgram.programId))
            throw new Error("invalid instruction; programId is not SystemProgram")
    }
    static checkKeyLength($, et) {
        if ($.length < et)
            throw new Error(`invalid instruction; found ${$.length} keys, expected at least ${et}`)
    }
}
const SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({
    Create: {
        index: 0,
        layout: struct$1([u32$1("instruction"), ns64$1("lamports"), ns64$1("space"), publicKey$4("programId")])
    },
    Assign: {
        index: 1,
        layout: struct$1([u32$1("instruction"), publicKey$4("programId")])
    },
    Transfer: {
        index: 2,
        layout: struct$1([u32$1("instruction"), u64$2("lamports")])
    },
    CreateWithSeed: {
        index: 3,
        layout: struct$1([u32$1("instruction"), publicKey$4("base"), rustString("seed"), ns64$1("lamports"), ns64$1("space"), publicKey$4("programId")])
    },
    AdvanceNonceAccount: {
        index: 4,
        layout: struct$1([u32$1("instruction")])
    },
    WithdrawNonceAccount: {
        index: 5,
        layout: struct$1([u32$1("instruction"), ns64$1("lamports")])
    },
    InitializeNonceAccount: {
        index: 6,
        layout: struct$1([u32$1("instruction"), publicKey$4("authorized")])
    },
    AuthorizeNonceAccount: {
        index: 7,
        layout: struct$1([u32$1("instruction"), publicKey$4("authorized")])
    },
    Allocate: {
        index: 8,
        layout: struct$1([u32$1("instruction"), ns64$1("space")])
    },
    AllocateWithSeed: {
        index: 9,
        layout: struct$1([u32$1("instruction"), publicKey$4("base"), rustString("seed"), ns64$1("space"), publicKey$4("programId")])
    },
    AssignWithSeed: {
        index: 10,
        layout: struct$1([u32$1("instruction"), publicKey$4("base"), rustString("seed"), publicKey$4("programId")])
    },
    TransferWithSeed: {
        index: 11,
        layout: struct$1([u32$1("instruction"), u64$2("lamports"), rustString("seed"), publicKey$4("programId")])
    },
    UpgradeNonceAccount: {
        index: 12,
        layout: struct$1([u32$1("instruction")])
    }
});
class SystemProgram {
    constructor() {}
    static createAccount($) {
        const et = SYSTEM_INSTRUCTION_LAYOUTS.Create
          , tt = encodeData(et, {
            lamports: $.lamports,
            space: $.space,
            programId: toBuffer($.programId.toBuffer())
        });
        return new TransactionInstruction({
            keys: [{
                pubkey: $.fromPubkey,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: $.newAccountPubkey,
                isSigner: !0,
                isWritable: !0
            }],
            programId: this.programId,
            data: tt
        })
    }
    static transfer($) {
        let et, tt;
        if ("basePubkey"in $) {
            const nt = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;
            et = encodeData(nt, {
                lamports: BigInt($.lamports),
                seed: $.seed,
                programId: toBuffer($.programId.toBuffer())
            }),
            tt = [{
                pubkey: $.fromPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: $.basePubkey,
                isSigner: !0,
                isWritable: !1
            }, {
                pubkey: $.toPubkey,
                isSigner: !1,
                isWritable: !0
            }]
        } else {
            const nt = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;
            et = encodeData(nt, {
                lamports: BigInt($.lamports)
            }),
            tt = [{
                pubkey: $.fromPubkey,
                isSigner: !0,
                isWritable: !0
            }, {
                pubkey: $.toPubkey,
                isSigner: !1,
                isWritable: !0
            }]
        }
        return new TransactionInstruction({
            keys: tt,
            programId: this.programId,
            data: et
        })
    }
    static assign($) {
        let et, tt;
        if ("basePubkey"in $) {
            const nt = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;
            et = encodeData(nt, {
                base: toBuffer($.basePubkey.toBuffer()),
                seed: $.seed,
                programId: toBuffer($.programId.toBuffer())
            }),
            tt = [{
                pubkey: $.accountPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: $.basePubkey,
                isSigner: !0,
                isWritable: !1
            }]
        } else {
            const nt = SYSTEM_INSTRUCTION_LAYOUTS.Assign;
            et = encodeData(nt, {
                programId: toBuffer($.programId.toBuffer())
            }),
            tt = [{
                pubkey: $.accountPubkey,
                isSigner: !0,
                isWritable: !0
            }]
        }
        return new TransactionInstruction({
            keys: tt,
            programId: this.programId,
            data: et
        })
    }
    static createAccountWithSeed($) {
        const et = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed
          , tt = encodeData(et, {
            base: toBuffer($.basePubkey.toBuffer()),
            seed: $.seed,
            lamports: $.lamports,
            space: $.space,
            programId: toBuffer($.programId.toBuffer())
        });
        let nt = [{
            pubkey: $.fromPubkey,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: $.newAccountPubkey,
            isSigner: !1,
            isWritable: !0
        }];
        return $.basePubkey.equals($.fromPubkey) || nt.push({
            pubkey: $.basePubkey,
            isSigner: !0,
            isWritable: !1
        }),
        new TransactionInstruction({
            keys: nt,
            programId: this.programId,
            data: tt
        })
    }
    static createNonceAccount($) {
        const et = new Transaction;
        "basePubkey"in $ && "seed"in $ ? et.add(SystemProgram.createAccountWithSeed({
            fromPubkey: $.fromPubkey,
            newAccountPubkey: $.noncePubkey,
            basePubkey: $.basePubkey,
            seed: $.seed,
            lamports: $.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
        })) : et.add(SystemProgram.createAccount({
            fromPubkey: $.fromPubkey,
            newAccountPubkey: $.noncePubkey,
            lamports: $.lamports,
            space: NONCE_ACCOUNT_LENGTH,
            programId: this.programId
        }));
        const tt = {
            noncePubkey: $.noncePubkey,
            authorizedPubkey: $.authorizedPubkey
        };
        return et.add(this.nonceInitialize(tt)),
        et
    }
    static nonceInitialize($) {
        const et = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount
          , tt = encodeData(et, {
            authorized: toBuffer($.authorizedPubkey.toBuffer())
        })
          , nt = {
            keys: [{
                pubkey: $.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: SYSVAR_RENT_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }],
            programId: this.programId,
            data: tt
        };
        return new TransactionInstruction(nt)
    }
    static nonceAdvance($) {
        const et = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount
          , tt = encodeData(et)
          , nt = {
            keys: [{
                pubkey: $.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: $.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: tt
        };
        return new TransactionInstruction(nt)
    }
    static nonceWithdraw($) {
        const et = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount
          , tt = encodeData(et, {
            lamports: $.lamports
        });
        return new TransactionInstruction({
            keys: [{
                pubkey: $.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: $.toPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: SYSVAR_RENT_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: $.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: tt
        })
    }
    static nonceAuthorize($) {
        const et = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount
          , tt = encodeData(et, {
            authorized: toBuffer($.newAuthorizedPubkey.toBuffer())
        });
        return new TransactionInstruction({
            keys: [{
                pubkey: $.noncePubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: $.authorizedPubkey,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: tt
        })
    }
    static allocate($) {
        let et, tt;
        if ("basePubkey"in $) {
            const nt = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;
            et = encodeData(nt, {
                base: toBuffer($.basePubkey.toBuffer()),
                seed: $.seed,
                space: $.space,
                programId: toBuffer($.programId.toBuffer())
            }),
            tt = [{
                pubkey: $.accountPubkey,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: $.basePubkey,
                isSigner: !0,
                isWritable: !1
            }]
        } else {
            const nt = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;
            et = encodeData(nt, {
                space: $.space
            }),
            tt = [{
                pubkey: $.accountPubkey,
                isSigner: !0,
                isWritable: !0
            }]
        }
        return new TransactionInstruction({
            keys: tt,
            programId: this.programId,
            data: et
        })
    }
}
SystemProgram.programId = new PublicKey("11111111111111111111111111111111");
const CHUNK_SIZE = PACKET_DATA_SIZE - 300;
class Loader {
    constructor() {}
    static getMinNumSignatures($) {
        return 2 * (Math.ceil($ / Loader.chunkSize) + 1 + 1)
    }
    static async load($, et, tt, nt, rt) {
        {
            const dt = await $.getMinimumBalanceForRentExemption(rt.length)
              , pt = await $.getAccountInfo(tt.publicKey, "confirmed");
            let ht = null;
            if (pt !== null) {
                if (pt.executable)
                    return !1;
                pt.data.length !== rt.length && (ht = ht || new Transaction,
                ht.add(SystemProgram.allocate({
                    accountPubkey: tt.publicKey,
                    space: rt.length
                }))),
                pt.owner.equals(nt) || (ht = ht || new Transaction,
                ht.add(SystemProgram.assign({
                    accountPubkey: tt.publicKey,
                    programId: nt
                }))),
                pt.lamports < dt && (ht = ht || new Transaction,
                ht.add(SystemProgram.transfer({
                    fromPubkey: et.publicKey,
                    toPubkey: tt.publicKey,
                    lamports: dt - pt.lamports
                })))
            } else
                ht = new Transaction().add(SystemProgram.createAccount({
                    fromPubkey: et.publicKey,
                    newAccountPubkey: tt.publicKey,
                    lamports: dt > 0 ? dt : 1,
                    space: rt.length,
                    programId: nt
                }));
            ht !== null && await sendAndConfirmTransaction($, ht, [et, tt], {
                commitment: "confirmed"
            })
        }
        const it = struct$1([u32$1("instruction"), u32$1("offset"), u32$1("bytesLength"), u32$1("bytesLengthPadding"), seq(u8$1("byte"), offset$1(u32$1(), -8), "bytes")])
          , ot = Loader.chunkSize;
        let st = 0
          , lt = rt
          , ct = [];
        for (; lt.length > 0; ) {
            const dt = lt.slice(0, ot)
              , pt = Buffer$1$1.alloc(ot + 16);
            it.encode({
                instruction: 0,
                offset: st,
                bytes: dt,
                bytesLength: 0,
                bytesLengthPadding: 0
            }, pt);
            const ht = new Transaction().add({
                keys: [{
                    pubkey: tt.publicKey,
                    isSigner: !0,
                    isWritable: !0
                }],
                programId: nt,
                data: pt
            });
            ct.push(sendAndConfirmTransaction($, ht, [et, tt], {
                commitment: "confirmed"
            })),
            $._rpcEndpoint.includes("solana.com") && await sleep(1e3 / 4),
            st += ot,
            lt = lt.slice(ot)
        }
        await Promise.all(ct);
        {
            const dt = struct$1([u32$1("instruction")])
              , pt = Buffer$1$1.alloc(dt.span);
            dt.encode({
                instruction: 1
            }, pt);
            const ht = new Transaction().add({
                keys: [{
                    pubkey: tt.publicKey,
                    isSigner: !0,
                    isWritable: !0
                }, {
                    pubkey: SYSVAR_RENT_PUBKEY,
                    isSigner: !1,
                    isWritable: !1
                }],
                programId: nt,
                data: pt
            })
              , mt = "processed"
              , yt = await $.sendTransaction(ht, [et, tt], {
                preflightCommitment: mt
            })
              , {context: Et, value: _t} = await $.confirmTransaction({
                signature: yt,
                lastValidBlockHeight: ht.lastValidBlockHeight,
                blockhash: ht.recentBlockhash
            }, mt);
            if (_t.err)
                throw new Error(`Transaction ${yt} failed (${JSON.stringify(_t)})`);
            for (; ; ) {
                try {
                    if (await $.getSlot({
                        commitment: mt
                    }) > Et.slot)
                        break
                } catch {}
                await new Promise(wt => setTimeout(wt, Math.round(MS_PER_SLOT / 2)))
            }
        }
        return !0
    }
}
Loader.chunkSize = CHUNK_SIZE;
const BPF_LOADER_PROGRAM_ID = new PublicKey("BPFLoader2111111111111111111111111111111111");
class BpfLoader {
    static getMinNumSignatures($) {
        return Loader.getMinNumSignatures($)
    }
    static load($, et, tt, nt, rt) {
        return Loader.load($, et, tt, rt, nt)
    }
}
function getDefaultExportFromCjs$1(_e) {
    return _e && _e.__esModule && Object.prototype.hasOwnProperty.call(_e, "default") ? _e.default : _e
}
var fastStableStringify$1, hasRequiredFastStableStringify;
function requireFastStableStringify() {
    if (hasRequiredFastStableStringify)
        return fastStableStringify$1;
    hasRequiredFastStableStringify = 1;
    var _e = Object.prototype.toString
      , $ = Object.keys || function(tt) {
        var nt = [];
        for (var rt in tt)
            nt.push(rt);
        return nt
    }
    ;
    function et(tt, nt) {
        var rt, it, ot, st, lt, ct, dt;
        if (tt === !0)
            return "true";
        if (tt === !1)
            return "false";
        switch (typeof tt) {
        case "object":
            if (tt === null)
                return null;
            if (tt.toJSON && typeof tt.toJSON == "function")
                return et(tt.toJSON(), nt);
            if (dt = _e.call(tt),
            dt === "[object Array]") {
                for (ot = "[",
                it = tt.length - 1,
                rt = 0; rt < it; rt++)
                    ot += et(tt[rt], !0) + ",";
                return it > -1 && (ot += et(tt[rt], !0)),
                ot + "]"
            } else if (dt === "[object Object]") {
                for (st = $(tt).sort(),
                it = st.length,
                ot = "",
                rt = 0; rt < it; )
                    lt = st[rt],
                    ct = et(tt[lt], !1),
                    ct !== void 0 && (ot && (ot += ","),
                    ot += JSON.stringify(lt) + ":" + ct),
                    rt++;
                return "{" + ot + "}"
            } else
                return JSON.stringify(tt);
        case "function":
        case "undefined":
            return nt ? null : void 0;
        case "string":
            return JSON.stringify(tt);
        default:
            return isFinite(tt) ? tt : null
        }
    }
    return fastStableStringify$1 = function(tt) {
        var nt = et(tt, !1);
        if (nt !== void 0)
            return "" + nt
    }
    ,
    fastStableStringify$1
}
var fastStableStringifyExports = requireFastStableStringify()
  , fastStableStringify = getDefaultExportFromCjs$1(fastStableStringifyExports);
const MINIMUM_SLOT_PER_EPOCH = 32;
function trailingZeros(_e) {
    let $ = 0;
    for (; _e > 1; )
        _e /= 2,
        $++;
    return $
}
function nextPowerOfTwo(_e) {
    return _e === 0 ? 1 : (_e--,
    _e |= _e >> 1,
    _e |= _e >> 2,
    _e |= _e >> 4,
    _e |= _e >> 8,
    _e |= _e >> 16,
    _e |= _e >> 32,
    _e + 1)
}
class EpochSchedule {
    constructor($, et, tt, nt, rt) {
        this.slotsPerEpoch = void 0,
        this.leaderScheduleSlotOffset = void 0,
        this.warmup = void 0,
        this.firstNormalEpoch = void 0,
        this.firstNormalSlot = void 0,
        this.slotsPerEpoch = $,
        this.leaderScheduleSlotOffset = et,
        this.warmup = tt,
        this.firstNormalEpoch = nt,
        this.firstNormalSlot = rt
    }
    getEpoch($) {
        return this.getEpochAndSlotIndex($)[0]
    }
    getEpochAndSlotIndex($) {
        if ($ < this.firstNormalSlot) {
            const et = trailingZeros(nextPowerOfTwo($ + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1
              , tt = this.getSlotsInEpoch(et)
              , nt = $ - (tt - MINIMUM_SLOT_PER_EPOCH);
            return [et, nt]
        } else {
            const et = $ - this.firstNormalSlot
              , tt = Math.floor(et / this.slotsPerEpoch)
              , nt = this.firstNormalEpoch + tt
              , rt = et % this.slotsPerEpoch;
            return [nt, rt]
        }
    }
    getFirstSlotInEpoch($) {
        return $ <= this.firstNormalEpoch ? (Math.pow(2, $) - 1) * MINIMUM_SLOT_PER_EPOCH : ($ - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot
    }
    getLastSlotInEpoch($) {
        return this.getFirstSlotInEpoch($) + this.getSlotsInEpoch($) - 1
    }
    getSlotsInEpoch($) {
        return $ < this.firstNormalEpoch ? Math.pow(2, $ + trailingZeros(MINIMUM_SLOT_PER_EPOCH)) : this.slotsPerEpoch
    }
}
var fetchImpl = globalThis.fetch;
class RpcWebSocketClient extends CommonClient {
    constructor($, et, tt) {
        const nt = rt => {
            const it = WebSocket$1(rt, {
                autoconnect: !0,
                max_reconnects: 5,
                reconnect: !0,
                reconnect_interval: 1e3,
                ...et
            });
            return "socket"in it ? this.underlyingSocket = it.socket : this.underlyingSocket = it,
            it
        }
        ;
        super(nt, $, et, tt),
        this.underlyingSocket = void 0
    }
    call(...$) {
        var tt;
        const et = (tt = this.underlyingSocket) == null ? void 0 : tt.readyState;
        return et === 1 ? super.call(...$) : Promise.reject(new Error("Tried to call a JSON-RPC method `" + $[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + et + ")"))
    }
    notify(...$) {
        var tt;
        const et = (tt = this.underlyingSocket) == null ? void 0 : tt.readyState;
        return et === 1 ? super.notify(...$) : Promise.reject(new Error("Tried to send a JSON-RPC notification `" + $[0] + "` but the socket was not `CONNECTING` or `OPEN` (`readyState` was " + et + ")"))
    }
}
function decodeData(_e, $) {
    let et;
    try {
        et = _e.layout.decode($)
    } catch (tt) {
        throw new Error("invalid instruction; " + tt)
    }
    if (et.typeIndex !== _e.index)
        throw new Error(`invalid account data; account type mismatch ${et.typeIndex} != ${_e.index}`);
    return et
}
const LOOKUP_TABLE_META_SIZE = 56;
class AddressLookupTableAccount {
    constructor($) {
        this.key = void 0,
        this.state = void 0,
        this.key = $.key,
        this.state = $.state
    }
    isActive() {
        const $ = BigInt("0xffffffffffffffff");
        return this.state.deactivationSlot === $
    }
    static deserialize($) {
        const et = decodeData(LookupTableMetaLayout, $)
          , tt = $.length - LOOKUP_TABLE_META_SIZE;
        assert$1(tt >= 0, "lookup table is invalid"),
        assert$1(tt % 32 === 0, "lookup table is invalid");
        const nt = tt / 32
          , {addresses: rt} = struct$1([seq(publicKey$4(), nt, "addresses")]).decode($.slice(LOOKUP_TABLE_META_SIZE));
        return {
            deactivationSlot: et.deactivationSlot,
            lastExtendedSlot: et.lastExtendedSlot,
            lastExtendedSlotStartIndex: et.lastExtendedStartIndex,
            authority: et.authority.length !== 0 ? new PublicKey(et.authority[0]) : void 0,
            addresses: rt.map(it => new PublicKey(it))
        }
    }
}
const LookupTableMetaLayout = {
    index: 1,
    layout: struct$1([u32$1("typeIndex"), u64$2("deactivationSlot"), nu64$1("lastExtendedSlot"), u8$1("lastExtendedStartIndex"), u8$1(), seq(publicKey$4(), offset$1(u8$1(), -1), "authority")])
}
  , URL_RE = /^[^:]+:\/\/([^:[]+|\[[^\]]+\])(:\d+)?(.*)/i;
function makeWebsocketUrl(_e) {
    const $ = _e.match(URL_RE);
    if ($ == null)
        throw TypeError(`Failed to validate endpoint URL \`${_e}\``);
    const [et,tt,nt,rt] = $
      , it = _e.startsWith("https:") ? "wss:" : "ws:"
      , ot = nt == null ? null : parseInt(nt.slice(1), 10)
      , st = ot == null ? "" : `:${ot + 1}`;
    return `${it}//${tt}${st}${rt}`
}
const PublicKeyFromString = coerce$1(instance(PublicKey), string$2(), _e => new PublicKey(_e))
  , RawAccountDataResult = tuple$1([string$2(), literal$1("base64")])
  , BufferFromRawAccountData = coerce$1(instance(Buffer$1$1), RawAccountDataResult, _e => Buffer$1$1.from(_e[0], "base64"))
  , BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;
function assertEndpointUrl(_e) {
    if (/^https?:/.test(_e) === !1)
        throw new TypeError("Endpoint URL must start with `http:` or `https:`.");
    return _e
}
function extractCommitmentFromConfig(_e) {
    let $, et;
    if (typeof _e == "string")
        $ = _e;
    else if (_e) {
        const {commitment: tt, ...nt} = _e;
        $ = tt,
        et = nt
    }
    return {
        commitment: $,
        config: et
    }
}
function applyDefaultMemcmpEncodingToFilters(_e) {
    return _e.map($ => "memcmp"in $ ? {
        ...$,
        memcmp: {
            ...$.memcmp,
            encoding: $.memcmp.encoding ?? "base58"
        }
    } : $)
}
function createRpcResult$1(_e) {
    return union$2([type$1({
        jsonrpc: literal$1("2.0"),
        id: string$2(),
        result: _e
    }), type$1({
        jsonrpc: literal$1("2.0"),
        id: string$2(),
        error: type$1({
            code: unknown$2(),
            message: string$2(),
            data: optional$1(any$1())
        })
    })])
}
const UnknownRpcResult$1 = createRpcResult$1(unknown$2());
function jsonRpcResult$1(_e) {
    return coerce$1(createRpcResult$1(_e), UnknownRpcResult$1, $ => "error"in $ ? $ : {
        ...$,
        result: create$4($.result, _e)
    })
}
function jsonRpcResultAndContext$1(_e) {
    return jsonRpcResult$1(type$1({
        context: type$1({
            slot: number$3()
        }),
        value: _e
    }))
}
function notificationResultAndContext(_e) {
    return type$1({
        context: type$1({
            slot: number$3()
        }),
        value: _e
    })
}
function versionedMessageFromResponse(_e, $) {
    return _e === 0 ? new MessageV0({
        header: $.header,
        staticAccountKeys: $.accountKeys.map(et => new PublicKey(et)),
        recentBlockhash: $.recentBlockhash,
        compiledInstructions: $.instructions.map(et => ({
            programIdIndex: et.programIdIndex,
            accountKeyIndexes: et.accounts,
            data: bs58$3.decode(et.data)
        })),
        addressTableLookups: $.addressTableLookups
    }) : new Message($)
}
const GetInflationGovernorResult = type$1({
    foundation: number$3(),
    foundationTerm: number$3(),
    initial: number$3(),
    taper: number$3(),
    terminal: number$3()
})
  , GetInflationRewardResult = jsonRpcResult$1(array$2(nullable$1(type$1({
    epoch: number$3(),
    effectiveSlot: number$3(),
    amount: number$3(),
    postBalance: number$3(),
    commission: optional$1(nullable$1(number$3()))
}))))
  , GetRecentPrioritizationFeesResult = array$2(type$1({
    slot: number$3(),
    prioritizationFee: number$3()
}))
  , GetInflationRateResult = type$1({
    total: number$3(),
    validator: number$3(),
    foundation: number$3(),
    epoch: number$3()
})
  , GetEpochInfoResult = type$1({
    epoch: number$3(),
    slotIndex: number$3(),
    slotsInEpoch: number$3(),
    absoluteSlot: number$3(),
    blockHeight: optional$1(number$3()),
    transactionCount: optional$1(number$3())
})
  , GetEpochScheduleResult = type$1({
    slotsPerEpoch: number$3(),
    leaderScheduleSlotOffset: number$3(),
    warmup: boolean$2(),
    firstNormalEpoch: number$3(),
    firstNormalSlot: number$3()
})
  , GetLeaderScheduleResult = record(string$2(), array$2(number$3()))
  , TransactionErrorResult = nullable$1(union$2([type$1({}), string$2()]))
  , SignatureStatusResult = type$1({
    err: TransactionErrorResult
})
  , SignatureReceivedResult = literal$1("receivedSignature")
  , VersionResult = type$1({
    "solana-core": string$2(),
    "feature-set": optional$1(number$3())
})
  , ParsedInstructionStruct = type$1({
    program: string$2(),
    programId: PublicKeyFromString,
    parsed: unknown$2()
})
  , PartiallyDecodedInstructionStruct = type$1({
    programId: PublicKeyFromString,
    accounts: array$2(PublicKeyFromString),
    data: string$2()
})
  , SimulatedTransactionResponseStruct$1 = jsonRpcResultAndContext$1(type$1({
    err: nullable$1(union$2([type$1({}), string$2()])),
    logs: nullable$1(array$2(string$2())),
    accounts: optional$1(nullable$1(array$2(nullable$1(type$1({
        executable: boolean$2(),
        owner: string$2(),
        lamports: number$3(),
        data: array$2(string$2()),
        rentEpoch: optional$1(number$3())
    }))))),
    unitsConsumed: optional$1(number$3()),
    returnData: optional$1(nullable$1(type$1({
        programId: string$2(),
        data: tuple$1([string$2(), literal$1("base64")])
    }))),
    innerInstructions: optional$1(nullable$1(array$2(type$1({
        index: number$3(),
        instructions: array$2(union$2([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))
    }))))
}))
  , BlockProductionResponseStruct = jsonRpcResultAndContext$1(type$1({
    byIdentity: record(string$2(), array$2(number$3())),
    range: type$1({
        firstSlot: number$3(),
        lastSlot: number$3()
    })
}));
function createRpcClient(_e, $, et, tt, nt, rt) {
    const it = et || fetchImpl;
    let ot;
    rt != null;
    let st;
    return tt && (st = async (ct, dt) => {
        const pt = await new Promise( (ht, mt) => {
            try {
                tt(ct, dt, (yt, Et) => ht([yt, Et]))
            } catch (yt) {
                mt(yt)
            }
        }
        );
        return await it(...pt)
    }
    ),
    new RpcClient(async (ct, dt) => {
        const pt = {
            method: "POST",
            body: ct,
            agent: ot,
            headers: Object.assign({
                "Content-Type": "application/json"
            }, $ || {}, COMMON_HTTP_HEADERS)
        };
        try {
            let ht = 5, mt, yt = 500;
            for (; st ? mt = await st(_e, pt) : mt = await it(_e, pt),
            !(mt.status !== 429 || nt === !0 || (ht -= 1,
            ht === 0)); )
                await sleep(yt),
                yt *= 2;
            const Et = await mt.text();
            mt.ok ? dt(null, Et) : dt(new Error(`${mt.status} ${mt.statusText}: ${Et}`))
        } catch (ht) {
            ht instanceof Error && dt(ht)
        }
    }
    ,{})
}
function createRpcRequest(_e) {
    return ($, et) => new Promise( (tt, nt) => {
        _e.request($, et, (rt, it) => {
            if (rt) {
                nt(rt);
                return
            }
            tt(it)
        }
        )
    }
    )
}
function createRpcBatchRequest(_e) {
    return $ => new Promise( (et, tt) => {
        $.length === 0 && et([]);
        const nt = $.map(rt => _e.request(rt.methodName, rt.args));
        _e.request(nt, (rt, it) => {
            if (rt) {
                tt(rt);
                return
            }
            et(it)
        }
        )
    }
    )
}
const GetInflationGovernorRpcResult = jsonRpcResult$1(GetInflationGovernorResult)
  , GetInflationRateRpcResult = jsonRpcResult$1(GetInflationRateResult)
  , GetRecentPrioritizationFeesRpcResult = jsonRpcResult$1(GetRecentPrioritizationFeesResult)
  , GetEpochInfoRpcResult = jsonRpcResult$1(GetEpochInfoResult)
  , GetEpochScheduleRpcResult = jsonRpcResult$1(GetEpochScheduleResult)
  , GetLeaderScheduleRpcResult = jsonRpcResult$1(GetLeaderScheduleResult)
  , SlotRpcResult = jsonRpcResult$1(number$3())
  , GetSupplyRpcResult = jsonRpcResultAndContext$1(type$1({
    total: number$3(),
    circulating: number$3(),
    nonCirculating: number$3(),
    nonCirculatingAccounts: array$2(PublicKeyFromString)
}))
  , TokenAmountResult = type$1({
    amount: string$2(),
    uiAmount: nullable$1(number$3()),
    decimals: number$3(),
    uiAmountString: optional$1(string$2())
})
  , GetTokenLargestAccountsResult = jsonRpcResultAndContext$1(array$2(type$1({
    address: PublicKeyFromString,
    amount: string$2(),
    uiAmount: nullable$1(number$3()),
    decimals: number$3(),
    uiAmountString: optional$1(string$2())
})))
  , GetTokenAccountsByOwner = jsonRpcResultAndContext$1(array$2(type$1({
    pubkey: PublicKeyFromString,
    account: type$1({
        executable: boolean$2(),
        owner: PublicKeyFromString,
        lamports: number$3(),
        data: BufferFromRawAccountData,
        rentEpoch: number$3()
    })
})))
  , ParsedAccountDataResult = type$1({
    program: string$2(),
    parsed: unknown$2(),
    space: number$3()
})
  , GetParsedTokenAccountsByOwner = jsonRpcResultAndContext$1(array$2(type$1({
    pubkey: PublicKeyFromString,
    account: type$1({
        executable: boolean$2(),
        owner: PublicKeyFromString,
        lamports: number$3(),
        data: ParsedAccountDataResult,
        rentEpoch: number$3()
    })
})))
  , GetLargestAccountsRpcResult = jsonRpcResultAndContext$1(array$2(type$1({
    lamports: number$3(),
    address: PublicKeyFromString
})))
  , AccountInfoResult = type$1({
    executable: boolean$2(),
    owner: PublicKeyFromString,
    lamports: number$3(),
    data: BufferFromRawAccountData,
    rentEpoch: number$3()
})
  , KeyedAccountInfoResult = type$1({
    pubkey: PublicKeyFromString,
    account: AccountInfoResult
})
  , ParsedOrRawAccountData = coerce$1(union$2([instance(Buffer$1$1), ParsedAccountDataResult]), union$2([RawAccountDataResult, ParsedAccountDataResult]), _e => Array.isArray(_e) ? create$4(_e, BufferFromRawAccountData) : _e)
  , ParsedAccountInfoResult = type$1({
    executable: boolean$2(),
    owner: PublicKeyFromString,
    lamports: number$3(),
    data: ParsedOrRawAccountData,
    rentEpoch: number$3()
})
  , KeyedParsedAccountInfoResult = type$1({
    pubkey: PublicKeyFromString,
    account: ParsedAccountInfoResult
})
  , StakeActivationResult = type$1({
    state: union$2([literal$1("active"), literal$1("inactive"), literal$1("activating"), literal$1("deactivating")]),
    active: number$3(),
    inactive: number$3()
})
  , GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult$1(array$2(type$1({
    signature: string$2(),
    slot: number$3(),
    err: TransactionErrorResult,
    memo: nullable$1(string$2()),
    blockTime: optional$1(nullable$1(number$3()))
})))
  , GetSignaturesForAddressRpcResult = jsonRpcResult$1(array$2(type$1({
    signature: string$2(),
    slot: number$3(),
    err: TransactionErrorResult,
    memo: nullable$1(string$2()),
    blockTime: optional$1(nullable$1(number$3()))
})))
  , AccountNotificationResult = type$1({
    subscription: number$3(),
    result: notificationResultAndContext(AccountInfoResult)
})
  , ProgramAccountInfoResult = type$1({
    pubkey: PublicKeyFromString,
    account: AccountInfoResult
})
  , ProgramAccountNotificationResult = type$1({
    subscription: number$3(),
    result: notificationResultAndContext(ProgramAccountInfoResult)
})
  , SlotInfoResult = type$1({
    parent: number$3(),
    slot: number$3(),
    root: number$3()
})
  , SlotNotificationResult = type$1({
    subscription: number$3(),
    result: SlotInfoResult
})
  , SlotUpdateResult = union$2([type$1({
    type: union$2([literal$1("firstShredReceived"), literal$1("completed"), literal$1("optimisticConfirmation"), literal$1("root")]),
    slot: number$3(),
    timestamp: number$3()
}), type$1({
    type: literal$1("createdBank"),
    parent: number$3(),
    slot: number$3(),
    timestamp: number$3()
}), type$1({
    type: literal$1("frozen"),
    slot: number$3(),
    timestamp: number$3(),
    stats: type$1({
        numTransactionEntries: number$3(),
        numSuccessfulTransactions: number$3(),
        numFailedTransactions: number$3(),
        maxTransactionsPerEntry: number$3()
    })
}), type$1({
    type: literal$1("dead"),
    slot: number$3(),
    timestamp: number$3(),
    err: string$2()
})])
  , SlotUpdateNotificationResult = type$1({
    subscription: number$3(),
    result: SlotUpdateResult
})
  , SignatureNotificationResult = type$1({
    subscription: number$3(),
    result: notificationResultAndContext(union$2([SignatureStatusResult, SignatureReceivedResult]))
})
  , RootNotificationResult = type$1({
    subscription: number$3(),
    result: number$3()
})
  , ContactInfoResult = type$1({
    pubkey: string$2(),
    gossip: nullable$1(string$2()),
    tpu: nullable$1(string$2()),
    rpc: nullable$1(string$2()),
    version: nullable$1(string$2())
})
  , VoteAccountInfoResult = type$1({
    votePubkey: string$2(),
    nodePubkey: string$2(),
    activatedStake: number$3(),
    epochVoteAccount: boolean$2(),
    epochCredits: array$2(tuple$1([number$3(), number$3(), number$3()])),
    commission: number$3(),
    lastVote: number$3(),
    rootSlot: nullable$1(number$3())
})
  , GetVoteAccounts = jsonRpcResult$1(type$1({
    current: array$2(VoteAccountInfoResult),
    delinquent: array$2(VoteAccountInfoResult)
}))
  , ConfirmationStatus = union$2([literal$1("processed"), literal$1("confirmed"), literal$1("finalized")])
  , SignatureStatusResponse = type$1({
    slot: number$3(),
    confirmations: nullable$1(number$3()),
    err: TransactionErrorResult,
    confirmationStatus: optional$1(ConfirmationStatus)
})
  , GetSignatureStatusesRpcResult = jsonRpcResultAndContext$1(array$2(nullable$1(SignatureStatusResponse)))
  , GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult$1(number$3())
  , AddressTableLookupStruct = type$1({
    accountKey: PublicKeyFromString,
    writableIndexes: array$2(number$3()),
    readonlyIndexes: array$2(number$3())
})
  , ConfirmedTransactionResult = type$1({
    signatures: array$2(string$2()),
    message: type$1({
        accountKeys: array$2(string$2()),
        header: type$1({
            numRequiredSignatures: number$3(),
            numReadonlySignedAccounts: number$3(),
            numReadonlyUnsignedAccounts: number$3()
        }),
        instructions: array$2(type$1({
            accounts: array$2(number$3()),
            data: string$2(),
            programIdIndex: number$3()
        })),
        recentBlockhash: string$2(),
        addressTableLookups: optional$1(array$2(AddressTableLookupStruct))
    })
})
  , AnnotatedAccountKey = type$1({
    pubkey: PublicKeyFromString,
    signer: boolean$2(),
    writable: boolean$2(),
    source: optional$1(union$2([literal$1("transaction"), literal$1("lookupTable")]))
})
  , ConfirmedTransactionAccountsModeResult = type$1({
    accountKeys: array$2(AnnotatedAccountKey),
    signatures: array$2(string$2())
})
  , ParsedInstructionResult = type$1({
    parsed: unknown$2(),
    program: string$2(),
    programId: PublicKeyFromString
})
  , RawInstructionResult = type$1({
    accounts: array$2(PublicKeyFromString),
    data: string$2(),
    programId: PublicKeyFromString
})
  , InstructionResult = union$2([RawInstructionResult, ParsedInstructionResult])
  , UnknownInstructionResult = union$2([type$1({
    parsed: unknown$2(),
    program: string$2(),
    programId: string$2()
}), type$1({
    accounts: array$2(string$2()),
    data: string$2(),
    programId: string$2()
})])
  , ParsedOrRawInstruction = coerce$1(InstructionResult, UnknownInstructionResult, _e => "accounts"in _e ? create$4(_e, RawInstructionResult) : create$4(_e, ParsedInstructionResult))
  , ParsedConfirmedTransactionResult = type$1({
    signatures: array$2(string$2()),
    message: type$1({
        accountKeys: array$2(AnnotatedAccountKey),
        instructions: array$2(ParsedOrRawInstruction),
        recentBlockhash: string$2(),
        addressTableLookups: optional$1(nullable$1(array$2(AddressTableLookupStruct)))
    })
})
  , TokenBalanceResult = type$1({
    accountIndex: number$3(),
    mint: string$2(),
    owner: optional$1(string$2()),
    programId: optional$1(string$2()),
    uiTokenAmount: TokenAmountResult
})
  , LoadedAddressesResult = type$1({
    writable: array$2(PublicKeyFromString),
    readonly: array$2(PublicKeyFromString)
})
  , ConfirmedTransactionMetaResult = type$1({
    err: TransactionErrorResult,
    fee: number$3(),
    innerInstructions: optional$1(nullable$1(array$2(type$1({
        index: number$3(),
        instructions: array$2(type$1({
            accounts: array$2(number$3()),
            data: string$2(),
            programIdIndex: number$3()
        }))
    })))),
    preBalances: array$2(number$3()),
    postBalances: array$2(number$3()),
    logMessages: optional$1(nullable$1(array$2(string$2()))),
    preTokenBalances: optional$1(nullable$1(array$2(TokenBalanceResult))),
    postTokenBalances: optional$1(nullable$1(array$2(TokenBalanceResult))),
    loadedAddresses: optional$1(LoadedAddressesResult),
    computeUnitsConsumed: optional$1(number$3())
})
  , ParsedConfirmedTransactionMetaResult = type$1({
    err: TransactionErrorResult,
    fee: number$3(),
    innerInstructions: optional$1(nullable$1(array$2(type$1({
        index: number$3(),
        instructions: array$2(ParsedOrRawInstruction)
    })))),
    preBalances: array$2(number$3()),
    postBalances: array$2(number$3()),
    logMessages: optional$1(nullable$1(array$2(string$2()))),
    preTokenBalances: optional$1(nullable$1(array$2(TokenBalanceResult))),
    postTokenBalances: optional$1(nullable$1(array$2(TokenBalanceResult))),
    loadedAddresses: optional$1(LoadedAddressesResult),
    computeUnitsConsumed: optional$1(number$3())
})
  , TransactionVersionStruct = union$2([literal$1(0), literal$1("legacy")])
  , RewardsResult = type$1({
    pubkey: string$2(),
    lamports: number$3(),
    postBalance: nullable$1(number$3()),
    rewardType: nullable$1(string$2()),
    commission: optional$1(nullable$1(number$3()))
})
  , GetBlockRpcResult = jsonRpcResult$1(nullable$1(type$1({
    blockhash: string$2(),
    previousBlockhash: string$2(),
    parentSlot: number$3(),
    transactions: array$2(type$1({
        transaction: ConfirmedTransactionResult,
        meta: nullable$1(ConfirmedTransactionMetaResult),
        version: optional$1(TransactionVersionStruct)
    })),
    rewards: optional$1(array$2(RewardsResult)),
    blockTime: nullable$1(number$3()),
    blockHeight: nullable$1(number$3())
})))
  , GetNoneModeBlockRpcResult = jsonRpcResult$1(nullable$1(type$1({
    blockhash: string$2(),
    previousBlockhash: string$2(),
    parentSlot: number$3(),
    rewards: optional$1(array$2(RewardsResult)),
    blockTime: nullable$1(number$3()),
    blockHeight: nullable$1(number$3())
})))
  , GetAccountsModeBlockRpcResult = jsonRpcResult$1(nullable$1(type$1({
    blockhash: string$2(),
    previousBlockhash: string$2(),
    parentSlot: number$3(),
    transactions: array$2(type$1({
        transaction: ConfirmedTransactionAccountsModeResult,
        meta: nullable$1(ConfirmedTransactionMetaResult),
        version: optional$1(TransactionVersionStruct)
    })),
    rewards: optional$1(array$2(RewardsResult)),
    blockTime: nullable$1(number$3()),
    blockHeight: nullable$1(number$3())
})))
  , GetParsedBlockRpcResult = jsonRpcResult$1(nullable$1(type$1({
    blockhash: string$2(),
    previousBlockhash: string$2(),
    parentSlot: number$3(),
    transactions: array$2(type$1({
        transaction: ParsedConfirmedTransactionResult,
        meta: nullable$1(ParsedConfirmedTransactionMetaResult),
        version: optional$1(TransactionVersionStruct)
    })),
    rewards: optional$1(array$2(RewardsResult)),
    blockTime: nullable$1(number$3()),
    blockHeight: nullable$1(number$3())
})))
  , GetParsedAccountsModeBlockRpcResult = jsonRpcResult$1(nullable$1(type$1({
    blockhash: string$2(),
    previousBlockhash: string$2(),
    parentSlot: number$3(),
    transactions: array$2(type$1({
        transaction: ConfirmedTransactionAccountsModeResult,
        meta: nullable$1(ParsedConfirmedTransactionMetaResult),
        version: optional$1(TransactionVersionStruct)
    })),
    rewards: optional$1(array$2(RewardsResult)),
    blockTime: nullable$1(number$3()),
    blockHeight: nullable$1(number$3())
})))
  , GetParsedNoneModeBlockRpcResult = jsonRpcResult$1(nullable$1(type$1({
    blockhash: string$2(),
    previousBlockhash: string$2(),
    parentSlot: number$3(),
    rewards: optional$1(array$2(RewardsResult)),
    blockTime: nullable$1(number$3()),
    blockHeight: nullable$1(number$3())
})))
  , GetConfirmedBlockRpcResult = jsonRpcResult$1(nullable$1(type$1({
    blockhash: string$2(),
    previousBlockhash: string$2(),
    parentSlot: number$3(),
    transactions: array$2(type$1({
        transaction: ConfirmedTransactionResult,
        meta: nullable$1(ConfirmedTransactionMetaResult)
    })),
    rewards: optional$1(array$2(RewardsResult)),
    blockTime: nullable$1(number$3())
})))
  , GetBlockSignaturesRpcResult = jsonRpcResult$1(nullable$1(type$1({
    blockhash: string$2(),
    previousBlockhash: string$2(),
    parentSlot: number$3(),
    signatures: array$2(string$2()),
    blockTime: nullable$1(number$3())
})))
  , GetTransactionRpcResult = jsonRpcResult$1(nullable$1(type$1({
    slot: number$3(),
    meta: nullable$1(ConfirmedTransactionMetaResult),
    blockTime: optional$1(nullable$1(number$3())),
    transaction: ConfirmedTransactionResult,
    version: optional$1(TransactionVersionStruct)
})))
  , GetParsedTransactionRpcResult = jsonRpcResult$1(nullable$1(type$1({
    slot: number$3(),
    transaction: ParsedConfirmedTransactionResult,
    meta: nullable$1(ParsedConfirmedTransactionMetaResult),
    blockTime: optional$1(nullable$1(number$3())),
    version: optional$1(TransactionVersionStruct)
})))
  , GetLatestBlockhashRpcResult = jsonRpcResultAndContext$1(type$1({
    blockhash: string$2(),
    lastValidBlockHeight: number$3()
}))
  , IsBlockhashValidRpcResult = jsonRpcResultAndContext$1(boolean$2())
  , PerfSampleResult = type$1({
    slot: number$3(),
    numTransactions: number$3(),
    numSlots: number$3(),
    samplePeriodSecs: number$3()
})
  , GetRecentPerformanceSamplesRpcResult = jsonRpcResult$1(array$2(PerfSampleResult))
  , GetFeeCalculatorRpcResult = jsonRpcResultAndContext$1(nullable$1(type$1({
    feeCalculator: type$1({
        lamportsPerSignature: number$3()
    })
})))
  , RequestAirdropRpcResult = jsonRpcResult$1(string$2())
  , SendTransactionRpcResult = jsonRpcResult$1(string$2())
  , LogsResult = type$1({
    err: TransactionErrorResult,
    logs: array$2(string$2()),
    signature: string$2()
})
  , LogsNotificationResult = type$1({
    result: notificationResultAndContext(LogsResult),
    subscription: number$3()
})
  , COMMON_HTTP_HEADERS = {
    "solana-client": "js/1.0.0-maintenance"
};
class Connection {
    constructor($, et) {
        this._commitment = void 0,
        this._confirmTransactionInitialTimeout = void 0,
        this._rpcEndpoint = void 0,
        this._rpcWsEndpoint = void 0,
        this._rpcClient = void 0,
        this._rpcRequest = void 0,
        this._rpcBatchRequest = void 0,
        this._rpcWebSocket = void 0,
        this._rpcWebSocketConnected = !1,
        this._rpcWebSocketHeartbeat = null,
        this._rpcWebSocketIdleTimeout = null,
        this._rpcWebSocketGeneration = 0,
        this._disableBlockhashCaching = !1,
        this._pollingBlockhash = !1,
        this._blockhashInfo = {
            latestBlockhash: null,
            lastFetch: 0,
            transactionSignatures: [],
            simulatedSignatures: []
        },
        this._nextClientSubscriptionId = 0,
        this._subscriptionDisposeFunctionsByClientSubscriptionId = {},
        this._subscriptionHashByClientSubscriptionId = {},
        this._subscriptionStateChangeCallbacksByHash = {},
        this._subscriptionCallbacksByServerSubscriptionId = {},
        this._subscriptionsByHash = {},
        this._subscriptionsAutoDisposedByRpc = new Set,
        this.getBlockHeight = ( () => {
            const lt = {};
            return async ct => {
                const {commitment: dt, config: pt} = extractCommitmentFromConfig(ct)
                  , ht = this._buildArgs([], dt, void 0, pt)
                  , mt = fastStableStringify(ht);
                return lt[mt] = lt[mt] ?? (async () => {
                    try {
                        const yt = await this._rpcRequest("getBlockHeight", ht)
                          , Et = create$4(yt, jsonRpcResult$1(number$3()));
                        if ("error"in Et)
                            throw new SolanaJSONRPCError(Et.error,"failed to get block height information");
                        return Et.result
                    } finally {
                        delete lt[mt]
                    }
                }
                )(),
                await lt[mt]
            }
        }
        )();
        let tt, nt, rt, it, ot, st;
        et && typeof et == "string" ? this._commitment = et : et && (this._commitment = et.commitment,
        this._confirmTransactionInitialTimeout = et.confirmTransactionInitialTimeout,
        tt = et.wsEndpoint,
        nt = et.httpHeaders,
        rt = et.fetch,
        it = et.fetchMiddleware,
        ot = et.disableRetryOnRateLimit,
        st = et.httpAgent),
        this._rpcEndpoint = assertEndpointUrl($),
        this._rpcWsEndpoint = tt || makeWebsocketUrl($),
        this._rpcClient = createRpcClient($, nt, rt, it, ot, st),
        this._rpcRequest = createRpcRequest(this._rpcClient),
        this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient),
        this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint,{
            autoconnect: !1,
            max_reconnects: 1 / 0
        }),
        this._rpcWebSocket.on("open", this._wsOnOpen.bind(this)),
        this._rpcWebSocket.on("error", this._wsOnError.bind(this)),
        this._rpcWebSocket.on("close", this._wsOnClose.bind(this)),
        this._rpcWebSocket.on("accountNotification", this._wsOnAccountNotification.bind(this)),
        this._rpcWebSocket.on("programNotification", this._wsOnProgramAccountNotification.bind(this)),
        this._rpcWebSocket.on("slotNotification", this._wsOnSlotNotification.bind(this)),
        this._rpcWebSocket.on("slotsUpdatesNotification", this._wsOnSlotUpdatesNotification.bind(this)),
        this._rpcWebSocket.on("signatureNotification", this._wsOnSignatureNotification.bind(this)),
        this._rpcWebSocket.on("rootNotification", this._wsOnRootNotification.bind(this)),
        this._rpcWebSocket.on("logsNotification", this._wsOnLogsNotification.bind(this))
    }
    get commitment() {
        return this._commitment
    }
    get rpcEndpoint() {
        return this._rpcEndpoint
    }
    async getBalanceAndContext($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , rt = this._buildArgs([$.toBase58()], tt, void 0, nt)
          , it = await this._rpcRequest("getBalance", rt)
          , ot = create$4(it, jsonRpcResultAndContext$1(number$3()));
        if ("error"in ot)
            throw new SolanaJSONRPCError(ot.error,`failed to get balance for ${$.toBase58()}`);
        return ot.result
    }
    async getBalance($, et) {
        return await this.getBalanceAndContext($, et).then(tt => tt.value).catch(tt => {
            throw new Error("failed to get balance of account " + $.toBase58() + ": " + tt)
        }
        )
    }
    async getBlockTime($) {
        const et = await this._rpcRequest("getBlockTime", [$])
          , tt = create$4(et, jsonRpcResult$1(nullable$1(number$3())));
        if ("error"in tt)
            throw new SolanaJSONRPCError(tt.error,`failed to get block time for slot ${$}`);
        return tt.result
    }
    async getMinimumLedgerSlot() {
        const $ = await this._rpcRequest("minimumLedgerSlot", [])
          , et = create$4($, jsonRpcResult$1(number$3()));
        if ("error"in et)
            throw new SolanaJSONRPCError(et.error,"failed to get minimum ledger slot");
        return et.result
    }
    async getFirstAvailableBlock() {
        const $ = await this._rpcRequest("getFirstAvailableBlock", [])
          , et = create$4($, SlotRpcResult);
        if ("error"in et)
            throw new SolanaJSONRPCError(et.error,"failed to get first available block");
        return et.result
    }
    async getSupply($) {
        let et = {};
        typeof $ == "string" ? et = {
            commitment: $
        } : $ ? et = {
            ...$,
            commitment: $ && $.commitment || this.commitment
        } : et = {
            commitment: this.commitment
        };
        const tt = await this._rpcRequest("getSupply", [et])
          , nt = create$4(tt, GetSupplyRpcResult);
        if ("error"in nt)
            throw new SolanaJSONRPCError(nt.error,"failed to get supply");
        return nt.result
    }
    async getTokenSupply($, et) {
        const tt = this._buildArgs([$.toBase58()], et)
          , nt = await this._rpcRequest("getTokenSupply", tt)
          , rt = create$4(nt, jsonRpcResultAndContext$1(TokenAmountResult));
        if ("error"in rt)
            throw new SolanaJSONRPCError(rt.error,"failed to get token supply");
        return rt.result
    }
    async getTokenAccountBalance($, et) {
        const tt = this._buildArgs([$.toBase58()], et)
          , nt = await this._rpcRequest("getTokenAccountBalance", tt)
          , rt = create$4(nt, jsonRpcResultAndContext$1(TokenAmountResult));
        if ("error"in rt)
            throw new SolanaJSONRPCError(rt.error,"failed to get token account balance");
        return rt.result
    }
    async getTokenAccountsByOwner($, et, tt) {
        const {commitment: nt, config: rt} = extractCommitmentFromConfig(tt);
        let it = [$.toBase58()];
        "mint"in et ? it.push({
            mint: et.mint.toBase58()
        }) : it.push({
            programId: et.programId.toBase58()
        });
        const ot = this._buildArgs(it, nt, "base64", rt)
          , st = await this._rpcRequest("getTokenAccountsByOwner", ot)
          , lt = create$4(st, GetTokenAccountsByOwner);
        if ("error"in lt)
            throw new SolanaJSONRPCError(lt.error,`failed to get token accounts owned by account ${$.toBase58()}`);
        return lt.result
    }
    async getParsedTokenAccountsByOwner($, et, tt) {
        let nt = [$.toBase58()];
        "mint"in et ? nt.push({
            mint: et.mint.toBase58()
        }) : nt.push({
            programId: et.programId.toBase58()
        });
        const rt = this._buildArgs(nt, tt, "jsonParsed")
          , it = await this._rpcRequest("getTokenAccountsByOwner", rt)
          , ot = create$4(it, GetParsedTokenAccountsByOwner);
        if ("error"in ot)
            throw new SolanaJSONRPCError(ot.error,`failed to get token accounts owned by account ${$.toBase58()}`);
        return ot.result
    }
    async getLargestAccounts($) {
        const et = {
            ...$,
            commitment: $ && $.commitment || this.commitment
        }
          , tt = et.filter || et.commitment ? [et] : []
          , nt = await this._rpcRequest("getLargestAccounts", tt)
          , rt = create$4(nt, GetLargestAccountsRpcResult);
        if ("error"in rt)
            throw new SolanaJSONRPCError(rt.error,"failed to get largest accounts");
        return rt.result
    }
    async getTokenLargestAccounts($, et) {
        const tt = this._buildArgs([$.toBase58()], et)
          , nt = await this._rpcRequest("getTokenLargestAccounts", tt)
          , rt = create$4(nt, GetTokenLargestAccountsResult);
        if ("error"in rt)
            throw new SolanaJSONRPCError(rt.error,"failed to get token largest accounts");
        return rt.result
    }
    async getAccountInfoAndContext($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , rt = this._buildArgs([$.toBase58()], tt, "base64", nt)
          , it = await this._rpcRequest("getAccountInfo", rt)
          , ot = create$4(it, jsonRpcResultAndContext$1(nullable$1(AccountInfoResult)));
        if ("error"in ot)
            throw new SolanaJSONRPCError(ot.error,`failed to get info about account ${$.toBase58()}`);
        return ot.result
    }
    async getParsedAccountInfo($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , rt = this._buildArgs([$.toBase58()], tt, "jsonParsed", nt)
          , it = await this._rpcRequest("getAccountInfo", rt)
          , ot = create$4(it, jsonRpcResultAndContext$1(nullable$1(ParsedAccountInfoResult)));
        if ("error"in ot)
            throw new SolanaJSONRPCError(ot.error,`failed to get info about account ${$.toBase58()}`);
        return ot.result
    }
    async getAccountInfo($, et) {
        try {
            return (await this.getAccountInfoAndContext($, et)).value
        } catch (tt) {
            throw new Error("failed to get info about account " + $.toBase58() + ": " + tt)
        }
    }
    async getMultipleParsedAccounts($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , rt = $.map(lt => lt.toBase58())
          , it = this._buildArgs([rt], tt, "jsonParsed", nt)
          , ot = await this._rpcRequest("getMultipleAccounts", it)
          , st = create$4(ot, jsonRpcResultAndContext$1(array$2(nullable$1(ParsedAccountInfoResult))));
        if ("error"in st)
            throw new SolanaJSONRPCError(st.error,`failed to get info for accounts ${rt}`);
        return st.result
    }
    async getMultipleAccountsInfoAndContext($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , rt = $.map(lt => lt.toBase58())
          , it = this._buildArgs([rt], tt, "base64", nt)
          , ot = await this._rpcRequest("getMultipleAccounts", it)
          , st = create$4(ot, jsonRpcResultAndContext$1(array$2(nullable$1(AccountInfoResult))));
        if ("error"in st)
            throw new SolanaJSONRPCError(st.error,`failed to get info for accounts ${rt}`);
        return st.result
    }
    async getMultipleAccountsInfo($, et) {
        return (await this.getMultipleAccountsInfoAndContext($, et)).value
    }
    async getStakeActivation($, et, tt) {
        const {commitment: nt, config: rt} = extractCommitmentFromConfig(et)
          , it = this._buildArgs([$.toBase58()], nt, void 0, {
            ...rt,
            epoch: tt ?? (rt == null ? void 0 : rt.epoch)
        })
          , ot = await this._rpcRequest("getStakeActivation", it)
          , st = create$4(ot, jsonRpcResult$1(StakeActivationResult));
        if ("error"in st)
            throw new SolanaJSONRPCError(st.error,`failed to get Stake Activation ${$.toBase58()}`);
        return st.result
    }
    async getProgramAccounts($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , {encoding: rt, ...it} = nt || {}
          , ot = this._buildArgs([$.toBase58()], tt, rt || "base64", {
            ...it,
            ...it.filters ? {
                filters: applyDefaultMemcmpEncodingToFilters(it.filters)
            } : null
        })
          , st = await this._rpcRequest("getProgramAccounts", ot)
          , lt = array$2(KeyedAccountInfoResult)
          , ct = it.withContext === !0 ? create$4(st, jsonRpcResultAndContext$1(lt)) : create$4(st, jsonRpcResult$1(lt));
        if ("error"in ct)
            throw new SolanaJSONRPCError(ct.error,`failed to get accounts owned by program ${$.toBase58()}`);
        return ct.result
    }
    async getParsedProgramAccounts($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , rt = this._buildArgs([$.toBase58()], tt, "jsonParsed", nt)
          , it = await this._rpcRequest("getProgramAccounts", rt)
          , ot = create$4(it, jsonRpcResult$1(array$2(KeyedParsedAccountInfoResult)));
        if ("error"in ot)
            throw new SolanaJSONRPCError(ot.error,`failed to get accounts owned by program ${$.toBase58()}`);
        return ot.result
    }
    async confirmTransaction($, et) {
        var rt;
        let tt;
        if (typeof $ == "string")
            tt = $;
        else {
            const it = $;
            if ((rt = it.abortSignal) != null && rt.aborted)
                return Promise.reject(it.abortSignal.reason);
            tt = it.signature
        }
        let nt;
        try {
            nt = bs58$3.decode(tt)
        } catch {
            throw new Error("signature must be base58 encoded: " + tt)
        }
        return assert$1(nt.length === 64, "signature has invalid length"),
        typeof $ == "string" ? await this.confirmTransactionUsingLegacyTimeoutStrategy({
            commitment: et || this.commitment,
            signature: tt
        }) : "lastValidBlockHeight"in $ ? await this.confirmTransactionUsingBlockHeightExceedanceStrategy({
            commitment: et || this.commitment,
            strategy: $
        }) : await this.confirmTransactionUsingDurableNonceStrategy({
            commitment: et || this.commitment,
            strategy: $
        })
    }
    getCancellationPromise($) {
        return new Promise( (et, tt) => {
            $ != null && ($.aborted ? tt($.reason) : $.addEventListener("abort", () => {
                tt($.reason)
            }
            ))
        }
        )
    }
    getTransactionConfirmationPromise({commitment: $, signature: et}) {
        let tt, nt, rt = !1;
        const it = new Promise( (st, lt) => {
            try {
                tt = this.onSignature(et, (dt, pt) => {
                    tt = void 0;
                    const ht = {
                        context: pt,
                        value: dt
                    };
                    st({
                        __type: TransactionStatus.PROCESSED,
                        response: ht
                    })
                }
                , $);
                const ct = new Promise(dt => {
                    tt == null ? dt() : nt = this._onSubscriptionStateChange(tt, pt => {
                        pt === "subscribed" && dt()
                    }
                    )
                }
                );
                (async () => {
                    if (await ct,
                    rt)
                        return;
                    const dt = await this.getSignatureStatus(et);
                    if (rt || dt == null)
                        return;
                    const {context: pt, value: ht} = dt;
                    if (ht != null)
                        if (ht != null && ht.err)
                            lt(ht.err);
                        else {
                            switch ($) {
                            case "confirmed":
                            case "single":
                            case "singleGossip":
                                {
                                    if (ht.confirmationStatus === "processed")
                                        return;
                                    break
                                }
                            case "finalized":
                            case "max":
                            case "root":
                                {
                                    if (ht.confirmationStatus === "processed" || ht.confirmationStatus === "confirmed")
                                        return;
                                    break
                                }
                            case "processed":
                            case "recent":
                            }
                            rt = !0,
                            st({
                                __type: TransactionStatus.PROCESSED,
                                response: {
                                    context: pt,
                                    value: ht
                                }
                            })
                        }
                }
                )()
            } catch (ct) {
                lt(ct)
            }
        }
        );
        return {
            abortConfirmation: () => {
                nt && (nt(),
                nt = void 0),
                tt != null && (this.removeSignatureListener(tt),
                tt = void 0)
            }
            ,
            confirmationPromise: it
        }
    }
    async confirmTransactionUsingBlockHeightExceedanceStrategy({commitment: $, strategy: {abortSignal: et, lastValidBlockHeight: tt, signature: nt}}) {
        let rt = !1;
        const it = new Promise(dt => {
            const pt = async () => {
                try {
                    return await this.getBlockHeight($)
                } catch {
                    return -1
                }
            }
            ;
            (async () => {
                let ht = await pt();
                if (!rt) {
                    for (; ht <= tt; )
                        if (await sleep(1e3),
                        rt || (ht = await pt(),
                        rt))
                            return;
                    dt({
                        __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED
                    })
                }
            }
            )()
        }
        )
          , {abortConfirmation: ot, confirmationPromise: st} = this.getTransactionConfirmationPromise({
            commitment: $,
            signature: nt
        })
          , lt = this.getCancellationPromise(et);
        let ct;
        try {
            const dt = await Promise.race([lt, st, it]);
            if (dt.__type === TransactionStatus.PROCESSED)
                ct = dt.response;
            else
                throw new TransactionExpiredBlockheightExceededError(nt)
        } finally {
            rt = !0,
            ot()
        }
        return ct
    }
    async confirmTransactionUsingDurableNonceStrategy({commitment: $, strategy: {abortSignal: et, minContextSlot: tt, nonceAccountPubkey: nt, nonceValue: rt, signature: it}}) {
        let ot = !1;
        const st = new Promise(ht => {
            let mt = rt
              , yt = null;
            const Et = async () => {
                try {
                    const {context: _t, value: wt} = await this.getNonceAndContext(nt, {
                        commitment: $,
                        minContextSlot: tt
                    });
                    return yt = _t.slot,
                    wt == null ? void 0 : wt.nonce
                } catch {
                    return mt
                }
            }
            ;
            (async () => {
                if (mt = await Et(),
                !ot)
                    for (; ; ) {
                        if (rt !== mt) {
                            ht({
                                __type: TransactionStatus.NONCE_INVALID,
                                slotInWhichNonceDidAdvance: yt
                            });
                            return
                        }
                        if (await sleep(2e3),
                        ot || (mt = await Et(),
                        ot))
                            return
                    }
            }
            )()
        }
        )
          , {abortConfirmation: lt, confirmationPromise: ct} = this.getTransactionConfirmationPromise({
            commitment: $,
            signature: it
        })
          , dt = this.getCancellationPromise(et);
        let pt;
        try {
            const ht = await Promise.race([dt, ct, st]);
            if (ht.__type === TransactionStatus.PROCESSED)
                pt = ht.response;
            else {
                let mt;
                for (; ; ) {
                    const yt = await this.getSignatureStatus(it);
                    if (yt == null)
                        break;
                    if (yt.context.slot < (ht.slotInWhichNonceDidAdvance ?? tt)) {
                        await sleep(400);
                        continue
                    }
                    mt = yt;
                    break
                }
                if (mt != null && mt.value) {
                    const yt = $ || "finalized"
                      , {confirmationStatus: Et} = mt.value;
                    switch (yt) {
                    case "processed":
                    case "recent":
                        if (Et !== "processed" && Et !== "confirmed" && Et !== "finalized")
                            throw new TransactionExpiredNonceInvalidError(it);
                        break;
                    case "confirmed":
                    case "single":
                    case "singleGossip":
                        if (Et !== "confirmed" && Et !== "finalized")
                            throw new TransactionExpiredNonceInvalidError(it);
                        break;
                    case "finalized":
                    case "max":
                    case "root":
                        if (Et !== "finalized")
                            throw new TransactionExpiredNonceInvalidError(it);
                        break;
                    default:
                    }
                    pt = {
                        context: mt.context,
                        value: {
                            err: mt.value.err
                        }
                    }
                } else
                    throw new TransactionExpiredNonceInvalidError(it)
            }
        } finally {
            ot = !0,
            lt()
        }
        return pt
    }
    async confirmTransactionUsingLegacyTimeoutStrategy({commitment: $, signature: et}) {
        let tt;
        const nt = new Promise(st => {
            let lt = this._confirmTransactionInitialTimeout || 6e4;
            switch ($) {
            case "processed":
            case "recent":
            case "single":
            case "confirmed":
            case "singleGossip":
                {
                    lt = this._confirmTransactionInitialTimeout || 3e4;
                    break
                }
            }
            tt = setTimeout( () => st({
                __type: TransactionStatus.TIMED_OUT,
                timeoutMs: lt
            }), lt)
        }
        )
          , {abortConfirmation: rt, confirmationPromise: it} = this.getTransactionConfirmationPromise({
            commitment: $,
            signature: et
        });
        let ot;
        try {
            const st = await Promise.race([it, nt]);
            if (st.__type === TransactionStatus.PROCESSED)
                ot = st.response;
            else
                throw new TransactionExpiredTimeoutError(et,st.timeoutMs / 1e3)
        } finally {
            clearTimeout(tt),
            rt()
        }
        return ot
    }
    async getClusterNodes() {
        const $ = await this._rpcRequest("getClusterNodes", [])
          , et = create$4($, jsonRpcResult$1(array$2(ContactInfoResult)));
        if ("error"in et)
            throw new SolanaJSONRPCError(et.error,"failed to get cluster nodes");
        return et.result
    }
    async getVoteAccounts($) {
        const et = this._buildArgs([], $)
          , tt = await this._rpcRequest("getVoteAccounts", et)
          , nt = create$4(tt, GetVoteAccounts);
        if ("error"in nt)
            throw new SolanaJSONRPCError(nt.error,"failed to get vote accounts");
        return nt.result
    }
    async getSlot($) {
        const {commitment: et, config: tt} = extractCommitmentFromConfig($)
          , nt = this._buildArgs([], et, void 0, tt)
          , rt = await this._rpcRequest("getSlot", nt)
          , it = create$4(rt, jsonRpcResult$1(number$3()));
        if ("error"in it)
            throw new SolanaJSONRPCError(it.error,"failed to get slot");
        return it.result
    }
    async getSlotLeader($) {
        const {commitment: et, config: tt} = extractCommitmentFromConfig($)
          , nt = this._buildArgs([], et, void 0, tt)
          , rt = await this._rpcRequest("getSlotLeader", nt)
          , it = create$4(rt, jsonRpcResult$1(string$2()));
        if ("error"in it)
            throw new SolanaJSONRPCError(it.error,"failed to get slot leader");
        return it.result
    }
    async getSlotLeaders($, et) {
        const tt = [$, et]
          , nt = await this._rpcRequest("getSlotLeaders", tt)
          , rt = create$4(nt, jsonRpcResult$1(array$2(PublicKeyFromString)));
        if ("error"in rt)
            throw new SolanaJSONRPCError(rt.error,"failed to get slot leaders");
        return rt.result
    }
    async getSignatureStatus($, et) {
        const {context: tt, value: nt} = await this.getSignatureStatuses([$], et);
        assert$1(nt.length === 1);
        const rt = nt[0];
        return {
            context: tt,
            value: rt
        }
    }
    async getSignatureStatuses($, et) {
        const tt = [$];
        et && tt.push(et);
        const nt = await this._rpcRequest("getSignatureStatuses", tt)
          , rt = create$4(nt, GetSignatureStatusesRpcResult);
        if ("error"in rt)
            throw new SolanaJSONRPCError(rt.error,"failed to get signature status");
        return rt.result
    }
    async getTransactionCount($) {
        const {commitment: et, config: tt} = extractCommitmentFromConfig($)
          , nt = this._buildArgs([], et, void 0, tt)
          , rt = await this._rpcRequest("getTransactionCount", nt)
          , it = create$4(rt, jsonRpcResult$1(number$3()));
        if ("error"in it)
            throw new SolanaJSONRPCError(it.error,"failed to get transaction count");
        return it.result
    }
    async getTotalSupply($) {
        return (await this.getSupply({
            commitment: $,
            excludeNonCirculatingAccountsList: !0
        })).value.total
    }
    async getInflationGovernor($) {
        const et = this._buildArgs([], $)
          , tt = await this._rpcRequest("getInflationGovernor", et)
          , nt = create$4(tt, GetInflationGovernorRpcResult);
        if ("error"in nt)
            throw new SolanaJSONRPCError(nt.error,"failed to get inflation");
        return nt.result
    }
    async getInflationReward($, et, tt) {
        const {commitment: nt, config: rt} = extractCommitmentFromConfig(tt)
          , it = this._buildArgs([$.map(lt => lt.toBase58())], nt, void 0, {
            ...rt,
            epoch: et ?? (rt == null ? void 0 : rt.epoch)
        })
          , ot = await this._rpcRequest("getInflationReward", it)
          , st = create$4(ot, GetInflationRewardResult);
        if ("error"in st)
            throw new SolanaJSONRPCError(st.error,"failed to get inflation reward");
        return st.result
    }
    async getInflationRate() {
        const $ = await this._rpcRequest("getInflationRate", [])
          , et = create$4($, GetInflationRateRpcResult);
        if ("error"in et)
            throw new SolanaJSONRPCError(et.error,"failed to get inflation rate");
        return et.result
    }
    async getEpochInfo($) {
        const {commitment: et, config: tt} = extractCommitmentFromConfig($)
          , nt = this._buildArgs([], et, void 0, tt)
          , rt = await this._rpcRequest("getEpochInfo", nt)
          , it = create$4(rt, GetEpochInfoRpcResult);
        if ("error"in it)
            throw new SolanaJSONRPCError(it.error,"failed to get epoch info");
        return it.result
    }
    async getEpochSchedule() {
        const $ = await this._rpcRequest("getEpochSchedule", [])
          , et = create$4($, GetEpochScheduleRpcResult);
        if ("error"in et)
            throw new SolanaJSONRPCError(et.error,"failed to get epoch schedule");
        const tt = et.result;
        return new EpochSchedule(tt.slotsPerEpoch,tt.leaderScheduleSlotOffset,tt.warmup,tt.firstNormalEpoch,tt.firstNormalSlot)
    }
    async getLeaderSchedule() {
        const $ = await this._rpcRequest("getLeaderSchedule", [])
          , et = create$4($, GetLeaderScheduleRpcResult);
        if ("error"in et)
            throw new SolanaJSONRPCError(et.error,"failed to get leader schedule");
        return et.result
    }
    async getMinimumBalanceForRentExemption($, et) {
        const tt = this._buildArgs([$], et)
          , nt = await this._rpcRequest("getMinimumBalanceForRentExemption", tt)
          , rt = create$4(nt, GetMinimumBalanceForRentExemptionRpcResult);
        return "error"in rt ? 0 : rt.result
    }
    async getRecentBlockhashAndContext($) {
        const {context: et, value: {blockhash: tt}} = await this.getLatestBlockhashAndContext($);
        return {
            context: et,
            value: {
                blockhash: tt,
                feeCalculator: {
                    get lamportsPerSignature() {
                        throw new Error("The capability to fetch `lamportsPerSignature` using the `getRecentBlockhash` API is no longer offered by the network. Use the `getFeeForMessage` API to obtain the fee for a given message.")
                    },
                    toJSON() {
                        return {}
                    }
                }
            }
        }
    }
    async getRecentPerformanceSamples($) {
        const et = await this._rpcRequest("getRecentPerformanceSamples", $ ? [$] : [])
          , tt = create$4(et, GetRecentPerformanceSamplesRpcResult);
        if ("error"in tt)
            throw new SolanaJSONRPCError(tt.error,"failed to get recent performance samples");
        return tt.result
    }
    async getFeeCalculatorForBlockhash($, et) {
        const tt = this._buildArgs([$], et)
          , nt = await this._rpcRequest("getFeeCalculatorForBlockhash", tt)
          , rt = create$4(nt, GetFeeCalculatorRpcResult);
        if ("error"in rt)
            throw new SolanaJSONRPCError(rt.error,"failed to get fee calculator");
        const {context: it, value: ot} = rt.result;
        return {
            context: it,
            value: ot !== null ? ot.feeCalculator : null
        }
    }
    async getFeeForMessage($, et) {
        const tt = toBuffer($.serialize()).toString("base64")
          , nt = this._buildArgs([tt], et)
          , rt = await this._rpcRequest("getFeeForMessage", nt)
          , it = create$4(rt, jsonRpcResultAndContext$1(nullable$1(number$3())));
        if ("error"in it)
            throw new SolanaJSONRPCError(it.error,"failed to get fee for message");
        if (it.result === null)
            throw new Error("invalid blockhash");
        return it.result
    }
    async getRecentPrioritizationFees($) {
        var it;
        const et = (it = $ == null ? void 0 : $.lockedWritableAccounts) == null ? void 0 : it.map(ot => ot.toBase58())
          , tt = et != null && et.length ? [et] : []
          , nt = await this._rpcRequest("getRecentPrioritizationFees", tt)
          , rt = create$4(nt, GetRecentPrioritizationFeesRpcResult);
        if ("error"in rt)
            throw new SolanaJSONRPCError(rt.error,"failed to get recent prioritization fees");
        return rt.result
    }
    async getRecentBlockhash($) {
        try {
            return (await this.getRecentBlockhashAndContext($)).value
        } catch (et) {
            throw new Error("failed to get recent blockhash: " + et)
        }
    }
    async getLatestBlockhash($) {
        try {
            return (await this.getLatestBlockhashAndContext($)).value
        } catch (et) {
            throw new Error("failed to get recent blockhash: " + et)
        }
    }
    async getLatestBlockhashAndContext($) {
        const {commitment: et, config: tt} = extractCommitmentFromConfig($)
          , nt = this._buildArgs([], et, void 0, tt)
          , rt = await this._rpcRequest("getLatestBlockhash", nt)
          , it = create$4(rt, GetLatestBlockhashRpcResult);
        if ("error"in it)
            throw new SolanaJSONRPCError(it.error,"failed to get latest blockhash");
        return it.result
    }
    async isBlockhashValid($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , rt = this._buildArgs([$], tt, void 0, nt)
          , it = await this._rpcRequest("isBlockhashValid", rt)
          , ot = create$4(it, IsBlockhashValidRpcResult);
        if ("error"in ot)
            throw new SolanaJSONRPCError(ot.error,"failed to determine if the blockhash `" + $ + "`is valid");
        return ot.result
    }
    async getVersion() {
        const $ = await this._rpcRequest("getVersion", [])
          , et = create$4($, jsonRpcResult$1(VersionResult));
        if ("error"in et)
            throw new SolanaJSONRPCError(et.error,"failed to get version");
        return et.result
    }
    async getGenesisHash() {
        const $ = await this._rpcRequest("getGenesisHash", [])
          , et = create$4($, jsonRpcResult$1(string$2()));
        if ("error"in et)
            throw new SolanaJSONRPCError(et.error,"failed to get genesis hash");
        return et.result
    }
    async getBlock($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , rt = this._buildArgsAtLeastConfirmed([$], tt, void 0, nt)
          , it = await this._rpcRequest("getBlock", rt);
        try {
            switch (nt == null ? void 0 : nt.transactionDetails) {
            case "accounts":
                {
                    const ot = create$4(it, GetAccountsModeBlockRpcResult);
                    if ("error"in ot)
                        throw ot.error;
                    return ot.result
                }
            case "none":
                {
                    const ot = create$4(it, GetNoneModeBlockRpcResult);
                    if ("error"in ot)
                        throw ot.error;
                    return ot.result
                }
            default:
                {
                    const ot = create$4(it, GetBlockRpcResult);
                    if ("error"in ot)
                        throw ot.error;
                    const {result: st} = ot;
                    return st ? {
                        ...st,
                        transactions: st.transactions.map( ({transaction: lt, meta: ct, version: dt}) => ({
                            meta: ct,
                            transaction: {
                                ...lt,
                                message: versionedMessageFromResponse(dt, lt.message)
                            },
                            version: dt
                        }))
                    } : null
                }
            }
        } catch (ot) {
            throw new SolanaJSONRPCError(ot,"failed to get confirmed block")
        }
    }
    async getParsedBlock($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , rt = this._buildArgsAtLeastConfirmed([$], tt, "jsonParsed", nt)
          , it = await this._rpcRequest("getBlock", rt);
        try {
            switch (nt == null ? void 0 : nt.transactionDetails) {
            case "accounts":
                {
                    const ot = create$4(it, GetParsedAccountsModeBlockRpcResult);
                    if ("error"in ot)
                        throw ot.error;
                    return ot.result
                }
            case "none":
                {
                    const ot = create$4(it, GetParsedNoneModeBlockRpcResult);
                    if ("error"in ot)
                        throw ot.error;
                    return ot.result
                }
            default:
                {
                    const ot = create$4(it, GetParsedBlockRpcResult);
                    if ("error"in ot)
                        throw ot.error;
                    return ot.result
                }
            }
        } catch (ot) {
            throw new SolanaJSONRPCError(ot,"failed to get block")
        }
    }
    async getBlockProduction($) {
        let et, tt;
        if (typeof $ == "string")
            tt = $;
        else if ($) {
            const {commitment: ot, ...st} = $;
            tt = ot,
            et = st
        }
        const nt = this._buildArgs([], tt, "base64", et)
          , rt = await this._rpcRequest("getBlockProduction", nt)
          , it = create$4(rt, BlockProductionResponseStruct);
        if ("error"in it)
            throw new SolanaJSONRPCError(it.error,"failed to get block production information");
        return it.result
    }
    async getTransaction($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , rt = this._buildArgsAtLeastConfirmed([$], tt, void 0, nt)
          , it = await this._rpcRequest("getTransaction", rt)
          , ot = create$4(it, GetTransactionRpcResult);
        if ("error"in ot)
            throw new SolanaJSONRPCError(ot.error,"failed to get transaction");
        const st = ot.result;
        return st && {
            ...st,
            transaction: {
                ...st.transaction,
                message: versionedMessageFromResponse(st.version, st.transaction.message)
            }
        }
    }
    async getParsedTransaction($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , rt = this._buildArgsAtLeastConfirmed([$], tt, "jsonParsed", nt)
          , it = await this._rpcRequest("getTransaction", rt)
          , ot = create$4(it, GetParsedTransactionRpcResult);
        if ("error"in ot)
            throw new SolanaJSONRPCError(ot.error,"failed to get transaction");
        return ot.result
    }
    async getParsedTransactions($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , rt = $.map(st => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([st], tt, "jsonParsed", nt)
        }));
        return (await this._rpcBatchRequest(rt)).map(st => {
            const lt = create$4(st, GetParsedTransactionRpcResult);
            if ("error"in lt)
                throw new SolanaJSONRPCError(lt.error,"failed to get transactions");
            return lt.result
        }
        )
    }
    async getTransactions($, et) {
        const {commitment: tt, config: nt} = extractCommitmentFromConfig(et)
          , rt = $.map(st => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([st], tt, void 0, nt)
        }));
        return (await this._rpcBatchRequest(rt)).map(st => {
            const lt = create$4(st, GetTransactionRpcResult);
            if ("error"in lt)
                throw new SolanaJSONRPCError(lt.error,"failed to get transactions");
            const ct = lt.result;
            return ct && {
                ...ct,
                transaction: {
                    ...ct.transaction,
                    message: versionedMessageFromResponse(ct.version, ct.transaction.message)
                }
            }
        }
        )
    }
    async getConfirmedBlock($, et) {
        const tt = this._buildArgsAtLeastConfirmed([$], et)
          , nt = await this._rpcRequest("getBlock", tt)
          , rt = create$4(nt, GetConfirmedBlockRpcResult);
        if ("error"in rt)
            throw new SolanaJSONRPCError(rt.error,"failed to get confirmed block");
        const it = rt.result;
        if (!it)
            throw new Error("Confirmed block " + $ + " not found");
        const ot = {
            ...it,
            transactions: it.transactions.map( ({transaction: st, meta: lt}) => {
                const ct = new Message(st.message);
                return {
                    meta: lt,
                    transaction: {
                        ...st,
                        message: ct
                    }
                }
            }
            )
        };
        return {
            ...ot,
            transactions: ot.transactions.map( ({transaction: st, meta: lt}) => ({
                meta: lt,
                transaction: Transaction.populate(st.message, st.signatures)
            }))
        }
    }
    async getBlocks($, et, tt) {
        const nt = this._buildArgsAtLeastConfirmed(et !== void 0 ? [$, et] : [$], tt)
          , rt = await this._rpcRequest("getBlocks", nt)
          , it = create$4(rt, jsonRpcResult$1(array$2(number$3())));
        if ("error"in it)
            throw new SolanaJSONRPCError(it.error,"failed to get blocks");
        return it.result
    }
    async getBlockSignatures($, et) {
        const tt = this._buildArgsAtLeastConfirmed([$], et, void 0, {
            transactionDetails: "signatures",
            rewards: !1
        })
          , nt = await this._rpcRequest("getBlock", tt)
          , rt = create$4(nt, GetBlockSignaturesRpcResult);
        if ("error"in rt)
            throw new SolanaJSONRPCError(rt.error,"failed to get block");
        const it = rt.result;
        if (!it)
            throw new Error("Block " + $ + " not found");
        return it
    }
    async getConfirmedBlockSignatures($, et) {
        const tt = this._buildArgsAtLeastConfirmed([$], et, void 0, {
            transactionDetails: "signatures",
            rewards: !1
        })
          , nt = await this._rpcRequest("getBlock", tt)
          , rt = create$4(nt, GetBlockSignaturesRpcResult);
        if ("error"in rt)
            throw new SolanaJSONRPCError(rt.error,"failed to get confirmed block");
        const it = rt.result;
        if (!it)
            throw new Error("Confirmed block " + $ + " not found");
        return it
    }
    async getConfirmedTransaction($, et) {
        const tt = this._buildArgsAtLeastConfirmed([$], et)
          , nt = await this._rpcRequest("getTransaction", tt)
          , rt = create$4(nt, GetTransactionRpcResult);
        if ("error"in rt)
            throw new SolanaJSONRPCError(rt.error,"failed to get transaction");
        const it = rt.result;
        if (!it)
            return it;
        const ot = new Message(it.transaction.message)
          , st = it.transaction.signatures;
        return {
            ...it,
            transaction: Transaction.populate(ot, st)
        }
    }
    async getParsedConfirmedTransaction($, et) {
        const tt = this._buildArgsAtLeastConfirmed([$], et, "jsonParsed")
          , nt = await this._rpcRequest("getTransaction", tt)
          , rt = create$4(nt, GetParsedTransactionRpcResult);
        if ("error"in rt)
            throw new SolanaJSONRPCError(rt.error,"failed to get confirmed transaction");
        return rt.result
    }
    async getParsedConfirmedTransactions($, et) {
        const tt = $.map(it => ({
            methodName: "getTransaction",
            args: this._buildArgsAtLeastConfirmed([it], et, "jsonParsed")
        }));
        return (await this._rpcBatchRequest(tt)).map(it => {
            const ot = create$4(it, GetParsedTransactionRpcResult);
            if ("error"in ot)
                throw new SolanaJSONRPCError(ot.error,"failed to get confirmed transactions");
            return ot.result
        }
        )
    }
    async getConfirmedSignaturesForAddress($, et, tt) {
        let nt = {}
          , rt = await this.getFirstAvailableBlock();
        for (; !("until"in nt) && (et--,
        !(et <= 0 || et < rt)); )
            try {
                const st = await this.getConfirmedBlockSignatures(et, "finalized");
                st.signatures.length > 0 && (nt.until = st.signatures[st.signatures.length - 1].toString())
            } catch (st) {
                if (st instanceof Error && st.message.includes("skipped"))
                    continue;
                throw st
            }
        let it = await this.getSlot("finalized");
        for (; !("before"in nt) && (tt++,
        !(tt > it)); )
            try {
                const st = await this.getConfirmedBlockSignatures(tt);
                st.signatures.length > 0 && (nt.before = st.signatures[st.signatures.length - 1].toString())
            } catch (st) {
                if (st instanceof Error && st.message.includes("skipped"))
                    continue;
                throw st
            }
        return (await this.getConfirmedSignaturesForAddress2($, nt)).map(st => st.signature)
    }
    async getConfirmedSignaturesForAddress2($, et, tt) {
        const nt = this._buildArgsAtLeastConfirmed([$.toBase58()], tt, void 0, et)
          , rt = await this._rpcRequest("getConfirmedSignaturesForAddress2", nt)
          , it = create$4(rt, GetConfirmedSignaturesForAddress2RpcResult);
        if ("error"in it)
            throw new SolanaJSONRPCError(it.error,"failed to get confirmed signatures for address");
        return it.result
    }
    async getSignaturesForAddress($, et, tt) {
        const nt = this._buildArgsAtLeastConfirmed([$.toBase58()], tt, void 0, et)
          , rt = await this._rpcRequest("getSignaturesForAddress", nt)
          , it = create$4(rt, GetSignaturesForAddressRpcResult);
        if ("error"in it)
            throw new SolanaJSONRPCError(it.error,"failed to get signatures for address");
        return it.result
    }
    async getAddressLookupTable($, et) {
        const {context: tt, value: nt} = await this.getAccountInfoAndContext($, et);
        let rt = null;
        return nt !== null && (rt = new AddressLookupTableAccount({
            key: $,
            state: AddressLookupTableAccount.deserialize(nt.data)
        })),
        {
            context: tt,
            value: rt
        }
    }
    async getNonceAndContext($, et) {
        const {context: tt, value: nt} = await this.getAccountInfoAndContext($, et);
        let rt = null;
        return nt !== null && (rt = NonceAccount.fromAccountData(nt.data)),
        {
            context: tt,
            value: rt
        }
    }
    async getNonce($, et) {
        return await this.getNonceAndContext($, et).then(tt => tt.value).catch(tt => {
            throw new Error("failed to get nonce for account " + $.toBase58() + ": " + tt)
        }
        )
    }
    async requestAirdrop($, et) {
        const tt = await this._rpcRequest("requestAirdrop", [$.toBase58(), et])
          , nt = create$4(tt, RequestAirdropRpcResult);
        if ("error"in nt)
            throw new SolanaJSONRPCError(nt.error,`airdrop to ${$.toBase58()} failed`);
        return nt.result
    }
    async _blockhashWithExpiryBlockHeight($) {
        if (!$) {
            for (; this._pollingBlockhash; )
                await sleep(100);
            const tt = Date.now() - this._blockhashInfo.lastFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;
            if (this._blockhashInfo.latestBlockhash !== null && !tt)
                return this._blockhashInfo.latestBlockhash
        }
        return await this._pollNewBlockhash()
    }
    async _pollNewBlockhash() {
        this._pollingBlockhash = !0;
        try {
            const $ = Date.now()
              , et = this._blockhashInfo.latestBlockhash
              , tt = et ? et.blockhash : null;
            for (let nt = 0; nt < 50; nt++) {
                const rt = await this.getLatestBlockhash("finalized");
                if (tt !== rt.blockhash)
                    return this._blockhashInfo = {
                        latestBlockhash: rt,
                        lastFetch: Date.now(),
                        transactionSignatures: [],
                        simulatedSignatures: []
                    },
                    rt;
                await sleep(MS_PER_SLOT / 2)
            }
            throw new Error(`Unable to obtain a new blockhash after ${Date.now() - $}ms`)
        } finally {
            this._pollingBlockhash = !1
        }
    }
    async getStakeMinimumDelegation($) {
        const {commitment: et, config: tt} = extractCommitmentFromConfig($)
          , nt = this._buildArgs([], et, "base64", tt)
          , rt = await this._rpcRequest("getStakeMinimumDelegation", nt)
          , it = create$4(rt, jsonRpcResultAndContext$1(number$3()));
        if ("error"in it)
            throw new SolanaJSONRPCError(it.error,"failed to get stake minimum delegation");
        return it.result
    }
    async simulateTransaction($, et, tt) {
        if ("message"in $) {
            const yt = $.serialize()
              , Et = Buffer$1$1.from(yt).toString("base64");
            if (Array.isArray(et) || tt !== void 0)
                throw new Error("Invalid arguments");
            const _t = et || {};
            _t.encoding = "base64",
            "commitment"in _t || (_t.commitment = this.commitment),
            et && typeof et == "object" && "innerInstructions"in et && (_t.innerInstructions = et.innerInstructions);
            const wt = [Et, _t]
              , St = await this._rpcRequest("simulateTransaction", wt)
              , Ct = create$4(St, SimulatedTransactionResponseStruct$1);
            if ("error"in Ct)
                throw new Error("failed to simulate transaction: " + Ct.error.message);
            return Ct.result
        }
        let nt;
        if ($ instanceof Transaction) {
            let mt = $;
            nt = new Transaction,
            nt.feePayer = mt.feePayer,
            nt.instructions = $.instructions,
            nt.nonceInfo = mt.nonceInfo,
            nt.signatures = mt.signatures
        } else
            nt = Transaction.populate($),
            nt._message = nt._json = void 0;
        if (et !== void 0 && !Array.isArray(et))
            throw new Error("Invalid arguments");
        const rt = et;
        if (nt.nonceInfo && rt)
            nt.sign(...rt);
        else {
            let mt = this._disableBlockhashCaching;
            for (; ; ) {
                const yt = await this._blockhashWithExpiryBlockHeight(mt);
                if (nt.lastValidBlockHeight = yt.lastValidBlockHeight,
                nt.recentBlockhash = yt.blockhash,
                !rt)
                    break;
                if (nt.sign(...rt),
                !nt.signature)
                    throw new Error("!signature");
                const Et = nt.signature.toString("base64");
                if (!this._blockhashInfo.simulatedSignatures.includes(Et) && !this._blockhashInfo.transactionSignatures.includes(Et)) {
                    this._blockhashInfo.simulatedSignatures.push(Et);
                    break
                } else
                    mt = !0
            }
        }
        const it = nt._compile()
          , ot = it.serialize()
          , lt = nt._serialize(ot).toString("base64")
          , ct = {
            encoding: "base64",
            commitment: this.commitment
        };
        if (tt) {
            const mt = (Array.isArray(tt) ? tt : it.nonProgramIds()).map(yt => yt.toBase58());
            ct.accounts = {
                encoding: "base64",
                addresses: mt
            }
        }
        rt && (ct.sigVerify = !0),
        et && typeof et == "object" && "innerInstructions"in et && (ct.innerInstructions = et.innerInstructions);
        const dt = [lt, ct]
          , pt = await this._rpcRequest("simulateTransaction", dt)
          , ht = create$4(pt, SimulatedTransactionResponseStruct$1);
        if ("error"in ht) {
            let mt;
            if ("data"in ht.error && (mt = ht.error.data.logs,
            mt && Array.isArray(mt))) {
                const yt = `
    `
                  , Et = yt + mt.join(yt)
            }
            throw new SendTransactionError({
                action: "simulate",
                signature: "",
                transactionMessage: ht.error.message,
                logs: mt
            })
        }
        return ht.result
    }
    async sendTransaction($, et, tt) {
        if ("version"in $) {
            if (et && Array.isArray(et))
                throw new Error("Invalid arguments");
            const it = $.serialize();
            return await this.sendRawTransaction(it, et)
        }
        if (et === void 0 || !Array.isArray(et))
            throw new Error("Invalid arguments");
        const nt = et;
        if ($.nonceInfo)
            $.sign(...nt);
        else {
            let it = this._disableBlockhashCaching;
            for (; ; ) {
                const ot = await this._blockhashWithExpiryBlockHeight(it);
                if ($.lastValidBlockHeight = ot.lastValidBlockHeight,
                $.recentBlockhash = ot.blockhash,
                $.sign(...nt),
                !$.signature)
                    throw new Error("!signature");
                const st = $.signature.toString("base64");
                if (this._blockhashInfo.transactionSignatures.includes(st))
                    it = !0;
                else {
                    this._blockhashInfo.transactionSignatures.push(st);
                    break
                }
            }
        }
        const rt = $.serialize();
        return await this.sendRawTransaction(rt, tt)
    }
    async sendRawTransaction($, et) {
        const tt = toBuffer($).toString("base64");
        return await this.sendEncodedTransaction(tt, et)
    }
    async sendEncodedTransaction($, et) {
        const tt = {
            encoding: "base64"
        }
          , nt = et && et.skipPreflight
          , rt = nt === !0 ? "processed" : et && et.preflightCommitment || this.commitment;
        et && et.maxRetries != null && (tt.maxRetries = et.maxRetries),
        et && et.minContextSlot != null && (tt.minContextSlot = et.minContextSlot),
        nt && (tt.skipPreflight = nt),
        rt && (tt.preflightCommitment = rt);
        const it = [$, tt]
          , ot = await this._rpcRequest("sendTransaction", it)
          , st = create$4(ot, SendTransactionRpcResult);
        if ("error"in st) {
            let lt;
            throw "data"in st.error && (lt = st.error.data.logs),
            new SendTransactionError({
                action: nt ? "send" : "simulate",
                signature: "",
                transactionMessage: st.error.message,
                logs: lt
            })
        }
        return st.result
    }
    _wsOnOpen() {
        this._rpcWebSocketConnected = !0,
        this._rpcWebSocketHeartbeat = setInterval( () => {
            (async () => {
                try {
                    await this._rpcWebSocket.notify("ping")
                } catch {}
            }
            )()
        }
        , 5e3),
        this._updateSubscriptions()
    }
    _wsOnError($) {
        this._rpcWebSocketConnected = !1
    }
    _wsOnClose($) {
        if (this._rpcWebSocketConnected = !1,
        this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER,
        this._rpcWebSocketIdleTimeout && (clearTimeout(this._rpcWebSocketIdleTimeout),
        this._rpcWebSocketIdleTimeout = null),
        this._rpcWebSocketHeartbeat && (clearInterval(this._rpcWebSocketHeartbeat),
        this._rpcWebSocketHeartbeat = null),
        $ === 1e3) {
            this._updateSubscriptions();
            return
        }
        this._subscriptionCallbacksByServerSubscriptionId = {},
        Object.entries(this._subscriptionsByHash).forEach( ([et,tt]) => {
            this._setSubscription(et, {
                ...tt,
                state: "pending"
            })
        }
        )
    }
    _setSubscription($, et) {
        var nt;
        const tt = (nt = this._subscriptionsByHash[$]) == null ? void 0 : nt.state;
        if (this._subscriptionsByHash[$] = et,
        tt !== et.state) {
            const rt = this._subscriptionStateChangeCallbacksByHash[$];
            rt && rt.forEach(it => {
                try {
                    it(et.state)
                } catch {}
            }
            )
        }
    }
    _onSubscriptionStateChange($, et) {
        var rt;
        const tt = this._subscriptionHashByClientSubscriptionId[$];
        if (tt == null)
            return () => {}
            ;
        const nt = (rt = this._subscriptionStateChangeCallbacksByHash)[tt] || (rt[tt] = new Set);
        return nt.add(et),
        () => {
            nt.delete(et),
            nt.size === 0 && delete this._subscriptionStateChangeCallbacksByHash[tt]
        }
    }
    async _updateSubscriptions() {
        if (Object.keys(this._subscriptionsByHash).length === 0) {
            this._rpcWebSocketConnected && (this._rpcWebSocketConnected = !1,
            this._rpcWebSocketIdleTimeout = setTimeout( () => {
                this._rpcWebSocketIdleTimeout = null;
                try {
                    this._rpcWebSocket.close()
                } catch (tt) {
                    tt instanceof Error
                }
            }
            , 500));
            return
        }
        if (this._rpcWebSocketIdleTimeout !== null && (clearTimeout(this._rpcWebSocketIdleTimeout),
        this._rpcWebSocketIdleTimeout = null,
        this._rpcWebSocketConnected = !0),
        !this._rpcWebSocketConnected) {
            this._rpcWebSocket.connect();
            return
        }
        const $ = this._rpcWebSocketGeneration
          , et = () => $ === this._rpcWebSocketGeneration;
        await Promise.all(Object.keys(this._subscriptionsByHash).map(async tt => {
            const nt = this._subscriptionsByHash[tt];
            if (nt !== void 0)
                switch (nt.state) {
                case "pending":
                case "unsubscribed":
                    if (nt.callbacks.size === 0) {
                        delete this._subscriptionsByHash[tt],
                        nt.state === "unsubscribed" && delete this._subscriptionCallbacksByServerSubscriptionId[nt.serverSubscriptionId],
                        await this._updateSubscriptions();
                        return
                    }
                    await (async () => {
                        const {args: rt, method: it} = nt;
                        try {
                            this._setSubscription(tt, {
                                ...nt,
                                state: "subscribing"
                            });
                            const ot = await this._rpcWebSocket.call(it, rt);
                            this._setSubscription(tt, {
                                ...nt,
                                serverSubscriptionId: ot,
                                state: "subscribed"
                            }),
                            this._subscriptionCallbacksByServerSubscriptionId[ot] = nt.callbacks,
                            await this._updateSubscriptions()
                        } catch {
                            if (!et())
                                return;
                            this._setSubscription(tt, {
                                ...nt,
                                state: "pending"
                            }),
                            await this._updateSubscriptions()
                        }
                    }
                    )();
                    break;
                case "subscribed":
                    nt.callbacks.size === 0 && await (async () => {
                        const {serverSubscriptionId: rt, unsubscribeMethod: it} = nt;
                        if (this._subscriptionsAutoDisposedByRpc.has(rt))
                            this._subscriptionsAutoDisposedByRpc.delete(rt);
                        else {
                            this._setSubscription(tt, {
                                ...nt,
                                state: "unsubscribing"
                            }),
                            this._setSubscription(tt, {
                                ...nt,
                                state: "unsubscribing"
                            });
                            try {
                                await this._rpcWebSocket.call(it, [rt])
                            } catch (ot) {
                                if (ot instanceof Error,
                                !et())
                                    return;
                                this._setSubscription(tt, {
                                    ...nt,
                                    state: "subscribed"
                                }),
                                await this._updateSubscriptions();
                                return
                            }
                        }
                        this._setSubscription(tt, {
                            ...nt,
                            state: "unsubscribed"
                        }),
                        await this._updateSubscriptions()
                    }
                    )();
                    break
                }
        }
        ))
    }
    _handleServerNotification($, et) {
        const tt = this._subscriptionCallbacksByServerSubscriptionId[$];
        tt !== void 0 && tt.forEach(nt => {
            try {
                nt(...et)
            } catch {}
        }
        )
    }
    _wsOnAccountNotification($) {
        const {result: et, subscription: tt} = create$4($, AccountNotificationResult);
        this._handleServerNotification(tt, [et.value, et.context])
    }
    _makeSubscription($, et) {
        const tt = this._nextClientSubscriptionId++
          , nt = fastStableStringify([$.method, et])
          , rt = this._subscriptionsByHash[nt];
        return rt === void 0 ? this._subscriptionsByHash[nt] = {
            ...$,
            args: et,
            callbacks: new Set([$.callback]),
            state: "pending"
        } : rt.callbacks.add($.callback),
        this._subscriptionHashByClientSubscriptionId[tt] = nt,
        this._subscriptionDisposeFunctionsByClientSubscriptionId[tt] = async () => {
            delete this._subscriptionDisposeFunctionsByClientSubscriptionId[tt],
            delete this._subscriptionHashByClientSubscriptionId[tt];
            const it = this._subscriptionsByHash[nt];
            assert$1(it !== void 0, `Could not find a \`Subscription\` when tearing down client subscription #${tt}`),
            it.callbacks.delete($.callback),
            await this._updateSubscriptions()
        }
        ,
        this._updateSubscriptions(),
        tt
    }
    onAccountChange($, et, tt) {
        const {commitment: nt, config: rt} = extractCommitmentFromConfig(tt)
          , it = this._buildArgs([$.toBase58()], nt || this._commitment || "finalized", "base64", rt);
        return this._makeSubscription({
            callback: et,
            method: "accountSubscribe",
            unsubscribeMethod: "accountUnsubscribe"
        }, it)
    }
    async removeAccountChangeListener($) {
        await this._unsubscribeClientSubscription($, "account change")
    }
    _wsOnProgramAccountNotification($) {
        const {result: et, subscription: tt} = create$4($, ProgramAccountNotificationResult);
        this._handleServerNotification(tt, [{
            accountId: et.value.pubkey,
            accountInfo: et.value.account
        }, et.context])
    }
    onProgramAccountChange($, et, tt, nt) {
        const {commitment: rt, config: it} = extractCommitmentFromConfig(tt)
          , ot = this._buildArgs([$.toBase58()], rt || this._commitment || "finalized", "base64", it || (nt ? {
            filters: applyDefaultMemcmpEncodingToFilters(nt)
        } : void 0));
        return this._makeSubscription({
            callback: et,
            method: "programSubscribe",
            unsubscribeMethod: "programUnsubscribe"
        }, ot)
    }
    async removeProgramAccountChangeListener($) {
        await this._unsubscribeClientSubscription($, "program account change")
    }
    onLogs($, et, tt) {
        const nt = this._buildArgs([typeof $ == "object" ? {
            mentions: [$.toString()]
        } : $], tt || this._commitment || "finalized");
        return this._makeSubscription({
            callback: et,
            method: "logsSubscribe",
            unsubscribeMethod: "logsUnsubscribe"
        }, nt)
    }
    async removeOnLogsListener($) {
        await this._unsubscribeClientSubscription($, "logs")
    }
    _wsOnLogsNotification($) {
        const {result: et, subscription: tt} = create$4($, LogsNotificationResult);
        this._handleServerNotification(tt, [et.value, et.context])
    }
    _wsOnSlotNotification($) {
        const {result: et, subscription: tt} = create$4($, SlotNotificationResult);
        this._handleServerNotification(tt, [et])
    }
    onSlotChange($) {
        return this._makeSubscription({
            callback: $,
            method: "slotSubscribe",
            unsubscribeMethod: "slotUnsubscribe"
        }, [])
    }
    async removeSlotChangeListener($) {
        await this._unsubscribeClientSubscription($, "slot change")
    }
    _wsOnSlotUpdatesNotification($) {
        const {result: et, subscription: tt} = create$4($, SlotUpdateNotificationResult);
        this._handleServerNotification(tt, [et])
    }
    onSlotUpdate($) {
        return this._makeSubscription({
            callback: $,
            method: "slotsUpdatesSubscribe",
            unsubscribeMethod: "slotsUpdatesUnsubscribe"
        }, [])
    }
    async removeSlotUpdateListener($) {
        await this._unsubscribeClientSubscription($, "slot update")
    }
    async _unsubscribeClientSubscription($, et) {
        const tt = this._subscriptionDisposeFunctionsByClientSubscriptionId[$];
        tt && await tt()
    }
    _buildArgs($, et, tt, nt) {
        const rt = et || this._commitment;
        if (rt || tt || nt) {
            let it = {};
            tt && (it.encoding = tt),
            rt && (it.commitment = rt),
            nt && (it = Object.assign(it, nt)),
            $.push(it)
        }
        return $
    }
    _buildArgsAtLeastConfirmed($, et, tt, nt) {
        const rt = et || this._commitment;
        if (rt && !["confirmed", "finalized"].includes(rt))
            throw new Error("Using Connection with default commitment: `" + this._commitment + "`, but method requires at least `confirmed`");
        return this._buildArgs($, et, tt, nt)
    }
    _wsOnSignatureNotification($) {
        const {result: et, subscription: tt} = create$4($, SignatureNotificationResult);
        et.value !== "receivedSignature" && this._subscriptionsAutoDisposedByRpc.add(tt),
        this._handleServerNotification(tt, et.value === "receivedSignature" ? [{
            type: "received"
        }, et.context] : [{
            type: "status",
            result: et.value
        }, et.context])
    }
    onSignature($, et, tt) {
        const nt = this._buildArgs([$], tt || this._commitment || "finalized")
          , rt = this._makeSubscription({
            callback: (it, ot) => {
                if (it.type === "status") {
                    et(it.result, ot);
                    try {
                        this.removeSignatureListener(rt)
                    } catch {}
                }
            }
            ,
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
        }, nt);
        return rt
    }
    onSignatureWithOptions($, et, tt) {
        const {commitment: nt, ...rt} = {
            ...tt,
            commitment: tt && tt.commitment || this._commitment || "finalized"
        }
          , it = this._buildArgs([$], nt, void 0, rt)
          , ot = this._makeSubscription({
            callback: (st, lt) => {
                et(st, lt);
                try {
                    this.removeSignatureListener(ot)
                } catch {}
            }
            ,
            method: "signatureSubscribe",
            unsubscribeMethod: "signatureUnsubscribe"
        }, it);
        return ot
    }
    async removeSignatureListener($) {
        await this._unsubscribeClientSubscription($, "signature result")
    }
    _wsOnRootNotification($) {
        const {result: et, subscription: tt} = create$4($, RootNotificationResult);
        this._handleServerNotification(tt, [et])
    }
    onRootChange($) {
        return this._makeSubscription({
            callback: $,
            method: "rootSubscribe",
            unsubscribeMethod: "rootUnsubscribe"
        }, [])
    }
    async removeRootChangeListener($) {
        await this._unsubscribeClientSubscription($, "root change")
    }
}
class Keypair {
    constructor($) {
        this._keypair = void 0,
        this._keypair = $ ?? generateKeypair()
    }
    static generate() {
        return new Keypair(generateKeypair())
    }
    static fromSecretKey($, et) {
        if ($.byteLength !== 64)
            throw new Error("bad secret key size");
        const tt = $.slice(32, 64);
        if (!et || !et.skipValidation) {
            const nt = $.slice(0, 32)
              , rt = getPublicKey(nt);
            for (let it = 0; it < 32; it++)
                if (tt[it] !== rt[it])
                    throw new Error("provided secretKey is invalid")
        }
        return new Keypair({
            publicKey: tt,
            secretKey: $
        })
    }
    static fromSeed($) {
        const et = getPublicKey($)
          , tt = new Uint8Array(64);
        return tt.set($),
        tt.set(et, 32),
        new Keypair({
            publicKey: et,
            secretKey: tt
        })
    }
    get publicKey() {
        return new PublicKey(this._keypair.publicKey)
    }
    get secretKey() {
        return new Uint8Array(this._keypair.secretKey)
    }
}
const LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({
    CreateLookupTable: {
        index: 0,
        layout: struct$1([u32$1("instruction"), u64$2("recentSlot"), u8$1("bumpSeed")])
    },
    FreezeLookupTable: {
        index: 1,
        layout: struct$1([u32$1("instruction")])
    },
    ExtendLookupTable: {
        index: 2,
        layout: struct$1([u32$1("instruction"), u64$2(), seq(publicKey$4(), offset$1(u32$1(), -8), "addresses")])
    },
    DeactivateLookupTable: {
        index: 3,
        layout: struct$1([u32$1("instruction")])
    },
    CloseLookupTable: {
        index: 4,
        layout: struct$1([u32$1("instruction")])
    }
});
class AddressLookupTableInstruction {
    constructor() {}
    static decodeInstructionType($) {
        this.checkProgramId($.programId);
        const tt = u32$1("instruction").decode($.data);
        let nt;
        for (const [rt,it] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS))
            if (it.index == tt) {
                nt = rt;
                break
            }
        if (!nt)
            throw new Error("Invalid Instruction. Should be a LookupTable Instruction");
        return nt
    }
    static decodeCreateLookupTable($) {
        this.checkProgramId($.programId),
        this.checkKeysLength($.keys, 4);
        const {recentSlot: et} = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, $.data);
        return {
            authority: $.keys[1].pubkey,
            payer: $.keys[2].pubkey,
            recentSlot: Number(et)
        }
    }
    static decodeExtendLookupTable($) {
        if (this.checkProgramId($.programId),
        $.keys.length < 2)
            throw new Error(`invalid instruction; found ${$.keys.length} keys, expected at least 2`);
        const {addresses: et} = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, $.data);
        return {
            lookupTable: $.keys[0].pubkey,
            authority: $.keys[1].pubkey,
            payer: $.keys.length > 2 ? $.keys[2].pubkey : void 0,
            addresses: et.map(tt => new PublicKey(tt))
        }
    }
    static decodeCloseLookupTable($) {
        return this.checkProgramId($.programId),
        this.checkKeysLength($.keys, 3),
        {
            lookupTable: $.keys[0].pubkey,
            authority: $.keys[1].pubkey,
            recipient: $.keys[2].pubkey
        }
    }
    static decodeFreezeLookupTable($) {
        return this.checkProgramId($.programId),
        this.checkKeysLength($.keys, 2),
        {
            lookupTable: $.keys[0].pubkey,
            authority: $.keys[1].pubkey
        }
    }
    static decodeDeactivateLookupTable($) {
        return this.checkProgramId($.programId),
        this.checkKeysLength($.keys, 2),
        {
            lookupTable: $.keys[0].pubkey,
            authority: $.keys[1].pubkey
        }
    }
    static checkProgramId($) {
        if (!$.equals(AddressLookupTableProgram.programId))
            throw new Error("invalid instruction; programId is not AddressLookupTable Program")
    }
    static checkKeysLength($, et) {
        if ($.length < et)
            throw new Error(`invalid instruction; found ${$.length} keys, expected at least ${et}`)
    }
}
class AddressLookupTableProgram {
    constructor() {}
    static createLookupTable($) {
        const [et,tt] = PublicKey.findProgramAddressSync([$.authority.toBuffer(), toBufferLE_1(BigInt($.recentSlot), 8)], this.programId)
          , nt = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable
          , rt = encodeData(nt, {
            recentSlot: BigInt($.recentSlot),
            bumpSeed: tt
        })
          , it = [{
            pubkey: et,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: $.authority,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: $.payer,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: SystemProgram.programId,
            isSigner: !1,
            isWritable: !1
        }];
        return [new TransactionInstruction({
            programId: this.programId,
            keys: it,
            data: rt
        }), et]
    }
    static freezeLookupTable($) {
        const et = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable
          , tt = encodeData(et)
          , nt = [{
            pubkey: $.lookupTable,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: $.authority,
            isSigner: !0,
            isWritable: !1
        }];
        return new TransactionInstruction({
            programId: this.programId,
            keys: nt,
            data: tt
        })
    }
    static extendLookupTable($) {
        const et = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable
          , tt = encodeData(et, {
            addresses: $.addresses.map(rt => rt.toBytes())
        })
          , nt = [{
            pubkey: $.lookupTable,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: $.authority,
            isSigner: !0,
            isWritable: !1
        }];
        return $.payer && nt.push({
            pubkey: $.payer,
            isSigner: !0,
            isWritable: !0
        }, {
            pubkey: SystemProgram.programId,
            isSigner: !1,
            isWritable: !1
        }),
        new TransactionInstruction({
            programId: this.programId,
            keys: nt,
            data: tt
        })
    }
    static deactivateLookupTable($) {
        const et = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable
          , tt = encodeData(et)
          , nt = [{
            pubkey: $.lookupTable,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: $.authority,
            isSigner: !0,
            isWritable: !1
        }];
        return new TransactionInstruction({
            programId: this.programId,
            keys: nt,
            data: tt
        })
    }
    static closeLookupTable($) {
        const et = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable
          , tt = encodeData(et)
          , nt = [{
            pubkey: $.lookupTable,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: $.authority,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: $.recipient,
            isSigner: !1,
            isWritable: !0
        }];
        return new TransactionInstruction({
            programId: this.programId,
            keys: nt,
            data: tt
        })
    }
}
AddressLookupTableProgram.programId = new PublicKey("AddressLookupTab1e1111111111111111111111111");
class ComputeBudgetInstruction {
    constructor() {}
    static decodeInstructionType($) {
        this.checkProgramId($.programId);
        const tt = u8$1("instruction").decode($.data);
        let nt;
        for (const [rt,it] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS))
            if (it.index == tt) {
                nt = rt;
                break
            }
        if (!nt)
            throw new Error("Instruction type incorrect; not a ComputeBudgetInstruction");
        return nt
    }
    static decodeRequestUnits($) {
        this.checkProgramId($.programId);
        const {units: et, additionalFee: tt} = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, $.data);
        return {
            units: et,
            additionalFee: tt
        }
    }
    static decodeRequestHeapFrame($) {
        this.checkProgramId($.programId);
        const {bytes: et} = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, $.data);
        return {
            bytes: et
        }
    }
    static decodeSetComputeUnitLimit($) {
        this.checkProgramId($.programId);
        const {units: et} = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, $.data);
        return {
            units: et
        }
    }
    static decodeSetComputeUnitPrice($) {
        this.checkProgramId($.programId);
        const {microLamports: et} = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, $.data);
        return {
            microLamports: et
        }
    }
    static checkProgramId($) {
        if (!$.equals(ComputeBudgetProgram.programId))
            throw new Error("invalid instruction; programId is not ComputeBudgetProgram")
    }
}
const COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({
    RequestUnits: {
        index: 0,
        layout: struct$1([u8$1("instruction"), u32$1("units"), u32$1("additionalFee")])
    },
    RequestHeapFrame: {
        index: 1,
        layout: struct$1([u8$1("instruction"), u32$1("bytes")])
    },
    SetComputeUnitLimit: {
        index: 2,
        layout: struct$1([u8$1("instruction"), u32$1("units")])
    },
    SetComputeUnitPrice: {
        index: 3,
        layout: struct$1([u8$1("instruction"), u64$2("microLamports")])
    }
});
class ComputeBudgetProgram {
    constructor() {}
    static requestUnits($) {
        const et = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits
          , tt = encodeData(et, $);
        return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data: tt
        })
    }
    static requestHeapFrame($) {
        const et = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame
          , tt = encodeData(et, $);
        return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data: tt
        })
    }
    static setComputeUnitLimit($) {
        const et = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit
          , tt = encodeData(et, $);
        return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data: tt
        })
    }
    static setComputeUnitPrice($) {
        const et = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice
          , tt = encodeData(et, {
            microLamports: BigInt($.microLamports)
        });
        return new TransactionInstruction({
            keys: [],
            programId: this.programId,
            data: tt
        })
    }
}
ComputeBudgetProgram.programId = new PublicKey("ComputeBudget111111111111111111111111111111");
const PRIVATE_KEY_BYTES$1 = 64
  , PUBLIC_KEY_BYTES$1 = 32
  , SIGNATURE_BYTES = 64
  , ED25519_INSTRUCTION_LAYOUT = struct$1([u8$1("numSignatures"), u8$1("padding"), u16("signatureOffset"), u16("signatureInstructionIndex"), u16("publicKeyOffset"), u16("publicKeyInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u16("messageInstructionIndex")]);
class Ed25519Program {
    constructor() {}
    static createInstructionWithPublicKey($) {
        const {publicKey: et, message: tt, signature: nt, instructionIndex: rt} = $;
        assert$1(et.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${et.length} bytes`),
        assert$1(nt.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${nt.length} bytes`);
        const it = ED25519_INSTRUCTION_LAYOUT.span
          , ot = it + et.length
          , st = ot + nt.length
          , lt = 1
          , ct = Buffer$1$1.alloc(st + tt.length)
          , dt = rt ?? 65535;
        return ED25519_INSTRUCTION_LAYOUT.encode({
            numSignatures: lt,
            padding: 0,
            signatureOffset: ot,
            signatureInstructionIndex: dt,
            publicKeyOffset: it,
            publicKeyInstructionIndex: dt,
            messageDataOffset: st,
            messageDataSize: tt.length,
            messageInstructionIndex: dt
        }, ct),
        ct.fill(et, it),
        ct.fill(nt, ot),
        ct.fill(tt, st),
        new TransactionInstruction({
            keys: [],
            programId: Ed25519Program.programId,
            data: ct
        })
    }
    static createInstructionWithPrivateKey($) {
        const {privateKey: et, message: tt, instructionIndex: nt} = $;
        assert$1(et.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${et.length} bytes`);
        try {
            const rt = Keypair.fromSecretKey(et)
              , it = rt.publicKey.toBytes()
              , ot = sign$1(tt, rt.secretKey);
            return this.createInstructionWithPublicKey({
                publicKey: it,
                message: tt,
                signature: ot,
                instructionIndex: nt
            })
        } catch (rt) {
            throw new Error(`Error creating instruction; ${rt}`)
        }
    }
}
Ed25519Program.programId = new PublicKey("Ed25519SigVerify111111111111111111111111111");
const ecdsaSign = (_e, $) => {
    const et = secp256k1.sign(_e, $);
    return [et.toCompactRawBytes(), et.recovery]
}
;
secp256k1.utils.isValidPrivateKey;
const publicKeyCreate = secp256k1.getPublicKey
  , PRIVATE_KEY_BYTES = 32
  , ETHEREUM_ADDRESS_BYTES = 20
  , PUBLIC_KEY_BYTES = 64
  , SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11
  , SECP256K1_INSTRUCTION_LAYOUT = struct$1([u8$1("numSignatures"), u16("signatureOffset"), u8$1("signatureInstructionIndex"), u16("ethAddressOffset"), u8$1("ethAddressInstructionIndex"), u16("messageDataOffset"), u16("messageDataSize"), u8$1("messageInstructionIndex"), blob$1(20, "ethAddress"), blob$1(64, "signature"), u8$1("recoveryId")]);
class Secp256k1Program {
    constructor() {}
    static publicKeyToEthAddress($) {
        assert$1($.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${$.length} bytes`);
        try {
            return Buffer$1$1.from(keccak_256(toBuffer($))).slice(-ETHEREUM_ADDRESS_BYTES)
        } catch (et) {
            throw new Error(`Error constructing Ethereum address: ${et}`)
        }
    }
    static createInstructionWithPublicKey($) {
        const {publicKey: et, message: tt, signature: nt, recoveryId: rt, instructionIndex: it} = $;
        return Secp256k1Program.createInstructionWithEthAddress({
            ethAddress: Secp256k1Program.publicKeyToEthAddress(et),
            message: tt,
            signature: nt,
            recoveryId: rt,
            instructionIndex: it
        })
    }
    static createInstructionWithEthAddress($) {
        const {ethAddress: et, message: tt, signature: nt, recoveryId: rt, instructionIndex: it=0} = $;
        let ot;
        typeof et == "string" ? et.startsWith("0x") ? ot = Buffer$1$1.from(et.substr(2), "hex") : ot = Buffer$1$1.from(et, "hex") : ot = et,
        assert$1(ot.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ot.length} bytes`);
        const st = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE
          , lt = st
          , ct = st + ot.length
          , dt = ct + nt.length + 1
          , pt = 1
          , ht = Buffer$1$1.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + tt.length);
        return SECP256K1_INSTRUCTION_LAYOUT.encode({
            numSignatures: pt,
            signatureOffset: ct,
            signatureInstructionIndex: it,
            ethAddressOffset: lt,
            ethAddressInstructionIndex: it,
            messageDataOffset: dt,
            messageDataSize: tt.length,
            messageInstructionIndex: it,
            signature: toBuffer(nt),
            ethAddress: toBuffer(ot),
            recoveryId: rt
        }, ht),
        ht.fill(toBuffer(tt), SECP256K1_INSTRUCTION_LAYOUT.span),
        new TransactionInstruction({
            keys: [],
            programId: Secp256k1Program.programId,
            data: ht
        })
    }
    static createInstructionWithPrivateKey($) {
        const {privateKey: et, message: tt, instructionIndex: nt} = $;
        assert$1(et.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${et.length} bytes`);
        try {
            const rt = toBuffer(et)
              , it = publicKeyCreate(rt, !1).slice(1)
              , ot = Buffer$1$1.from(keccak_256(toBuffer(tt)))
              , [st,lt] = ecdsaSign(ot, rt);
            return this.createInstructionWithPublicKey({
                publicKey: it,
                message: tt,
                signature: st,
                recoveryId: lt,
                instructionIndex: nt
            })
        } catch (rt) {
            throw new Error(`Error creating instruction; ${rt}`)
        }
    }
}
Secp256k1Program.programId = new PublicKey("KeccakSecp256k11111111111111111111111111111");
var _Lockup;
const STAKE_CONFIG_ID = new PublicKey("StakeConfig11111111111111111111111111111111");
class Authorized {
    constructor($, et) {
        this.staker = void 0,
        this.withdrawer = void 0,
        this.staker = $,
        this.withdrawer = et
    }
}
class Lockup {
    constructor($, et, tt) {
        this.unixTimestamp = void 0,
        this.epoch = void 0,
        this.custodian = void 0,
        this.unixTimestamp = $,
        this.epoch = et,
        this.custodian = tt
    }
}
_Lockup = Lockup;
Lockup.default = new _Lockup(0,0,PublicKey.default);
class StakeInstruction {
    constructor() {}
    static decodeInstructionType($) {
        this.checkProgramId($.programId);
        const tt = u32$1("instruction").decode($.data);
        let nt;
        for (const [rt,it] of Object.entries(STAKE_INSTRUCTION_LAYOUTS))
            if (it.index == tt) {
                nt = rt;
                break
            }
        if (!nt)
            throw new Error("Instruction type incorrect; not a StakeInstruction");
        return nt
    }
    static decodeInitialize($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 2);
        const {authorized: et, lockup: tt} = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, $.data);
        return {
            stakePubkey: $.keys[0].pubkey,
            authorized: new Authorized(new PublicKey(et.staker),new PublicKey(et.withdrawer)),
            lockup: new Lockup(tt.unixTimestamp,tt.epoch,new PublicKey(tt.custodian))
        }
    }
    static decodeDelegate($) {
        return this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 6),
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, $.data),
        {
            stakePubkey: $.keys[0].pubkey,
            votePubkey: $.keys[1].pubkey,
            authorizedPubkey: $.keys[5].pubkey
        }
    }
    static decodeAuthorize($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 3);
        const {newAuthorized: et, stakeAuthorizationType: tt} = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, $.data)
          , nt = {
            stakePubkey: $.keys[0].pubkey,
            authorizedPubkey: $.keys[2].pubkey,
            newAuthorizedPubkey: new PublicKey(et),
            stakeAuthorizationType: {
                index: tt
            }
        };
        return $.keys.length > 3 && (nt.custodianPubkey = $.keys[3].pubkey),
        nt
    }
    static decodeAuthorizeWithSeed($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 2);
        const {newAuthorized: et, stakeAuthorizationType: tt, authoritySeed: nt, authorityOwner: rt} = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, $.data)
          , it = {
            stakePubkey: $.keys[0].pubkey,
            authorityBase: $.keys[1].pubkey,
            authoritySeed: nt,
            authorityOwner: new PublicKey(rt),
            newAuthorizedPubkey: new PublicKey(et),
            stakeAuthorizationType: {
                index: tt
            }
        };
        return $.keys.length > 3 && (it.custodianPubkey = $.keys[3].pubkey),
        it
    }
    static decodeSplit($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 3);
        const {lamports: et} = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, $.data);
        return {
            stakePubkey: $.keys[0].pubkey,
            splitStakePubkey: $.keys[1].pubkey,
            authorizedPubkey: $.keys[2].pubkey,
            lamports: et
        }
    }
    static decodeMerge($) {
        return this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 3),
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, $.data),
        {
            stakePubkey: $.keys[0].pubkey,
            sourceStakePubKey: $.keys[1].pubkey,
            authorizedPubkey: $.keys[4].pubkey
        }
    }
    static decodeWithdraw($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 5);
        const {lamports: et} = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, $.data)
          , tt = {
            stakePubkey: $.keys[0].pubkey,
            toPubkey: $.keys[1].pubkey,
            authorizedPubkey: $.keys[4].pubkey,
            lamports: et
        };
        return $.keys.length > 5 && (tt.custodianPubkey = $.keys[5].pubkey),
        tt
    }
    static decodeDeactivate($) {
        return this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 3),
        decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, $.data),
        {
            stakePubkey: $.keys[0].pubkey,
            authorizedPubkey: $.keys[2].pubkey
        }
    }
    static checkProgramId($) {
        if (!$.equals(StakeProgram.programId))
            throw new Error("invalid instruction; programId is not StakeProgram")
    }
    static checkKeyLength($, et) {
        if ($.length < et)
            throw new Error(`invalid instruction; found ${$.length} keys, expected at least ${et}`)
    }
}
const STAKE_INSTRUCTION_LAYOUTS = Object.freeze({
    Initialize: {
        index: 0,
        layout: struct$1([u32$1("instruction"), authorized(), lockup()])
    },
    Authorize: {
        index: 1,
        layout: struct$1([u32$1("instruction"), publicKey$4("newAuthorized"), u32$1("stakeAuthorizationType")])
    },
    Delegate: {
        index: 2,
        layout: struct$1([u32$1("instruction")])
    },
    Split: {
        index: 3,
        layout: struct$1([u32$1("instruction"), ns64$1("lamports")])
    },
    Withdraw: {
        index: 4,
        layout: struct$1([u32$1("instruction"), ns64$1("lamports")])
    },
    Deactivate: {
        index: 5,
        layout: struct$1([u32$1("instruction")])
    },
    Merge: {
        index: 7,
        layout: struct$1([u32$1("instruction")])
    },
    AuthorizeWithSeed: {
        index: 8,
        layout: struct$1([u32$1("instruction"), publicKey$4("newAuthorized"), u32$1("stakeAuthorizationType"), rustString("authoritySeed"), publicKey$4("authorityOwner")])
    }
})
  , StakeAuthorizationLayout = Object.freeze({
    Staker: {
        index: 0
    },
    Withdrawer: {
        index: 1
    }
});
class StakeProgram {
    constructor() {}
    static initialize($) {
        const {stakePubkey: et, authorized: tt, lockup: nt} = $
          , rt = nt || Lockup.default
          , it = STAKE_INSTRUCTION_LAYOUTS.Initialize
          , ot = encodeData(it, {
            authorized: {
                staker: toBuffer(tt.staker.toBuffer()),
                withdrawer: toBuffer(tt.withdrawer.toBuffer())
            },
            lockup: {
                unixTimestamp: rt.unixTimestamp,
                epoch: rt.epoch,
                custodian: toBuffer(rt.custodian.toBuffer())
            }
        })
          , st = {
            keys: [{
                pubkey: et,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: SYSVAR_RENT_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }],
            programId: this.programId,
            data: ot
        };
        return new TransactionInstruction(st)
    }
    static createAccountWithSeed($) {
        const et = new Transaction;
        et.add(SystemProgram.createAccountWithSeed({
            fromPubkey: $.fromPubkey,
            newAccountPubkey: $.stakePubkey,
            basePubkey: $.basePubkey,
            seed: $.seed,
            lamports: $.lamports,
            space: this.space,
            programId: this.programId
        }));
        const {stakePubkey: tt, authorized: nt, lockup: rt} = $;
        return et.add(this.initialize({
            stakePubkey: tt,
            authorized: nt,
            lockup: rt
        }))
    }
    static createAccount($) {
        const et = new Transaction;
        et.add(SystemProgram.createAccount({
            fromPubkey: $.fromPubkey,
            newAccountPubkey: $.stakePubkey,
            lamports: $.lamports,
            space: this.space,
            programId: this.programId
        }));
        const {stakePubkey: tt, authorized: nt, lockup: rt} = $;
        return et.add(this.initialize({
            stakePubkey: tt,
            authorized: nt,
            lockup: rt
        }))
    }
    static delegate($) {
        const {stakePubkey: et, authorizedPubkey: tt, votePubkey: nt} = $
          , rt = STAKE_INSTRUCTION_LAYOUTS.Delegate
          , it = encodeData(rt);
        return new Transaction().add({
            keys: [{
                pubkey: et,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: nt,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: SYSVAR_CLOCK_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: STAKE_CONFIG_ID,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: tt,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: it
        })
    }
    static authorize($) {
        const {stakePubkey: et, authorizedPubkey: tt, newAuthorizedPubkey: nt, stakeAuthorizationType: rt, custodianPubkey: it} = $
          , ot = STAKE_INSTRUCTION_LAYOUTS.Authorize
          , st = encodeData(ot, {
            newAuthorized: toBuffer(nt.toBuffer()),
            stakeAuthorizationType: rt.index
        })
          , lt = [{
            pubkey: et,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: tt,
            isSigner: !0,
            isWritable: !1
        }];
        return it && lt.push({
            pubkey: it,
            isSigner: !0,
            isWritable: !1
        }),
        new Transaction().add({
            keys: lt,
            programId: this.programId,
            data: st
        })
    }
    static authorizeWithSeed($) {
        const {stakePubkey: et, authorityBase: tt, authoritySeed: nt, authorityOwner: rt, newAuthorizedPubkey: it, stakeAuthorizationType: ot, custodianPubkey: st} = $
          , lt = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed
          , ct = encodeData(lt, {
            newAuthorized: toBuffer(it.toBuffer()),
            stakeAuthorizationType: ot.index,
            authoritySeed: nt,
            authorityOwner: toBuffer(rt.toBuffer())
        })
          , dt = [{
            pubkey: et,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: tt,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: !1,
            isWritable: !1
        }];
        return st && dt.push({
            pubkey: st,
            isSigner: !0,
            isWritable: !1
        }),
        new Transaction().add({
            keys: dt,
            programId: this.programId,
            data: ct
        })
    }
    static splitInstruction($) {
        const {stakePubkey: et, authorizedPubkey: tt, splitStakePubkey: nt, lamports: rt} = $
          , it = STAKE_INSTRUCTION_LAYOUTS.Split
          , ot = encodeData(it, {
            lamports: rt
        });
        return new TransactionInstruction({
            keys: [{
                pubkey: et,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: nt,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: tt,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: ot
        })
    }
    static split($, et) {
        const tt = new Transaction;
        return tt.add(SystemProgram.createAccount({
            fromPubkey: $.authorizedPubkey,
            newAccountPubkey: $.splitStakePubkey,
            lamports: et,
            space: this.space,
            programId: this.programId
        })),
        tt.add(this.splitInstruction($))
    }
    static splitWithSeed($, et) {
        const {stakePubkey: tt, authorizedPubkey: nt, splitStakePubkey: rt, basePubkey: it, seed: ot, lamports: st} = $
          , lt = new Transaction;
        return lt.add(SystemProgram.allocate({
            accountPubkey: rt,
            basePubkey: it,
            seed: ot,
            space: this.space,
            programId: this.programId
        })),
        et && et > 0 && lt.add(SystemProgram.transfer({
            fromPubkey: $.authorizedPubkey,
            toPubkey: rt,
            lamports: et
        })),
        lt.add(this.splitInstruction({
            stakePubkey: tt,
            authorizedPubkey: nt,
            splitStakePubkey: rt,
            lamports: st
        }))
    }
    static merge($) {
        const {stakePubkey: et, sourceStakePubKey: tt, authorizedPubkey: nt} = $
          , rt = STAKE_INSTRUCTION_LAYOUTS.Merge
          , it = encodeData(rt);
        return new Transaction().add({
            keys: [{
                pubkey: et,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: tt,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: SYSVAR_CLOCK_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: nt,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: it
        })
    }
    static withdraw($) {
        const {stakePubkey: et, authorizedPubkey: tt, toPubkey: nt, lamports: rt, custodianPubkey: it} = $
          , ot = STAKE_INSTRUCTION_LAYOUTS.Withdraw
          , st = encodeData(ot, {
            lamports: rt
        })
          , lt = [{
            pubkey: et,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: nt,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: tt,
            isSigner: !0,
            isWritable: !1
        }];
        return it && lt.push({
            pubkey: it,
            isSigner: !0,
            isWritable: !1
        }),
        new Transaction().add({
            keys: lt,
            programId: this.programId,
            data: st
        })
    }
    static deactivate($) {
        const {stakePubkey: et, authorizedPubkey: tt} = $
          , nt = STAKE_INSTRUCTION_LAYOUTS.Deactivate
          , rt = encodeData(nt);
        return new Transaction().add({
            keys: [{
                pubkey: et,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: SYSVAR_CLOCK_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: tt,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: rt
        })
    }
}
StakeProgram.programId = new PublicKey("Stake11111111111111111111111111111111111111");
StakeProgram.space = 200;
class VoteInit {
    constructor($, et, tt, nt) {
        this.nodePubkey = void 0,
        this.authorizedVoter = void 0,
        this.authorizedWithdrawer = void 0,
        this.commission = void 0,
        this.nodePubkey = $,
        this.authorizedVoter = et,
        this.authorizedWithdrawer = tt,
        this.commission = nt
    }
}
class VoteInstruction {
    constructor() {}
    static decodeInstructionType($) {
        this.checkProgramId($.programId);
        const tt = u32$1("instruction").decode($.data);
        let nt;
        for (const [rt,it] of Object.entries(VOTE_INSTRUCTION_LAYOUTS))
            if (it.index == tt) {
                nt = rt;
                break
            }
        if (!nt)
            throw new Error("Instruction type incorrect; not a VoteInstruction");
        return nt
    }
    static decodeInitializeAccount($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 4);
        const {voteInit: et} = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, $.data);
        return {
            votePubkey: $.keys[0].pubkey,
            nodePubkey: $.keys[3].pubkey,
            voteInit: new VoteInit(new PublicKey(et.nodePubkey),new PublicKey(et.authorizedVoter),new PublicKey(et.authorizedWithdrawer),et.commission)
        }
    }
    static decodeAuthorize($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 3);
        const {newAuthorized: et, voteAuthorizationType: tt} = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, $.data);
        return {
            votePubkey: $.keys[0].pubkey,
            authorizedPubkey: $.keys[2].pubkey,
            newAuthorizedPubkey: new PublicKey(et),
            voteAuthorizationType: {
                index: tt
            }
        }
    }
    static decodeAuthorizeWithSeed($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 3);
        const {voteAuthorizeWithSeedArgs: {currentAuthorityDerivedKeyOwnerPubkey: et, currentAuthorityDerivedKeySeed: tt, newAuthorized: nt, voteAuthorizationType: rt}} = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, $.data);
        return {
            currentAuthorityDerivedKeyBasePubkey: $.keys[2].pubkey,
            currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(et),
            currentAuthorityDerivedKeySeed: tt,
            newAuthorizedPubkey: new PublicKey(nt),
            voteAuthorizationType: {
                index: rt
            },
            votePubkey: $.keys[0].pubkey
        }
    }
    static decodeWithdraw($) {
        this.checkProgramId($.programId),
        this.checkKeyLength($.keys, 3);
        const {lamports: et} = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, $.data);
        return {
            votePubkey: $.keys[0].pubkey,
            authorizedWithdrawerPubkey: $.keys[2].pubkey,
            lamports: et,
            toPubkey: $.keys[1].pubkey
        }
    }
    static checkProgramId($) {
        if (!$.equals(VoteProgram.programId))
            throw new Error("invalid instruction; programId is not VoteProgram")
    }
    static checkKeyLength($, et) {
        if ($.length < et)
            throw new Error(`invalid instruction; found ${$.length} keys, expected at least ${et}`)
    }
}
const VOTE_INSTRUCTION_LAYOUTS = Object.freeze({
    InitializeAccount: {
        index: 0,
        layout: struct$1([u32$1("instruction"), voteInit()])
    },
    Authorize: {
        index: 1,
        layout: struct$1([u32$1("instruction"), publicKey$4("newAuthorized"), u32$1("voteAuthorizationType")])
    },
    Withdraw: {
        index: 3,
        layout: struct$1([u32$1("instruction"), ns64$1("lamports")])
    },
    UpdateValidatorIdentity: {
        index: 4,
        layout: struct$1([u32$1("instruction")])
    },
    AuthorizeWithSeed: {
        index: 10,
        layout: struct$1([u32$1("instruction"), voteAuthorizeWithSeedArgs()])
    }
})
  , VoteAuthorizationLayout = Object.freeze({
    Voter: {
        index: 0
    },
    Withdrawer: {
        index: 1
    }
});
class VoteProgram {
    constructor() {}
    static initializeAccount($) {
        const {votePubkey: et, nodePubkey: tt, voteInit: nt} = $
          , rt = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount
          , it = encodeData(rt, {
            voteInit: {
                nodePubkey: toBuffer(nt.nodePubkey.toBuffer()),
                authorizedVoter: toBuffer(nt.authorizedVoter.toBuffer()),
                authorizedWithdrawer: toBuffer(nt.authorizedWithdrawer.toBuffer()),
                commission: nt.commission
            }
        })
          , ot = {
            keys: [{
                pubkey: et,
                isSigner: !1,
                isWritable: !0
            }, {
                pubkey: SYSVAR_RENT_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: SYSVAR_CLOCK_PUBKEY,
                isSigner: !1,
                isWritable: !1
            }, {
                pubkey: tt,
                isSigner: !0,
                isWritable: !1
            }],
            programId: this.programId,
            data: it
        };
        return new TransactionInstruction(ot)
    }
    static createAccount($) {
        const et = new Transaction;
        return et.add(SystemProgram.createAccount({
            fromPubkey: $.fromPubkey,
            newAccountPubkey: $.votePubkey,
            lamports: $.lamports,
            space: this.space,
            programId: this.programId
        })),
        et.add(this.initializeAccount({
            votePubkey: $.votePubkey,
            nodePubkey: $.voteInit.nodePubkey,
            voteInit: $.voteInit
        }))
    }
    static authorize($) {
        const {votePubkey: et, authorizedPubkey: tt, newAuthorizedPubkey: nt, voteAuthorizationType: rt} = $
          , it = VOTE_INSTRUCTION_LAYOUTS.Authorize
          , ot = encodeData(it, {
            newAuthorized: toBuffer(nt.toBuffer()),
            voteAuthorizationType: rt.index
        })
          , st = [{
            pubkey: et,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: tt,
            isSigner: !0,
            isWritable: !1
        }];
        return new Transaction().add({
            keys: st,
            programId: this.programId,
            data: ot
        })
    }
    static authorizeWithSeed($) {
        const {currentAuthorityDerivedKeyBasePubkey: et, currentAuthorityDerivedKeyOwnerPubkey: tt, currentAuthorityDerivedKeySeed: nt, newAuthorizedPubkey: rt, voteAuthorizationType: it, votePubkey: ot} = $
          , st = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed
          , lt = encodeData(st, {
            voteAuthorizeWithSeedArgs: {
                currentAuthorityDerivedKeyOwnerPubkey: toBuffer(tt.toBuffer()),
                currentAuthorityDerivedKeySeed: nt,
                newAuthorized: toBuffer(rt.toBuffer()),
                voteAuthorizationType: it.index
            }
        })
          , ct = [{
            pubkey: ot,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: SYSVAR_CLOCK_PUBKEY,
            isSigner: !1,
            isWritable: !1
        }, {
            pubkey: et,
            isSigner: !0,
            isWritable: !1
        }];
        return new Transaction().add({
            keys: ct,
            programId: this.programId,
            data: lt
        })
    }
    static withdraw($) {
        const {votePubkey: et, authorizedWithdrawerPubkey: tt, lamports: nt, toPubkey: rt} = $
          , it = VOTE_INSTRUCTION_LAYOUTS.Withdraw
          , ot = encodeData(it, {
            lamports: nt
        })
          , st = [{
            pubkey: et,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: rt,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: tt,
            isSigner: !0,
            isWritable: !1
        }];
        return new Transaction().add({
            keys: st,
            programId: this.programId,
            data: ot
        })
    }
    static safeWithdraw($, et, tt) {
        if ($.lamports > et - tt)
            throw new Error("Withdraw will leave vote account with insufficient funds.");
        return VoteProgram.withdraw($)
    }
    static updateValidatorIdentity($) {
        const {votePubkey: et, authorizedWithdrawerPubkey: tt, nodePubkey: nt} = $
          , rt = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity
          , it = encodeData(rt)
          , ot = [{
            pubkey: et,
            isSigner: !1,
            isWritable: !0
        }, {
            pubkey: nt,
            isSigner: !0,
            isWritable: !1
        }, {
            pubkey: tt,
            isSigner: !0,
            isWritable: !1
        }];
        return new Transaction().add({
            keys: ot,
            programId: this.programId,
            data: it
        })
    }
}
VoteProgram.programId = new PublicKey("Vote111111111111111111111111111111111111111");
VoteProgram.space = 3762;
const VALIDATOR_INFO_KEY = new PublicKey("Va1idator1nfo111111111111111111111111111111")
  , InfoString = type$1({
    name: string$2(),
    website: optional$1(string$2()),
    details: optional$1(string$2()),
    iconUrl: optional$1(string$2()),
    keybaseUsername: optional$1(string$2())
});
class ValidatorInfo {
    constructor($, et) {
        this.key = void 0,
        this.info = void 0,
        this.key = $,
        this.info = et
    }
    static fromConfigData($) {
        let et = [...$];
        if (decodeLength(et) !== 2)
            return null;
        const nt = [];
        for (let rt = 0; rt < 2; rt++) {
            const it = new PublicKey(guardedSplice(et, 0, PUBLIC_KEY_LENGTH))
              , ot = guardedShift(et) === 1;
            nt.push({
                publicKey: it,
                isSigner: ot
            })
        }
        if (nt[0].publicKey.equals(VALIDATOR_INFO_KEY) && nt[1].isSigner) {
            const rt = rustString().decode(Buffer$1$1.from(et))
              , it = JSON.parse(rt);
            return assert$2(it, InfoString),
            new ValidatorInfo(nt[1].publicKey,it)
        }
        return null
    }
}
const VOTE_PROGRAM_ID = new PublicKey("Vote111111111111111111111111111111111111111")
  , VoteAccountLayout = struct$1([publicKey$4("nodePubkey"), publicKey$4("authorizedWithdrawer"), u8$1("commission"), nu64$1(), seq(struct$1([nu64$1("slot"), u32$1("confirmationCount")]), offset$1(u32$1(), -8), "votes"), u8$1("rootSlotValid"), nu64$1("rootSlot"), nu64$1(), seq(struct$1([nu64$1("epoch"), publicKey$4("authorizedVoter")]), offset$1(u32$1(), -8), "authorizedVoters"), struct$1([seq(struct$1([publicKey$4("authorizedPubkey"), nu64$1("epochOfLastAuthorizedSwitch"), nu64$1("targetEpoch")]), 32, "buf"), nu64$1("idx"), u8$1("isEmpty")], "priorVoters"), nu64$1(), seq(struct$1([nu64$1("epoch"), nu64$1("credits"), nu64$1("prevCredits")]), offset$1(u32$1(), -8), "epochCredits"), struct$1([nu64$1("slot"), nu64$1("timestamp")], "lastTimestamp")]);
class VoteAccount {
    constructor($) {
        this.nodePubkey = void 0,
        this.authorizedWithdrawer = void 0,
        this.commission = void 0,
        this.rootSlot = void 0,
        this.votes = void 0,
        this.authorizedVoters = void 0,
        this.priorVoters = void 0,
        this.epochCredits = void 0,
        this.lastTimestamp = void 0,
        this.nodePubkey = $.nodePubkey,
        this.authorizedWithdrawer = $.authorizedWithdrawer,
        this.commission = $.commission,
        this.rootSlot = $.rootSlot,
        this.votes = $.votes,
        this.authorizedVoters = $.authorizedVoters,
        this.priorVoters = $.priorVoters,
        this.epochCredits = $.epochCredits,
        this.lastTimestamp = $.lastTimestamp
    }
    static fromAccountData($) {
        const tt = VoteAccountLayout.decode(toBuffer($), 4);
        let nt = tt.rootSlot;
        return tt.rootSlotValid || (nt = null),
        new VoteAccount({
            nodePubkey: new PublicKey(tt.nodePubkey),
            authorizedWithdrawer: new PublicKey(tt.authorizedWithdrawer),
            commission: tt.commission,
            votes: tt.votes,
            rootSlot: nt,
            authorizedVoters: tt.authorizedVoters.map(parseAuthorizedVoter),
            priorVoters: getPriorVoters(tt.priorVoters),
            epochCredits: tt.epochCredits,
            lastTimestamp: tt.lastTimestamp
        })
    }
}
function parseAuthorizedVoter({authorizedVoter: _e, epoch: $}) {
    return {
        epoch: $,
        authorizedVoter: new PublicKey(_e)
    }
}
function parsePriorVoters({authorizedPubkey: _e, epochOfLastAuthorizedSwitch: $, targetEpoch: et}) {
    return {
        authorizedPubkey: new PublicKey(_e),
        epochOfLastAuthorizedSwitch: $,
        targetEpoch: et
    }
}
function getPriorVoters({buf: _e, idx: $, isEmpty: et}) {
    return et ? [] : [..._e.slice($ + 1).map(parsePriorVoters), ..._e.slice(0, $).map(parsePriorVoters)]
}
const endpoint = {
    http: {
        devnet: "http://api.devnet.solana.com",
        testnet: "http://api.testnet.solana.com",
        "mainnet-beta": "http://api.mainnet-beta.solana.com/"
    },
    https: {
        devnet: "https://api.devnet.solana.com",
        testnet: "https://api.testnet.solana.com",
        "mainnet-beta": "https://api.mainnet-beta.solana.com/"
    }
};
function clusterApiUrl(_e, $) {
    const et = $ === !1 ? "http" : "https";
    if (!_e)
        return endpoint[et].devnet;
    const tt = endpoint[et][_e];
    if (!tt)
        throw new Error(`Unknown ${et} cluster: ${_e}`);
    return tt
}
async function sendAndConfirmRawTransaction$1(_e, $, et, tt) {
    let nt, rt;
    et && Object.prototype.hasOwnProperty.call(et, "lastValidBlockHeight") || et && Object.prototype.hasOwnProperty.call(et, "nonceValue") ? (nt = et,
    rt = tt) : rt = et;
    const it = rt && {
        skipPreflight: rt.skipPreflight,
        preflightCommitment: rt.preflightCommitment || rt.commitment,
        minContextSlot: rt.minContextSlot
    }
      , ot = await _e.sendRawTransaction($, it)
      , st = rt && rt.commitment
      , ct = (await (nt ? _e.confirmTransaction(nt, st) : _e.confirmTransaction(ot, st))).value;
    if (ct.err)
        throw ot != null ? new SendTransactionError({
            action: it != null && it.skipPreflight ? "send" : "simulate",
            signature: ot,
            transactionMessage: `Status: (${JSON.stringify(ct)})`
        }) : new Error(`Raw transaction ${ot} failed (${JSON.stringify(ct)})`);
    return ot
}
const LAMPORTS_PER_SOL$1 = 1e9
  , index_browser_esm = Object.freeze(Object.defineProperty({
    __proto__: null,
    Account,
    AddressLookupTableAccount,
    AddressLookupTableInstruction,
    AddressLookupTableProgram,
    Authorized,
    BLOCKHASH_CACHE_TIMEOUT_MS,
    BPF_LOADER_DEPRECATED_PROGRAM_ID,
    BPF_LOADER_PROGRAM_ID,
    BpfLoader,
    COMPUTE_BUDGET_INSTRUCTION_LAYOUTS,
    ComputeBudgetInstruction,
    ComputeBudgetProgram,
    Connection,
    Ed25519Program,
    Enum,
    EpochSchedule,
    FeeCalculatorLayout,
    Keypair,
    LAMPORTS_PER_SOL: LAMPORTS_PER_SOL$1,
    LOOKUP_TABLE_INSTRUCTION_LAYOUTS,
    Loader,
    Lockup,
    MAX_SEED_LENGTH,
    Message,
    MessageAccountKeys,
    MessageV0,
    NONCE_ACCOUNT_LENGTH,
    NonceAccount,
    PACKET_DATA_SIZE,
    PUBLIC_KEY_LENGTH,
    PublicKey,
    SIGNATURE_LENGTH_IN_BYTES,
    SOLANA_SCHEMA,
    STAKE_CONFIG_ID,
    STAKE_INSTRUCTION_LAYOUTS,
    SYSTEM_INSTRUCTION_LAYOUTS,
    SYSVAR_CLOCK_PUBKEY,
    SYSVAR_EPOCH_SCHEDULE_PUBKEY,
    SYSVAR_INSTRUCTIONS_PUBKEY,
    SYSVAR_RECENT_BLOCKHASHES_PUBKEY,
    SYSVAR_RENT_PUBKEY,
    SYSVAR_REWARDS_PUBKEY,
    SYSVAR_SLOT_HASHES_PUBKEY,
    SYSVAR_SLOT_HISTORY_PUBKEY,
    SYSVAR_STAKE_HISTORY_PUBKEY,
    Secp256k1Program,
    SendTransactionError,
    SolanaJSONRPCError,
    SolanaJSONRPCErrorCode,
    StakeAuthorizationLayout,
    StakeInstruction,
    StakeProgram,
    Struct: Struct$1,
    SystemInstruction,
    SystemProgram,
    Transaction,
    TransactionExpiredBlockheightExceededError,
    TransactionExpiredNonceInvalidError,
    TransactionExpiredTimeoutError,
    TransactionInstruction,
    TransactionMessage,
    TransactionStatus,
    VALIDATOR_INFO_KEY,
    VERSION_PREFIX_MASK,
    VOTE_PROGRAM_ID,
    ValidatorInfo,
    VersionedMessage,
    VersionedTransaction,
    VoteAccount,
    VoteAuthorizationLayout,
    VoteInit,
    VoteInstruction,
    VoteProgram,
    clusterApiUrl,
    sendAndConfirmRawTransaction: sendAndConfirmRawTransaction$1,
    sendAndConfirmTransaction
}, Symbol.toStringTag, {
    value: "Module"
}));
var Env_Mode = (_e => (_e.DEV = "development",
_e.PORD = "production",
_e))(Env_Mode || {})
  , Program_Name = (_e => (_e.GgMeme = "GgMeme",
_e.FeeDistributor = "FeeDistributor",
_e))(Program_Name || {})
  , Page = (_e => (_e.Index = "/",
_e.PostDetail = "/detail",
_e.Profile = "/profile",
_e.Publish = "/publish",
_e.Search = "/search",
_e.Edit = "/edit",
_e))(Page || {})
  , Dom_Size = (_e => (_e[_e.DIALOG_WIDTH_LARGE = 540] = "DIALOG_WIDTH_LARGE",
_e[_e.HEIGHT_HEADER = 100] = "HEIGHT_HEADER",
_e[_e.HEIGHT_HEADER_MOBILE = 64] = "HEIGHT_HEADER_MOBILE",
_e[_e.HEIGHT_FOOTER = 40] = "HEIGHT_FOOTER",
_e[_e.HEIGHT_NAV_MOBILE = 52] = "HEIGHT_NAV_MOBILE",
_e[_e.SECTION_LOADING = 256] = "SECTION_LOADING",
_e[_e.UPLOAD_IMAGE = 88] = "UPLOAD_IMAGE",
_e[_e.MEDIA_PIC_SIZE = 228] = "MEDIA_PIC_SIZE",
_e[_e.PADDING_BASE = 8] = "PADDING_BASE",
_e[_e.THRESHOLD_HEIGHT = 240] = "THRESHOLD_HEIGHT",
_e[_e.MEDIA_PIC_MAX_SIZE = 458] = "MEDIA_PIC_MAX_SIZE",
_e[_e.LAYOUT_ASIDE_WIDTH = 324] = "LAYOUT_ASIDE_WIDTH",
_e[_e.BASE_WIDTH_COL = 140] = "BASE_WIDTH_COL",
_e[_e.HEIGHT_MODULE = 72] = "HEIGHT_MODULE",
_e[_e.HEIGHT_MODULE_MOBILE = 52] = "HEIGHT_MODULE_MOBILE",
_e))(Dom_Size || {})
  , Program_Account_Name = (_e => (_e.ConfigAccount = "ConfigAccount",
_e))(Program_Account_Name || {})
  , ClusterNetwork = (_e => (_e.Mainnet = "mainnet-beta",
_e.Testnet = "testnet",
_e.Devnet = "devnet",
_e.Custom = "custom",
_e))(ClusterNetwork || {})
  , TradeDirection = (_e => (_e.Buy = "buy",
_e.Sell = "sell",
_e))(TradeDirection || {})
  , App_Theme = (_e => (_e.light = "light",
_e.dark = "dark",
_e))(App_Theme || {})
  , Media_Type = (_e => (_e.File = "file",
_e.Image = "image",
_e.Video = "video",
_e.Audio = "audio",
_e))(Media_Type || {})
  , SCROLL_DIRECTION = (_e => (_e.NEXT = "next",
_e.PREV = "prev",
_e))(SCROLL_DIRECTION || {})
  , Tiker_Sorted_By = (_e => (_e.MARKET_CAP = "MARKET_CAP",
_e.HOLDERS = "HOLDERS",
_e.LATEST_TXN = "LATEST_TXN",
_e.PRICE_CHANGE_24H = "PRICE_CHANGE_24H",
_e.PRICE_CHANGE_1H = "PRICE_CHANGE_1H",
_e.PRICE_CHANGE_5M = "PRICE_CHANGE_5M",
_e.TX_COUNT_24H = "TX_COUNT_24H",
_e.TX_COUNT_1H = "TX_COUNT_1H",
_e.TX_COUNT_5M = "TX_COUNT_5M",
_e.NATIVE_VOLUME_24H = "NATIVE_VOLUME_24H",
_e.NATIVE_VOLUME_1H = "NATIVE_VOLUME_1H",
_e.NATIVE_VOLUME_5M = "NATIVE_VOLUME_5M",
_e.INITIALIZE_AT = "INITIALIZE_AT",
_e))(Tiker_Sorted_By || {})
  , Trending_Type = (_e => (_e["5M"] = "5",
_e["1H"] = "60",
_e["1D"] = "1D",
_e))(Trending_Type || {})
  , Ticker_Detail_Tabs = (_e => (_e.Posts = "Posts",
_e.Proposals = "Proposals",
_e.Trades = "Trades",
_e.Holders = "Holders",
_e.Hidden = "Hidden",
_e))(Ticker_Detail_Tabs || {})
  , Moderator_Status = (_e => (_e.SUPER_MODERATOR = "SUPER_MODERATOR",
_e.MODERATOR = "MODERATOR",
_e.NORMAL = "NORMAL",
_e))(Moderator_Status || {})
  , Charts_Tabs = (_e => (_e.Chart = "Chart",
_e.BoundingCurve = "BoundingCurve",
_e))(Charts_Tabs || {});
const DEV_PROGRAM_ACCOUNTS = {
    ConfigAccount: "GRAwZQybSEocRMhm27tsfRa3kC5EUwzs9cBUpJBHvVrM"
}
  , PROD_PROGRAM_ACCOUNTS = {
    ConfigAccount: "7ci3rZLKS92bdvVBD9qGH8qpRk3o975TxViLAFRh7hUx"
}
  , DEV_PROGRAM_IDS = {
    GgMeme: "quakeq7M2xRtm5sWahu5tqAW6SiX6Pu56fAVw5fKEHw",
    FeeDistributor: "quakeZy21sx3BkYnneXoDjQ3fYzMsSZ6w5fbzAo9SmS"
}
  , PROD_PROGRAM_IDS = {
    GgMeme: "super4XGGb7KWorPuoSNVQDHAVQjWzTpqcoRS86d9Us",
    FeeDistributor: "feeDQ2GHpsLz67tNSXjfYfCmW7bXKcL4PEU7WAgFaN9"
};
function getProgramAccountPublicKey(_e, $) {
    return Env_Mode.PORD === "production" ? new PublicKey(PROD_PROGRAM_ACCOUNTS[_e]) : new PublicKey(DEV_PROGRAM_ACCOUNTS[_e])
}
const DEFAULT_TOKEN_DECIMALS = 6
  , DEFAULT_NATIVE_DECIMALS = 9
  , DEFAULT_TOKEN_DECIMALS_NUMBER = 1e6
  , METADATA_SEED = "metadata"
  , TOKEN_METADATA_PROGRAM_ID = new PublicKey("metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s")
  , launchTimestamp = "2025-02-25T01:59:59Z"
  , LAMPORTS_PER_SOL = 1e9
  , SOL_DECIMAL = 9
  , PLATFORM_TOKEN = "SUPER"
  , DEFAULT_PRECISION = 6
  , MAX_USER_INTERER = 12
  , DEFAULT_PAGE_LIMIT = "10"
  , GLOBAL_INTERVAL_TIMEOUT = 5 * 1e3
  , STORAGE_KEY_PRICES = "STORAGE_KEY_PRICES"
  , EVENT_CHART_PRICE = "EVENT_CHART_PRICE"
  , STORAGE_KEY_SOL = "STORAGE_KEY_SOL"
  , MAX_FOR_URL = 50
  , NEAREST_VALUE = 1e-4
  , SOLANA_OWNER = "11111111111111111111111111111111"
  , WS_PING_INTERVAL = 1e4
  , UNITS_CONSUMED_MULTIPLIER = 1.2
  , UNITS_CONSUMED = 14e5
  , DEBOUNCE_TIME_OUT = 400
  , DEFAULT_SLIPPAGE = "3.5"
  , blackHoleAddress = "1nc1nerator11111111111111111111111111111111"
  , __vite_import_meta_env__$3 = {}
  , isSelfAtom = (_e, $) => _e.unstable_is ? _e.unstable_is($) : $ === _e
  , hasInitialValue = _e => "init"in _e
  , isActuallyWritableAtom = _e => !!_e.write
  , isAtomStateInitialized = _e => "v"in _e || "e"in _e
  , returnAtomValue = _e => {
    if ("e"in _e)
        throw _e.e;
    if ((__vite_import_meta_env__$3 ? "production" : void 0) !== "production" && !("v"in _e))
        throw new Error("[Bug] atom state is not initialized");
    return _e.v
}
  , PROMISE_STATE = Symbol()
  , getPromiseState = _e => _e[PROMISE_STATE]
  , isPendingPromise = _e => {
    var $;
    return isPromiseLike$2(_e) && !(($ = getPromiseState(_e)) != null && $[1])
}
  , cancelPromise = (_e, $) => {
    const et = getPromiseState(_e);
    if (et)
        et[1] = !0,
        et[0].forEach(tt => tt($));
    else if ((__vite_import_meta_env__$3 ? "production" : void 0) !== "production")
        throw new Error("[Bug] cancelable promise not found")
}
  , patchPromiseForCancelability = _e => {
    if (getPromiseState(_e))
        return;
    const $ = [new Set, !1];
    _e[PROMISE_STATE] = $;
    const et = () => {
        $[1] = !0
    }
    ;
    _e.then(et, et),
    _e.onCancel = tt => {
        $[0].add(tt)
    }
}
  , isPromiseLike$2 = _e => typeof (_e == null ? void 0 : _e.then) == "function"
  , addPendingPromiseToDependency = (_e, $, et) => {
    et.p.has(_e) || (et.p.add(_e),
    $.then( () => {
        et.p.delete(_e)
    }
    , () => {
        et.p.delete(_e)
    }
    ))
}
  , setAtomStateValueOrPromise = (_e, $, et) => {
    const tt = et(_e)
      , nt = "v"in tt
      , rt = tt.v
      , it = isPendingPromise(tt.v) ? tt.v : null;
    if (isPromiseLike$2($)) {
        patchPromiseForCancelability($);
        for (const ot of tt.d.keys())
            addPendingPromiseToDependency(_e, $, et(ot))
    }
    tt.v = $,
    delete tt.e,
    (!nt || !Object.is(rt, tt.v)) && (++tt.n,
    it && cancelPromise(it, $))
}
  , getMountedOrPendingDependents = (_e, $, et) => {
    var tt;
    const nt = new Set;
    for (const rt of ((tt = et.get(_e)) == null ? void 0 : tt.t) || [])
        et.has(rt) && nt.add(rt);
    for (const rt of $.p)
        nt.add(rt);
    return nt
}
  , createStoreHook = () => {
    const _e = new Set
      , $ = () => {
        _e.forEach(et => et())
    }
    ;
    return $.add = et => (_e.add(et),
    () => {
        _e.delete(et)
    }
    ),
    $
}
  , createStoreHookForAtoms = () => {
    const _e = {}
      , $ = new WeakMap
      , et = tt => {
        var nt, rt;
        (nt = $.get(_e)) == null || nt.forEach(it => it(tt)),
        (rt = $.get(tt)) == null || rt.forEach(it => it())
    }
    ;
    return et.add = (tt, nt) => {
        const rt = tt || _e
          , it = ($.has(rt) ? $ : $.set(rt, new Set)).get(rt);
        return it.add(nt),
        () => {
            it == null || it.delete(nt),
            it.size || $.delete(rt)
        }
    }
    ,
    et
}
  , initializeStoreHooks = _e => (_e.c || (_e.c = createStoreHookForAtoms()),
_e.m || (_e.m = createStoreHookForAtoms()),
_e.u || (_e.u = createStoreHookForAtoms()),
_e.f || (_e.f = createStoreHook()),
_e)
  , BUILDING_BLOCKS = Symbol()
  , buildStore = (_e=new WeakMap, $=new WeakMap, et=new WeakMap, tt=new Set, nt=new Set, rt=new Set, it={}, ot= (pt, ...ht) => pt.read(...ht), st= (pt, ...ht) => pt.write(...ht), lt= (pt, ht) => {
    var mt;
    return (mt = pt.unstable_onInit) == null ? void 0 : mt.call(pt, ht)
}
, ct= (pt, ht) => {
    var mt;
    return (mt = pt.onMount) == null ? void 0 : mt.call(pt, ht)
}
, ...dt) => {
    const pt = dt[0] || (kt => {
        if ((__vite_import_meta_env__$3 ? "production" : void 0) !== "production" && !kt)
            throw new Error("Atom is undefined or null");
        let Ut = _e.get(kt);
        return Ut || (Ut = {
            d: new Map,
            p: new Set,
            n: 0
        },
        _e.set(kt, Ut),
        lt == null || lt(kt, Lt)),
        Ut
    }
    )
      , ht = dt[1] || ( () => {
        let kt, Ut;
        const Jt = Pt => {
            try {
                Pt()
            } catch (Xt) {
                kt || (kt = !0,
                Ut = Xt)
            }
        }
        ;
        do {
            it.f && Jt(it.f);
            const Pt = new Set
              , Xt = Pt.add.bind(Pt);
            tt.forEach(rn => {
                var zt;
                return (zt = $.get(rn)) == null ? void 0 : zt.l.forEach(Xt)
            }
            ),
            tt.clear(),
            rt.forEach(Xt),
            rt.clear(),
            nt.forEach(Xt),
            nt.clear(),
            Pt.forEach(Jt),
            tt.size && mt()
        } while (tt.size || rt.size || nt.size);
        if (kt)
            throw Ut
    }
    )
      , mt = dt[2] || ( () => {
        const kt = []
          , Ut = new WeakSet
          , Jt = new WeakSet
          , Pt = Array.from(tt);
        for (; Pt.length; ) {
            const Xt = Pt[Pt.length - 1]
              , rn = pt(Xt);
            if (Jt.has(Xt)) {
                Pt.pop();
                continue
            }
            if (Ut.has(Xt)) {
                if (et.get(Xt) === rn.n)
                    kt.push([Xt, rn]);
                else if ((__vite_import_meta_env__$3 ? "production" : void 0) !== "production" && et.has(Xt))
                    throw new Error("[Bug] invalidated atom exists");
                Jt.add(Xt),
                Pt.pop();
                continue
            }
            Ut.add(Xt);
            for (const zt of getMountedOrPendingDependents(Xt, rn, $))
                Ut.has(zt) || Pt.push(zt)
        }
        for (let Xt = kt.length - 1; Xt >= 0; --Xt) {
            const [rn,zt] = kt[Xt];
            let xt = !1;
            for (const $t of zt.d.keys())
                if ($t !== rn && tt.has($t)) {
                    xt = !0;
                    break
                }
            xt && (yt(rn),
            wt(rn)),
            et.delete(rn)
        }
    }
    )
      , yt = dt[3] || (kt => {
        var Ut, Jt;
        const Pt = pt(kt);
        if (isAtomStateInitialized(Pt) && ($.has(kt) && et.get(kt) !== Pt.n || Array.from(Pt.d).every( ([Ft,Ht]) => yt(Ft).n === Ht)))
            return Pt;
        Pt.d.clear();
        let Xt = !0;
        const rn = () => {
            $.has(kt) && (wt(kt),
            mt(),
            ht())
        }
          , zt = Ft => {
            var Ht;
            if (isSelfAtom(kt, Ft)) {
                const Wt = pt(Ft);
                if (!isAtomStateInitialized(Wt))
                    if (hasInitialValue(Ft))
                        setAtomStateValueOrPromise(Ft, Ft.init, pt);
                    else
                        throw new Error("no atom init");
                return returnAtomValue(Wt)
            }
            const qt = yt(Ft);
            try {
                return returnAtomValue(qt)
            } finally {
                Pt.d.set(Ft, qt.n),
                isPendingPromise(Pt.v) && addPendingPromiseToDependency(kt, Pt.v, qt),
                (Ht = $.get(Ft)) == null || Ht.t.add(kt),
                Xt || rn()
            }
        }
        ;
        let xt, $t;
        const Dt = {
            get signal() {
                return xt || (xt = new AbortController),
                xt.signal
            },
            get setSelf() {
                return (__vite_import_meta_env__$3 ? "production" : void 0) !== "production" && isActuallyWritableAtom(kt),
                !$t && isActuallyWritableAtom(kt) && ($t = (...Ft) => {
                    if (!Xt)
                        try {
                            return _t(kt, ...Ft)
                        } finally {
                            mt(),
                            ht()
                        }
                }
                ),
                $t
            }
        }
          , jt = Pt.n;
        try {
            const Ft = ot(kt, zt, Dt);
            return setAtomStateValueOrPromise(kt, Ft, pt),
            isPromiseLike$2(Ft) && ((Ut = Ft.onCancel) == null || Ut.call(Ft, () => xt == null ? void 0 : xt.abort()),
            Ft.then(rn, rn)),
            Pt
        } catch (Ft) {
            return delete Pt.v,
            Pt.e = Ft,
            ++Pt.n,
            Pt
        } finally {
            Xt = !1,
            jt !== Pt.n && et.get(kt) === jt && (et.set(kt, Pt.n),
            tt.add(kt),
            (Jt = it.c) == null || Jt.call(it, kt))
        }
    }
    )
      , Et = dt[4] || (kt => {
        const Ut = [kt];
        for (; Ut.length; ) {
            const Jt = Ut.pop()
              , Pt = pt(Jt);
            for (const Xt of getMountedOrPendingDependents(Jt, Pt, $)) {
                const rn = pt(Xt);
                et.set(Xt, rn.n),
                Ut.push(Xt)
            }
        }
    }
    )
      , _t = dt[5] || ( (kt, ...Ut) => {
        let Jt = !0;
        const Pt = rn => returnAtomValue(yt(rn))
          , Xt = (rn, ...zt) => {
            var xt;
            const $t = pt(rn);
            try {
                if (isSelfAtom(kt, rn)) {
                    if (!hasInitialValue(rn))
                        throw new Error("atom not writable");
                    const Dt = $t.n
                      , jt = zt[0];
                    setAtomStateValueOrPromise(rn, jt, pt),
                    wt(rn),
                    Dt !== $t.n && (tt.add(rn),
                    (xt = it.c) == null || xt.call(it, rn),
                    Et(rn));
                    return
                } else
                    return _t(rn, ...zt)
            } finally {
                Jt || (mt(),
                ht())
            }
        }
        ;
        try {
            return st(kt, Pt, Xt, ...Ut)
        } finally {
            Jt = !1
        }
    }
    )
      , wt = dt[6] || (kt => {
        var Ut;
        const Jt = pt(kt)
          , Pt = $.get(kt);
        if (Pt && !isPendingPromise(Jt.v)) {
            for (const [Xt,rn] of Jt.d)
                if (!Pt.d.has(Xt)) {
                    const zt = pt(Xt);
                    St(Xt).t.add(kt),
                    Pt.d.add(Xt),
                    rn !== zt.n && (tt.add(Xt),
                    (Ut = it.c) == null || Ut.call(it, Xt),
                    Et(Xt))
                }
            for (const Xt of Pt.d || [])
                if (!Jt.d.has(Xt)) {
                    Pt.d.delete(Xt);
                    const rn = Ct(Xt);
                    rn == null || rn.t.delete(kt)
                }
        }
    }
    )
      , St = dt[7] || (kt => {
        var Ut;
        const Jt = pt(kt);
        let Pt = $.get(kt);
        if (!Pt) {
            yt(kt);
            for (const Xt of Jt.d.keys())
                St(Xt).t.add(kt);
            if (Pt = {
                l: new Set,
                d: new Set(Jt.d.keys()),
                t: new Set
            },
            $.set(kt, Pt),
            (Ut = it.m) == null || Ut.call(it, kt),
            isActuallyWritableAtom(kt)) {
                const Xt = () => {
                    let rn = !0;
                    const zt = (...xt) => {
                        try {
                            return _t(kt, ...xt)
                        } finally {
                            rn || (mt(),
                            ht())
                        }
                    }
                    ;
                    try {
                        const xt = ct(kt, zt);
                        xt && (Pt.u = () => {
                            rn = !0;
                            try {
                                xt()
                            } finally {
                                rn = !1
                            }
                        }
                        )
                    } finally {
                        rn = !1
                    }
                }
                ;
                nt.add(Xt)
            }
        }
        return Pt
    }
    )
      , Ct = dt[8] || (kt => {
        var Ut;
        const Jt = pt(kt);
        let Pt = $.get(kt);
        if (Pt && !Pt.l.size && !Array.from(Pt.t).some(Xt => {
            var rn;
            return (rn = $.get(Xt)) == null ? void 0 : rn.d.has(kt)
        }
        )) {
            Pt.u && rt.add(Pt.u),
            Pt = void 0,
            $.delete(kt),
            (Ut = it.u) == null || Ut.call(it, kt);
            for (const Xt of Jt.d.keys()) {
                const rn = Ct(Xt);
                rn == null || rn.t.delete(kt)
            }
            return
        }
        return Pt
    }
    )
      , Nt = [_e, $, et, tt, nt, rt, it, ot, st, lt, ct, pt, ht, mt, yt, Et, _t, wt, St, Ct]
      , Lt = {
        get: kt => returnAtomValue(yt(kt)),
        set: (kt, ...Ut) => {
            try {
                return _t(kt, ...Ut)
            } finally {
                mt(),
                ht()
            }
        }
        ,
        sub: (kt, Ut) => {
            const Pt = St(kt).l;
            return Pt.add(Ut),
            ht(),
            () => {
                Pt.delete(Ut),
                Ct(kt),
                ht()
            }
        }
    };
    return Object.defineProperty(Lt, BUILDING_BLOCKS, {
        value: Nt
    }),
    Lt
}
  , INTERNAL_buildStoreRev1 = buildStore
  , INTERNAL_initializeStoreHooks = initializeStoreHooks
  , __vite_import_meta_env__$2 = {};
let keyCount = 0;
function atom(_e, $) {
    const et = `atom${++keyCount}`
      , tt = {
        toString() {
            return (__vite_import_meta_env__$2 ? "production" : void 0) !== "production" && this.debugLabel ? et + ":" + this.debugLabel : et
        }
    };
    return typeof _e == "function" ? tt.read = _e : (tt.init = _e,
    tt.read = defaultRead,
    tt.write = defaultWrite),
    $ && (tt.write = $),
    tt
}
function defaultRead(_e) {
    return _e(this)
}
function defaultWrite(_e, $, et) {
    return $(this, typeof et == "function" ? et(_e(this)) : et)
}
const createDevStoreRev4 = () => {
    let _e = 0;
    const $ = INTERNAL_initializeStoreHooks({})
      , et = new WeakMap
      , tt = new WeakMap
      , nt = INTERNAL_buildStoreRev1(et, tt, void 0, void 0, void 0, void 0, $, void 0, (ot, st, lt, ...ct) => _e ? lt(ot, ...ct) : ot.write(st, lt, ...ct))
      , rt = new Set;
    return $.m.add(void 0, ot => {
        rt.add(ot);
        const st = et.get(ot);
        st.m = tt.get(ot)
    }
    ),
    $.u.add(void 0, ot => {
        rt.delete(ot);
        const st = et.get(ot);
        delete st.m
    }
    ),
    Object.assign(nt, {
        dev4_get_internal_weak_map: () => et,
        dev4_get_mounted_atoms: () => rt,
        dev4_restore_atoms: ot => {
            const st = {
                read: () => null,
                write: (lt, ct) => {
                    ++_e;
                    try {
                        for (const [dt,pt] of ot)
                            "init"in dt && ct(dt, pt)
                    } finally {
                        --_e
                    }
                }
            };
            nt.set(st)
        }
    })
}
  , createStore$1 = () => (__vite_import_meta_env__$2 ? "production" : void 0) !== "production" ? createDevStoreRev4() : INTERNAL_buildStoreRev1();
let defaultStore;
const getDefaultStore = () => (defaultStore || (defaultStore = createStore$1(),
(__vite_import_meta_env__$2 ? "production" : void 0) !== "production" && (globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore),
globalThis.__JOTAI_DEFAULT_STORE__)),
defaultStore)
  , __vite_import_meta_env__$1 = {}
  , StoreContext = reactExports.createContext(void 0)
  , useStore$3 = _e => reactExports.useContext(StoreContext) || getDefaultStore()
  , isPromiseLike$1 = _e => typeof (_e == null ? void 0 : _e.then) == "function"
  , attachPromiseMeta = _e => {
    _e.status = "pending",
    _e.then($ => {
        _e.status = "fulfilled",
        _e.value = $
    }
    , $ => {
        _e.status = "rejected",
        _e.reason = $
    }
    )
}
  , use = React.use || (_e => {
    if (_e.status === "pending")
        throw _e;
    if (_e.status === "fulfilled")
        return _e.value;
    throw _e.status === "rejected" ? _e.reason : (attachPromiseMeta(_e),
    _e)
}
)
  , continuablePromiseMap = new WeakMap
  , createContinuablePromise = _e => {
    let $ = continuablePromiseMap.get(_e);
    return $ || ($ = new Promise( (et, tt) => {
        let nt = _e;
        const rt = st => lt => {
            nt === st && et(lt)
        }
          , it = st => lt => {
            nt === st && tt(lt)
        }
          , ot = st => {
            "onCancel"in st && typeof st.onCancel == "function" && st.onCancel(lt => {
                if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && lt === st)
                    throw new Error("[Bug] p is not updated even after cancelation");
                isPromiseLike$1(lt) ? (continuablePromiseMap.set(lt, $),
                nt = lt,
                lt.then(rt(lt), it(lt)),
                ot(lt)) : et(lt)
            }
            )
        }
        ;
        _e.then(rt(_e), it(_e)),
        ot(_e)
    }
    ),
    continuablePromiseMap.set(_e, $)),
    $
}
;
function useAtomValue(_e, $) {
    const et = useStore$3()
      , [[tt,nt,rt],it] = reactExports.useReducer(lt => {
        const ct = et.get(_e);
        return Object.is(lt[0], ct) && lt[1] === et && lt[2] === _e ? lt : [ct, et, _e]
    }
    , void 0, () => [et.get(_e), et, _e]);
    let ot = tt;
    if ((nt !== et || rt !== _e) && (it(),
    ot = et.get(_e)),
    reactExports.useEffect( () => {
        const lt = et.sub(_e, () => {
            it()
        }
        );
        return it(),
        lt
    }
    , [et, _e, void 0]),
    reactExports.useDebugValue(ot),
    isPromiseLike$1(ot)) {
        const lt = createContinuablePromise(ot);
        return use(lt)
    }
    return ot
}
function useSetAtom(_e, $) {
    const et = useStore$3();
    return reactExports.useCallback( (...nt) => {
        if ((__vite_import_meta_env__$1 ? "production" : void 0) !== "production" && !("write"in _e))
            throw new Error("not writable atom");
        return et.set(_e, ...nt)
    }
    , [et, _e])
}
const __vite_import_meta_env__ = {}
  , RESET = Symbol((__vite_import_meta_env__ ? "production" : void 0) !== "production" ? "RESET" : "")
  , isPromiseLike = _e => typeof (_e == null ? void 0 : _e.then) == "function";
function createJSONStorage$1(_e= () => {
    try {
        return window.localStorage
    } catch {
        return
    }
}
, $) {
    var et;
    let tt, nt;
    const rt = {
        getItem: (st, lt) => {
            var ct, dt;
            const pt = mt => {
                if (mt = mt || "",
                tt !== mt) {
                    try {
                        nt = JSON.parse(mt, $ == null ? void 0 : $.reviver)
                    } catch {
                        return lt
                    }
                    tt = mt
                }
                return nt
            }
              , ht = (dt = (ct = _e()) == null ? void 0 : ct.getItem(st)) != null ? dt : null;
            return isPromiseLike(ht) ? ht.then(pt) : pt(ht)
        }
        ,
        setItem: (st, lt) => {
            var ct;
            return (ct = _e()) == null ? void 0 : ct.setItem(st, JSON.stringify(lt, void 0))
        }
        ,
        removeItem: st => {
            var lt;
            return (lt = _e()) == null ? void 0 : lt.removeItem(st)
        }
    }
      , it = st => (lt, ct, dt) => st(lt, pt => {
        let ht;
        try {
            ht = JSON.parse(pt || "")
        } catch {
            ht = dt
        }
        ct(ht)
    }
    );
    let ot;
    try {
        ot = (et = _e()) == null ? void 0 : et.subscribe
    } catch {}
    return !ot && typeof window < "u" && typeof window.addEventListener == "function" && window.Storage && (ot = (st, lt) => {
        if (!(_e()instanceof window.Storage))
            return () => {}
            ;
        const ct = dt => {
            dt.storageArea === _e() && dt.key === st && lt(dt.newValue)
        }
        ;
        return window.addEventListener("storage", ct),
        () => {
            window.removeEventListener("storage", ct)
        }
    }
    ),
    ot && (rt.subscribe = it(ot)),
    rt
}
const defaultStorage = createJSONStorage$1();
function atomWithStorage(_e, $, et=defaultStorage, tt) {
    const nt = atom($);
    return (__vite_import_meta_env__ ? "production" : void 0) !== "production" && (nt.debugPrivate = !0),
    nt.onMount = it => {
        it(et.getItem(_e, $));
        let ot;
        return et.subscribe && (ot = et.subscribe(_e, it, $)),
        ot
    }
    ,
    atom(it => it(nt), (it, ot, st) => {
        const lt = typeof st == "function" ? st(it(nt)) : st;
        return lt === RESET ? (ot(nt, $),
        et.removeItem(_e)) : lt instanceof Promise ? lt.then(ct => (ot(nt, ct),
        et.setItem(_e, ct))) : (ot(nt, lt),
        et.setItem(_e, lt))
    }
    )
}
let e$1 = {
    data: ""
}
  , t$1 = _e => typeof window == "object" ? ((_e ? _e.querySelector("#_goober") : window._goober) || Object.assign((_e || document.head).appendChild(document.createElement("style")), {
    innerHTML: " ",
    id: "_goober"
})).firstChild : _e || e$1
  , l$1 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g
  , a = /\/\*[^]*?\*\/|  +/g
  , n$1 = /\n+/g
  , o = (_e, $) => {
    let et = ""
      , tt = ""
      , nt = "";
    for (let rt in _e) {
        let it = _e[rt];
        rt[0] == "@" ? rt[1] == "i" ? et = rt + " " + it + ";" : tt += rt[1] == "f" ? o(it, rt) : rt + "{" + o(it, rt[1] == "k" ? "" : $) + "}" : typeof it == "object" ? tt += o(it, $ ? $.replace(/([^,])+/g, ot => rt.replace(/([^,]*:\S+\([^)]*\))|([^,])+/g, st => /&/.test(st) ? st.replace(/&/g, ot) : ot ? ot + " " + st : st)) : rt) : it != null && (rt = /^--/.test(rt) ? rt : rt.replace(/[A-Z]/g, "-$&").toLowerCase(),
        nt += o.p ? o.p(rt, it) : rt + ":" + it + ";")
    }
    return et + ($ && nt ? $ + "{" + nt + "}" : nt) + tt
}
  , c$2 = {}
  , s = _e => {
    if (typeof _e == "object") {
        let $ = "";
        for (let et in _e)
            $ += et + s(_e[et]);
        return $
    }
    return _e
}
  , i$2 = (_e, $, et, tt, nt) => {
    let rt = s(_e)
      , it = c$2[rt] || (c$2[rt] = (st => {
        let lt = 0
          , ct = 11;
        for (; lt < st.length; )
            ct = 101 * ct + st.charCodeAt(lt++) >>> 0;
        return "go" + ct
    }
    )(rt));
    if (!c$2[it]) {
        let st = rt !== _e ? _e : (lt => {
            let ct, dt, pt = [{}];
            for (; ct = l$1.exec(lt.replace(a, "")); )
                ct[4] ? pt.shift() : ct[3] ? (dt = ct[3].replace(n$1, " ").trim(),
                pt.unshift(pt[0][dt] = pt[0][dt] || {})) : pt[0][ct[1]] = ct[2].replace(n$1, " ").trim();
            return pt[0]
        }
        )(_e);
        c$2[it] = o(nt ? {
            ["@keyframes " + it]: st
        } : st, et ? "" : "." + it)
    }
    let ot = et && c$2.g ? c$2.g : null;
    return et && (c$2.g = c$2[it]),
    ( (st, lt, ct, dt) => {
        dt ? lt.data = lt.data.replace(dt, st) : lt.data.indexOf(st) === -1 && (lt.data = ct ? st + lt.data : lt.data + st)
    }
    )(c$2[it], $, tt, ot),
    it
}
  , p$1 = (_e, $, et) => _e.reduce( (tt, nt, rt) => {
    let it = $[rt];
    if (it && it.call) {
        let ot = it(et)
          , st = ot && ot.props && ot.props.className || /^go/.test(ot) && ot;
        it = st ? "." + st : ot && typeof ot == "object" ? ot.props ? "" : o(ot, "") : ot === !1 ? "" : ot
    }
    return tt + nt + (it ?? "")
}
, "");
function u$1(_e) {
    let $ = this || {}
      , et = _e.call ? _e($.p) : _e;
    return i$2(et.unshift ? et.raw ? p$1(et, [].slice.call(arguments, 1), $.p) : et.reduce( (tt, nt) => Object.assign(tt, nt && nt.call ? nt($.p) : nt), {}) : et, t$1($.target), $.g, $.o, $.k)
}
let d$1, f$2, g$1;
u$1.bind({
    g: 1
});
let h$1 = u$1.bind({
    k: 1
});
function m$1(_e, $, et, tt) {
    o.p = $,
    d$1 = _e,
    f$2 = et,
    g$1 = tt
}
function j$1(_e, $) {
    let et = this || {};
    return function() {
        let tt = arguments;
        function nt(rt, it) {
            let ot = Object.assign({}, rt)
              , st = ot.className || nt.className;
            et.p = Object.assign({
                theme: f$2 && f$2()
            }, ot),
            et.o = / *go\d+/.test(st),
            ot.className = u$1.apply(et, tt) + (st ? " " + st : "");
            let lt = _e;
            return _e[0] && (lt = ot.as || _e,
            delete ot.as),
            g$1 && lt[0] && g$1(ot),
            d$1(lt, ot)
        }
        return nt
    }
}
var W = _e => typeof _e == "function"
  , f$1 = (_e, $) => W(_e) ? _e($) : _e
  , F = ( () => {
    let _e = 0;
    return () => (++_e).toString()
}
)()
  , A$1 = ( () => {
    let _e;
    return () => {
        if (_e === void 0 && typeof window < "u") {
            let $ = matchMedia("(prefers-reduced-motion: reduce)");
            _e = !$ || $.matches
        }
        return _e
    }
}
)()
  , Y = 20
  , U = (_e, $) => {
    switch ($.type) {
    case 0:
        return {
            ..._e,
            toasts: [$.toast, ..._e.toasts].slice(0, Y)
        };
    case 1:
        return {
            ..._e,
            toasts: _e.toasts.map(rt => rt.id === $.toast.id ? {
                ...rt,
                ...$.toast
            } : rt)
        };
    case 2:
        let {toast: et} = $;
        return U(_e, {
            type: _e.toasts.find(rt => rt.id === et.id) ? 1 : 0,
            toast: et
        });
    case 3:
        let {toastId: tt} = $;
        return {
            ..._e,
            toasts: _e.toasts.map(rt => rt.id === tt || tt === void 0 ? {
                ...rt,
                dismissed: !0,
                visible: !1
            } : rt)
        };
    case 4:
        return $.toastId === void 0 ? {
            ..._e,
            toasts: []
        } : {
            ..._e,
            toasts: _e.toasts.filter(rt => rt.id !== $.toastId)
        };
    case 5:
        return {
            ..._e,
            pausedAt: $.time
        };
    case 6:
        let nt = $.time - (_e.pausedAt || 0);
        return {
            ..._e,
            pausedAt: void 0,
            toasts: _e.toasts.map(rt => ({
                ...rt,
                pauseDuration: rt.pauseDuration + nt
            }))
        }
    }
}
  , P$1 = []
  , y$1 = {
    toasts: [],
    pausedAt: void 0
}
  , u = _e => {
    y$1 = U(y$1, _e),
    P$1.forEach($ => {
        $(y$1)
    }
    )
}
  , q$1 = {
    blank: 4e3,
    error: 4e3,
    success: 2e3,
    loading: 1 / 0,
    custom: 4e3
}
  , D = (_e={}) => {
    let[$,et] = reactExports.useState(y$1)
      , tt = reactExports.useRef(y$1);
    reactExports.useEffect( () => (tt.current !== y$1 && et(y$1),
    P$1.push(et),
    () => {
        let rt = P$1.indexOf(et);
        rt > -1 && P$1.splice(rt, 1)
    }
    ), []);
    let nt = $.toasts.map(rt => {
        var it, ot, st;
        return {
            ..._e,
            ..._e[rt.type],
            ...rt,
            removeDelay: rt.removeDelay || ((it = _e[rt.type]) == null ? void 0 : it.removeDelay) || (_e == null ? void 0 : _e.removeDelay),
            duration: rt.duration || ((ot = _e[rt.type]) == null ? void 0 : ot.duration) || (_e == null ? void 0 : _e.duration) || q$1[rt.type],
            style: {
                ..._e.style,
                ...(st = _e[rt.type]) == null ? void 0 : st.style,
                ...rt.style
            }
        }
    }
    );
    return {
        ...$,
        toasts: nt
    }
}
  , J = (_e, $="blank", et) => ({
    createdAt: Date.now(),
    visible: !0,
    dismissed: !1,
    type: $,
    ariaProps: {
        role: "status",
        "aria-live": "polite"
    },
    message: _e,
    pauseDuration: 0,
    ...et,
    id: (et == null ? void 0 : et.id) || F()
})
  , x$1 = _e => ($, et) => {
    let tt = J($, _e, et);
    return u({
        type: 2,
        toast: tt
    }),
    tt.id
}
  , c$1 = (_e, $) => x$1("blank")(_e, $);
c$1.error = x$1("error");
c$1.success = x$1("success");
c$1.loading = x$1("loading");
c$1.custom = x$1("custom");
c$1.dismiss = _e => {
    u({
        type: 3,
        toastId: _e
    })
}
;
c$1.remove = _e => u({
    type: 4,
    toastId: _e
});
c$1.promise = (_e, $, et) => {
    let tt = c$1.loading($.loading, {
        ...et,
        ...et == null ? void 0 : et.loading
    });
    return typeof _e == "function" && (_e = _e()),
    _e.then(nt => {
        let rt = $.success ? f$1($.success, nt) : void 0;
        return rt ? c$1.success(rt, {
            id: tt,
            ...et,
            ...et == null ? void 0 : et.success
        }) : c$1.dismiss(tt),
        nt
    }
    ).catch(nt => {
        let rt = $.error ? f$1($.error, nt) : void 0;
        rt ? c$1.error(rt, {
            id: tt,
            ...et,
            ...et == null ? void 0 : et.error
        }) : c$1.dismiss(tt)
    }
    ),
    _e
}
;
var K = (_e, $) => {
    u({
        type: 1,
        toast: {
            id: _e,
            height: $
        }
    })
}
  , X = () => {
    u({
        type: 5,
        time: Date.now()
    })
}
  , b$1 = new Map
  , Z = 1e3
  , ee = (_e, $=Z) => {
    if (b$1.has(_e))
        return;
    let et = setTimeout( () => {
        b$1.delete(_e),
        u({
            type: 4,
            toastId: _e
        })
    }
    , $);
    b$1.set(_e, et)
}
  , O = _e => {
    let {toasts: $, pausedAt: et} = D(_e);
    reactExports.useEffect( () => {
        if (et)
            return;
        let rt = Date.now()
          , it = $.map(ot => {
            if (ot.duration === 1 / 0)
                return;
            let st = (ot.duration || 0) + ot.pauseDuration - (rt - ot.createdAt);
            if (st < 0) {
                ot.visible && c$1.dismiss(ot.id);
                return
            }
            return setTimeout( () => c$1.dismiss(ot.id), st)
        }
        );
        return () => {
            it.forEach(ot => ot && clearTimeout(ot))
        }
    }
    , [$, et]);
    let tt = reactExports.useCallback( () => {
        et && u({
            type: 6,
            time: Date.now()
        })
    }
    , [et])
      , nt = reactExports.useCallback( (rt, it) => {
        let {reverseOrder: ot=!1, gutter: st=8, defaultPosition: lt} = it || {}
          , ct = $.filter(ht => (ht.position || lt) === (rt.position || lt) && ht.height)
          , dt = ct.findIndex(ht => ht.id === rt.id)
          , pt = ct.filter( (ht, mt) => mt < dt && ht.visible).length;
        return ct.filter(ht => ht.visible).slice(...ot ? [pt + 1] : [0, pt]).reduce( (ht, mt) => ht + (mt.height || 0) + st, 0)
    }
    , [$]);
    return reactExports.useEffect( () => {
        $.forEach(rt => {
            if (rt.dismissed)
                ee(rt.id, rt.removeDelay);
            else {
                let it = b$1.get(rt.id);
                it && (clearTimeout(it),
                b$1.delete(rt.id))
            }
        }
        )
    }
    , [$]),
    {
        toasts: $,
        handlers: {
            updateHeight: K,
            startPause: X,
            endPause: tt,
            calculateOffset: nt
        }
    }
}
  , oe = h$1`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`
  , re = h$1`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`
  , se = h$1`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`
  , k$2 = j$1("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${_e => _e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${oe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${re} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${_e => _e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${se} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`
  , ne = h$1`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`
  , V = j$1("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${_e => _e.secondary || "#e0e0e0"};
  border-right-color: ${_e => _e.primary || "#616161"};
  animation: ${ne} 1s linear infinite;
`
  , pe = h$1`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`
  , de = h$1`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`
  , _ = j$1("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${_e => _e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${pe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${de} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${_e => _e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`
  , ue = j$1("div")`
  position: absolute;
`
  , le = j$1("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`
  , fe = h$1`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`
  , Te = j$1("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${fe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`
  , M = ({toast: _e}) => {
    let {icon: $, type: et, iconTheme: tt} = _e;
    return $ !== void 0 ? typeof $ == "string" ? reactExports.createElement(Te, null, $) : $ : et === "blank" ? null : reactExports.createElement(le, null, reactExports.createElement(V, {
        ...tt
    }), et !== "loading" && reactExports.createElement(ue, null, et === "error" ? reactExports.createElement(k$2, {
        ...tt
    }) : reactExports.createElement(_, {
        ...tt
    })))
}
  , ye = _e => `
0% {transform: translate3d(0,${_e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`
  , ge = _e => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${_e * -150}%,-1px) scale(.6); opacity:0;}
`
  , he = "0%{opacity:0;} 100%{opacity:1;}"
  , xe = "0%{opacity:1;} 100%{opacity:0;}"
  , be = j$1("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`
  , Se = j$1("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`
  , Ae = (_e, $) => {
    let et = _e.includes("top") ? 1 : -1
      , [tt,nt] = A$1() ? [he, xe] : [ye(et), ge(et)];
    return {
        animation: $ ? `${h$1(tt)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${h$1(nt)} 0.4s forwards cubic-bezier(.06,.71,.55,1)`
    }
}
  , C = reactExports.memo( ({toast: _e, position: $, style: et, children: tt}) => {
    let nt = _e.height ? Ae(_e.position || $ || "top-center", _e.visible) : {
        opacity: 0
    }
      , rt = reactExports.createElement(M, {
        toast: _e
    })
      , it = reactExports.createElement(Se, {
        ..._e.ariaProps
    }, f$1(_e.message, _e));
    return reactExports.createElement(be, {
        className: _e.className,
        style: {
            ...nt,
            ...et,
            ..._e.style
        }
    }, typeof tt == "function" ? tt({
        icon: rt,
        message: it
    }) : reactExports.createElement(reactExports.Fragment, null, rt, it))
}
);
m$1(reactExports.createElement);
var ve = ({id: _e, className: $, style: et, onHeightUpdate: tt, children: nt}) => {
    let rt = reactExports.useCallback(it => {
        if (it) {
            let ot = () => {
                let st = it.getBoundingClientRect().height;
                tt(_e, st)
            }
            ;
            ot(),
            new MutationObserver(ot).observe(it, {
                subtree: !0,
                childList: !0,
                characterData: !0
            })
        }
    }
    , [_e, tt]);
    return reactExports.createElement("div", {
        ref: rt,
        className: $,
        style: et
    }, nt)
}
  , Ee = (_e, $) => {
    let et = _e.includes("top")
      , tt = et ? {
        top: 0
    } : {
        bottom: 0
    }
      , nt = _e.includes("center") ? {
        justifyContent: "center"
    } : _e.includes("right") ? {
        justifyContent: "flex-end"
    } : {};
    return {
        left: 0,
        right: 0,
        display: "flex",
        position: "absolute",
        transition: A$1() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)",
        transform: `translateY(${$ * (et ? 1 : -1)}px)`,
        ...tt,
        ...nt
    }
}
  , De = u$1`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`
  , R = 16
  , Oe = ({reverseOrder: _e, position: $="top-center", toastOptions: et, gutter: tt, children: nt, containerStyle: rt, containerClassName: it}) => {
    let {toasts: ot, handlers: st} = O(et);
    return reactExports.createElement("div", {
        id: "_rht_toaster",
        style: {
            position: "fixed",
            zIndex: 9999,
            top: R,
            left: R,
            right: R,
            bottom: R,
            pointerEvents: "none",
            ...rt
        },
        className: it,
        onMouseEnter: st.startPause,
        onMouseLeave: st.endPause
    }, ot.map(lt => {
        let ct = lt.position || $
          , dt = st.calculateOffset(lt, {
            reverseOrder: _e,
            gutter: tt,
            defaultPosition: $
        })
          , pt = Ee(ct, dt);
        return reactExports.createElement(ve, {
            id: lt.id,
            key: lt.id,
            onHeightUpdate: st.updateHeight,
            className: lt.visible ? De : "",
            style: pt
        }, lt.type === "custom" ? f$1(lt.message, lt) : nt ? nt(lt) : reactExports.createElement(C, {
            toast: lt,
            position: ct
        }))
    }
    ))
}
  , Vt = c$1;
const defaultClusters = [{
    name: ClusterNetwork.Mainnet,
    endpoint: "https://mainnet.helius-rpc.com/?api-key=b1a83427-6f4f-4c28-9461-58fa53dd5a60",
    network: ClusterNetwork.Mainnet
}, {
    name: "devnet",
    endpoint: clusterApiUrl("devnet"),
    network: ClusterNetwork.Devnet
}, {
    name: "local",
    endpoint: "http://localhost:8899"
}, {
    name: "testnet",
    endpoint: clusterApiUrl("testnet"),
    network: ClusterNetwork.Testnet
}]
  , clusterAtom = atomWithStorage("solana-cluster", Env_Mode.DEV === "production" ? defaultClusters[1] : defaultClusters[0])
  , clustersAtom = atomWithStorage("solana-clusters", defaultClusters)
  , activeClustersAtom = atom(_e => {
    const $ = _e(clustersAtom)
      , et = _e(clusterAtom);
    return $.map(tt => ({
        ...tt,
        active: tt.name === et.name
    }))
}
)
  , activeClusterAtom = atom(_e => {
    const $ = _e(activeClustersAtom);
    return $.find(et => et.active) || $[0]
}
)
  , Context = reactExports.createContext({});
function ClusterProvider({children: _e}) {
    const $ = useAtomValue(activeClusterAtom)
      , et = useAtomValue(activeClustersAtom)
      , tt = useSetAtom(clusterAtom)
      , nt = useSetAtom(clustersAtom)
      , rt = {
        cluster: $,
        clusters: et.sort( (it, ot) => it.name > ot.name ? 1 : -1),
        addCluster: it => {
            try {
                new Connection(it.endpoint),
                nt([...et, it])
            } catch (ot) {
                Vt.error(`${ot}`)
            }
        }
        ,
        deleteCluster: it => {
            nt(et.filter(ot => ot.name !== it.name))
        }
        ,
        setCluster: it => tt(it),
        getExplorerUrl: it => `https://solscan.io/${it}${getClusterUrlParam($)}`
    };
    return jsxRuntimeExports.jsx(Context.Provider, {
        value: rt,
        children: _e
    })
}
function useCluster() {
    return reactExports.useContext(Context)
}
function getClusterUrlParam(_e) {
    let $ = "";
    switch (_e.network) {
    case ClusterNetwork.Devnet:
        $ = "devnet";
        break;
    case ClusterNetwork.Mainnet:
        $ = "";
        break;
    case ClusterNetwork.Testnet:
        $ = "testnet";
        break;
    default:
        $ = `custom&customUrl=${encodeURIComponent(_e.endpoint)}`;
        break
    }
    return $.length ? `?cluster=${$}` : ""
}
const tagRe = /<([a-zA-Z0-9]+)>(.*?)<\/\1>|<([a-zA-Z0-9]+)\/>/
  , nlRe = /(?:\r\n|\r|\n)/g
  , voidElementTags = {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0,
    menuitem: !0
};
function formatElements(_e, $={}) {
    const et = makeCounter(0, "$lingui$")
      , tt = _e.replace(nlRe, "").split(tagRe);
    if (tt.length === 1)
        return _e;
    const nt = []
      , rt = tt.shift();
    rt && nt.push(rt);
    for (const [it,ot,st] of getElements(tt)) {
        let lt = typeof it < "u" ? $[it] : void 0;
        (!lt || voidElementTags[lt.type] && ot) && (lt = React.createElement(React.Fragment)),
        Array.isArray(lt) && (lt = React.createElement(React.Fragment, {}, lt)),
        nt.push(React.cloneElement(lt, {
            key: et()
        }, ot ? formatElements(ot, $) : lt.props.children)),
        st && nt.push(st)
    }
    return nt.length === 1 ? nt[0] : nt
}
function getElements(_e) {
    if (!_e.length)
        return [];
    const [$,et,tt,nt] = _e.slice(0, 4);
    return [[$ || tt, et || "", nt]].concat(getElements(_e.slice(4, _e.length)))
}
const makeCounter = (_e=0, $="") => () => `${$}_${_e++}`;
function TransNoContext(_e) {
    const {render: $, component: et, id: tt, message: nt, formats: rt, lingui: {i18n: it, defaultComponent: ot}} = _e
      , st = {
        ..._e.values
    }
      , lt = {
        ..._e.components
    };
    st && Object.keys(st).forEach(yt => {
        const Et = st[yt];
        if (!(React.isValidElement(Et) || Array.isArray(Et) && Et.every(React.isValidElement)))
            return;
        const wt = Object.keys(lt).length;
        lt[wt] = Et,
        st[yt] = `<${wt}/>`
    }
    );
    const ct = it && typeof it._ == "function" ? it._(tt, st, {
        message: nt,
        formats: rt
    }) : tt
      , dt = ct ? formatElements(ct, lt) : null;
    if ($ === null || et === null)
        return dt;
    const pt = ot || RenderFragment
      , ht = {
        id: tt,
        message: nt,
        translation: dt,
        isTranslated: tt !== dt && nt !== dt,
        children: dt
    };
    if (!($ && et)) {
        if (!($ && typeof $ != "function")) {
            if (et && typeof et != "function")
                return React.createElement(pt, ht, dt)
        }
    }
    if (typeof $ == "function")
        return $(ht);
    const mt = et || pt;
    return React.createElement(mt, ht, dt)
}
const RenderFragment = ({children: _e}) => React.createElement(React.Fragment, null, _e)
  , LinguiContext = React.createContext(null)
  , useLinguiInternal = _e => React.useContext(LinguiContext)
  , I18nProvider = ({i18n: _e, defaultComponent: $, children: et}) => {
    const tt = React.useRef(_e.locale)
      , nt = React.useCallback( () => ({
        i18n: _e,
        defaultComponent: $,
        _: _e.t.bind(_e)
    }), [_e, $])
      , [rt,it] = React.useState(nt());
    return React.useEffect( () => {
        const ot = () => {
            tt.current = _e.locale,
            it(nt())
        }
          , st = _e.on("change", ot);
        return tt.current !== _e.locale && ot(),
        st
    }
    , [_e, nt]),
    tt.current ? React.createElement(LinguiContext.Provider, {
        value: rt
    }, et) : null
}
;
function Trans(_e) {
    const $ = useLinguiInternal();
    return React.createElement(TransNoContext, {
        ..._e,
        lingui: $
    })
}
var dist$4 = {}
  , errors$1 = {};
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.errorMessages = _e.ErrorType = void 0;
    var $;
    (function(et) {
        et.MalformedUnicode = "MALFORMED_UNICODE",
        et.MalformedHexadecimal = "MALFORMED_HEXADECIMAL",
        et.CodePointLimit = "CODE_POINT_LIMIT",
        et.OctalDeprecation = "OCTAL_DEPRECATION",
        et.EndOfString = "END_OF_STRING"
    }
    )($ = _e.ErrorType || (_e.ErrorType = {})),
    _e.errorMessages = new Map([[$.MalformedUnicode, "malformed Unicode character escape sequence"], [$.MalformedHexadecimal, "malformed hexadecimal character escape sequence"], [$.CodePointLimit, "Unicode codepoint must not be greater than 0x10FFFF in escape sequence"], [$.OctalDeprecation, '"0"-prefixed octal literals and octal escape sequences are deprecated; for octal literals use the "0o" prefix instead'], [$.EndOfString, "malformed escape sequence at end of string"]])
}
)(errors$1);
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.unraw = _e.errorMessages = _e.ErrorType = void 0;
    const $ = errors$1;
    Object.defineProperty(_e, "ErrorType", {
        enumerable: !0,
        get: function() {
            return $.ErrorType
        }
    }),
    Object.defineProperty(_e, "errorMessages", {
        enumerable: !0,
        get: function() {
            return $.errorMessages
        }
    });
    function et(ht) {
        return !ht.match(/[^a-f0-9]/i) ? parseInt(ht, 16) : NaN
    }
    function tt(ht, mt, yt) {
        const Et = et(ht);
        if (Number.isNaN(Et) || yt !== void 0 && yt !== ht.length)
            throw new SyntaxError($.errorMessages.get(mt));
        return Et
    }
    function nt(ht) {
        const mt = tt(ht, $.ErrorType.MalformedHexadecimal, 2);
        return String.fromCharCode(mt)
    }
    function rt(ht, mt) {
        const yt = tt(ht, $.ErrorType.MalformedUnicode, 4);
        if (mt !== void 0) {
            const Et = tt(mt, $.ErrorType.MalformedUnicode, 4);
            return String.fromCharCode(yt, Et)
        }
        return String.fromCharCode(yt)
    }
    function it(ht) {
        return ht.charAt(0) === "{" && ht.charAt(ht.length - 1) === "}"
    }
    function ot(ht) {
        if (!it(ht))
            throw new SyntaxError($.errorMessages.get($.ErrorType.MalformedUnicode));
        const mt = ht.slice(1, -1)
          , yt = tt(mt, $.ErrorType.MalformedUnicode);
        try {
            return String.fromCodePoint(yt)
        } catch (Et) {
            throw Et instanceof RangeError ? new SyntaxError($.errorMessages.get($.ErrorType.CodePointLimit)) : Et
        }
    }
    function st(ht, mt=!1) {
        if (mt)
            throw new SyntaxError($.errorMessages.get($.ErrorType.OctalDeprecation));
        const yt = parseInt(ht, 8);
        return String.fromCharCode(yt)
    }
    const lt = new Map([["b", "\b"], ["f", "\f"], ["n", `
`], ["r", "\r"], ["t", "	"], ["v", "\v"], ["0", "\0"]]);
    function ct(ht) {
        return lt.get(ht) || ht
    }
    const dt = /\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;
    function pt(ht, mt=!1) {
        return ht.replace(dt, function(yt, Et, _t, wt, St, Ct, Nt, Lt, kt) {
            if (Et !== void 0)
                return "\\";
            if (_t !== void 0)
                return nt(_t);
            if (wt !== void 0)
                return ot(wt);
            if (St !== void 0)
                return rt(St, Ct);
            if (Nt !== void 0)
                return rt(Nt);
            if (Lt === "0")
                return "\0";
            if (Lt !== void 0)
                return st(Lt, !mt);
            if (kt !== void 0)
                return ct(kt);
            throw new SyntaxError($.errorMessages.get($.ErrorType.EndOfString))
        })
    }
    _e.unraw = pt,
    _e.default = pt
}
)(dist$4);
const isString$3 = _e => typeof _e == "string"
  , isFunction$7 = _e => typeof _e == "function"
  , cache = new Map
  , defaultLocale = "en";
function normalizeLocales(_e) {
    return [...Array.isArray(_e) ? _e : [_e], defaultLocale]
}
function date$1(_e, $, et) {
    const tt = normalizeLocales(_e);
    return getMemoized( () => cacheKey("date", tt, et), () => new Intl.DateTimeFormat(tt,et)).format(isString$3($) ? new Date($) : $)
}
function number$2(_e, $, et) {
    const tt = normalizeLocales(_e);
    return getMemoized( () => cacheKey("number", tt, et), () => new Intl.NumberFormat(tt,et)).format($)
}
function plural(_e, $, et, {offset: tt=0, ...nt}) {
    const rt = normalizeLocales(_e)
      , it = $ ? getMemoized( () => cacheKey("plural-ordinal", rt), () => new Intl.PluralRules(rt,{
        type: "ordinal"
    })) : getMemoized( () => cacheKey("plural-cardinal", rt), () => new Intl.PluralRules(rt,{
        type: "cardinal"
    }));
    return nt[et] ?? nt[it.select(et - tt)] ?? nt.other
}
function getMemoized(_e, $) {
    const et = _e();
    let tt = cache.get(et);
    return tt || (tt = $(),
    cache.set(et, tt)),
    tt
}
function cacheKey(_e, $, et) {
    const tt = $.join("-");
    return `${_e}-${tt}-${JSON.stringify(et)}`
}
const UNICODE_REGEX = /\\u[a-fA-F0-9]{4}|\\x[a-fA-F0-9]{2}/
  , OCTOTHORPE_PH = "%__lingui_octothorpe__%"
  , getDefaultFormats = (_e, $, et={}) => {
    const tt = $ || _e
      , nt = it => typeof it == "object" ? it : et[it] || {
        style: it
    }
      , rt = (it, ot) => {
        const st = Object.keys(et).length ? nt("number") : void 0
          , lt = number$2(tt, it, st);
        return ot.replace(new RegExp(OCTOTHORPE_PH,"g"), lt)
    }
    ;
    return {
        plural: (it, ot) => {
            const {offset: st=0} = ot
              , lt = plural(tt, !1, it, ot);
            return rt(it - st, lt)
        }
        ,
        selectordinal: (it, ot) => {
            const {offset: st=0} = ot
              , lt = plural(tt, !0, it, ot);
            return rt(it - st, lt)
        }
        ,
        select: selectFormatter,
        number: (it, ot) => number$2(tt, it, nt(ot)),
        date: (it, ot) => date$1(tt, it, nt(ot))
    }
}
  , selectFormatter = (_e, $) => $[_e] ?? $.other;
function interpolate(_e, $, et) {
    return (tt={}, nt) => {
        const rt = getDefaultFormats($, et, nt)
          , it = (st, lt=!1) => Array.isArray(st) ? st.reduce( (ct, dt) => {
            if (dt === "#" && lt)
                return ct + OCTOTHORPE_PH;
            if (isString$3(dt))
                return ct + dt;
            const [pt,ht,mt] = dt;
            let yt = {};
            ht === "plural" || ht === "selectordinal" || ht === "select" ? Object.entries(mt).forEach( ([_t,wt]) => {
                yt[_t] = it(wt, ht === "plural" || ht === "selectordinal")
            }
            ) : yt = mt;
            let Et;
            if (ht) {
                const _t = rt[ht];
                Et = _t(tt[pt], yt)
            } else
                Et = tt[pt];
            return Et == null ? ct : ct + Et
        }
        , "") : st
          , ot = it(_e);
        return isString$3(ot) && UNICODE_REGEX.test(ot) ? dist$4.unraw(ot.trim()) : isString$3(ot) ? ot.trim() : ot ? String(ot) : ""
    }
}
var __defProp$1 = Object.defineProperty
  , __defNormalProp$1 = (_e, $, et) => $ in _e ? __defProp$1(_e, $, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: et
}) : _e[$] = et
  , __publicField$1 = (_e, $, et) => (__defNormalProp$1(_e, $ + "", et),
et);
let EventEmitter$1 = class {
    constructor() {
        __publicField$1(this, "_events", {})
    }
    on($, et) {
        var tt;
        return (tt = this._events)[$] ?? (tt[$] = []),
        this._events[$].push(et),
        () => this.removeListener($, et)
    }
    removeListener($, et) {
        const tt = this._getListeners($);
        if (!tt)
            return;
        const nt = tt.indexOf(et);
        ~nt && tt.splice(nt, 1)
    }
    emit($, ...et) {
        const tt = this._getListeners($);
        tt && tt.map(nt => nt.apply(this, et))
    }
    _getListeners($) {
        const et = this._events[$];
        return Array.isArray(et) ? et : !1
    }
}
;
var __defProp = Object.defineProperty
  , __defNormalProp = (_e, $, et) => $ in _e ? __defProp(_e, $, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: et
}) : _e[$] = et
  , __publicField = (_e, $, et) => (__defNormalProp(_e, typeof $ != "symbol" ? $ + "" : $, et),
et);
class I18n extends EventEmitter$1 {
    constructor($) {
        super(),
        __publicField(this, "_locale", ""),
        __publicField(this, "_locales"),
        __publicField(this, "_localeData", {}),
        __publicField(this, "_messages", {}),
        __publicField(this, "_missing"),
        __publicField(this, "t", this._.bind(this)),
        $.missing != null && (this._missing = $.missing),
        $.messages != null && this.load($.messages),
        $.localeData != null && this.loadLocaleData($.localeData),
        (typeof $.locale == "string" || $.locales) && this.activate($.locale ?? defaultLocale, $.locales)
    }
    get locale() {
        return this._locale
    }
    get locales() {
        return this._locales
    }
    get messages() {
        return this._messages[this._locale] ?? {}
    }
    get localeData() {
        return this._localeData[this._locale] ?? {}
    }
    _loadLocaleData($, et) {
        const tt = this._localeData[$];
        tt ? Object.assign(tt, et) : this._localeData[$] = et
    }
    loadLocaleData($, et) {
        et != null ? this._loadLocaleData($, et) : Object.keys($).forEach(tt => this._loadLocaleData(tt, $[tt])),
        this.emit("change")
    }
    _load($, et) {
        const tt = this._messages[$];
        tt ? Object.assign(tt, et) : this._messages[$] = et
    }
    load($, et) {
        typeof $ == "string" && typeof et == "object" ? this._load($, et) : Object.entries($).forEach( ([tt,nt]) => this._load(tt, nt)),
        this.emit("change")
    }
    loadAndActivate({locale: $, locales: et, messages: tt}) {
        this._locale = $,
        this._locales = et || void 0,
        this._messages[this._locale] = tt,
        this.emit("change")
    }
    activate($, et) {
        this._locale = $,
        this._locales = et,
        this.emit("change")
    }
    _($, et, tt) {
        let nt = tt == null ? void 0 : tt.message;
        $ || ($ = ""),
        isString$3($) || (et = $.values || et,
        nt = $.message,
        $ = $.id);
        const rt = this.messages[$]
          , it = rt === void 0
          , ot = this._missing;
        if (ot && it)
            return isFunction$7(ot) ? ot(this._locale, $) : ot;
        it && this.emit("missing", {
            id: $,
            locale: this._locale
        });
        let st = rt || nt || $;
        return isString$3(st) && UNICODE_REGEX.test(st) ? JSON.parse(`"${st}"`) : isString$3(st) ? st : interpolate(st, this._locale, this._locales)(et, tt == null ? void 0 : tt.formats)
    }
    date($, et) {
        return date$1(this._locales || this._locale, $, et)
    }
    number($, et) {
        return number$2(this._locales || this._locale, $, et)
    }
}
function setupI18n(_e={}) {
    return new I18n(_e)
}
const i18n = setupI18n();
var camelcase = {
    exports: {}
};
const UPPERCASE = /[\p{Lu}]/u
  , LOWERCASE = /[\p{Ll}]/u
  , LEADING_CAPITAL = /^[\p{Lu}](?![\p{Lu}])/gu
  , IDENTIFIER = /([\p{Alpha}\p{N}_]|$)/u
  , SEPARATORS = /[_.\- ]+/
  , LEADING_SEPARATORS = new RegExp("^" + SEPARATORS.source)
  , SEPARATORS_AND_IDENTIFIER = new RegExp(SEPARATORS.source + IDENTIFIER.source,"gu")
  , NUMBERS_AND_IDENTIFIER = new RegExp("\\d+" + IDENTIFIER.source,"gu")
  , preserveCamelCase = (_e, $, et) => {
    let tt = !1
      , nt = !1
      , rt = !1;
    for (let it = 0; it < _e.length; it++) {
        const ot = _e[it];
        tt && UPPERCASE.test(ot) ? (_e = _e.slice(0, it) + "-" + _e.slice(it),
        tt = !1,
        rt = nt,
        nt = !0,
        it++) : nt && rt && LOWERCASE.test(ot) ? (_e = _e.slice(0, it - 1) + "-" + _e.slice(it - 1),
        rt = nt,
        nt = !1,
        tt = !0) : (tt = $(ot) === ot && et(ot) !== ot,
        rt = nt,
        nt = et(ot) === ot && $(ot) !== ot)
    }
    return _e
}
  , preserveConsecutiveUppercase = (_e, $) => (LEADING_CAPITAL.lastIndex = 0,
_e.replace(LEADING_CAPITAL, et => $(et)))
  , postProcess = (_e, $) => (SEPARATORS_AND_IDENTIFIER.lastIndex = 0,
NUMBERS_AND_IDENTIFIER.lastIndex = 0,
_e.replace(SEPARATORS_AND_IDENTIFIER, (et, tt) => $(tt)).replace(NUMBERS_AND_IDENTIFIER, et => $(et)))
  , camelCase$1 = (_e, $) => {
    if (!(typeof _e == "string" || Array.isArray(_e)))
        throw new TypeError("Expected the input to be `string | string[]`");
    if ($ = {
        pascalCase: !1,
        preserveConsecutiveUppercase: !1,
        ...$
    },
    Array.isArray(_e) ? _e = _e.map(rt => rt.trim()).filter(rt => rt.length).join("-") : _e = _e.trim(),
    _e.length === 0)
        return "";
    const et = $.locale === !1 ? rt => rt.toLowerCase() : rt => rt.toLocaleLowerCase($.locale)
      , tt = $.locale === !1 ? rt => rt.toUpperCase() : rt => rt.toLocaleUpperCase($.locale);
    return _e.length === 1 ? $.pascalCase ? tt(_e) : et(_e) : (_e !== et(_e) && (_e = preserveCamelCase(_e, et, tt)),
    _e = _e.replace(LEADING_SEPARATORS, ""),
    $.preserveConsecutiveUppercase ? _e = preserveConsecutiveUppercase(_e, et) : _e = et(_e),
    $.pascalCase && (_e = tt(_e.charAt(0)) + _e.slice(1)),
    postProcess(_e, tt))
}
;
camelcase.exports = camelCase$1;
camelcase.exports.default = camelCase$1;
var camelcaseExports = camelcase.exports;
const camelCase$2 = getDefaultExportFromCjs$2(camelcaseExports);
var dist$3 = {}
  , Layout$2 = {};
let Layout$1 = class {
    constructor($, et) {
        if (!Number.isInteger($))
            throw new TypeError("span must be an integer");
        this.span = $,
        this.property = et
    }
    makeDestinationObject() {
        return {}
    }
    decode($, et) {
        throw new Error("Layout is abstract")
    }
    encode($, et, tt) {
        throw new Error("Layout is abstract")
    }
    getSpan($, et) {
        if (0 > this.span)
            throw new RangeError("indeterminate span");
        return this.span
    }
    replicate($) {
        const et = Object.create(this.constructor.prototype);
        return Object.assign(et, this),
        et.property = $,
        et
    }
    fromArray($) {}
}
;
Layout$2.Layout = Layout$1;
function nameWithProperty$1(_e, $) {
    return $.property ? _e + "[" + $.property + "]" : _e
}
Layout$2.nameWithProperty = nameWithProperty$1;
function bindConstructorLayout(_e, $) {
    if (typeof _e != "function")
        throw new TypeError("Class must be constructor");
    if (_e.hasOwnProperty("layout_"))
        throw new Error("Class is already bound to a layout");
    if (!($ && $ instanceof Layout$1))
        throw new TypeError("layout must be a Layout");
    if ($.hasOwnProperty("boundConstructor_"))
        throw new Error("layout is already bound to a constructor");
    _e.layout_ = $,
    $.boundConstructor_ = _e,
    $.makeDestinationObject = () => new _e,
    Object.defineProperty(_e.prototype, "encode", {
        value: function(et, tt) {
            return $.encode(this, et, tt)
        },
        writable: !0
    }),
    Object.defineProperty(_e, "decode", {
        value: function(et, tt) {
            return $.decode(et, tt)
        },
        writable: !0
    })
}
Layout$2.bindConstructorLayout = bindConstructorLayout;
let ExternalLayout$1 = class extends Layout$1 {
    isCount() {
        throw new Error("ExternalLayout is abstract")
    }
}
;
class GreedyCount extends ExternalLayout$1 {
    constructor($, et) {
        if ($ === void 0 && ($ = 1),
        !Number.isInteger($) || 0 >= $)
            throw new TypeError("elementSpan must be a (positive) integer");
        super(-1, et),
        this.elementSpan = $
    }
    isCount() {
        return !0
    }
    decode($, et) {
        et === void 0 && (et = 0);
        const tt = $.length - et;
        return Math.floor(tt / this.elementSpan)
    }
    encode($, et, tt) {
        return 0
    }
}
let OffsetLayout$1 = class extends ExternalLayout$1 {
    constructor($, et, tt) {
        if (!($ instanceof Layout$1))
            throw new TypeError("layout must be a Layout");
        if (et === void 0)
            et = 0;
        else if (!Number.isInteger(et))
            throw new TypeError("offset must be integer or undefined");
        super($.span, tt || $.property),
        this.layout = $,
        this.offset = et
    }
    isCount() {
        return this.layout instanceof UInt$1 || this.layout instanceof UIntBE$1
    }
    decode($, et) {
        return et === void 0 && (et = 0),
        this.layout.decode($, et + this.offset)
    }
    encode($, et, tt) {
        return tt === void 0 && (tt = 0),
        this.layout.encode($, et, tt + this.offset)
    }
}
  , UInt$1 = class extends Layout$1 {
    constructor($, et) {
        if (super($, et),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode($, et) {
        return et === void 0 && (et = 0),
        $.readUIntLE(et, this.span)
    }
    encode($, et, tt) {
        return tt === void 0 && (tt = 0),
        et.writeUIntLE($, tt, this.span),
        this.span
    }
}
  , UIntBE$1 = class extends Layout$1 {
    constructor($, et) {
        if (super($, et),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode($, et) {
        return et === void 0 && (et = 0),
        $.readUIntBE(et, this.span)
    }
    encode($, et, tt) {
        return tt === void 0 && (tt = 0),
        et.writeUIntBE($, tt, this.span),
        this.span
    }
}
;
class Int extends Layout$1 {
    constructor($, et) {
        if (super($, et),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode($, et) {
        return et === void 0 && (et = 0),
        $.readIntLE(et, this.span)
    }
    encode($, et, tt) {
        return tt === void 0 && (tt = 0),
        et.writeIntLE($, tt, this.span),
        this.span
    }
}
class IntBE extends Layout$1 {
    constructor($, et) {
        if (super($, et),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode($, et) {
        return et === void 0 && (et = 0),
        $.readIntBE(et, this.span)
    }
    encode($, et, tt) {
        return tt === void 0 && (tt = 0),
        et.writeIntBE($, tt, this.span),
        this.span
    }
}
const V2E32$1 = Math.pow(2, 32);
function divmodInt64$1(_e) {
    const $ = Math.floor(_e / V2E32$1)
      , et = _e - $ * V2E32$1;
    return {
        hi32: $,
        lo32: et
    }
}
function roundedInt64$1(_e, $) {
    return _e * V2E32$1 + $
}
let NearUInt64$1 = class extends Layout$1 {
    constructor($) {
        super(8, $)
    }
    decode($, et) {
        et === void 0 && (et = 0);
        const tt = $.readUInt32LE(et)
          , nt = $.readUInt32LE(et + 4);
        return roundedInt64$1(nt, tt)
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        const nt = divmodInt64$1($);
        return et.writeUInt32LE(nt.lo32, tt),
        et.writeUInt32LE(nt.hi32, tt + 4),
        8
    }
}
;
class NearUInt64BE extends Layout$1 {
    constructor($) {
        super(8, $)
    }
    decode($, et) {
        et === void 0 && (et = 0);
        const tt = $.readUInt32BE(et)
          , nt = $.readUInt32BE(et + 4);
        return roundedInt64$1(tt, nt)
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        const nt = divmodInt64$1($);
        return et.writeUInt32BE(nt.hi32, tt),
        et.writeUInt32BE(nt.lo32, tt + 4),
        8
    }
}
let NearInt64$1 = class extends Layout$1 {
    constructor($) {
        super(8, $)
    }
    decode($, et) {
        et === void 0 && (et = 0);
        const tt = $.readUInt32LE(et)
          , nt = $.readInt32LE(et + 4);
        return roundedInt64$1(nt, tt)
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        const nt = divmodInt64$1($);
        return et.writeUInt32LE(nt.lo32, tt),
        et.writeInt32LE(nt.hi32, tt + 4),
        8
    }
}
;
class NearInt64BE extends Layout$1 {
    constructor($) {
        super(8, $)
    }
    decode($, et) {
        et === void 0 && (et = 0);
        const tt = $.readInt32BE(et)
          , nt = $.readUInt32BE(et + 4);
        return roundedInt64$1(tt, nt)
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        const nt = divmodInt64$1($);
        return et.writeInt32BE(nt.hi32, tt),
        et.writeUInt32BE(nt.lo32, tt + 4),
        8
    }
}
class Float extends Layout$1 {
    constructor($) {
        super(4, $)
    }
    decode($, et) {
        return et === void 0 && (et = 0),
        $.readFloatLE(et)
    }
    encode($, et, tt) {
        return tt === void 0 && (tt = 0),
        et.writeFloatLE($, tt),
        4
    }
}
class FloatBE extends Layout$1 {
    constructor($) {
        super(4, $)
    }
    decode($, et) {
        return et === void 0 && (et = 0),
        $.readFloatBE(et)
    }
    encode($, et, tt) {
        return tt === void 0 && (tt = 0),
        et.writeFloatBE($, tt),
        4
    }
}
class Double extends Layout$1 {
    constructor($) {
        super(8, $)
    }
    decode($, et) {
        return et === void 0 && (et = 0),
        $.readDoubleLE(et)
    }
    encode($, et, tt) {
        return tt === void 0 && (tt = 0),
        et.writeDoubleLE($, tt),
        8
    }
}
class DoubleBE extends Layout$1 {
    constructor($) {
        super(8, $)
    }
    decode($, et) {
        return et === void 0 && (et = 0),
        $.readDoubleBE(et)
    }
    encode($, et, tt) {
        return tt === void 0 && (tt = 0),
        et.writeDoubleBE($, tt),
        8
    }
}
class Sequence extends Layout$1 {
    constructor($, et, tt) {
        if (!($ instanceof Layout$1))
            throw new TypeError("elementLayout must be a Layout");
        if (!(et instanceof ExternalLayout$1 && et.isCount() || Number.isInteger(et) && 0 <= et))
            throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
        let nt = -1;
        !(et instanceof ExternalLayout$1) && 0 < $.span && (nt = et * $.span),
        super(nt, tt),
        this.elementLayout = $,
        this.count = et
    }
    getSpan($, et) {
        if (0 <= this.span)
            return this.span;
        et === void 0 && (et = 0);
        let tt = 0
          , nt = this.count;
        if (nt instanceof ExternalLayout$1 && (nt = nt.decode($, et)),
        0 < this.elementLayout.span)
            tt = nt * this.elementLayout.span;
        else {
            let rt = 0;
            for (; rt < nt; )
                tt += this.elementLayout.getSpan($, et + tt),
                ++rt
        }
        return tt
    }
    decode($, et) {
        et === void 0 && (et = 0);
        const tt = [];
        let nt = 0
          , rt = this.count;
        for (rt instanceof ExternalLayout$1 && (rt = rt.decode($, et)); nt < rt; )
            tt.push(this.elementLayout.decode($, et)),
            et += this.elementLayout.getSpan($, et),
            nt += 1;
        return tt
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        const nt = this.elementLayout
          , rt = $.reduce( (it, ot) => it + nt.encode(ot, et, tt + it), 0);
        return this.count instanceof ExternalLayout$1 && this.count.encode($.length, et, tt),
        rt
    }
}
let Structure$1 = class extends Layout$1 {
    constructor($, et, tt) {
        if (!(Array.isArray($) && $.reduce( (rt, it) => rt && it instanceof Layout$1, !0)))
            throw new TypeError("fields must be array of Layout instances");
        typeof et == "boolean" && tt === void 0 && (tt = et,
        et = void 0);
        for (const rt of $)
            if (0 > rt.span && rt.property === void 0)
                throw new Error("fields cannot contain unnamed variable-length layout");
        let nt = -1;
        try {
            nt = $.reduce( (rt, it) => rt + it.getSpan(), 0)
        } catch {}
        super(nt, et),
        this.fields = $,
        this.decodePrefixes = !!tt
    }
    getSpan($, et) {
        if (0 <= this.span)
            return this.span;
        et === void 0 && (et = 0);
        let tt = 0;
        try {
            tt = this.fields.reduce( (nt, rt) => {
                const it = rt.getSpan($, et);
                return et += it,
                nt + it
            }
            , 0)
        } catch {
            throw new RangeError("indeterminate span")
        }
        return tt
    }
    decode($, et) {
        et === void 0 && (et = 0);
        const tt = this.makeDestinationObject();
        for (const nt of this.fields)
            if (nt.property !== void 0 && (tt[nt.property] = nt.decode($, et)),
            et += nt.getSpan($, et),
            this.decodePrefixes && $.length === et)
                break;
        return tt
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        const nt = tt;
        let rt = 0
          , it = 0;
        for (const ot of this.fields) {
            let st = ot.span;
            if (it = 0 < st ? st : 0,
            ot.property !== void 0) {
                const lt = $[ot.property];
                lt !== void 0 && (it = ot.encode(lt, et, tt),
                0 > st && (st = ot.getSpan(et, tt)))
            }
            rt = tt,
            tt += st
        }
        return rt + it - nt
    }
    fromArray($) {
        const et = this.makeDestinationObject();
        for (const tt of this.fields)
            tt.property !== void 0 && 0 < $.length && (et[tt.property] = $.shift());
        return et
    }
    layoutFor($) {
        if (typeof $ != "string")
            throw new TypeError("property must be string");
        for (const et of this.fields)
            if (et.property === $)
                return et
    }
    offsetOf($) {
        if (typeof $ != "string")
            throw new TypeError("property must be string");
        let et = 0;
        for (const tt of this.fields) {
            if (tt.property === $)
                return et;
            0 > tt.span ? et = -1 : 0 <= et && (et += tt.span)
        }
    }
}
  , UnionDiscriminator$1 = class {
    constructor($) {
        this.property = $
    }
    decode() {
        throw new Error("UnionDiscriminator is abstract")
    }
    encode() {
        throw new Error("UnionDiscriminator is abstract")
    }
}
  , UnionLayoutDiscriminator$1 = class extends UnionDiscriminator$1 {
    constructor($, et) {
        if (!($ instanceof ExternalLayout$1 && $.isCount()))
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
        super(et || $.property || "variant"),
        this.layout = $
    }
    decode($, et) {
        return this.layout.decode($, et)
    }
    encode($, et, tt) {
        return this.layout.encode($, et, tt)
    }
}
  , Union$1 = class extends Layout$1 {
    constructor($, et, tt) {
        const nt = $ instanceof UInt$1 || $ instanceof UIntBE$1;
        if (nt)
            $ = new UnionLayoutDiscriminator$1(new OffsetLayout$1($));
        else if ($ instanceof ExternalLayout$1 && $.isCount())
            $ = new UnionLayoutDiscriminator$1($);
        else if (!($ instanceof UnionDiscriminator$1))
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        if (et === void 0 && (et = null),
        !(et === null || et instanceof Layout$1))
            throw new TypeError("defaultLayout must be null or a Layout");
        if (et !== null) {
            if (0 > et.span)
                throw new Error("defaultLayout must have constant span");
            et.property === void 0 && (et = et.replicate("content"))
        }
        let rt = -1;
        et && (rt = et.span,
        0 <= rt && nt && (rt += $.layout.span)),
        super(rt, tt),
        this.discriminator = $,
        this.usesPrefixDiscriminator = nt,
        this.defaultLayout = et,
        this.registry = {};
        let it = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(ot) {
            return it(ot)
        }
        ,
        this.configGetSourceVariant = function(ot) {
            it = ot.bind(this)
        }
    }
    getSpan($, et) {
        if (0 <= this.span)
            return this.span;
        et === void 0 && (et = 0);
        const tt = this.getVariant($, et);
        if (!tt)
            throw new Error("unable to determine span for unrecognized variant");
        return tt.getSpan($, et)
    }
    defaultGetSourceVariant($) {
        if ($.hasOwnProperty(this.discriminator.property)) {
            if (this.defaultLayout && $.hasOwnProperty(this.defaultLayout.property))
                return;
            const et = this.registry[$[this.discriminator.property]];
            if (et && (!et.layout || $.hasOwnProperty(et.property)))
                return et
        } else
            for (const et in this.registry) {
                const tt = this.registry[et];
                if ($.hasOwnProperty(tt.property))
                    return tt
            }
        throw new Error("unable to infer src variant")
    }
    decode($, et) {
        et === void 0 && (et = 0);
        let tt;
        const nt = this.discriminator
          , rt = nt.decode($, et);
        let it = this.registry[rt];
        if (it === void 0) {
            let ot = 0;
            it = this.defaultLayout,
            this.usesPrefixDiscriminator && (ot = nt.layout.span),
            tt = this.makeDestinationObject(),
            tt[nt.property] = rt,
            tt[it.property] = this.defaultLayout.decode($, et + ot)
        } else
            tt = it.decode($, et);
        return tt
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        const nt = this.getSourceVariant($);
        if (nt === void 0) {
            const rt = this.discriminator
              , it = this.defaultLayout;
            let ot = 0;
            return this.usesPrefixDiscriminator && (ot = rt.layout.span),
            rt.encode($[rt.property], et, tt),
            ot + it.encode($[it.property], et, tt + ot)
        }
        return nt.encode($, et, tt)
    }
    addVariant($, et, tt) {
        const nt = new VariantLayout$1(this,$,et,tt);
        return this.registry[$] = nt,
        nt
    }
    getVariant($, et) {
        let tt = $;
        return Buffer$2.isBuffer($) && (et === void 0 && (et = 0),
        tt = this.discriminator.decode($, et)),
        this.registry[tt]
    }
}
  , VariantLayout$1 = class extends Layout$1 {
    constructor($, et, tt, nt) {
        if (!($ instanceof Union$1))
            throw new TypeError("union must be a Union");
        if (!Number.isInteger(et) || 0 > et)
            throw new TypeError("variant must be a (non-negative) integer");
        if (typeof tt == "string" && nt === void 0 && (nt = tt,
        tt = null),
        tt) {
            if (!(tt instanceof Layout$1))
                throw new TypeError("layout must be a Layout");
            if ($.defaultLayout !== null && 0 <= tt.span && tt.span > $.defaultLayout.span)
                throw new Error("variant span exceeds span of containing union");
            if (typeof nt != "string")
                throw new TypeError("variant must have a String property")
        }
        let rt = $.span;
        0 > $.span && (rt = tt ? tt.span : 0,
        0 <= rt && $.usesPrefixDiscriminator && (rt += $.discriminator.layout.span)),
        super(rt, nt),
        this.union = $,
        this.variant = et,
        this.layout = tt || null
    }
    getSpan($, et) {
        if (0 <= this.span)
            return this.span;
        et === void 0 && (et = 0);
        let tt = 0;
        return this.union.usesPrefixDiscriminator && (tt = this.union.discriminator.layout.span),
        tt + this.layout.getSpan($, et + tt)
    }
    decode($, et) {
        const tt = this.makeDestinationObject();
        if (et === void 0 && (et = 0),
        this !== this.union.getVariant($, et))
            throw new Error("variant mismatch");
        let nt = 0;
        return this.union.usesPrefixDiscriminator && (nt = this.union.discriminator.layout.span),
        this.layout ? tt[this.property] = this.layout.decode($, et + nt) : this.property ? tt[this.property] = !0 : this.union.usesPrefixDiscriminator && (tt[this.union.discriminator.property] = this.variant),
        tt
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        let nt = 0;
        if (this.union.usesPrefixDiscriminator && (nt = this.union.discriminator.layout.span),
        this.layout && !$.hasOwnProperty(this.property))
            throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, et, tt);
        let rt = nt;
        if (this.layout && (this.layout.encode($[this.property], et, tt + nt),
        rt += this.layout.getSpan(et, tt + nt),
        0 <= this.union.span && rt > this.union.span))
            throw new Error("encoded variant overruns containing union");
        return rt
    }
    fromArray($) {
        if (this.layout)
            return this.layout.fromArray($)
    }
}
;
function fixBitwiseResult(_e) {
    return 0 > _e && (_e += 4294967296),
    _e
}
class BitStructure extends Layout$1 {
    constructor($, et, tt) {
        if (!($ instanceof UInt$1 || $ instanceof UIntBE$1))
            throw new TypeError("word must be a UInt or UIntBE layout");
        if (typeof et == "string" && tt === void 0 && (tt = et,
        et = void 0),
        4 < $.span)
            throw new RangeError("word cannot exceed 32 bits");
        super($.span, tt),
        this.word = $,
        this.msb = !!et,
        this.fields = [];
        let nt = 0;
        this._packedSetValue = function(rt) {
            return nt = fixBitwiseResult(rt),
            this
        }
        ,
        this._packedGetValue = function() {
            return nt
        }
    }
    decode($, et) {
        const tt = this.makeDestinationObject();
        et === void 0 && (et = 0);
        const nt = this.word.decode($, et);
        this._packedSetValue(nt);
        for (const rt of this.fields)
            rt.property !== void 0 && (tt[rt.property] = rt.decode(nt));
        return tt
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        const nt = this.word.decode(et, tt);
        this._packedSetValue(nt);
        for (const rt of this.fields)
            if (rt.property !== void 0) {
                const it = $[rt.property];
                it !== void 0 && rt.encode(it)
            }
        return this.word.encode(this._packedGetValue(), et, tt)
    }
    addField($, et) {
        const tt = new BitField(this,$,et);
        return this.fields.push(tt),
        tt
    }
    addBoolean($) {
        const et = new Boolean$1(this,$);
        return this.fields.push(et),
        et
    }
    fieldFor($) {
        if (typeof $ != "string")
            throw new TypeError("property must be string");
        for (const et of this.fields)
            if (et.property === $)
                return et
    }
}
class BitField {
    constructor($, et, tt) {
        if (!($ instanceof BitStructure))
            throw new TypeError("container must be a BitStructure");
        if (!Number.isInteger(et) || 0 >= et)
            throw new TypeError("bits must be positive integer");
        const nt = 8 * $.span
          , rt = $.fields.reduce( (it, ot) => it + ot.bits, 0);
        if (et + rt > nt)
            throw new Error("bits too long for span remainder (" + (nt - rt) + " of " + nt + " remain)");
        this.container = $,
        this.bits = et,
        this.valueMask = (1 << et) - 1,
        et === 32 && (this.valueMask = 4294967295),
        this.start = rt,
        this.container.msb && (this.start = nt - rt - et),
        this.wordMask = fixBitwiseResult(this.valueMask << this.start),
        this.property = tt
    }
    decode() {
        const $ = this.container._packedGetValue();
        return fixBitwiseResult($ & this.wordMask) >>> this.start
    }
    encode($) {
        if (!Number.isInteger($) || $ !== fixBitwiseResult($ & this.valueMask))
            throw new TypeError(nameWithProperty$1("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
        const et = this.container._packedGetValue()
          , tt = fixBitwiseResult($ << this.start);
        this.container._packedSetValue(fixBitwiseResult(et & ~this.wordMask) | tt)
    }
}
let Boolean$1 = class extends BitField {
    constructor($, et) {
        super($, 1, et)
    }
    decode($, et) {
        return !!BitField.prototype.decode.call(this, $, et)
    }
    encode($) {
        return typeof $ == "boolean" && ($ = +$),
        BitField.prototype.encode.call(this, $)
    }
}
  , Blob$2 = class extends Layout$1 {
    constructor($, et) {
        if (!($ instanceof ExternalLayout$1 && $.isCount() || Number.isInteger($) && 0 <= $))
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        let tt = -1;
        $ instanceof ExternalLayout$1 || (tt = $),
        super(tt, et),
        this.length = $
    }
    getSpan($, et) {
        let tt = this.span;
        return 0 > tt && (tt = this.length.decode($, et)),
        tt
    }
    decode($, et) {
        et === void 0 && (et = 0);
        let tt = this.span;
        return 0 > tt && (tt = this.length.decode($, et)),
        $.slice(et, et + tt)
    }
    encode($, et, tt) {
        let nt = this.length;
        if (this.length instanceof ExternalLayout$1 && (nt = $.length),
        !(Buffer$2.isBuffer($) && nt === $.length))
            throw new TypeError(nameWithProperty$1("Blob.encode", this) + " requires (length " + nt + ") Buffer as src");
        if (tt + nt > et.length)
            throw new RangeError("encoding overruns Buffer");
        return et.write($.toString("hex"), tt, nt, "hex"),
        this.length instanceof ExternalLayout$1 && this.length.encode(nt, et, tt),
        nt
    }
}
;
class CString extends Layout$1 {
    constructor($) {
        super(-1, $)
    }
    getSpan($, et) {
        if (!Buffer$2.isBuffer($))
            throw new TypeError("b must be a Buffer");
        et === void 0 && (et = 0);
        let tt = et;
        for (; tt < $.length && $[tt] !== 0; )
            tt += 1;
        return 1 + tt - et
    }
    decode($, et, tt) {
        et === void 0 && (et = 0);
        let nt = this.getSpan($, et);
        return $.slice(et, et + nt - 1).toString("utf-8")
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0),
        typeof $ != "string" && ($ = $.toString());
        const nt = new Buffer$2($,"utf8")
          , rt = nt.length;
        if (tt + rt > et.length)
            throw new RangeError("encoding overruns Buffer");
        return nt.copy(et, tt),
        et[tt + rt] = 0,
        rt + 1
    }
}
class UTF8 extends Layout$1 {
    constructor($, et) {
        if (typeof $ == "string" && et === void 0 && (et = $,
        $ = void 0),
        $ === void 0)
            $ = -1;
        else if (!Number.isInteger($))
            throw new TypeError("maxSpan must be an integer");
        super(-1, et),
        this.maxSpan = $
    }
    getSpan($, et) {
        if (!Buffer$2.isBuffer($))
            throw new TypeError("b must be a Buffer");
        return et === void 0 && (et = 0),
        $.length - et
    }
    decode($, et, tt) {
        et === void 0 && (et = 0);
        let nt = this.getSpan($, et);
        if (0 <= this.maxSpan && this.maxSpan < nt)
            throw new RangeError("text length exceeds maxSpan");
        return $.slice(et, et + nt).toString("utf-8")
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0),
        typeof $ != "string" && ($ = $.toString());
        const nt = new Buffer$2($,"utf8")
          , rt = nt.length;
        if (0 <= this.maxSpan && this.maxSpan < rt)
            throw new RangeError("text length exceeds maxSpan");
        if (tt + rt > et.length)
            throw new RangeError("encoding overruns Buffer");
        return nt.copy(et, tt),
        rt
    }
}
class Constant extends Layout$1 {
    constructor($, et) {
        super(0, et),
        this.value = $
    }
    decode($, et, tt) {
        return this.value
    }
    encode($, et, tt) {
        return 0
    }
}
Layout$2.ExternalLayout = ExternalLayout$1;
Layout$2.GreedyCount = GreedyCount;
Layout$2.OffsetLayout = OffsetLayout$1;
Layout$2.UInt = UInt$1;
Layout$2.UIntBE = UIntBE$1;
Layout$2.Int = Int;
Layout$2.IntBE = IntBE;
Layout$2.Float = Float;
Layout$2.FloatBE = FloatBE;
Layout$2.Double = Double;
Layout$2.DoubleBE = DoubleBE;
Layout$2.Sequence = Sequence;
Layout$2.Structure = Structure$1;
Layout$2.UnionDiscriminator = UnionDiscriminator$1;
Layout$2.UnionLayoutDiscriminator = UnionLayoutDiscriminator$1;
Layout$2.Union = Union$1;
Layout$2.VariantLayout = VariantLayout$1;
Layout$2.BitStructure = BitStructure;
Layout$2.BitField = BitField;
Layout$2.Boolean = Boolean$1;
Layout$2.Blob = Blob$2;
Layout$2.CString = CString;
Layout$2.UTF8 = UTF8;
Layout$2.Constant = Constant;
Layout$2.greedy = (_e, $) => new GreedyCount(_e,$);
Layout$2.offset = (_e, $, et) => new OffsetLayout$1(_e,$,et);
Layout$2.u8 = _e => new UInt$1(1,_e);
Layout$2.u16 = _e => new UInt$1(2,_e);
Layout$2.u24 = _e => new UInt$1(3,_e);
Layout$2.u32 = _e => new UInt$1(4,_e);
Layout$2.u40 = _e => new UInt$1(5,_e);
Layout$2.u48 = _e => new UInt$1(6,_e);
Layout$2.nu64 = _e => new NearUInt64$1(_e);
Layout$2.u16be = _e => new UIntBE$1(2,_e);
Layout$2.u24be = _e => new UIntBE$1(3,_e);
Layout$2.u32be = _e => new UIntBE$1(4,_e);
Layout$2.u40be = _e => new UIntBE$1(5,_e);
Layout$2.u48be = _e => new UIntBE$1(6,_e);
Layout$2.nu64be = _e => new NearUInt64BE(_e);
Layout$2.s8 = _e => new Int(1,_e);
Layout$2.s16 = _e => new Int(2,_e);
Layout$2.s24 = _e => new Int(3,_e);
Layout$2.s32 = _e => new Int(4,_e);
Layout$2.s40 = _e => new Int(5,_e);
Layout$2.s48 = _e => new Int(6,_e);
Layout$2.ns64 = _e => new NearInt64$1(_e);
Layout$2.s16be = _e => new IntBE(2,_e);
Layout$2.s24be = _e => new IntBE(3,_e);
Layout$2.s32be = _e => new IntBE(4,_e);
Layout$2.s40be = _e => new IntBE(5,_e);
Layout$2.s48be = _e => new IntBE(6,_e);
Layout$2.ns64be = _e => new NearInt64BE(_e);
Layout$2.f32 = _e => new Float(_e);
Layout$2.f32be = _e => new FloatBE(_e);
Layout$2.f64 = _e => new Double(_e);
Layout$2.f64be = _e => new DoubleBE(_e);
Layout$2.struct = (_e, $, et) => new Structure$1(_e,$,et);
Layout$2.bits = (_e, $, et) => new BitStructure(_e,$,et);
Layout$2.seq = (_e, $, et) => new Sequence(_e,$,et);
Layout$2.union = (_e, $, et) => new Union$1(_e,$,et);
Layout$2.unionLayoutDiscriminator = (_e, $) => new UnionLayoutDiscriminator$1(_e,$);
Layout$2.blob = (_e, $) => new Blob$2(_e,$);
Layout$2.cstr = _e => new CString(_e);
Layout$2.utf8 = (_e, $) => new UTF8(_e,$);
Layout$2.const = (_e, $) => new Constant(_e,$);
const require$$5 = getAugmentedNamespace(index_browser_esm);
(function(_e) {
    var $ = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(rn) {
        return rn && rn.__esModule ? rn : {
            default: rn
        }
    }
    ;
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.map = _e.array = _e.rustEnum = _e.str = _e.vecU8 = _e.tagged = _e.vec = _e.bool = _e.option = _e.publicKey = _e.i256 = _e.u256 = _e.i128 = _e.u128 = _e.i64 = _e.u64 = _e.struct = _e.f64 = _e.f32 = _e.i32 = _e.u32 = _e.i16 = _e.u16 = _e.i8 = _e.u8 = void 0;
    const et = Layout$2
      , tt = require$$5
      , nt = $(bnExports);
    var rt = Layout$2;
    Object.defineProperty(_e, "u8", {
        enumerable: !0,
        get: function() {
            return rt.u8
        }
    }),
    Object.defineProperty(_e, "i8", {
        enumerable: !0,
        get: function() {
            return rt.s8
        }
    }),
    Object.defineProperty(_e, "u16", {
        enumerable: !0,
        get: function() {
            return rt.u16
        }
    }),
    Object.defineProperty(_e, "i16", {
        enumerable: !0,
        get: function() {
            return rt.s16
        }
    }),
    Object.defineProperty(_e, "u32", {
        enumerable: !0,
        get: function() {
            return rt.u32
        }
    }),
    Object.defineProperty(_e, "i32", {
        enumerable: !0,
        get: function() {
            return rt.s32
        }
    }),
    Object.defineProperty(_e, "f32", {
        enumerable: !0,
        get: function() {
            return rt.f32
        }
    }),
    Object.defineProperty(_e, "f64", {
        enumerable: !0,
        get: function() {
            return rt.f64
        }
    }),
    Object.defineProperty(_e, "struct", {
        enumerable: !0,
        get: function() {
            return rt.struct
        }
    });
    class it extends et.Layout {
        constructor(zt, xt, $t) {
            super(zt, $t),
            this.blob = (0,
            et.blob)(zt),
            this.signed = xt
        }
        decode(zt, xt=0) {
            const $t = new nt.default(this.blob.decode(zt, xt),10,"le");
            return this.signed ? $t.fromTwos(this.span * 8).clone() : $t
        }
        encode(zt, xt, $t=0) {
            return this.signed && (zt = zt.toTwos(this.span * 8)),
            this.blob.encode(zt.toArrayLike(Buffer$2, "le", this.span), xt, $t)
        }
    }
    function ot(rn) {
        return new it(8,!1,rn)
    }
    _e.u64 = ot;
    function st(rn) {
        return new it(8,!0,rn)
    }
    _e.i64 = st;
    function lt(rn) {
        return new it(16,!1,rn)
    }
    _e.u128 = lt;
    function ct(rn) {
        return new it(16,!0,rn)
    }
    _e.i128 = ct;
    function dt(rn) {
        return new it(32,!1,rn)
    }
    _e.u256 = dt;
    function pt(rn) {
        return new it(32,!0,rn)
    }
    _e.i256 = pt;
    class ht extends et.Layout {
        constructor(zt, xt, $t, Dt) {
            super(zt.span, Dt),
            this.layout = zt,
            this.decoder = xt,
            this.encoder = $t
        }
        decode(zt, xt) {
            return this.decoder(this.layout.decode(zt, xt))
        }
        encode(zt, xt, $t) {
            return this.layout.encode(this.encoder(zt), xt, $t)
        }
        getSpan(zt, xt) {
            return this.layout.getSpan(zt, xt)
        }
    }
    function mt(rn) {
        return new ht((0,
        et.blob)(32),zt => new tt.PublicKey(zt),zt => zt.toBuffer(),rn)
    }
    _e.publicKey = mt;
    class yt extends et.Layout {
        constructor(zt, xt) {
            super(-1, xt),
            this.layout = zt,
            this.discriminator = (0,
            et.u8)()
        }
        encode(zt, xt, $t=0) {
            return zt == null ? this.discriminator.encode(0, xt, $t) : (this.discriminator.encode(1, xt, $t),
            this.layout.encode(zt, xt, $t + 1) + 1)
        }
        decode(zt, xt=0) {
            const $t = this.discriminator.decode(zt, xt);
            if ($t === 0)
                return null;
            if ($t === 1)
                return this.layout.decode(zt, xt + 1);
            throw new Error("Invalid option " + this.property)
        }
        getSpan(zt, xt=0) {
            const $t = this.discriminator.decode(zt, xt);
            if ($t === 0)
                return 1;
            if ($t === 1)
                return this.layout.getSpan(zt, xt + 1) + 1;
            throw new Error("Invalid option " + this.property)
        }
    }
    function Et(rn, zt) {
        return new yt(rn,zt)
    }
    _e.option = Et;
    function _t(rn) {
        return new ht((0,
        et.u8)(),wt,St,rn)
    }
    _e.bool = _t;
    function wt(rn) {
        if (rn === 0)
            return !1;
        if (rn === 1)
            return !0;
        throw new Error("Invalid bool: " + rn)
    }
    function St(rn) {
        return rn ? 1 : 0
    }
    function Ct(rn, zt) {
        const xt = (0,
        et.u32)("length")
          , $t = (0,
        et.struct)([xt, (0,
        et.seq)(rn, (0,
        et.offset)(xt, -xt.span), "values")]);
        return new ht($t, ({values: Dt}) => Dt,Dt => ({
            values: Dt
        }),zt)
    }
    _e.vec = Ct;
    function Nt(rn, zt, xt) {
        const $t = (0,
        et.struct)([ot("tag"), zt.replicate("data")]);
        function Dt({tag: jt, data: Ft}) {
            if (!jt.eq(rn))
                throw new Error("Invalid tag, expected: " + rn.toString("hex") + ", got: " + jt.toString("hex"));
            return Ft
        }
        return new ht($t,Dt,jt => ({
            tag: rn,
            data: jt
        }),xt)
    }
    _e.tagged = Nt;
    function Lt(rn) {
        const zt = (0,
        et.u32)("length")
          , xt = (0,
        et.struct)([zt, (0,
        et.blob)((0,
        et.offset)(zt, -zt.span), "data")]);
        return new ht(xt, ({data: $t}) => $t,$t => ({
            data: $t
        }),rn)
    }
    _e.vecU8 = Lt;
    function kt(rn) {
        return new ht(Lt(),zt => zt.toString("utf-8"),zt => Buffer$2.from(zt, "utf-8"),rn)
    }
    _e.str = kt;
    function Ut(rn, zt, xt) {
        const $t = (0,
        et.union)(xt ?? (0,
        et.u8)(), zt);
        return rn.forEach( (Dt, jt) => $t.addVariant(jt, Dt, Dt.property)),
        $t
    }
    _e.rustEnum = Ut;
    function Jt(rn, zt, xt) {
        const $t = (0,
        et.struct)([(0,
        et.seq)(rn, zt, "values")]);
        return new ht($t, ({values: Dt}) => Dt,Dt => ({
            values: Dt
        }),xt)
    }
    _e.array = Jt;
    class Pt extends et.Layout {
        constructor(zt, xt, $t) {
            super(zt.span + xt.span, $t),
            this.keyLayout = zt,
            this.valueLayout = xt
        }
        decode(zt, xt) {
            xt = xt || 0;
            const $t = this.keyLayout.decode(zt, xt)
              , Dt = this.valueLayout.decode(zt, xt + this.keyLayout.getSpan(zt, xt));
            return [$t, Dt]
        }
        encode(zt, xt, $t) {
            $t = $t || 0;
            const Dt = this.keyLayout.encode(zt[0], xt, $t)
              , jt = this.valueLayout.encode(zt[1], xt, $t + Dt);
            return Dt + jt
        }
        getSpan(zt, xt) {
            return this.keyLayout.getSpan(zt, xt) + this.valueLayout.getSpan(zt, xt)
        }
    }
    function Xt(rn, zt, xt) {
        const $t = (0,
        et.u32)("length")
          , Dt = (0,
        et.struct)([$t, (0,
        et.seq)(new Pt(rn,zt), (0,
        et.offset)($t, -$t.span), "values")]);
        return new ht(Dt, ({values: jt}) => new Map(jt),jt => ({
            values: Array.from(jt.entries())
        }),xt)
    }
    _e.map = Xt
}
)(dist$3);
/*! pako 2.1.0 https://github.com/nodeca/pako @license (MIT AND Zlib) */
function zero$1(_e) {
    let $ = _e.length;
    for (; --$ >= 0; )
        _e[$] = 0
}
const MIN_MATCH$1 = 3
  , MAX_MATCH$1 = 258
  , LENGTH_CODES$1 = 29
  , LITERALS$1 = 256
  , L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1
  , D_CODES$1 = 30
  , DIST_CODE_LEN = 512
  , static_ltree = new Array((L_CODES$1 + 2) * 2);
zero$1(static_ltree);
const static_dtree = new Array(D_CODES$1 * 2);
zero$1(static_dtree);
const _dist_code = new Array(DIST_CODE_LEN);
zero$1(_dist_code);
const _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);
zero$1(_length_code);
const base_length = new Array(LENGTH_CODES$1);
zero$1(base_length);
const base_dist = new Array(D_CODES$1);
zero$1(base_dist);
const adler32 = (_e, $, et, tt) => {
    let nt = _e & 65535 | 0
      , rt = _e >>> 16 & 65535 | 0
      , it = 0;
    for (; et !== 0; ) {
        it = et > 2e3 ? 2e3 : et,
        et -= it;
        do
            nt = nt + $[tt++] | 0,
            rt = rt + nt | 0;
        while (--it);
        nt %= 65521,
        rt %= 65521
    }
    return nt | rt << 16 | 0
}
;
var adler32_1 = adler32;
const makeTable = () => {
    let _e, $ = [];
    for (var et = 0; et < 256; et++) {
        _e = et;
        for (var tt = 0; tt < 8; tt++)
            _e = _e & 1 ? 3988292384 ^ _e >>> 1 : _e >>> 1;
        $[et] = _e
    }
    return $
}
  , crcTable = new Uint32Array(makeTable())
  , crc32 = (_e, $, et, tt) => {
    const nt = crcTable
      , rt = tt + et;
    _e ^= -1;
    for (let it = tt; it < rt; it++)
        _e = _e >>> 8 ^ nt[(_e ^ $[it]) & 255];
    return _e ^ -1
}
;
var crc32_1 = crc32
  , messages$2 = {
    2: "need dictionary",
    1: "stream end",
    0: "",
    "-1": "file error",
    "-2": "stream error",
    "-3": "data error",
    "-4": "insufficient memory",
    "-5": "buffer error",
    "-6": "incompatible version"
}
  , constants$2 = {
    Z_NO_FLUSH: 0,
    Z_FINISH: 4,
    Z_BLOCK: 5,
    Z_TREES: 6,
    Z_OK: 0,
    Z_STREAM_END: 1,
    Z_NEED_DICT: 2,
    Z_STREAM_ERROR: -2,
    Z_DATA_ERROR: -3,
    Z_MEM_ERROR: -4,
    Z_BUF_ERROR: -5,
    Z_DEFLATED: 8
};
const _has$1 = (_e, $) => Object.prototype.hasOwnProperty.call(_e, $);
var assign$1 = function(_e) {
    const $ = Array.prototype.slice.call(arguments, 1);
    for (; $.length; ) {
        const et = $.shift();
        if (et) {
            if (typeof et != "object")
                throw new TypeError(et + "must be non-object");
            for (const tt in et)
                _has$1(et, tt) && (_e[tt] = et[tt])
        }
    }
    return _e
}
  , flattenChunks = _e => {
    let $ = 0;
    for (let tt = 0, nt = _e.length; tt < nt; tt++)
        $ += _e[tt].length;
    const et = new Uint8Array($);
    for (let tt = 0, nt = 0, rt = _e.length; tt < rt; tt++) {
        let it = _e[tt];
        et.set(it, nt),
        nt += it.length
    }
    return et
}
  , common$1 = {
    assign: assign$1,
    flattenChunks
};
let STR_APPLY_UIA_OK = !0;
try {
    String.fromCharCode.apply(null, new Uint8Array(1))
} catch {
    STR_APPLY_UIA_OK = !1
}
const _utf8len = new Uint8Array(256);
for (let _e = 0; _e < 256; _e++)
    _utf8len[_e] = _e >= 252 ? 6 : _e >= 248 ? 5 : _e >= 240 ? 4 : _e >= 224 ? 3 : _e >= 192 ? 2 : 1;
_utf8len[254] = _utf8len[254] = 1;
var string2buf = _e => {
    if (typeof TextEncoder == "function" && TextEncoder.prototype.encode)
        return new TextEncoder().encode(_e);
    let $, et, tt, nt, rt, it = _e.length, ot = 0;
    for (nt = 0; nt < it; nt++)
        et = _e.charCodeAt(nt),
        (et & 64512) === 55296 && nt + 1 < it && (tt = _e.charCodeAt(nt + 1),
        (tt & 64512) === 56320 && (et = 65536 + (et - 55296 << 10) + (tt - 56320),
        nt++)),
        ot += et < 128 ? 1 : et < 2048 ? 2 : et < 65536 ? 3 : 4;
    for ($ = new Uint8Array(ot),
    rt = 0,
    nt = 0; rt < ot; nt++)
        et = _e.charCodeAt(nt),
        (et & 64512) === 55296 && nt + 1 < it && (tt = _e.charCodeAt(nt + 1),
        (tt & 64512) === 56320 && (et = 65536 + (et - 55296 << 10) + (tt - 56320),
        nt++)),
        et < 128 ? $[rt++] = et : et < 2048 ? ($[rt++] = 192 | et >>> 6,
        $[rt++] = 128 | et & 63) : et < 65536 ? ($[rt++] = 224 | et >>> 12,
        $[rt++] = 128 | et >>> 6 & 63,
        $[rt++] = 128 | et & 63) : ($[rt++] = 240 | et >>> 18,
        $[rt++] = 128 | et >>> 12 & 63,
        $[rt++] = 128 | et >>> 6 & 63,
        $[rt++] = 128 | et & 63);
    return $
}
;
const buf2binstring = (_e, $) => {
    if ($ < 65534 && _e.subarray && STR_APPLY_UIA_OK)
        return String.fromCharCode.apply(null, _e.length === $ ? _e : _e.subarray(0, $));
    let et = "";
    for (let tt = 0; tt < $; tt++)
        et += String.fromCharCode(_e[tt]);
    return et
}
;
var buf2string = (_e, $) => {
    const et = $ || _e.length;
    if (typeof TextDecoder == "function" && TextDecoder.prototype.decode)
        return new TextDecoder().decode(_e.subarray(0, $));
    let tt, nt;
    const rt = new Array(et * 2);
    for (nt = 0,
    tt = 0; tt < et; ) {
        let it = _e[tt++];
        if (it < 128) {
            rt[nt++] = it;
            continue
        }
        let ot = _utf8len[it];
        if (ot > 4) {
            rt[nt++] = 65533,
            tt += ot - 1;
            continue
        }
        for (it &= ot === 2 ? 31 : ot === 3 ? 15 : 7; ot > 1 && tt < et; )
            it = it << 6 | _e[tt++] & 63,
            ot--;
        if (ot > 1) {
            rt[nt++] = 65533;
            continue
        }
        it < 65536 ? rt[nt++] = it : (it -= 65536,
        rt[nt++] = 55296 | it >> 10 & 1023,
        rt[nt++] = 56320 | it & 1023)
    }
    return buf2binstring(rt, nt)
}
  , utf8border = (_e, $) => {
    $ = $ || _e.length,
    $ > _e.length && ($ = _e.length);
    let et = $ - 1;
    for (; et >= 0 && (_e[et] & 192) === 128; )
        et--;
    return et < 0 || et === 0 ? $ : et + _utf8len[_e[et]] > $ ? et : $
}
  , strings = {
    string2buf,
    buf2string,
    utf8border
};
function ZStream() {
    this.input = null,
    this.next_in = 0,
    this.avail_in = 0,
    this.total_in = 0,
    this.output = null,
    this.next_out = 0,
    this.avail_out = 0,
    this.total_out = 0,
    this.msg = "",
    this.state = null,
    this.data_type = 2,
    this.adler = 0
}
var zstream = ZStream;
const BAD$1 = 16209
  , TYPE$1 = 16191;
var inffast = function($, et) {
    let tt, nt, rt, it, ot, st, lt, ct, dt, pt, ht, mt, yt, Et, _t, wt, St, Ct, Nt, Lt, kt, Ut, Jt, Pt;
    const Xt = $.state;
    tt = $.next_in,
    Jt = $.input,
    nt = tt + ($.avail_in - 5),
    rt = $.next_out,
    Pt = $.output,
    it = rt - (et - $.avail_out),
    ot = rt + ($.avail_out - 257),
    st = Xt.dmax,
    lt = Xt.wsize,
    ct = Xt.whave,
    dt = Xt.wnext,
    pt = Xt.window,
    ht = Xt.hold,
    mt = Xt.bits,
    yt = Xt.lencode,
    Et = Xt.distcode,
    _t = (1 << Xt.lenbits) - 1,
    wt = (1 << Xt.distbits) - 1;
    e: do {
        mt < 15 && (ht += Jt[tt++] << mt,
        mt += 8,
        ht += Jt[tt++] << mt,
        mt += 8),
        St = yt[ht & _t];
        t: for (; ; ) {
            if (Ct = St >>> 24,
            ht >>>= Ct,
            mt -= Ct,
            Ct = St >>> 16 & 255,
            Ct === 0)
                Pt[rt++] = St & 65535;
            else if (Ct & 16) {
                Nt = St & 65535,
                Ct &= 15,
                Ct && (mt < Ct && (ht += Jt[tt++] << mt,
                mt += 8),
                Nt += ht & (1 << Ct) - 1,
                ht >>>= Ct,
                mt -= Ct),
                mt < 15 && (ht += Jt[tt++] << mt,
                mt += 8,
                ht += Jt[tt++] << mt,
                mt += 8),
                St = Et[ht & wt];
                n: for (; ; ) {
                    if (Ct = St >>> 24,
                    ht >>>= Ct,
                    mt -= Ct,
                    Ct = St >>> 16 & 255,
                    Ct & 16) {
                        if (Lt = St & 65535,
                        Ct &= 15,
                        mt < Ct && (ht += Jt[tt++] << mt,
                        mt += 8,
                        mt < Ct && (ht += Jt[tt++] << mt,
                        mt += 8)),
                        Lt += ht & (1 << Ct) - 1,
                        Lt > st) {
                            $.msg = "invalid distance too far back",
                            Xt.mode = BAD$1;
                            break e
                        }
                        if (ht >>>= Ct,
                        mt -= Ct,
                        Ct = rt - it,
                        Lt > Ct) {
                            if (Ct = Lt - Ct,
                            Ct > ct && Xt.sane) {
                                $.msg = "invalid distance too far back",
                                Xt.mode = BAD$1;
                                break e
                            }
                            if (kt = 0,
                            Ut = pt,
                            dt === 0) {
                                if (kt += lt - Ct,
                                Ct < Nt) {
                                    Nt -= Ct;
                                    do
                                        Pt[rt++] = pt[kt++];
                                    while (--Ct);
                                    kt = rt - Lt,
                                    Ut = Pt
                                }
                            } else if (dt < Ct) {
                                if (kt += lt + dt - Ct,
                                Ct -= dt,
                                Ct < Nt) {
                                    Nt -= Ct;
                                    do
                                        Pt[rt++] = pt[kt++];
                                    while (--Ct);
                                    if (kt = 0,
                                    dt < Nt) {
                                        Ct = dt,
                                        Nt -= Ct;
                                        do
                                            Pt[rt++] = pt[kt++];
                                        while (--Ct);
                                        kt = rt - Lt,
                                        Ut = Pt
                                    }
                                }
                            } else if (kt += dt - Ct,
                            Ct < Nt) {
                                Nt -= Ct;
                                do
                                    Pt[rt++] = pt[kt++];
                                while (--Ct);
                                kt = rt - Lt,
                                Ut = Pt
                            }
                            for (; Nt > 2; )
                                Pt[rt++] = Ut[kt++],
                                Pt[rt++] = Ut[kt++],
                                Pt[rt++] = Ut[kt++],
                                Nt -= 3;
                            Nt && (Pt[rt++] = Ut[kt++],
                            Nt > 1 && (Pt[rt++] = Ut[kt++]))
                        } else {
                            kt = rt - Lt;
                            do
                                Pt[rt++] = Pt[kt++],
                                Pt[rt++] = Pt[kt++],
                                Pt[rt++] = Pt[kt++],
                                Nt -= 3;
                            while (Nt > 2);
                            Nt && (Pt[rt++] = Pt[kt++],
                            Nt > 1 && (Pt[rt++] = Pt[kt++]))
                        }
                    } else if (Ct & 64) {
                        $.msg = "invalid distance code",
                        Xt.mode = BAD$1;
                        break e
                    } else {
                        St = Et[(St & 65535) + (ht & (1 << Ct) - 1)];
                        continue n
                    }
                    break
                }
            } else if (Ct & 64)
                if (Ct & 32) {
                    Xt.mode = TYPE$1;
                    break e
                } else {
                    $.msg = "invalid literal/length code",
                    Xt.mode = BAD$1;
                    break e
                }
            else {
                St = yt[(St & 65535) + (ht & (1 << Ct) - 1)];
                continue t
            }
            break
        }
    } while (tt < nt && rt < ot);
    Nt = mt >> 3,
    tt -= Nt,
    mt -= Nt << 3,
    ht &= (1 << mt) - 1,
    $.next_in = tt,
    $.next_out = rt,
    $.avail_in = tt < nt ? 5 + (nt - tt) : 5 - (tt - nt),
    $.avail_out = rt < ot ? 257 + (ot - rt) : 257 - (rt - ot),
    Xt.hold = ht,
    Xt.bits = mt
};
const MAXBITS = 15
  , ENOUGH_LENS$1 = 852
  , ENOUGH_DISTS$1 = 592
  , CODES$1 = 0
  , LENS$1 = 1
  , DISTS$1 = 2
  , lbase = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0])
  , lext = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78])
  , dbase = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0])
  , dext = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64])
  , inflate_table = (_e, $, et, tt, nt, rt, it, ot) => {
    const st = ot.bits;
    let lt = 0, ct = 0, dt = 0, pt = 0, ht = 0, mt = 0, yt = 0, Et = 0, _t = 0, wt = 0, St, Ct, Nt, Lt, kt, Ut = null, Jt;
    const Pt = new Uint16Array(MAXBITS + 1)
      , Xt = new Uint16Array(MAXBITS + 1);
    let rn = null, zt, xt, $t;
    for (lt = 0; lt <= MAXBITS; lt++)
        Pt[lt] = 0;
    for (ct = 0; ct < tt; ct++)
        Pt[$[et + ct]]++;
    for (ht = st,
    pt = MAXBITS; pt >= 1 && Pt[pt] === 0; pt--)
        ;
    if (ht > pt && (ht = pt),
    pt === 0)
        return nt[rt++] = 1 << 24 | 64 << 16 | 0,
        nt[rt++] = 1 << 24 | 64 << 16 | 0,
        ot.bits = 1,
        0;
    for (dt = 1; dt < pt && Pt[dt] === 0; dt++)
        ;
    for (ht < dt && (ht = dt),
    Et = 1,
    lt = 1; lt <= MAXBITS; lt++)
        if (Et <<= 1,
        Et -= Pt[lt],
        Et < 0)
            return -1;
    if (Et > 0 && (_e === CODES$1 || pt !== 1))
        return -1;
    for (Xt[1] = 0,
    lt = 1; lt < MAXBITS; lt++)
        Xt[lt + 1] = Xt[lt] + Pt[lt];
    for (ct = 0; ct < tt; ct++)
        $[et + ct] !== 0 && (it[Xt[$[et + ct]]++] = ct);
    if (_e === CODES$1 ? (Ut = rn = it,
    Jt = 20) : _e === LENS$1 ? (Ut = lbase,
    rn = lext,
    Jt = 257) : (Ut = dbase,
    rn = dext,
    Jt = 0),
    wt = 0,
    ct = 0,
    lt = dt,
    kt = rt,
    mt = ht,
    yt = 0,
    Nt = -1,
    _t = 1 << ht,
    Lt = _t - 1,
    _e === LENS$1 && _t > ENOUGH_LENS$1 || _e === DISTS$1 && _t > ENOUGH_DISTS$1)
        return 1;
    for (; ; ) {
        zt = lt - yt,
        it[ct] + 1 < Jt ? (xt = 0,
        $t = it[ct]) : it[ct] >= Jt ? (xt = rn[it[ct] - Jt],
        $t = Ut[it[ct] - Jt]) : (xt = 96,
        $t = 0),
        St = 1 << lt - yt,
        Ct = 1 << mt,
        dt = Ct;
        do
            Ct -= St,
            nt[kt + (wt >> yt) + Ct] = zt << 24 | xt << 16 | $t | 0;
        while (Ct !== 0);
        for (St = 1 << lt - 1; wt & St; )
            St >>= 1;
        if (St !== 0 ? (wt &= St - 1,
        wt += St) : wt = 0,
        ct++,
        --Pt[lt] === 0) {
            if (lt === pt)
                break;
            lt = $[et + it[ct]]
        }
        if (lt > ht && (wt & Lt) !== Nt) {
            for (yt === 0 && (yt = ht),
            kt += dt,
            mt = lt - yt,
            Et = 1 << mt; mt + yt < pt && (Et -= Pt[mt + yt],
            !(Et <= 0)); )
                mt++,
                Et <<= 1;
            if (_t += 1 << mt,
            _e === LENS$1 && _t > ENOUGH_LENS$1 || _e === DISTS$1 && _t > ENOUGH_DISTS$1)
                return 1;
            Nt = wt & Lt,
            nt[Nt] = ht << 24 | mt << 16 | kt - rt | 0
        }
    }
    return wt !== 0 && (nt[kt + wt] = lt - yt << 24 | 64 << 16 | 0),
    ot.bits = ht,
    0
}
;
var inftrees = inflate_table;
const CODES = 0
  , LENS = 1
  , DISTS = 2
  , {Z_FINISH: Z_FINISH$1, Z_BLOCK, Z_TREES, Z_OK: Z_OK$1, Z_STREAM_END: Z_STREAM_END$1, Z_NEED_DICT: Z_NEED_DICT$1, Z_STREAM_ERROR: Z_STREAM_ERROR$1, Z_DATA_ERROR: Z_DATA_ERROR$1, Z_MEM_ERROR: Z_MEM_ERROR$1, Z_BUF_ERROR, Z_DEFLATED} = constants$2
  , HEAD = 16180
  , FLAGS = 16181
  , TIME = 16182
  , OS = 16183
  , EXLEN = 16184
  , EXTRA = 16185
  , NAME$1 = 16186
  , COMMENT$1 = 16187
  , HCRC = 16188
  , DICTID = 16189
  , DICT = 16190
  , TYPE = 16191
  , TYPEDO = 16192
  , STORED = 16193
  , COPY_ = 16194
  , COPY = 16195
  , TABLE = 16196
  , LENLENS = 16197
  , CODELENS = 16198
  , LEN_ = 16199
  , LEN = 16200
  , LENEXT = 16201
  , DIST = 16202
  , DISTEXT = 16203
  , MATCH$1 = 16204
  , LIT = 16205
  , CHECK = 16206
  , LENGTH$1 = 16207
  , DONE = 16208
  , BAD = 16209
  , MEM = 16210
  , SYNC = 16211
  , ENOUGH_LENS = 852
  , ENOUGH_DISTS = 592
  , MAX_WBITS = 15
  , DEF_WBITS = MAX_WBITS
  , zswap32 = _e => (_e >>> 24 & 255) + (_e >>> 8 & 65280) + ((_e & 65280) << 8) + ((_e & 255) << 24);
function InflateState() {
    this.strm = null,
    this.mode = 0,
    this.last = !1,
    this.wrap = 0,
    this.havedict = !1,
    this.flags = 0,
    this.dmax = 0,
    this.check = 0,
    this.total = 0,
    this.head = null,
    this.wbits = 0,
    this.wsize = 0,
    this.whave = 0,
    this.wnext = 0,
    this.window = null,
    this.hold = 0,
    this.bits = 0,
    this.length = 0,
    this.offset = 0,
    this.extra = 0,
    this.lencode = null,
    this.distcode = null,
    this.lenbits = 0,
    this.distbits = 0,
    this.ncode = 0,
    this.nlen = 0,
    this.ndist = 0,
    this.have = 0,
    this.next = null,
    this.lens = new Uint16Array(320),
    this.work = new Uint16Array(288),
    this.lendyn = null,
    this.distdyn = null,
    this.sane = 0,
    this.back = 0,
    this.was = 0
}
const inflateStateCheck = _e => {
    if (!_e)
        return 1;
    const $ = _e.state;
    return !$ || $.strm !== _e || $.mode < HEAD || $.mode > SYNC ? 1 : 0
}
  , inflateResetKeep = _e => {
    if (inflateStateCheck(_e))
        return Z_STREAM_ERROR$1;
    const $ = _e.state;
    return _e.total_in = _e.total_out = $.total = 0,
    _e.msg = "",
    $.wrap && (_e.adler = $.wrap & 1),
    $.mode = HEAD,
    $.last = 0,
    $.havedict = 0,
    $.flags = -1,
    $.dmax = 32768,
    $.head = null,
    $.hold = 0,
    $.bits = 0,
    $.lencode = $.lendyn = new Int32Array(ENOUGH_LENS),
    $.distcode = $.distdyn = new Int32Array(ENOUGH_DISTS),
    $.sane = 1,
    $.back = -1,
    Z_OK$1
}
  , inflateReset = _e => {
    if (inflateStateCheck(_e))
        return Z_STREAM_ERROR$1;
    const $ = _e.state;
    return $.wsize = 0,
    $.whave = 0,
    $.wnext = 0,
    inflateResetKeep(_e)
}
  , inflateReset2 = (_e, $) => {
    let et;
    if (inflateStateCheck(_e))
        return Z_STREAM_ERROR$1;
    const tt = _e.state;
    return $ < 0 ? (et = 0,
    $ = -$) : (et = ($ >> 4) + 5,
    $ < 48 && ($ &= 15)),
    $ && ($ < 8 || $ > 15) ? Z_STREAM_ERROR$1 : (tt.window !== null && tt.wbits !== $ && (tt.window = null),
    tt.wrap = et,
    tt.wbits = $,
    inflateReset(_e))
}
  , inflateInit2 = (_e, $) => {
    if (!_e)
        return Z_STREAM_ERROR$1;
    const et = new InflateState;
    _e.state = et,
    et.strm = _e,
    et.window = null,
    et.mode = HEAD;
    const tt = inflateReset2(_e, $);
    return tt !== Z_OK$1 && (_e.state = null),
    tt
}
  , inflateInit = _e => inflateInit2(_e, DEF_WBITS);
let virgin = !0, lenfix, distfix;
const fixedtables = _e => {
    if (virgin) {
        lenfix = new Int32Array(512),
        distfix = new Int32Array(32);
        let $ = 0;
        for (; $ < 144; )
            _e.lens[$++] = 8;
        for (; $ < 256; )
            _e.lens[$++] = 9;
        for (; $ < 280; )
            _e.lens[$++] = 7;
        for (; $ < 288; )
            _e.lens[$++] = 8;
        for (inftrees(LENS, _e.lens, 0, 288, lenfix, 0, _e.work, {
            bits: 9
        }),
        $ = 0; $ < 32; )
            _e.lens[$++] = 5;
        inftrees(DISTS, _e.lens, 0, 32, distfix, 0, _e.work, {
            bits: 5
        }),
        virgin = !1
    }
    _e.lencode = lenfix,
    _e.lenbits = 9,
    _e.distcode = distfix,
    _e.distbits = 5
}
  , updatewindow = (_e, $, et, tt) => {
    let nt;
    const rt = _e.state;
    return rt.window === null && (rt.wsize = 1 << rt.wbits,
    rt.wnext = 0,
    rt.whave = 0,
    rt.window = new Uint8Array(rt.wsize)),
    tt >= rt.wsize ? (rt.window.set($.subarray(et - rt.wsize, et), 0),
    rt.wnext = 0,
    rt.whave = rt.wsize) : (nt = rt.wsize - rt.wnext,
    nt > tt && (nt = tt),
    rt.window.set($.subarray(et - tt, et - tt + nt), rt.wnext),
    tt -= nt,
    tt ? (rt.window.set($.subarray(et - tt, et), 0),
    rt.wnext = tt,
    rt.whave = rt.wsize) : (rt.wnext += nt,
    rt.wnext === rt.wsize && (rt.wnext = 0),
    rt.whave < rt.wsize && (rt.whave += nt))),
    0
}
  , inflate$2 = (_e, $) => {
    let et, tt, nt, rt, it, ot, st, lt, ct, dt, pt, ht, mt, yt, Et = 0, _t, wt, St, Ct, Nt, Lt, kt, Ut;
    const Jt = new Uint8Array(4);
    let Pt, Xt;
    const rn = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
    if (inflateStateCheck(_e) || !_e.output || !_e.input && _e.avail_in !== 0)
        return Z_STREAM_ERROR$1;
    et = _e.state,
    et.mode === TYPE && (et.mode = TYPEDO),
    it = _e.next_out,
    nt = _e.output,
    st = _e.avail_out,
    rt = _e.next_in,
    tt = _e.input,
    ot = _e.avail_in,
    lt = et.hold,
    ct = et.bits,
    dt = ot,
    pt = st,
    Ut = Z_OK$1;
    e: for (; ; )
        switch (et.mode) {
        case HEAD:
            if (et.wrap === 0) {
                et.mode = TYPEDO;
                break
            }
            for (; ct < 16; ) {
                if (ot === 0)
                    break e;
                ot--,
                lt += tt[rt++] << ct,
                ct += 8
            }
            if (et.wrap & 2 && lt === 35615) {
                et.wbits === 0 && (et.wbits = 15),
                et.check = 0,
                Jt[0] = lt & 255,
                Jt[1] = lt >>> 8 & 255,
                et.check = crc32_1(et.check, Jt, 2, 0),
                lt = 0,
                ct = 0,
                et.mode = FLAGS;
                break
            }
            if (et.head && (et.head.done = !1),
            !(et.wrap & 1) || (((lt & 255) << 8) + (lt >> 8)) % 31) {
                _e.msg = "incorrect header check",
                et.mode = BAD;
                break
            }
            if ((lt & 15) !== Z_DEFLATED) {
                _e.msg = "unknown compression method",
                et.mode = BAD;
                break
            }
            if (lt >>>= 4,
            ct -= 4,
            kt = (lt & 15) + 8,
            et.wbits === 0 && (et.wbits = kt),
            kt > 15 || kt > et.wbits) {
                _e.msg = "invalid window size",
                et.mode = BAD;
                break
            }
            et.dmax = 1 << et.wbits,
            et.flags = 0,
            _e.adler = et.check = 1,
            et.mode = lt & 512 ? DICTID : TYPE,
            lt = 0,
            ct = 0;
            break;
        case FLAGS:
            for (; ct < 16; ) {
                if (ot === 0)
                    break e;
                ot--,
                lt += tt[rt++] << ct,
                ct += 8
            }
            if (et.flags = lt,
            (et.flags & 255) !== Z_DEFLATED) {
                _e.msg = "unknown compression method",
                et.mode = BAD;
                break
            }
            if (et.flags & 57344) {
                _e.msg = "unknown header flags set",
                et.mode = BAD;
                break
            }
            et.head && (et.head.text = lt >> 8 & 1),
            et.flags & 512 && et.wrap & 4 && (Jt[0] = lt & 255,
            Jt[1] = lt >>> 8 & 255,
            et.check = crc32_1(et.check, Jt, 2, 0)),
            lt = 0,
            ct = 0,
            et.mode = TIME;
        case TIME:
            for (; ct < 32; ) {
                if (ot === 0)
                    break e;
                ot--,
                lt += tt[rt++] << ct,
                ct += 8
            }
            et.head && (et.head.time = lt),
            et.flags & 512 && et.wrap & 4 && (Jt[0] = lt & 255,
            Jt[1] = lt >>> 8 & 255,
            Jt[2] = lt >>> 16 & 255,
            Jt[3] = lt >>> 24 & 255,
            et.check = crc32_1(et.check, Jt, 4, 0)),
            lt = 0,
            ct = 0,
            et.mode = OS;
        case OS:
            for (; ct < 16; ) {
                if (ot === 0)
                    break e;
                ot--,
                lt += tt[rt++] << ct,
                ct += 8
            }
            et.head && (et.head.xflags = lt & 255,
            et.head.os = lt >> 8),
            et.flags & 512 && et.wrap & 4 && (Jt[0] = lt & 255,
            Jt[1] = lt >>> 8 & 255,
            et.check = crc32_1(et.check, Jt, 2, 0)),
            lt = 0,
            ct = 0,
            et.mode = EXLEN;
        case EXLEN:
            if (et.flags & 1024) {
                for (; ct < 16; ) {
                    if (ot === 0)
                        break e;
                    ot--,
                    lt += tt[rt++] << ct,
                    ct += 8
                }
                et.length = lt,
                et.head && (et.head.extra_len = lt),
                et.flags & 512 && et.wrap & 4 && (Jt[0] = lt & 255,
                Jt[1] = lt >>> 8 & 255,
                et.check = crc32_1(et.check, Jt, 2, 0)),
                lt = 0,
                ct = 0
            } else
                et.head && (et.head.extra = null);
            et.mode = EXTRA;
        case EXTRA:
            if (et.flags & 1024 && (ht = et.length,
            ht > ot && (ht = ot),
            ht && (et.head && (kt = et.head.extra_len - et.length,
            et.head.extra || (et.head.extra = new Uint8Array(et.head.extra_len)),
            et.head.extra.set(tt.subarray(rt, rt + ht), kt)),
            et.flags & 512 && et.wrap & 4 && (et.check = crc32_1(et.check, tt, ht, rt)),
            ot -= ht,
            rt += ht,
            et.length -= ht),
            et.length))
                break e;
            et.length = 0,
            et.mode = NAME$1;
        case NAME$1:
            if (et.flags & 2048) {
                if (ot === 0)
                    break e;
                ht = 0;
                do
                    kt = tt[rt + ht++],
                    et.head && kt && et.length < 65536 && (et.head.name += String.fromCharCode(kt));
                while (kt && ht < ot);
                if (et.flags & 512 && et.wrap & 4 && (et.check = crc32_1(et.check, tt, ht, rt)),
                ot -= ht,
                rt += ht,
                kt)
                    break e
            } else
                et.head && (et.head.name = null);
            et.length = 0,
            et.mode = COMMENT$1;
        case COMMENT$1:
            if (et.flags & 4096) {
                if (ot === 0)
                    break e;
                ht = 0;
                do
                    kt = tt[rt + ht++],
                    et.head && kt && et.length < 65536 && (et.head.comment += String.fromCharCode(kt));
                while (kt && ht < ot);
                if (et.flags & 512 && et.wrap & 4 && (et.check = crc32_1(et.check, tt, ht, rt)),
                ot -= ht,
                rt += ht,
                kt)
                    break e
            } else
                et.head && (et.head.comment = null);
            et.mode = HCRC;
        case HCRC:
            if (et.flags & 512) {
                for (; ct < 16; ) {
                    if (ot === 0)
                        break e;
                    ot--,
                    lt += tt[rt++] << ct,
                    ct += 8
                }
                if (et.wrap & 4 && lt !== (et.check & 65535)) {
                    _e.msg = "header crc mismatch",
                    et.mode = BAD;
                    break
                }
                lt = 0,
                ct = 0
            }
            et.head && (et.head.hcrc = et.flags >> 9 & 1,
            et.head.done = !0),
            _e.adler = et.check = 0,
            et.mode = TYPE;
            break;
        case DICTID:
            for (; ct < 32; ) {
                if (ot === 0)
                    break e;
                ot--,
                lt += tt[rt++] << ct,
                ct += 8
            }
            _e.adler = et.check = zswap32(lt),
            lt = 0,
            ct = 0,
            et.mode = DICT;
        case DICT:
            if (et.havedict === 0)
                return _e.next_out = it,
                _e.avail_out = st,
                _e.next_in = rt,
                _e.avail_in = ot,
                et.hold = lt,
                et.bits = ct,
                Z_NEED_DICT$1;
            _e.adler = et.check = 1,
            et.mode = TYPE;
        case TYPE:
            if ($ === Z_BLOCK || $ === Z_TREES)
                break e;
        case TYPEDO:
            if (et.last) {
                lt >>>= ct & 7,
                ct -= ct & 7,
                et.mode = CHECK;
                break
            }
            for (; ct < 3; ) {
                if (ot === 0)
                    break e;
                ot--,
                lt += tt[rt++] << ct,
                ct += 8
            }
            switch (et.last = lt & 1,
            lt >>>= 1,
            ct -= 1,
            lt & 3) {
            case 0:
                et.mode = STORED;
                break;
            case 1:
                if (fixedtables(et),
                et.mode = LEN_,
                $ === Z_TREES) {
                    lt >>>= 2,
                    ct -= 2;
                    break e
                }
                break;
            case 2:
                et.mode = TABLE;
                break;
            case 3:
                _e.msg = "invalid block type",
                et.mode = BAD
            }
            lt >>>= 2,
            ct -= 2;
            break;
        case STORED:
            for (lt >>>= ct & 7,
            ct -= ct & 7; ct < 32; ) {
                if (ot === 0)
                    break e;
                ot--,
                lt += tt[rt++] << ct,
                ct += 8
            }
            if ((lt & 65535) !== (lt >>> 16 ^ 65535)) {
                _e.msg = "invalid stored block lengths",
                et.mode = BAD;
                break
            }
            if (et.length = lt & 65535,
            lt = 0,
            ct = 0,
            et.mode = COPY_,
            $ === Z_TREES)
                break e;
        case COPY_:
            et.mode = COPY;
        case COPY:
            if (ht = et.length,
            ht) {
                if (ht > ot && (ht = ot),
                ht > st && (ht = st),
                ht === 0)
                    break e;
                nt.set(tt.subarray(rt, rt + ht), it),
                ot -= ht,
                rt += ht,
                st -= ht,
                it += ht,
                et.length -= ht;
                break
            }
            et.mode = TYPE;
            break;
        case TABLE:
            for (; ct < 14; ) {
                if (ot === 0)
                    break e;
                ot--,
                lt += tt[rt++] << ct,
                ct += 8
            }
            if (et.nlen = (lt & 31) + 257,
            lt >>>= 5,
            ct -= 5,
            et.ndist = (lt & 31) + 1,
            lt >>>= 5,
            ct -= 5,
            et.ncode = (lt & 15) + 4,
            lt >>>= 4,
            ct -= 4,
            et.nlen > 286 || et.ndist > 30) {
                _e.msg = "too many length or distance symbols",
                et.mode = BAD;
                break
            }
            et.have = 0,
            et.mode = LENLENS;
        case LENLENS:
            for (; et.have < et.ncode; ) {
                for (; ct < 3; ) {
                    if (ot === 0)
                        break e;
                    ot--,
                    lt += tt[rt++] << ct,
                    ct += 8
                }
                et.lens[rn[et.have++]] = lt & 7,
                lt >>>= 3,
                ct -= 3
            }
            for (; et.have < 19; )
                et.lens[rn[et.have++]] = 0;
            if (et.lencode = et.lendyn,
            et.lenbits = 7,
            Pt = {
                bits: et.lenbits
            },
            Ut = inftrees(CODES, et.lens, 0, 19, et.lencode, 0, et.work, Pt),
            et.lenbits = Pt.bits,
            Ut) {
                _e.msg = "invalid code lengths set",
                et.mode = BAD;
                break
            }
            et.have = 0,
            et.mode = CODELENS;
        case CODELENS:
            for (; et.have < et.nlen + et.ndist; ) {
                for (; Et = et.lencode[lt & (1 << et.lenbits) - 1],
                _t = Et >>> 24,
                wt = Et >>> 16 & 255,
                St = Et & 65535,
                !(_t <= ct); ) {
                    if (ot === 0)
                        break e;
                    ot--,
                    lt += tt[rt++] << ct,
                    ct += 8
                }
                if (St < 16)
                    lt >>>= _t,
                    ct -= _t,
                    et.lens[et.have++] = St;
                else {
                    if (St === 16) {
                        for (Xt = _t + 2; ct < Xt; ) {
                            if (ot === 0)
                                break e;
                            ot--,
                            lt += tt[rt++] << ct,
                            ct += 8
                        }
                        if (lt >>>= _t,
                        ct -= _t,
                        et.have === 0) {
                            _e.msg = "invalid bit length repeat",
                            et.mode = BAD;
                            break
                        }
                        kt = et.lens[et.have - 1],
                        ht = 3 + (lt & 3),
                        lt >>>= 2,
                        ct -= 2
                    } else if (St === 17) {
                        for (Xt = _t + 3; ct < Xt; ) {
                            if (ot === 0)
                                break e;
                            ot--,
                            lt += tt[rt++] << ct,
                            ct += 8
                        }
                        lt >>>= _t,
                        ct -= _t,
                        kt = 0,
                        ht = 3 + (lt & 7),
                        lt >>>= 3,
                        ct -= 3
                    } else {
                        for (Xt = _t + 7; ct < Xt; ) {
                            if (ot === 0)
                                break e;
                            ot--,
                            lt += tt[rt++] << ct,
                            ct += 8
                        }
                        lt >>>= _t,
                        ct -= _t,
                        kt = 0,
                        ht = 11 + (lt & 127),
                        lt >>>= 7,
                        ct -= 7
                    }
                    if (et.have + ht > et.nlen + et.ndist) {
                        _e.msg = "invalid bit length repeat",
                        et.mode = BAD;
                        break
                    }
                    for (; ht--; )
                        et.lens[et.have++] = kt
                }
            }
            if (et.mode === BAD)
                break;
            if (et.lens[256] === 0) {
                _e.msg = "invalid code -- missing end-of-block",
                et.mode = BAD;
                break
            }
            if (et.lenbits = 9,
            Pt = {
                bits: et.lenbits
            },
            Ut = inftrees(LENS, et.lens, 0, et.nlen, et.lencode, 0, et.work, Pt),
            et.lenbits = Pt.bits,
            Ut) {
                _e.msg = "invalid literal/lengths set",
                et.mode = BAD;
                break
            }
            if (et.distbits = 6,
            et.distcode = et.distdyn,
            Pt = {
                bits: et.distbits
            },
            Ut = inftrees(DISTS, et.lens, et.nlen, et.ndist, et.distcode, 0, et.work, Pt),
            et.distbits = Pt.bits,
            Ut) {
                _e.msg = "invalid distances set",
                et.mode = BAD;
                break
            }
            if (et.mode = LEN_,
            $ === Z_TREES)
                break e;
        case LEN_:
            et.mode = LEN;
        case LEN:
            if (ot >= 6 && st >= 258) {
                _e.next_out = it,
                _e.avail_out = st,
                _e.next_in = rt,
                _e.avail_in = ot,
                et.hold = lt,
                et.bits = ct,
                inffast(_e, pt),
                it = _e.next_out,
                nt = _e.output,
                st = _e.avail_out,
                rt = _e.next_in,
                tt = _e.input,
                ot = _e.avail_in,
                lt = et.hold,
                ct = et.bits,
                et.mode === TYPE && (et.back = -1);
                break
            }
            for (et.back = 0; Et = et.lencode[lt & (1 << et.lenbits) - 1],
            _t = Et >>> 24,
            wt = Et >>> 16 & 255,
            St = Et & 65535,
            !(_t <= ct); ) {
                if (ot === 0)
                    break e;
                ot--,
                lt += tt[rt++] << ct,
                ct += 8
            }
            if (wt && !(wt & 240)) {
                for (Ct = _t,
                Nt = wt,
                Lt = St; Et = et.lencode[Lt + ((lt & (1 << Ct + Nt) - 1) >> Ct)],
                _t = Et >>> 24,
                wt = Et >>> 16 & 255,
                St = Et & 65535,
                !(Ct + _t <= ct); ) {
                    if (ot === 0)
                        break e;
                    ot--,
                    lt += tt[rt++] << ct,
                    ct += 8
                }
                lt >>>= Ct,
                ct -= Ct,
                et.back += Ct
            }
            if (lt >>>= _t,
            ct -= _t,
            et.back += _t,
            et.length = St,
            wt === 0) {
                et.mode = LIT;
                break
            }
            if (wt & 32) {
                et.back = -1,
                et.mode = TYPE;
                break
            }
            if (wt & 64) {
                _e.msg = "invalid literal/length code",
                et.mode = BAD;
                break
            }
            et.extra = wt & 15,
            et.mode = LENEXT;
        case LENEXT:
            if (et.extra) {
                for (Xt = et.extra; ct < Xt; ) {
                    if (ot === 0)
                        break e;
                    ot--,
                    lt += tt[rt++] << ct,
                    ct += 8
                }
                et.length += lt & (1 << et.extra) - 1,
                lt >>>= et.extra,
                ct -= et.extra,
                et.back += et.extra
            }
            et.was = et.length,
            et.mode = DIST;
        case DIST:
            for (; Et = et.distcode[lt & (1 << et.distbits) - 1],
            _t = Et >>> 24,
            wt = Et >>> 16 & 255,
            St = Et & 65535,
            !(_t <= ct); ) {
                if (ot === 0)
                    break e;
                ot--,
                lt += tt[rt++] << ct,
                ct += 8
            }
            if (!(wt & 240)) {
                for (Ct = _t,
                Nt = wt,
                Lt = St; Et = et.distcode[Lt + ((lt & (1 << Ct + Nt) - 1) >> Ct)],
                _t = Et >>> 24,
                wt = Et >>> 16 & 255,
                St = Et & 65535,
                !(Ct + _t <= ct); ) {
                    if (ot === 0)
                        break e;
                    ot--,
                    lt += tt[rt++] << ct,
                    ct += 8
                }
                lt >>>= Ct,
                ct -= Ct,
                et.back += Ct
            }
            if (lt >>>= _t,
            ct -= _t,
            et.back += _t,
            wt & 64) {
                _e.msg = "invalid distance code",
                et.mode = BAD;
                break
            }
            et.offset = St,
            et.extra = wt & 15,
            et.mode = DISTEXT;
        case DISTEXT:
            if (et.extra) {
                for (Xt = et.extra; ct < Xt; ) {
                    if (ot === 0)
                        break e;
                    ot--,
                    lt += tt[rt++] << ct,
                    ct += 8
                }
                et.offset += lt & (1 << et.extra) - 1,
                lt >>>= et.extra,
                ct -= et.extra,
                et.back += et.extra
            }
            if (et.offset > et.dmax) {
                _e.msg = "invalid distance too far back",
                et.mode = BAD;
                break
            }
            et.mode = MATCH$1;
        case MATCH$1:
            if (st === 0)
                break e;
            if (ht = pt - st,
            et.offset > ht) {
                if (ht = et.offset - ht,
                ht > et.whave && et.sane) {
                    _e.msg = "invalid distance too far back",
                    et.mode = BAD;
                    break
                }
                ht > et.wnext ? (ht -= et.wnext,
                mt = et.wsize - ht) : mt = et.wnext - ht,
                ht > et.length && (ht = et.length),
                yt = et.window
            } else
                yt = nt,
                mt = it - et.offset,
                ht = et.length;
            ht > st && (ht = st),
            st -= ht,
            et.length -= ht;
            do
                nt[it++] = yt[mt++];
            while (--ht);
            et.length === 0 && (et.mode = LEN);
            break;
        case LIT:
            if (st === 0)
                break e;
            nt[it++] = et.length,
            st--,
            et.mode = LEN;
            break;
        case CHECK:
            if (et.wrap) {
                for (; ct < 32; ) {
                    if (ot === 0)
                        break e;
                    ot--,
                    lt |= tt[rt++] << ct,
                    ct += 8
                }
                if (pt -= st,
                _e.total_out += pt,
                et.total += pt,
                et.wrap & 4 && pt && (_e.adler = et.check = et.flags ? crc32_1(et.check, nt, pt, it - pt) : adler32_1(et.check, nt, pt, it - pt)),
                pt = st,
                et.wrap & 4 && (et.flags ? lt : zswap32(lt)) !== et.check) {
                    _e.msg = "incorrect data check",
                    et.mode = BAD;
                    break
                }
                lt = 0,
                ct = 0
            }
            et.mode = LENGTH$1;
        case LENGTH$1:
            if (et.wrap && et.flags) {
                for (; ct < 32; ) {
                    if (ot === 0)
                        break e;
                    ot--,
                    lt += tt[rt++] << ct,
                    ct += 8
                }
                if (et.wrap & 4 && lt !== (et.total & 4294967295)) {
                    _e.msg = "incorrect length check",
                    et.mode = BAD;
                    break
                }
                lt = 0,
                ct = 0
            }
            et.mode = DONE;
        case DONE:
            Ut = Z_STREAM_END$1;
            break e;
        case BAD:
            Ut = Z_DATA_ERROR$1;
            break e;
        case MEM:
            return Z_MEM_ERROR$1;
        case SYNC:
        default:
            return Z_STREAM_ERROR$1
        }
    return _e.next_out = it,
    _e.avail_out = st,
    _e.next_in = rt,
    _e.avail_in = ot,
    et.hold = lt,
    et.bits = ct,
    (et.wsize || pt !== _e.avail_out && et.mode < BAD && (et.mode < CHECK || $ !== Z_FINISH$1)) && updatewindow(_e, _e.output, _e.next_out, pt - _e.avail_out),
    dt -= _e.avail_in,
    pt -= _e.avail_out,
    _e.total_in += dt,
    _e.total_out += pt,
    et.total += pt,
    et.wrap & 4 && pt && (_e.adler = et.check = et.flags ? crc32_1(et.check, nt, pt, _e.next_out - pt) : adler32_1(et.check, nt, pt, _e.next_out - pt)),
    _e.data_type = et.bits + (et.last ? 64 : 0) + (et.mode === TYPE ? 128 : 0) + (et.mode === LEN_ || et.mode === COPY_ ? 256 : 0),
    (dt === 0 && pt === 0 || $ === Z_FINISH$1) && Ut === Z_OK$1 && (Ut = Z_BUF_ERROR),
    Ut
}
  , inflateEnd = _e => {
    if (inflateStateCheck(_e))
        return Z_STREAM_ERROR$1;
    let $ = _e.state;
    return $.window && ($.window = null),
    _e.state = null,
    Z_OK$1
}
  , inflateGetHeader = (_e, $) => {
    if (inflateStateCheck(_e))
        return Z_STREAM_ERROR$1;
    const et = _e.state;
    return et.wrap & 2 ? (et.head = $,
    $.done = !1,
    Z_OK$1) : Z_STREAM_ERROR$1
}
  , inflateSetDictionary = (_e, $) => {
    const et = $.length;
    let tt, nt, rt;
    return inflateStateCheck(_e) || (tt = _e.state,
    tt.wrap !== 0 && tt.mode !== DICT) ? Z_STREAM_ERROR$1 : tt.mode === DICT && (nt = 1,
    nt = adler32_1(nt, $, et, 0),
    nt !== tt.check) ? Z_DATA_ERROR$1 : (rt = updatewindow(_e, $, et, et),
    rt ? (tt.mode = MEM,
    Z_MEM_ERROR$1) : (tt.havedict = 1,
    Z_OK$1))
}
;
var inflateReset_1 = inflateReset
  , inflateReset2_1 = inflateReset2
  , inflateResetKeep_1 = inflateResetKeep
  , inflateInit_1 = inflateInit
  , inflateInit2_1 = inflateInit2
  , inflate_2$1 = inflate$2
  , inflateEnd_1 = inflateEnd
  , inflateGetHeader_1 = inflateGetHeader
  , inflateSetDictionary_1 = inflateSetDictionary
  , inflateInfo = "pako inflate (from Nodeca project)"
  , inflate_1$2 = {
    inflateReset: inflateReset_1,
    inflateReset2: inflateReset2_1,
    inflateResetKeep: inflateResetKeep_1,
    inflateInit: inflateInit_1,
    inflateInit2: inflateInit2_1,
    inflate: inflate_2$1,
    inflateEnd: inflateEnd_1,
    inflateGetHeader: inflateGetHeader_1,
    inflateSetDictionary: inflateSetDictionary_1,
    inflateInfo
};
function GZheader() {
    this.text = 0,
    this.time = 0,
    this.xflags = 0,
    this.os = 0,
    this.extra = null,
    this.extra_len = 0,
    this.name = "",
    this.comment = "",
    this.hcrc = 0,
    this.done = !1
}
var gzheader = GZheader;
const toString$7 = Object.prototype.toString
  , {Z_NO_FLUSH, Z_FINISH, Z_OK, Z_STREAM_END, Z_NEED_DICT, Z_STREAM_ERROR, Z_DATA_ERROR, Z_MEM_ERROR} = constants$2;
function Inflate$1(_e) {
    this.options = common$1.assign({
        chunkSize: 1024 * 64,
        windowBits: 15,
        to: ""
    }, _e || {});
    const $ = this.options;
    $.raw && $.windowBits >= 0 && $.windowBits < 16 && ($.windowBits = -$.windowBits,
    $.windowBits === 0 && ($.windowBits = -15)),
    $.windowBits >= 0 && $.windowBits < 16 && !(_e && _e.windowBits) && ($.windowBits += 32),
    $.windowBits > 15 && $.windowBits < 48 && ($.windowBits & 15 || ($.windowBits |= 15)),
    this.err = 0,
    this.msg = "",
    this.ended = !1,
    this.chunks = [],
    this.strm = new zstream,
    this.strm.avail_out = 0;
    let et = inflate_1$2.inflateInit2(this.strm, $.windowBits);
    if (et !== Z_OK)
        throw new Error(messages$2[et]);
    if (this.header = new gzheader,
    inflate_1$2.inflateGetHeader(this.strm, this.header),
    $.dictionary && (typeof $.dictionary == "string" ? $.dictionary = strings.string2buf($.dictionary) : toString$7.call($.dictionary) === "[object ArrayBuffer]" && ($.dictionary = new Uint8Array($.dictionary)),
    $.raw && (et = inflate_1$2.inflateSetDictionary(this.strm, $.dictionary),
    et !== Z_OK)))
        throw new Error(messages$2[et])
}
Inflate$1.prototype.push = function(_e, $) {
    const et = this.strm
      , tt = this.options.chunkSize
      , nt = this.options.dictionary;
    let rt, it, ot;
    if (this.ended)
        return !1;
    for ($ === ~~$ ? it = $ : it = $ === !0 ? Z_FINISH : Z_NO_FLUSH,
    toString$7.call(_e) === "[object ArrayBuffer]" ? et.input = new Uint8Array(_e) : et.input = _e,
    et.next_in = 0,
    et.avail_in = et.input.length; ; ) {
        for (et.avail_out === 0 && (et.output = new Uint8Array(tt),
        et.next_out = 0,
        et.avail_out = tt),
        rt = inflate_1$2.inflate(et, it),
        rt === Z_NEED_DICT && nt && (rt = inflate_1$2.inflateSetDictionary(et, nt),
        rt === Z_OK ? rt = inflate_1$2.inflate(et, it) : rt === Z_DATA_ERROR && (rt = Z_NEED_DICT)); et.avail_in > 0 && rt === Z_STREAM_END && et.state.wrap > 0 && _e[et.next_in] !== 0; )
            inflate_1$2.inflateReset(et),
            rt = inflate_1$2.inflate(et, it);
        switch (rt) {
        case Z_STREAM_ERROR:
        case Z_DATA_ERROR:
        case Z_NEED_DICT:
        case Z_MEM_ERROR:
            return this.onEnd(rt),
            this.ended = !0,
            !1
        }
        if (ot = et.avail_out,
        et.next_out && (et.avail_out === 0 || rt === Z_STREAM_END))
            if (this.options.to === "string") {
                let st = strings.utf8border(et.output, et.next_out)
                  , lt = et.next_out - st
                  , ct = strings.buf2string(et.output, st);
                et.next_out = lt,
                et.avail_out = tt - lt,
                lt && et.output.set(et.output.subarray(st, st + lt), 0),
                this.onData(ct)
            } else
                this.onData(et.output.length === et.next_out ? et.output : et.output.subarray(0, et.next_out));
        if (!(rt === Z_OK && ot === 0)) {
            if (rt === Z_STREAM_END)
                return rt = inflate_1$2.inflateEnd(this.strm),
                this.onEnd(rt),
                this.ended = !0,
                !0;
            if (et.avail_in === 0)
                break
        }
    }
    return !0
}
;
Inflate$1.prototype.onData = function(_e) {
    this.chunks.push(_e)
}
;
Inflate$1.prototype.onEnd = function(_e) {
    _e === Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = common$1.flattenChunks(this.chunks)),
    this.chunks = [],
    this.err = _e,
    this.msg = this.strm.msg
}
;
function inflate$1(_e, $) {
    const et = new Inflate$1($);
    if (et.push(_e),
    et.err)
        throw et.msg || messages$2[et.err];
    return et.result
}
var inflate_2 = inflate$1
  , inflate_1$1 = {
    inflate: inflate_2
};
const {inflate} = inflate_1$1;
var inflate_1 = inflate
  , eventemitter3 = {
    exports: {}
};
(function(_e) {
    var $ = Object.prototype.hasOwnProperty
      , et = "~";
    function tt() {}
    Object.create && (tt.prototype = Object.create(null),
    new tt().__proto__ || (et = !1));
    function nt(st, lt, ct) {
        this.fn = st,
        this.context = lt,
        this.once = ct || !1
    }
    function rt(st, lt, ct, dt, pt) {
        if (typeof ct != "function")
            throw new TypeError("The listener must be a function");
        var ht = new nt(ct,dt || st,pt)
          , mt = et ? et + lt : lt;
        return st._events[mt] ? st._events[mt].fn ? st._events[mt] = [st._events[mt], ht] : st._events[mt].push(ht) : (st._events[mt] = ht,
        st._eventsCount++),
        st
    }
    function it(st, lt) {
        --st._eventsCount === 0 ? st._events = new tt : delete st._events[lt]
    }
    function ot() {
        this._events = new tt,
        this._eventsCount = 0
    }
    ot.prototype.eventNames = function() {
        var lt = [], ct, dt;
        if (this._eventsCount === 0)
            return lt;
        for (dt in ct = this._events)
            $.call(ct, dt) && lt.push(et ? dt.slice(1) : dt);
        return Object.getOwnPropertySymbols ? lt.concat(Object.getOwnPropertySymbols(ct)) : lt
    }
    ,
    ot.prototype.listeners = function(lt) {
        var ct = et ? et + lt : lt
          , dt = this._events[ct];
        if (!dt)
            return [];
        if (dt.fn)
            return [dt.fn];
        for (var pt = 0, ht = dt.length, mt = new Array(ht); pt < ht; pt++)
            mt[pt] = dt[pt].fn;
        return mt
    }
    ,
    ot.prototype.listenerCount = function(lt) {
        var ct = et ? et + lt : lt
          , dt = this._events[ct];
        return dt ? dt.fn ? 1 : dt.length : 0
    }
    ,
    ot.prototype.emit = function(lt, ct, dt, pt, ht, mt) {
        var yt = et ? et + lt : lt;
        if (!this._events[yt])
            return !1;
        var Et = this._events[yt], _t = arguments.length, wt, St;
        if (Et.fn) {
            switch (Et.once && this.removeListener(lt, Et.fn, void 0, !0),
            _t) {
            case 1:
                return Et.fn.call(Et.context),
                !0;
            case 2:
                return Et.fn.call(Et.context, ct),
                !0;
            case 3:
                return Et.fn.call(Et.context, ct, dt),
                !0;
            case 4:
                return Et.fn.call(Et.context, ct, dt, pt),
                !0;
            case 5:
                return Et.fn.call(Et.context, ct, dt, pt, ht),
                !0;
            case 6:
                return Et.fn.call(Et.context, ct, dt, pt, ht, mt),
                !0
            }
            for (St = 1,
            wt = new Array(_t - 1); St < _t; St++)
                wt[St - 1] = arguments[St];
            Et.fn.apply(Et.context, wt)
        } else {
            var Ct = Et.length, Nt;
            for (St = 0; St < Ct; St++)
                switch (Et[St].once && this.removeListener(lt, Et[St].fn, void 0, !0),
                _t) {
                case 1:
                    Et[St].fn.call(Et[St].context);
                    break;
                case 2:
                    Et[St].fn.call(Et[St].context, ct);
                    break;
                case 3:
                    Et[St].fn.call(Et[St].context, ct, dt);
                    break;
                case 4:
                    Et[St].fn.call(Et[St].context, ct, dt, pt);
                    break;
                default:
                    if (!wt)
                        for (Nt = 1,
                        wt = new Array(_t - 1); Nt < _t; Nt++)
                            wt[Nt - 1] = arguments[Nt];
                    Et[St].fn.apply(Et[St].context, wt)
                }
        }
        return !0
    }
    ,
    ot.prototype.on = function(lt, ct, dt) {
        return rt(this, lt, ct, dt, !1)
    }
    ,
    ot.prototype.once = function(lt, ct, dt) {
        return rt(this, lt, ct, dt, !0)
    }
    ,
    ot.prototype.removeListener = function(lt, ct, dt, pt) {
        var ht = et ? et + lt : lt;
        if (!this._events[ht])
            return this;
        if (!ct)
            return it(this, ht),
            this;
        var mt = this._events[ht];
        if (mt.fn)
            mt.fn === ct && (!pt || mt.once) && (!dt || mt.context === dt) && it(this, ht);
        else {
            for (var yt = 0, Et = [], _t = mt.length; yt < _t; yt++)
                (mt[yt].fn !== ct || pt && !mt[yt].once || dt && mt[yt].context !== dt) && Et.push(mt[yt]);
            Et.length ? this._events[ht] = Et.length === 1 ? Et[0] : Et : it(this, ht)
        }
        return this
    }
    ,
    ot.prototype.removeAllListeners = function(lt) {
        var ct;
        return lt ? (ct = et ? et + lt : lt,
        this._events[ct] && it(this, ct)) : (this._events = new tt,
        this._eventsCount = 0),
        this
    }
    ,
    ot.prototype.off = ot.prototype.removeListener,
    ot.prototype.addListener = ot.prototype.on,
    ot.prefixed = et,
    ot.EventEmitter = ot,
    _e.exports = ot
}
)(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = getDefaultExportFromCjs$2(eventemitter3Exports);
function chunks(_e, $) {
    return Array.apply(0, new Array(Math.ceil(_e.length / $))).map( (et, tt) => _e.slice(tt * $, (tt + 1) * $))
}
const isVersionedTransaction$2 = _e => "version"in _e;
function decode$2(_e) {
    return new TextDecoder("utf-8").decode(_e)
}
function encode$1$1(_e) {
    return bs58$3.encode(_e)
}
function encode$3(_e) {
    return _e.toString("base64")
}
function decode(_e) {
    return Buffer$1$1.from(_e, "base64")
}
function isCompositeAccounts(_e) {
    return "accounts"in _e
}
async function idlAddress(_e) {
    const $ = (await PublicKey.findProgramAddress([], _e))[0];
    return await PublicKey.createWithSeed($, seed(), _e)
}
function seed() {
    return "anchor:idl"
}
const IDL_ACCOUNT_LAYOUT = dist$3.struct([dist$3.publicKey("authority"), dist$3.vecU8("data")]);
function decodeIdlAccount(_e) {
    return IDL_ACCOUNT_LAYOUT.decode(_e)
}
function convertIdlToCamelCase(_e) {
    const $ = ["name", "path", "account", "relations", "generic"]
      , et = rt => rt.split(".").map(camelCase$2).join(".")
      , tt = rt => {
        for (const it in rt) {
            const ot = rt[it];
            $.includes(it) ? rt[it] = Array.isArray(ot) ? ot.map(et) : et(ot) : typeof ot == "object" && tt(ot)
        }
    }
      , nt = structuredClone(_e);
    return tt(nt),
    nt
}
function handleDefinedFields(_e, $, et, tt) {
    return _e != null && _e.length ? _e[0].name ? et(_e) : tt(_e) : $()
}
function parseIdlErrors(_e) {
    const $ = new Map;
    return _e.errors && _e.errors.forEach(et => {
        var tt;
        let nt = (tt = et.msg) !== null && tt !== void 0 ? tt : et.name;
        $.set(et.code, nt)
    }
    ),
    $
}
function toInstruction(_e, ...$) {
    if (_e.args.length != $.length)
        throw new Error("Invalid argument length");
    const et = {};
    let tt = 0;
    return _e.args.forEach(nt => {
        et[nt.name] = $[tt],
        tt += 1
    }
    ),
    et
}
function validateAccounts(_e, $={}) {
    _e.forEach(et => {
        if (isCompositeAccounts(et))
            validateAccounts(et.accounts, $[et.name]);
        else if (!$[et.name])
            throw new Error(`Account \`${et.name}\` not provided.`)
    }
    )
}
function translateAddress(_e) {
    return _e instanceof PublicKey ? _e : new PublicKey(_e)
}
class StructError extends TypeError {
    constructor($, et) {
        let tt;
        const {message: nt, ...rt} = $
          , {path: it} = $
          , ot = it.length === 0 ? nt : "At path: " + it.join(".") + " -- " + nt;
        super(ot),
        this.value = void 0,
        this.key = void 0,
        this.type = void 0,
        this.refinement = void 0,
        this.path = void 0,
        this.branch = void 0,
        this.failures = void 0,
        Object.assign(this, rt),
        this.name = this.constructor.name,
        this.failures = () => {
            var st;
            return (st = tt) != null ? st : tt = [$, ...et()]
        }
    }
}
function isIterable(_e) {
    return isObject$k(_e) && typeof _e[Symbol.iterator] == "function"
}
function isObject$k(_e) {
    return typeof _e == "object" && _e != null
}
function print(_e) {
    return typeof _e == "string" ? JSON.stringify(_e) : "" + _e
}
function shiftIterator(_e) {
    const {done: $, value: et} = _e.next();
    return $ ? void 0 : et
}
function toFailure(_e, $, et, tt) {
    if (_e === !0)
        return;
    _e === !1 ? _e = {} : typeof _e == "string" && (_e = {
        message: _e
    });
    const {path: nt, branch: rt} = $
      , {type: it} = et
      , {refinement: ot, message: st="Expected a value of type `" + it + "`" + (ot ? " with refinement `" + ot + "`" : "") + ", but received: `" + print(tt) + "`"} = _e;
    return {
        value: tt,
        type: it,
        refinement: ot,
        key: nt[nt.length - 1],
        path: nt,
        branch: rt,
        ..._e,
        message: st
    }
}
function *toFailures(_e, $, et, tt) {
    isIterable(_e) || (_e = [_e]);
    for (const nt of _e) {
        const rt = toFailure(nt, $, et, tt);
        rt && (yield rt)
    }
}
function *run(_e, $, et) {
    et === void 0 && (et = {});
    const {path: tt=[], branch: nt=[_e], coerce: rt=!1, mask: it=!1} = et
      , ot = {
        path: tt,
        branch: nt
    };
    if (rt && (_e = $.coercer(_e, ot),
    it && $.type !== "type" && isObject$k($.schema) && isObject$k(_e) && !Array.isArray(_e)))
        for (const lt in _e)
            $.schema[lt] === void 0 && delete _e[lt];
    let st = !0;
    for (const lt of $.validator(_e, ot))
        st = !1,
        yield[lt, void 0];
    for (let[lt,ct,dt] of $.entries(_e, ot)) {
        const pt = run(ct, dt, {
            path: lt === void 0 ? tt : [...tt, lt],
            branch: lt === void 0 ? nt : [...nt, ct],
            coerce: rt,
            mask: it
        });
        for (const ht of pt)
            ht[0] ? (st = !1,
            yield[ht[0], void 0]) : rt && (ct = ht[1],
            lt === void 0 ? _e = ct : _e instanceof Map ? _e.set(lt, ct) : _e instanceof Set ? _e.add(ct) : isObject$k(_e) && (_e[lt] = ct))
    }
    if (st)
        for (const lt of $.refiner(_e, ot))
            st = !1,
            yield[lt, void 0];
    st && (yield[void 0, _e])
}
class Struct {
    constructor($) {
        this.TYPE = void 0,
        this.type = void 0,
        this.schema = void 0,
        this.coercer = void 0,
        this.validator = void 0,
        this.refiner = void 0,
        this.entries = void 0;
        const {type: et, schema: tt, validator: nt, refiner: rt, coercer: it=st => st, entries: ot=function*() {}
        } = $;
        this.type = et,
        this.schema = tt,
        this.entries = ot,
        this.coercer = it,
        nt ? this.validator = (st, lt) => {
            const ct = nt(st, lt);
            return toFailures(ct, lt, this, st)
        }
        : this.validator = () => [],
        rt ? this.refiner = (st, lt) => {
            const ct = rt(st, lt);
            return toFailures(ct, lt, this, st)
        }
        : this.refiner = () => []
    }
    assert($) {
        return assert($, this)
    }
    create($) {
        return create$2($, this)
    }
    is($) {
        return is($, this)
    }
    mask($) {
        return mask($, this)
    }
    validate($, et) {
        return et === void 0 && (et = {}),
        validate($, this, et)
    }
}
function assert(_e, $) {
    const et = validate(_e, $);
    if (et[0])
        throw et[0]
}
function create$2(_e, $) {
    const et = validate(_e, $, {
        coerce: !0
    });
    if (et[0])
        throw et[0];
    return et[1]
}
function mask(_e, $) {
    const et = validate(_e, $, {
        coerce: !0,
        mask: !0
    });
    if (et[0])
        throw et[0];
    return et[1]
}
function is(_e, $) {
    return !validate(_e, $)[0]
}
function validate(_e, $, et) {
    et === void 0 && (et = {});
    const tt = run(_e, $, et)
      , nt = shiftIterator(tt);
    return nt[0] ? [new StructError(nt[0],function*() {
        for (const it of tt)
            it[0] && (yield it[0])
    }
    ), void 0] : [void 0, nt[1]]
}
function define$1(_e, $) {
    return new Struct({
        type: _e,
        schema: null,
        validator: $
    })
}
function any() {
    return define$1("any", () => !0)
}
function array$1(_e) {
    return new Struct({
        type: "array",
        schema: _e,
        *entries($) {
            if (_e && Array.isArray($))
                for (const [et,tt] of $.entries())
                    yield[et, tt, _e]
        },
        coercer($) {
            return Array.isArray($) ? $.slice() : $
        },
        validator($) {
            return Array.isArray($) || "Expected an array value, but received: " + print($)
        }
    })
}
function boolean$1() {
    return define$1("boolean", _e => typeof _e == "boolean")
}
function literal(_e) {
    const $ = print(_e);
    return new Struct({
        type: "literal",
        schema: _e,
        validator(et) {
            return et === _e || "Expected the literal `" + $ + "`, but received: " + print(et)
        }
    })
}
function nullable(_e) {
    return new Struct({
        ..._e,
        validator: ($, et) => $ === null || _e.validator($, et),
        refiner: ($, et) => $ === null || _e.refiner($, et)
    })
}
function number$1() {
    return define$1("number", _e => typeof _e == "number" && !isNaN(_e) || "Expected a number, but received: " + print(_e))
}
function optional(_e) {
    return new Struct({
        ..._e,
        validator: ($, et) => $ === void 0 || _e.validator($, et),
        refiner: ($, et) => $ === void 0 || _e.refiner($, et)
    })
}
function string$1() {
    return define$1("string", _e => typeof _e == "string" || "Expected a string, but received: " + print(_e))
}
function type(_e) {
    const $ = Object.keys(_e);
    return new Struct({
        type: "type",
        schema: _e,
        *entries(et) {
            if (isObject$k(et))
                for (const tt of $)
                    yield[tt, et[tt], _e[tt]]
        },
        validator(et) {
            return isObject$k(et) || "Expected an object, but received: " + print(et)
        }
    })
}
function union$1(_e) {
    const $ = _e.map(et => et.type).join(" | ");
    return new Struct({
        type: "union",
        schema: null,
        coercer(et, tt) {
            return (_e.find(rt => {
                const [it] = rt.validate(et, {
                    coerce: !0
                });
                return !it
            }
            ) || unknown$1()).coercer(et, tt)
        },
        validator(et, tt) {
            const nt = [];
            for (const rt of _e) {
                const [...it] = run(et, rt, tt)
                  , [ot] = it;
                if (ot[0])
                    for (const [st] of it)
                        st && nt.push(st);
                else
                    return []
            }
            return ["Expected the value to satisfy a union of `" + $ + "`, but received: " + print(et), ...nt]
        }
    })
}
function unknown$1() {
    return define$1("unknown", () => !0)
}
function coerce(_e, $, et) {
    return new Struct({
        ..._e,
        coercer: (tt, nt) => is(tt, $) ? _e.coercer(et(tt, nt), nt) : _e.coercer(tt, nt)
    })
}
const GET_MULTIPLE_ACCOUNTS_LIMIT = 99;
async function getMultipleAccountsAndContext(_e, $, et) {
    if ($.length <= GET_MULTIPLE_ACCOUNTS_LIMIT)
        return await getMultipleAccountsAndContextCore(_e, $, et);
    {
        const tt = chunks($, GET_MULTIPLE_ACCOUNTS_LIMIT);
        return (await Promise.all(tt.map(rt => getMultipleAccountsAndContextCore(_e, rt, et)))).flat()
    }
}
async function getMultipleAccountsAndContextCore(_e, $, et) {
    const tt = et ?? _e.commitment
      , {value: nt, context: rt} = await _e.getMultipleAccountsInfoAndContext($, tt);
    return nt.map( (ot, st) => ot === null ? null : {
        publicKey: $[st],
        account: ot,
        context: rt
    })
}
async function simulateTransaction(_e, $, et, tt, nt) {
    var rt;
    et && et.length > 0 && $.sign(...et);
    const it = $._compile()
      , ot = it.serialize()
      , lt = $._serialize(ot).toString("base64")
      , ct = {
        encoding: "base64",
        commitment: tt ?? _e.commitment
    };
    if (nt) {
        const mt = (Array.isArray(nt) ? nt : it.nonProgramIds()).map(yt => yt.toBase58());
        ct.accounts = {
            encoding: "base64",
            addresses: mt
        }
    }
    et && et.length > 0 && (ct.sigVerify = !0);
    const dt = [lt, ct]
      , pt = await _e._rpcRequest("simulateTransaction", dt)
      , ht = create$2(pt, SimulatedTransactionResponseStruct);
    if ("error"in ht) {
        let mt;
        if ("data"in ht.error && (mt = (rt = ht.error.data) === null || rt === void 0 ? void 0 : rt.logs,
        mt && Array.isArray(mt))) {
            const yt = `
    `
              , Et = yt + mt.join(yt)
        }
        throw new SendTransactionError("failed to simulate transaction: " + ht.error.message,mt)
    }
    return ht.result
}
function jsonRpcResult(_e) {
    return coerce(createRpcResult(_e), UnknownRpcResult, $ => "error"in $ ? $ : {
        ...$,
        result: create$2($.result, _e)
    })
}
const UnknownRpcResult = createRpcResult(unknown$1());
function createRpcResult(_e) {
    return union$1([type({
        jsonrpc: literal("2.0"),
        id: string$1(),
        result: _e
    }), type({
        jsonrpc: literal("2.0"),
        id: string$1(),
        error: type({
            code: unknown$1(),
            message: string$1(),
            data: optional(any())
        })
    })])
}
function jsonRpcResultAndContext(_e) {
    return jsonRpcResult(type({
        context: type({
            slot: number$1()
        }),
        value: _e
    }))
}
const SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({
    err: nullable(union$1([type({}), string$1()])),
    logs: nullable(array$1(string$1())),
    accounts: optional(nullable(array$1(nullable(type({
        executable: boolean$1(),
        owner: string$1(),
        lamports: number$1(),
        data: array$1(string$1()),
        rentEpoch: optional(number$1())
    }))))),
    unitsConsumed: optional(number$1())
}));
class AnchorProvider {
    constructor($, et, tt=AnchorProvider.defaultOptions()) {
        this.connection = $,
        this.wallet = et,
        this.opts = tt,
        this.publicKey = et == null ? void 0 : et.publicKey
    }
    static defaultOptions() {
        return {
            preflightCommitment: "processed",
            commitment: "processed"
        }
    }
    static local($, et=AnchorProvider.defaultOptions()) {
        throw new Error("Provider local is not available on browser.")
    }
    static env() {
        throw new Error("Provider env is not available on browser.")
    }
    async sendAndConfirm($, et, tt) {
        var nt, rt, it, ot;
        if (tt === void 0 && (tt = this.opts),
        isVersionedTransaction$2($))
            et && $.sign(et);
        else if ($.feePayer = (nt = $.feePayer) !== null && nt !== void 0 ? nt : this.wallet.publicKey,
        $.recentBlockhash = (await this.connection.getLatestBlockhash(tt.preflightCommitment)).blockhash,
        et)
            for (const lt of et)
                $.partialSign(lt);
        $ = await this.wallet.signTransaction($);
        const st = $.serialize();
        try {
            return await sendAndConfirmRawTransaction(this.connection, st, tt)
        } catch (lt) {
            if (lt instanceof ConfirmError) {
                const ct = encode$1$1(isVersionedTransaction$2($) ? ((rt = $.signatures) === null || rt === void 0 ? void 0 : rt[0]) || new Uint8Array : (it = $.signature) !== null && it !== void 0 ? it : new Uint8Array)
                  , dt = isVersionedTransaction$2($) ? 0 : void 0
                  , pt = await this.connection.getTransaction(ct, {
                    commitment: "confirmed",
                    maxSupportedTransactionVersion: dt
                });
                if (pt) {
                    const ht = (ot = pt.meta) === null || ot === void 0 ? void 0 : ot.logMessages;
                    throw ht ? new SendTransactionError(lt.message,ht) : lt
                } else
                    throw lt
            } else
                throw lt
        }
    }
    async sendAll($, et) {
        var tt, nt, rt;
        et === void 0 && (et = this.opts);
        const it = (await this.connection.getLatestBlockhash(et.preflightCommitment)).blockhash;
        let ot = $.map(ct => {
            var dt, pt;
            if (isVersionedTransaction$2(ct.tx)) {
                let ht = ct.tx;
                return ct.signers && ht.sign(ct.signers),
                ht
            } else {
                let ht = ct.tx
                  , mt = (dt = ct.signers) !== null && dt !== void 0 ? dt : [];
                return ht.feePayer = (pt = ht.feePayer) !== null && pt !== void 0 ? pt : this.wallet.publicKey,
                ht.recentBlockhash = it,
                mt.forEach(yt => {
                    ht.partialSign(yt)
                }
                ),
                ht
            }
        }
        );
        const st = await this.wallet.signAllTransactions(ot)
          , lt = [];
        for (let ct = 0; ct < ot.length; ct += 1) {
            const dt = st[ct]
              , pt = dt.serialize();
            try {
                lt.push(await sendAndConfirmRawTransaction(this.connection, pt, et))
            } catch (ht) {
                if (ht instanceof ConfirmError) {
                    const mt = encode$1$1(isVersionedTransaction$2(dt) ? ((tt = dt.signatures) === null || tt === void 0 ? void 0 : tt[0]) || new Uint8Array : (nt = dt.signature) !== null && nt !== void 0 ? nt : new Uint8Array)
                      , yt = isVersionedTransaction$2(dt) ? 0 : void 0
                      , Et = await this.connection.getTransaction(mt, {
                        commitment: "confirmed",
                        maxSupportedTransactionVersion: yt
                    });
                    if (Et) {
                        const _t = (rt = Et.meta) === null || rt === void 0 ? void 0 : rt.logMessages;
                        throw _t ? new SendTransactionError(ht.message,_t) : ht
                    } else
                        throw ht
                } else
                    throw ht
            }
        }
        return lt
    }
    async simulate($, et, tt, nt) {
        let rt = (await this.connection.getLatestBlockhash(tt ?? this.connection.commitment)).blockhash, it;
        if (isVersionedTransaction$2($) ? (et && et.length > 0 && ($.sign(et),
        $ = await this.wallet.signTransaction($)),
        it = await this.connection.simulateTransaction($, {
            commitment: tt
        })) : ($.feePayer = $.feePayer || this.wallet.publicKey,
        $.recentBlockhash = rt,
        et && et.length > 0 && ($ = await this.wallet.signTransaction($)),
        it = await simulateTransaction(this.connection, $, et, tt, nt)),
        it.value.err)
            throw new SimulateError(it.value);
        return it.value
    }
}
class SimulateError extends Error {
    constructor($, et) {
        super(et),
        this.simulationResponse = $
    }
}
async function sendAndConfirmRawTransaction(_e, $, et) {
    const tt = et && {
        skipPreflight: et.skipPreflight,
        preflightCommitment: et.preflightCommitment || et.commitment
    }
      , nt = await _e.sendRawTransaction($, tt)
      , rt = (await _e.confirmTransaction(nt, et && et.commitment)).value;
    if (rt.err)
        throw new ConfirmError(`Raw transaction ${nt} failed (${JSON.stringify(rt)})`);
    return nt
}
class ConfirmError extends Error {
    constructor($) {
        super($)
    }
}
function getProvider() {
    return AnchorProvider.local()
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : {}
  , dist$2 = {};
Object.defineProperty(dist$2, "__esModule", {
    value: !0
});
var ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = ANCHOR_ERROR__REQUIRE_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_VIOLATED = ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = dist$2.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = dist$2.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = dist$2.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = ANCHOR_ERROR__CONSTRAINT_SPACE = dist$2.ANCHOR_ERROR__CONSTRAINT_SPACE = ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = dist$2.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = dist$2.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = ANCHOR_ERROR__CONSTRAINT_ZERO = dist$2.ANCHOR_ERROR__CONSTRAINT_ZERO = ANCHOR_ERROR__CONSTRAINT_ADDRESS = dist$2.ANCHOR_ERROR__CONSTRAINT_ADDRESS = ANCHOR_ERROR__CONSTRAINT_CLOSE = dist$2.ANCHOR_ERROR__CONSTRAINT_CLOSE = ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = dist$2.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = dist$2.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = ANCHOR_ERROR__CONSTRAINT_STATE = dist$2.ANCHOR_ERROR__CONSTRAINT_STATE = ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = dist$2.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = ANCHOR_ERROR__CONSTRAINT_SEEDS = dist$2.ANCHOR_ERROR__CONSTRAINT_SEEDS = ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = dist$2.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = ANCHOR_ERROR__CONSTRAINT_OWNER = dist$2.ANCHOR_ERROR__CONSTRAINT_OWNER = ANCHOR_ERROR__CONSTRAINT_RAW = dist$2.ANCHOR_ERROR__CONSTRAINT_RAW = ANCHOR_ERROR__CONSTRAINT_SIGNER = dist$2.ANCHOR_ERROR__CONSTRAINT_SIGNER = ANCHOR_ERROR__CONSTRAINT_HAS_ONE = dist$2.ANCHOR_ERROR__CONSTRAINT_HAS_ONE = ANCHOR_ERROR__CONSTRAINT_MUT = dist$2.ANCHOR_ERROR__CONSTRAINT_MUT = ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = dist$2.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = dist$2.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = dist$2.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = ANCHOR_ERROR__IDL_INSTRUCTION_STUB = dist$2.ANCHOR_ERROR__IDL_INSTRUCTION_STUB = ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = dist$2.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = dist$2.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = dist$2.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = ANCHOR_ERROR__INSTRUCTION_MISSING = dist$2.ANCHOR_ERROR__INSTRUCTION_MISSING = void 0
  , ANCHOR_ERROR__DEPRECATED = dist$2.ANCHOR_ERROR__DEPRECATED = ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = dist$2.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = dist$2.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = dist$2.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = dist$2.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = dist$2.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = dist$2.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = dist$2.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = ANCHOR_ERROR__INVALID_PROGRAM_ID = dist$2.ANCHOR_ERROR__INVALID_PROGRAM_ID = ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = dist$2.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = dist$2.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = dist$2.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = dist$2.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = dist$2.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = dist$2.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = ANCHOR_ERROR__REQUIRE_GT_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_GT_VIOLATED = ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = void 0
  , ANCHOR_ERROR__INSTRUCTION_MISSING = dist$2.ANCHOR_ERROR__INSTRUCTION_MISSING = 100
  , ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = dist$2.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = 101
  , ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = dist$2.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = 102
  , ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = dist$2.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = 103
  , ANCHOR_ERROR__IDL_INSTRUCTION_STUB = dist$2.ANCHOR_ERROR__IDL_INSTRUCTION_STUB = 1e3
  , ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = dist$2.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = 1001
  , ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = dist$2.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = 1002
  , ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = dist$2.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = 1500
  , ANCHOR_ERROR__CONSTRAINT_MUT = dist$2.ANCHOR_ERROR__CONSTRAINT_MUT = 2e3
  , ANCHOR_ERROR__CONSTRAINT_HAS_ONE = dist$2.ANCHOR_ERROR__CONSTRAINT_HAS_ONE = 2001
  , ANCHOR_ERROR__CONSTRAINT_SIGNER = dist$2.ANCHOR_ERROR__CONSTRAINT_SIGNER = 2002
  , ANCHOR_ERROR__CONSTRAINT_RAW = dist$2.ANCHOR_ERROR__CONSTRAINT_RAW = 2003
  , ANCHOR_ERROR__CONSTRAINT_OWNER = dist$2.ANCHOR_ERROR__CONSTRAINT_OWNER = 2004
  , ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = dist$2.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = 2005
  , ANCHOR_ERROR__CONSTRAINT_SEEDS = dist$2.ANCHOR_ERROR__CONSTRAINT_SEEDS = 2006
  , ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = dist$2.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = 2007
  , ANCHOR_ERROR__CONSTRAINT_STATE = dist$2.ANCHOR_ERROR__CONSTRAINT_STATE = 2008
  , ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = dist$2.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = 2009
  , ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = dist$2.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = 2010
  , ANCHOR_ERROR__CONSTRAINT_CLOSE = dist$2.ANCHOR_ERROR__CONSTRAINT_CLOSE = 2011
  , ANCHOR_ERROR__CONSTRAINT_ADDRESS = dist$2.ANCHOR_ERROR__CONSTRAINT_ADDRESS = 2012
  , ANCHOR_ERROR__CONSTRAINT_ZERO = dist$2.ANCHOR_ERROR__CONSTRAINT_ZERO = 2013
  , ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = dist$2.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = 2014
  , ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = dist$2.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = 2015
  , ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = 2016
  , ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = 2017
  , ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = 2018
  , ANCHOR_ERROR__CONSTRAINT_SPACE = dist$2.ANCHOR_ERROR__CONSTRAINT_SPACE = 2019
  , ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = dist$2.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = 2020
  , ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = dist$2.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = 2021
  , ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = 2022
  , ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = dist$2.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = 2023
  , ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = 2024
  , ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = 2025
  , ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = 2026
  , ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = 2027
  , ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = 2028
  , ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = 2029
  , ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = 2030
  , ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = 2031
  , ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = 2032
  , ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = 2033
  , ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = 2034
  , ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = 2035
  , ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = 2036
  , ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = 2037
  , ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = 2038
  , ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = dist$2.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = 2039
  , ANCHOR_ERROR__REQUIRE_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_VIOLATED = 2500;
ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = 2501;
var ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = 2502
  , ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = 2503
  , ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = 2504
  , ANCHOR_ERROR__REQUIRE_GT_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_GT_VIOLATED = 2505
  , ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = dist$2.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = 2506
  , ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = dist$2.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = 3e3
  , ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = dist$2.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = 3001
  , ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = dist$2.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = 3002
  , ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = dist$2.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = 3003
  , ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = dist$2.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = 3004
  , ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = 3005
  , ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = 3006
  , ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = dist$2.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = 3007
  , ANCHOR_ERROR__INVALID_PROGRAM_ID = dist$2.ANCHOR_ERROR__INVALID_PROGRAM_ID = 3008
  , ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = dist$2.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = 3009
  , ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = 3010
  , ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = 3011
  , ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = 3012
  , ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = 3013
  , ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = dist$2.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = 3014
  , ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = dist$2.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = 3015
  , ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = dist$2.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = 3016
  , ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = dist$2.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = 3017
  , ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = dist$2.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = 4100
  , ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = dist$2.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = 4101
  , ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = dist$2.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = 4102;
ANCHOR_ERROR__DEPRECATED = dist$2.ANCHOR_ERROR__DEPRECATED = 5e3;
const _FEATURES = new Map;
function isSet$1(_e) {
    return _FEATURES.get(_e) !== void 0
}
class IdlError extends Error {
    constructor($) {
        super($),
        this.name = "IdlError"
    }
}
class ProgramErrorStack {
    constructor($) {
        this.stack = $
    }
    static parse($) {
        var et;
        const tt = /^Program (\w*) invoke/
          , nt = /^Program \w* success/
          , rt = [];
        for (let it = 0; it < $.length; it++) {
            if (nt.exec($[it])) {
                rt.pop();
                continue
            }
            const ot = (et = tt.exec($[it])) === null || et === void 0 ? void 0 : et[1];
            ot && rt.push(new PublicKey(ot))
        }
        return new ProgramErrorStack(rt)
    }
}
class AnchorError extends Error {
    constructor($, et, tt, nt, rt, it) {
        super(tt.join(`
`).replace("Program log: ", "")),
        this.errorLogs = tt,
        this.logs = nt,
        this.error = {
            errorCode: $,
            errorMessage: et,
            comparedValues: it,
            origin: rt
        },
        this._programErrorStack = ProgramErrorStack.parse(nt)
    }
    static parse($) {
        if (!$)
            return null;
        const et = $.findIndex(pt => pt.startsWith("Program log: AnchorError"));
        if (et === -1)
            return null;
        const tt = $[et]
          , nt = [tt];
        let rt;
        if (et + 1 < $.length) {
            if ($[et + 1] === "Program log: Left:") {
                const pt = /^Program log: (.*)$/
                  , ht = pt.exec($[et + 2])[1]
                  , mt = pt.exec($[et + 4])[1];
                rt = [new PublicKey(ht), new PublicKey(mt)],
                nt.push(...$.slice(et + 1, et + 5))
            } else if ($[et + 1].startsWith("Program log: Left:")) {
                const pt = /^Program log: (Left|Right): (.*)$/
                  , ht = pt.exec($[et + 1])[2]
                  , mt = pt.exec($[et + 2])[2];
                nt.push(...$.slice(et + 1, et + 3)),
                rt = [ht, mt]
            }
        }
        const ot = /^Program log: AnchorError occurred\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(tt)
          , lt = /^Program log: AnchorError thrown in (.*):(\d*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(tt)
          , dt = /^Program log: AnchorError caused by account: (.*)\. Error Code: (.*)\. Error Number: (\d*)\. Error Message: (.*)\./.exec(tt);
        if (ot) {
            const [pt,ht,mt] = ot.slice(1, 4)
              , yt = {
                code: pt,
                number: parseInt(ht)
            };
            return new AnchorError(yt,mt,nt,$,void 0,rt)
        } else if (lt) {
            const [pt,ht,mt,yt,Et] = lt.slice(1, 6)
              , _t = {
                code: mt,
                number: parseInt(yt)
            }
              , wt = {
                file: pt,
                line: parseInt(ht)
            };
            return new AnchorError(_t,Et,nt,$,wt,rt)
        } else if (dt) {
            const [pt,ht,mt,yt] = dt.slice(1, 5)
              , Et = pt
              , _t = {
                code: ht,
                number: parseInt(mt)
            };
            return new AnchorError(_t,yt,nt,$,Et,rt)
        } else
            return null
    }
    get program() {
        return this._programErrorStack.stack[this._programErrorStack.stack.length - 1]
    }
    get programErrorStack() {
        return this._programErrorStack.stack
    }
    toString() {
        return this.message
    }
}
class ProgramError extends Error {
    constructor($, et, tt) {
        super(),
        this.code = $,
        this.msg = et,
        this.logs = tt,
        tt && (this._programErrorStack = ProgramErrorStack.parse(tt))
    }
    static parse($, et) {
        const tt = $.toString();
        let nt;
        if (tt.includes("custom program error:")) {
            let ot = tt.split("custom program error: ");
            if (ot.length !== 2)
                return null;
            nt = ot[1]
        } else {
            const ot = tt.match(/"Custom":([0-9]+)}/g);
            if (!ot || ot.length > 1)
                return null;
            nt = ot[0].match(/([0-9]+)/g)[0]
        }
        let rt;
        try {
            rt = parseInt(nt)
        } catch {
            return null
        }
        let it = et.get(rt);
        return it !== void 0 ? new ProgramError(rt,it,$.logs) : (it = LangErrorMessage.get(rt),
        it !== void 0 ? new ProgramError(rt,it,$.logs) : null)
    }
    get program() {
        var $;
        return ($ = this._programErrorStack) === null || $ === void 0 ? void 0 : $.stack[this._programErrorStack.stack.length - 1]
    }
    get programErrorStack() {
        var $;
        return ($ = this._programErrorStack) === null || $ === void 0 ? void 0 : $.stack
    }
    toString() {
        return this.msg
    }
}
function translateError(_e, $) {
    isSet$1("debug-logs");
    const et = AnchorError.parse(_e.logs);
    if (et)
        return et;
    const tt = ProgramError.parse(_e, $);
    if (tt)
        return tt;
    if (_e.logs) {
        const nt = {
            get: function(rt, it) {
                return it === "programErrorStack" ? rt.programErrorStack.stack : it === "program" ? rt.programErrorStack.stack[_e.programErrorStack.stack.length - 1] : Reflect.get(...arguments)
            }
        };
        return _e.programErrorStack = ProgramErrorStack.parse(_e.logs),
        new Proxy(_e,nt)
    }
    return _e
}
const LangErrorCode = {
    InstructionMissing: ANCHOR_ERROR__INSTRUCTION_MISSING,
    InstructionFallbackNotFound: ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND,
    InstructionDidNotDeserialize: ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE,
    InstructionDidNotSerialize: ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE,
    IdlInstructionStub: ANCHOR_ERROR__IDL_INSTRUCTION_STUB,
    IdlInstructionInvalidProgram: ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM,
    IdlAccountNotEmpty: ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY,
    EventInstructionStub: ANCHOR_ERROR__EVENT_INSTRUCTION_STUB,
    ConstraintMut: ANCHOR_ERROR__CONSTRAINT_MUT,
    ConstraintHasOne: ANCHOR_ERROR__CONSTRAINT_HAS_ONE,
    ConstraintSigner: ANCHOR_ERROR__CONSTRAINT_SIGNER,
    ConstraintRaw: ANCHOR_ERROR__CONSTRAINT_RAW,
    ConstraintOwner: ANCHOR_ERROR__CONSTRAINT_OWNER,
    ConstraintRentExempt: ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT,
    ConstraintSeeds: ANCHOR_ERROR__CONSTRAINT_SEEDS,
    ConstraintExecutable: ANCHOR_ERROR__CONSTRAINT_EXECUTABLE,
    ConstraintState: ANCHOR_ERROR__CONSTRAINT_STATE,
    ConstraintAssociated: ANCHOR_ERROR__CONSTRAINT_ASSOCIATED,
    ConstraintAssociatedInit: ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT,
    ConstraintClose: ANCHOR_ERROR__CONSTRAINT_CLOSE,
    ConstraintAddress: ANCHOR_ERROR__CONSTRAINT_ADDRESS,
    ConstraintZero: ANCHOR_ERROR__CONSTRAINT_ZERO,
    ConstraintTokenMint: ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT,
    ConstraintTokenOwner: ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER,
    ConstraintMintMintAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY,
    ConstraintMintFreezeAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY,
    ConstraintMintDecimals: ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS,
    ConstraintSpace: ANCHOR_ERROR__CONSTRAINT_SPACE,
    ConstraintAccountIsNone: ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE,
    ConstraintTokenTokenProgram: ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM,
    ConstraintMintTokenProgram: ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM,
    ConstraintAssociatedTokenTokenProgram: ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM,
    ConstraintMintGroupPointerExtension: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION,
    ConstraintMintGroupPointerExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY,
    ConstraintMintGroupPointerExtensionGroupAddress: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS,
    ConstraintMintGroupMemberPointerExtension: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION,
    ConstraintMintGroupMemberPointerExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY,
    ConstraintMintGroupMemberPointerExtensionMemberAddress: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS,
    ConstraintMintMetadataPointerExtension: ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION,
    ConstraintMintMetadataPointerExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY,
    ConstraintMintMetadataPointerExtensionMetadataAddress: ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS,
    ConstraintMintCloseAuthorityExtension: ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION,
    ConstraintMintCloseAuthorityExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY,
    ConstraintMintPermanentDelegateExtension: ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION,
    ConstraintMintPermanentDelegateExtensionDelegate: ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE,
    ConstraintMintTransferHookExtension: ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION,
    ConstraintMintTransferHookExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY,
    ConstraintMintTransferHookExtensionProgramId: ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID,
    RequireViolated: ANCHOR_ERROR__REQUIRE_VIOLATED,
    RequireEqViolated: ANCHOR_ERROR__REQUIRE_EQ_VIOLATED,
    RequireKeysEqViolated: ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED,
    RequireNeqViolated: ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED,
    RequireKeysNeqViolated: ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED,
    RequireGtViolated: ANCHOR_ERROR__REQUIRE_GT_VIOLATED,
    RequireGteViolated: ANCHOR_ERROR__REQUIRE_GTE_VIOLATED,
    AccountDiscriminatorAlreadySet: ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET,
    AccountDiscriminatorNotFound: ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND,
    AccountDiscriminatorMismatch: ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH,
    AccountDidNotDeserialize: ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE,
    AccountDidNotSerialize: ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE,
    AccountNotEnoughKeys: ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS,
    AccountNotMutable: ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE,
    AccountOwnedByWrongProgram: ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM,
    InvalidProgramId: ANCHOR_ERROR__INVALID_PROGRAM_ID,
    InvalidProgramExecutable: ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE,
    AccountNotSigner: ANCHOR_ERROR__ACCOUNT_NOT_SIGNER,
    AccountNotSystemOwned: ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED,
    AccountNotInitialized: ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED,
    AccountNotProgramData: ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA,
    AccountNotAssociatedTokenAccount: ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT,
    AccountSysvarMismatch: ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH,
    AccountReallocExceedsLimit: ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT,
    AccountDuplicateReallocs: ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS,
    DeclaredProgramIdMismatch: ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH,
    TryingToInitPayerAsProgramAccount: ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT,
    InvalidNumericConversion: ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION,
    Deprecated: ANCHOR_ERROR__DEPRECATED
}
  , LangErrorMessage = new Map([[LangErrorCode.InstructionMissing, "8 byte instruction identifier not provided"], [LangErrorCode.InstructionFallbackNotFound, "Fallback functions are not supported"], [LangErrorCode.InstructionDidNotDeserialize, "The program could not deserialize the given instruction"], [LangErrorCode.InstructionDidNotSerialize, "The program could not serialize the given instruction"], [LangErrorCode.IdlInstructionStub, "The program was compiled without idl instructions"], [LangErrorCode.IdlInstructionInvalidProgram, "The transaction was given an invalid program for the IDL instruction"], [LangErrorCode.IdlAccountNotEmpty, "IDL account must be empty in order to resize, try closing first"], [LangErrorCode.EventInstructionStub, "The program was compiled without `event-cpi` feature"], [LangErrorCode.ConstraintMut, "A mut constraint was violated"], [LangErrorCode.ConstraintHasOne, "A has one constraint was violated"], [LangErrorCode.ConstraintSigner, "A signer constraint was violated"], [LangErrorCode.ConstraintRaw, "A raw constraint was violated"], [LangErrorCode.ConstraintOwner, "An owner constraint was violated"], [LangErrorCode.ConstraintRentExempt, "A rent exemption constraint was violated"], [LangErrorCode.ConstraintSeeds, "A seeds constraint was violated"], [LangErrorCode.ConstraintExecutable, "An executable constraint was violated"], [LangErrorCode.ConstraintState, "Deprecated Error, feel free to replace with something else"], [LangErrorCode.ConstraintAssociated, "An associated constraint was violated"], [LangErrorCode.ConstraintAssociatedInit, "An associated init constraint was violated"], [LangErrorCode.ConstraintClose, "A close constraint was violated"], [LangErrorCode.ConstraintAddress, "An address constraint was violated"], [LangErrorCode.ConstraintZero, "Expected zero account discriminant"], [LangErrorCode.ConstraintTokenMint, "A token mint constraint was violated"], [LangErrorCode.ConstraintTokenOwner, "A token owner constraint was violated"], [LangErrorCode.ConstraintMintMintAuthority, "A mint mint authority constraint was violated"], [LangErrorCode.ConstraintMintFreezeAuthority, "A mint freeze authority constraint was violated"], [LangErrorCode.ConstraintMintDecimals, "A mint decimals constraint was violated"], [LangErrorCode.ConstraintSpace, "A space constraint was violated"], [LangErrorCode.ConstraintAccountIsNone, "A required account for the constraint is None"], [LangErrorCode.ConstraintTokenTokenProgram, "A token account token program constraint was violated"], [LangErrorCode.ConstraintMintTokenProgram, "A mint token program constraint was violated"], [LangErrorCode.ConstraintAssociatedTokenTokenProgram, "An associated token account token program constraint was violated"], [LangErrorCode.ConstraintMintGroupPointerExtension, "A group pointer extension constraint was violated"], [LangErrorCode.ConstraintMintGroupPointerExtensionAuthority, "A group pointer extension authority constraint was violated"], [LangErrorCode.ConstraintMintGroupPointerExtensionGroupAddress, "A group pointer extension group address constraint was violated"], [LangErrorCode.ConstraintMintGroupMemberPointerExtension, "A group member pointer extension constraint was violated"], [LangErrorCode.ConstraintMintGroupMemberPointerExtensionAuthority, "A group member pointer extension authority constraint was violated"], [LangErrorCode.ConstraintMintGroupMemberPointerExtensionMemberAddress, "A group member pointer extension group address constraint was violated"], [LangErrorCode.ConstraintMintMetadataPointerExtension, "A metadata pointer extension constraint was violated"], [LangErrorCode.ConstraintMintMetadataPointerExtensionAuthority, "A metadata pointer extension authority constraint was violated"], [LangErrorCode.ConstraintMintMetadataPointerExtensionMetadataAddress, "A metadata pointer extension metadata address constraint was violated"], [LangErrorCode.ConstraintMintCloseAuthorityExtension, "A close authority constraint was violated"], [LangErrorCode.ConstraintMintCloseAuthorityExtensionAuthority, "A close authority extension authority constraint was violated"], [LangErrorCode.ConstraintMintPermanentDelegateExtension, "A permanent delegate extension constraint was violated"], [LangErrorCode.ConstraintMintPermanentDelegateExtensionDelegate, "A permanent delegate extension delegate constraint was violated"], [LangErrorCode.ConstraintMintTransferHookExtension, "A transfer hook extension constraint was violated"], [LangErrorCode.ConstraintMintTransferHookExtensionAuthority, "A transfer hook extension authority constraint was violated"], [LangErrorCode.ConstraintMintTransferHookExtensionProgramId, "A transfer hook extension transfer hook program id constraint was violated"], [LangErrorCode.RequireViolated, "A require expression was violated"], [LangErrorCode.RequireEqViolated, "A require_eq expression was violated"], [LangErrorCode.RequireKeysEqViolated, "A require_keys_eq expression was violated"], [LangErrorCode.RequireNeqViolated, "A require_neq expression was violated"], [LangErrorCode.RequireKeysNeqViolated, "A require_keys_neq expression was violated"], [LangErrorCode.RequireGtViolated, "A require_gt expression was violated"], [LangErrorCode.RequireGteViolated, "A require_gte expression was violated"], [LangErrorCode.AccountDiscriminatorAlreadySet, "The account discriminator was already set on this account"], [LangErrorCode.AccountDiscriminatorNotFound, "No 8 byte discriminator was found on the account"], [LangErrorCode.AccountDiscriminatorMismatch, "8 byte discriminator did not match what was expected"], [LangErrorCode.AccountDidNotDeserialize, "Failed to deserialize the account"], [LangErrorCode.AccountDidNotSerialize, "Failed to serialize the account"], [LangErrorCode.AccountNotEnoughKeys, "Not enough account keys given to the instruction"], [LangErrorCode.AccountNotMutable, "The given account is not mutable"], [LangErrorCode.AccountOwnedByWrongProgram, "The given account is owned by a different program than expected"], [LangErrorCode.InvalidProgramId, "Program ID was not as expected"], [LangErrorCode.InvalidProgramExecutable, "Program account is not executable"], [LangErrorCode.AccountNotSigner, "The given account did not sign"], [LangErrorCode.AccountNotSystemOwned, "The given account is not owned by the system program"], [LangErrorCode.AccountNotInitialized, "The program expected this account to be already initialized"], [LangErrorCode.AccountNotProgramData, "The given account is not a program data account"], [LangErrorCode.AccountNotAssociatedTokenAccount, "The given account is not the associated token account"], [LangErrorCode.AccountSysvarMismatch, "The given public key does not match the required sysvar"], [LangErrorCode.AccountReallocExceedsLimit, "The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit"], [LangErrorCode.AccountDuplicateReallocs, "The account was duplicated for more than one reallocation"], [LangErrorCode.DeclaredProgramIdMismatch, "The declared program id does not match the actual program id"], [LangErrorCode.TryingToInitPayerAsProgramAccount, "You cannot/should not initialize the payer account as a program account"], [LangErrorCode.InvalidNumericConversion, "The program could not perform the numeric conversion, out of range integral type conversion attempted"], [LangErrorCode.Deprecated, "The API being used is deprecated and should no longer be used"]]);
class IdlCoder {
    static fieldLayout($, et=[], tt) {
        const nt = $.name;
        switch ($.type) {
        case "bool":
            return dist$3.bool(nt);
        case "u8":
            return dist$3.u8(nt);
        case "i8":
            return dist$3.i8(nt);
        case "u16":
            return dist$3.u16(nt);
        case "i16":
            return dist$3.i16(nt);
        case "u32":
            return dist$3.u32(nt);
        case "i32":
            return dist$3.i32(nt);
        case "f32":
            return dist$3.f32(nt);
        case "u64":
            return dist$3.u64(nt);
        case "i64":
            return dist$3.i64(nt);
        case "f64":
            return dist$3.f64(nt);
        case "u128":
            return dist$3.u128(nt);
        case "i128":
            return dist$3.i128(nt);
        case "u256":
            return dist$3.u256(nt);
        case "i256":
            return dist$3.i256(nt);
        case "bytes":
            return dist$3.vecU8(nt);
        case "string":
            return dist$3.str(nt);
        case "pubkey":
            return dist$3.publicKey(nt);
        default:
            {
                if ("option"in $.type)
                    return dist$3.option(IdlCoder.fieldLayout({
                        type: $.type.option
                    }, et, tt), nt);
                if ("vec"in $.type)
                    return dist$3.vec(IdlCoder.fieldLayout({
                        type: $.type.vec
                    }, et, tt), nt);
                if ("array"in $.type) {
                    let[rt,it] = $.type.array;
                    return it = IdlCoder.resolveArrayLen(it, tt),
                    dist$3.array(IdlCoder.fieldLayout({
                        type: rt
                    }, et, tt), it, nt)
                }
                if ("defined"in $.type) {
                    if (!et)
                        throw new IdlError("User defined types not provided");
                    const rt = $.type.defined.name
                      , it = et.find(ot => ot.name === rt);
                    if (!it)
                        throw new IdlError(`Type not found: ${$.name}`);
                    return IdlCoder.typeDefLayout({
                        typeDef: it,
                        types: et,
                        genericArgs: tt ?? $.type.defined.generics,
                        name: nt
                    })
                }
                if ("generic"in $.type) {
                    const rt = tt == null ? void 0 : tt.at(0);
                    if ((rt == null ? void 0 : rt.kind) !== "type")
                        throw new IdlError(`Invalid generic field: ${$.name}`);
                    return IdlCoder.fieldLayout({
                        ...$,
                        type: rt.type
                    }, et)
                }
                throw new IdlError(`Not yet implemented: ${JSON.stringify($.type)}`)
            }
        }
    }
    static typeDefLayout({typeDef: $, types: et, name: tt, genericArgs: nt}) {
        switch ($.type.kind) {
        case "struct":
            {
                const rt = handleDefinedFields($.type.fields, () => [], it => it.map(ot => {
                    const st = nt && IdlCoder.resolveGenericArgs({
                        type: ot.type,
                        typeDef: $,
                        genericArgs: nt
                    });
                    return IdlCoder.fieldLayout(ot, et, st)
                }
                ), it => it.map( (ot, st) => {
                    const lt = nt && IdlCoder.resolveGenericArgs({
                        type: ot,
                        typeDef: $,
                        genericArgs: nt
                    });
                    return IdlCoder.fieldLayout({
                        name: st.toString(),
                        type: ot
                    }, et, lt)
                }
                ));
                return dist$3.struct(rt, tt)
            }
        case "enum":
            {
                const rt = $.type.variants.map(it => {
                    const ot = handleDefinedFields(it.fields, () => [], st => st.map(lt => {
                        const ct = nt && IdlCoder.resolveGenericArgs({
                            type: lt.type,
                            typeDef: $,
                            genericArgs: nt
                        });
                        return IdlCoder.fieldLayout(lt, et, ct)
                    }
                    ), st => st.map( (lt, ct) => {
                        const dt = nt && IdlCoder.resolveGenericArgs({
                            type: lt,
                            typeDef: $,
                            genericArgs: nt
                        });
                        return IdlCoder.fieldLayout({
                            name: ct.toString(),
                            type: lt
                        }, et, dt)
                    }
                    ));
                    return dist$3.struct(ot, it.name)
                }
                );
                return tt !== void 0 ? dist$3.rustEnum(rt).replicate(tt) : dist$3.rustEnum(rt, tt)
            }
        case "type":
            return IdlCoder.fieldLayout({
                type: $.type.alias,
                name: tt
            }, et)
        }
    }
    static typeSize($, et, tt) {
        var nt;
        switch ($) {
        case "bool":
            return 1;
        case "u8":
            return 1;
        case "i8":
            return 1;
        case "i16":
            return 2;
        case "u16":
            return 2;
        case "u32":
            return 4;
        case "i32":
            return 4;
        case "f32":
            return 4;
        case "u64":
            return 8;
        case "i64":
            return 8;
        case "f64":
            return 8;
        case "u128":
            return 16;
        case "i128":
            return 16;
        case "u256":
            return 32;
        case "i256":
            return 32;
        case "bytes":
            return 1;
        case "string":
            return 1;
        case "pubkey":
            return 32;
        default:
            if ("option"in $)
                return 1 + IdlCoder.typeSize($.option, et, tt);
            if ("coption"in $)
                return 4 + IdlCoder.typeSize($.coption, et, tt);
            if ("vec"in $)
                return 1;
            if ("array"in $) {
                let[rt,it] = $.array;
                return it = IdlCoder.resolveArrayLen(it, tt),
                IdlCoder.typeSize(rt, et, tt) * it
            }
            if ("defined"in $) {
                const rt = (nt = et.types) === null || nt === void 0 ? void 0 : nt.find(ot => ot.name === $.defined.name);
                if (!rt)
                    throw new IdlError(`Type not found: ${JSON.stringify($)}`);
                const it = ot => {
                    const st = tt ?? $.defined.generics
                      , lt = st && IdlCoder.resolveGenericArgs({
                        type: ot,
                        typeDef: rt,
                        genericArgs: st
                    });
                    return IdlCoder.typeSize(ot, et, lt)
                }
                ;
                switch (rt.type.kind) {
                case "struct":
                    return handleDefinedFields(rt.type.fields, () => [0], ot => ot.map(st => it(st.type)), ot => ot.map(st => it(st))).reduce( (ot, st) => ot + st, 0);
                case "enum":
                    {
                        const ot = rt.type.variants.map(st => handleDefinedFields(st.fields, () => [0], lt => lt.map(ct => it(ct.type)), lt => lt.map(ct => it(ct))).reduce( (lt, ct) => lt + ct, 0));
                        return Math.max(...ot) + 1
                    }
                case "type":
                    return IdlCoder.typeSize(rt.type.alias, et, tt)
                }
            }
            if ("generic"in $) {
                const rt = tt == null ? void 0 : tt.at(0);
                if ((rt == null ? void 0 : rt.kind) !== "type")
                    throw new IdlError(`Invalid generic: ${$.generic}`);
                return IdlCoder.typeSize(rt.type, et, tt)
            }
            throw new Error(`Invalid type ${JSON.stringify($)}`)
        }
    }
    static resolveArrayLen($, et) {
        if (typeof $ == "number")
            return $;
        if (et) {
            const tt = et.find(nt => nt.kind === "const");
            (tt == null ? void 0 : tt.kind) === "const" && ($ = +tt.value)
        }
        if (typeof $ != "number")
            throw new IdlError("Generic array length did not resolve");
        return $
    }
    static resolveGenericArgs({type: $, typeDef: et, genericArgs: tt, isDefined: nt}) {
        if (typeof $ != "object")
            return null;
        for (const rt in et.generics) {
            const it = et.generics[rt];
            if ("generic"in $ && it.name === $.generic)
                return [tt[rt]];
            if ("option"in $) {
                const ot = IdlCoder.resolveGenericArgs({
                    type: $.option,
                    typeDef: et,
                    genericArgs: tt,
                    isDefined: nt
                });
                if (!ot || !nt)
                    return ot;
                if (ot[0].kind === "type")
                    return [{
                        kind: "type",
                        type: {
                            option: ot[0].type
                        }
                    }]
            }
            if ("vec"in $) {
                const ot = IdlCoder.resolveGenericArgs({
                    type: $.vec,
                    typeDef: et,
                    genericArgs: tt,
                    isDefined: nt
                });
                if (!ot || !nt)
                    return ot;
                if (ot[0].kind === "type")
                    return [{
                        kind: "type",
                        type: {
                            vec: ot[0].type
                        }
                    }]
            }
            if ("array"in $) {
                const [ot,st] = $.array
                  , lt = typeof st == "object"
                  , ct = IdlCoder.resolveGenericArgs({
                    type: ot,
                    typeDef: et,
                    genericArgs: tt,
                    isDefined: nt
                });
                if (ct) {
                    for (const dt in et.generics.slice(+rt)) {
                        const pt = +rt + +dt;
                        lt && et.generics[pt].name === st.generic && ct.push(tt[pt])
                    }
                    if (!nt)
                        return ct;
                    if (ct[0].kind === "type" && ct[1].kind === "const")
                        return [{
                            kind: "type",
                            type: {
                                array: [ct[0].type, +ct[1].value]
                            }
                        }]
                }
                if (lt && it.name === st.generic) {
                    const dt = tt[rt];
                    return nt ? [{
                        kind: "type",
                        type: {
                            array: [ot, +dt.value]
                        }
                    }] : [dt]
                }
                return null
            }
            if ("defined"in $)
                return $.defined.generics ? $.defined.generics.flatMap(ot => {
                    switch (ot.kind) {
                    case "type":
                        return IdlCoder.resolveGenericArgs({
                            type: ot.type,
                            typeDef: et,
                            genericArgs: tt,
                            isDefined: !0
                        });
                    case "const":
                        return [ot]
                    }
                }
                ).filter(ot => ot !== null) : null
        }
        return null
    }
}
class BorshInstructionCoder {
    constructor($) {
        this.idl = $;
        const et = $.instructions.map(nt => {
            const rt = nt.name
              , it = nt.args.map(st => IdlCoder.fieldLayout(st, $.types))
              , ot = dist$3.struct(it, rt);
            return [rt, {
                discriminator: nt.discriminator,
                layout: ot
            }]
        }
        );
        this.ixLayouts = new Map(et);
        const tt = et.map( ([nt,{discriminator: rt, layout: it}]) => [bs58$3.encode(rt), {
            name: nt,
            layout: it
        }]);
        this.sighashLayouts = new Map(tt)
    }
    encode($, et) {
        const tt = Buffer$1$1.alloc(1e3)
          , nt = this.ixLayouts.get($);
        if (!nt)
            throw new Error(`Unknown method: ${$}`);
        const rt = nt.layout.encode(et, tt)
          , it = tt.slice(0, rt);
        return Buffer$1$1.concat([Buffer$1$1.from(nt.discriminator), it])
    }
    decode($, et="hex") {
        typeof $ == "string" && ($ = et === "hex" ? Buffer$1$1.from($, "hex") : bs58$3.decode($));
        const tt = $.slice(0, DISCRIMINATOR_SIZE)
          , nt = $.slice(DISCRIMINATOR_SIZE)
          , rt = this.sighashLayouts.get(bs58$3.encode(tt));
        return rt ? {
            name: rt.name,
            data: rt.layout.decode(nt)
        } : null
    }
    format($, et) {
        return InstructionFormatter.format($, et, this.idl)
    }
}
class InstructionFormatter {
    static format($, et, tt) {
        const nt = tt.instructions.find(st => $.name === st.name);
        if (!nt)
            return null;
        const rt = nt.args.map(st => ({
            name: st.name,
            type: InstructionFormatter.formatIdlType(st.type),
            data: InstructionFormatter.formatIdlData(st, $.data[st.name], tt.types)
        }))
          , it = InstructionFormatter.flattenIdlAccounts(nt.accounts)
          , ot = et.map( (st, lt) => lt < it.length ? {
            name: it[lt].name,
            ...st
        } : {
            name: void 0,
            ...st
        });
        return {
            args: rt,
            accounts: ot
        }
    }
    static formatIdlType($) {
        if (typeof $ == "string")
            return $;
        if ("option"in $)
            return `Option<${this.formatIdlType($.option)}>`;
        if ("coption"in $)
            return `COption<${this.formatIdlType($.coption)}>`;
        if ("vec"in $)
            return `Vec<${this.formatIdlType($.vec)}>`;
        if ("array"in $)
            return `Array<${$.array[0]}; ${$.array[1]}>`;
        if ("defined"in $) {
            const et = $.defined.name;
            if ($.defined.generics) {
                const tt = $.defined.generics.map(nt => {
                    switch (nt.kind) {
                    case "type":
                        return InstructionFormatter.formatIdlType(nt.type);
                    case "const":
                        return nt.value
                    }
                }
                ).join(", ");
                return `${et}<${tt}>`
            }
            return et
        }
        throw new Error(`Unknown IDL type: ${$}`)
    }
    static formatIdlData($, et, tt) {
        if (typeof $.type == "string")
            return et.toString();
        if ("vec"in $.type)
            return "[" + et.map(nt => this.formatIdlData({
                name: "",
                type: $.type.vec
            }, nt, tt)).join(", ") + "]";
        if ("option"in $.type)
            return et === null ? "null" : this.formatIdlData({
                name: "",
                type: $.type.option
            }, et, tt);
        if ("defined"in $.type) {
            if (!tt)
                throw new Error("User defined types not provided");
            const nt = $.type.defined.name
              , rt = tt.find(it => it.name === nt);
            if (!rt)
                throw new Error(`Type not found: ${nt}`);
            return InstructionFormatter.formatIdlDataDefined(rt, et, tt)
        }
        return "unknown"
    }
    static formatIdlDataDefined($, et, tt) {
        switch ($.type.kind) {
        case "struct":
            return "{ " + handleDefinedFields($.type.fields, () => "", nt => Object.entries(et).map( ([rt,it]) => {
                const ot = nt.find(st => st.name === rt);
                if (!ot)
                    throw new Error(`Field not found: ${rt}`);
                return rt + ": " + InstructionFormatter.formatIdlData(ot, it, tt)
            }
            ).join(", "), nt => Object.entries(et).map( ([rt,it]) => rt + ": " + InstructionFormatter.formatIdlData({
                name: "",
                type: nt[rt]
            }, it, tt)).join(", ")) + " }";
        case "enum":
            {
                const nt = Object.keys(et)[0]
                  , rt = $.type.variants.find(ot => ot.name === nt);
                if (!rt)
                    throw new Error(`Unable to find variant: ${nt}`);
                const it = et[nt];
                return handleDefinedFields(rt.fields, () => nt, ot => {
                    const st = Object.keys(it).map(lt => {
                        const ct = it[lt]
                          , dt = ot.find(pt => pt.name === lt);
                        if (!dt)
                            throw new Error(`Field not found: ${lt}`);
                        return lt + ": " + InstructionFormatter.formatIdlData(dt, ct, tt)
                    }
                    ).join(", ");
                    return `${nt} { ${st} }`
                }
                , ot => {
                    const st = Object.entries(it).map( ([lt,ct]) => lt + ": " + InstructionFormatter.formatIdlData({
                        name: "",
                        type: ot[lt]
                    }, ct, tt)).join(", ");
                    return `${nt} { ${st} }`
                }
                )
            }
        case "type":
            return InstructionFormatter.formatIdlType($.type.alias)
        }
    }
    static flattenIdlAccounts($, et) {
        return $.map(tt => {
            const nt = sentenceCase$1(tt.name);
            if (tt.hasOwnProperty("accounts")) {
                const rt = et ? `${et} > ${nt}` : nt;
                return InstructionFormatter.flattenIdlAccounts(tt.accounts, rt)
            } else
                return {
                    ...tt,
                    name: et ? `${et} > ${nt}` : nt
                }
        }
        ).flat()
    }
}
function sentenceCase$1(_e) {
    const $ = _e.replace(/([A-Z])/g, " $1");
    return $.charAt(0).toUpperCase() + $.slice(1)
}
const DISCRIMINATOR_SIZE = 8;
class BorshAccountsCoder {
    constructor($) {
        if (this.idl = $,
        !$.accounts) {
            this.accountLayouts = new Map;
            return
        }
        const et = $.types;
        if (!et)
            throw new Error("Accounts require `idl.types`");
        const tt = $.accounts.map(nt => {
            const rt = et.find(it => it.name === nt.name);
            if (!rt)
                throw new Error(`Account not found: ${nt.name}`);
            return [nt.name, IdlCoder.typeDefLayout({
                typeDef: rt,
                types: et
            })]
        }
        );
        this.accountLayouts = new Map(tt)
    }
    async encode($, et) {
        const tt = Buffer$1$1.alloc(1e3)
          , nt = this.accountLayouts.get($);
        if (!nt)
            throw new Error(`Unknown account: ${$}`);
        const rt = nt.encode(et, tt)
          , it = tt.slice(0, rt)
          , ot = this.accountDiscriminator($);
        return Buffer$1$1.concat([ot, it])
    }
    decode($, et) {
        if (this.accountDiscriminator($).compare(et.slice(0, DISCRIMINATOR_SIZE)))
            throw new Error("Invalid account discriminator");
        return this.decodeUnchecked($, et)
    }
    decodeAny($) {
        const et = $.slice(0, DISCRIMINATOR_SIZE)
          , tt = Array.from(this.accountLayouts.keys()).find(nt => this.accountDiscriminator(nt).equals(et));
        if (!tt)
            throw new Error("Account not found");
        return this.decodeUnchecked(tt, $)
    }
    decodeUnchecked($, et) {
        const tt = et.subarray(DISCRIMINATOR_SIZE)
          , nt = this.accountLayouts.get($);
        if (!nt)
            throw new Error(`Unknown account: ${$}`);
        return nt.decode(tt)
    }
    memcmp($, et) {
        const tt = this.accountDiscriminator($);
        return {
            offset: 0,
            bytes: bs58$3.encode(et ? Buffer$1$1.concat([tt, et]) : tt)
        }
    }
    size($) {
        return DISCRIMINATOR_SIZE + IdlCoder.typeSize({
            defined: {
                name: $
            }
        }, this.idl)
    }
    accountDiscriminator($) {
        var et;
        const tt = (et = this.idl.accounts) === null || et === void 0 ? void 0 : et.find(nt => nt.name === $);
        if (!tt)
            throw new Error(`Account not found: ${$}`);
        return Buffer$1$1.from(tt.discriminator)
    }
}
class BorshEventCoder {
    constructor($) {
        var et;
        if (!$.events) {
            this.layouts = new Map;
            return
        }
        const tt = $.types;
        if (!tt)
            throw new Error("Events require `idl.types`");
        const nt = $.events.map(rt => {
            const it = tt.find(ot => ot.name === rt.name);
            if (!it)
                throw new Error(`Event not found: ${rt.name}`);
            return [rt.name, IdlCoder.typeDefLayout({
                typeDef: it,
                types: tt
            })]
        }
        );
        this.layouts = new Map(nt),
        this.discriminators = new Map(((et = $.events) !== null && et !== void 0 ? et : []).map(rt => [encode$3(Buffer$1$1.from(rt.discriminator)), rt.name]))
    }
    decode($) {
        let et;
        try {
            et = decode($)
        } catch {
            return null
        }
        const tt = encode$3(et.slice(0, 8))
          , nt = this.discriminators.get(tt);
        if (!nt)
            return null;
        const rt = this.layouts.get(nt);
        if (!rt)
            throw new Error(`Unknown event: ${nt}`);
        return {
            data: rt.decode(et.slice(8)),
            name: nt
        }
    }
}
class BorshTypesCoder {
    constructor($) {
        const et = $.types;
        if (!et) {
            this.typeLayouts = new Map;
            return
        }
        const tt = et.filter(nt => !nt.generics).map(nt => [nt.name, IdlCoder.typeDefLayout({
            typeDef: nt,
            types: et
        })]);
        this.typeLayouts = new Map(tt)
    }
    encode($, et) {
        const tt = Buffer$1$1.alloc(1e3)
          , nt = this.typeLayouts.get($);
        if (!nt)
            throw new Error(`Unknown type: ${$}`);
        const rt = nt.encode(et, tt);
        return tt.slice(0, rt)
    }
    decode($, et) {
        const tt = this.typeLayouts.get($);
        if (!tt)
            throw new Error(`Unknown type: ${$}`);
        return tt.decode(et)
    }
}
class BorshCoder {
    constructor($) {
        this.instruction = new BorshInstructionCoder($),
        this.accounts = new BorshAccountsCoder($),
        this.events = new BorshEventCoder($),
        this.types = new BorshTypesCoder($)
    }
}
class Layout {
    constructor($, et) {
        if (!Number.isInteger($))
            throw new TypeError("span must be an integer");
        this.span = $,
        this.property = et
    }
    makeDestinationObject() {
        return {}
    }
    decode($, et) {
        throw new Error("Layout is abstract")
    }
    encode($, et, tt) {
        throw new Error("Layout is abstract")
    }
    getSpan($, et) {
        if (0 > this.span)
            throw new RangeError("indeterminate span");
        return this.span
    }
    replicate($) {
        const et = Object.create(this.constructor.prototype);
        return Object.assign(et, this),
        et.property = $,
        et
    }
    fromArray($) {}
}
var Layout_2 = Layout;
function nameWithProperty(_e, $) {
    return $.property ? _e + "[" + $.property + "]" : _e
}
class ExternalLayout extends Layout {
    isCount() {
        throw new Error("ExternalLayout is abstract")
    }
}
class OffsetLayout extends ExternalLayout {
    constructor($, et, tt) {
        if (!($ instanceof Layout))
            throw new TypeError("layout must be a Layout");
        if (et === void 0)
            et = 0;
        else if (!Number.isInteger(et))
            throw new TypeError("offset must be integer or undefined");
        super($.span, tt || $.property),
        this.layout = $,
        this.offset = et
    }
    isCount() {
        return this.layout instanceof UInt || this.layout instanceof UIntBE
    }
    decode($, et) {
        return et === void 0 && (et = 0),
        this.layout.decode($, et + this.offset)
    }
    encode($, et, tt) {
        return tt === void 0 && (tt = 0),
        this.layout.encode($, et, tt + this.offset)
    }
}
class UInt extends Layout {
    constructor($, et) {
        if (super($, et),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode($, et) {
        return et === void 0 && (et = 0),
        $.readUIntLE(et, this.span)
    }
    encode($, et, tt) {
        return tt === void 0 && (tt = 0),
        et.writeUIntLE($, tt, this.span),
        this.span
    }
}
class UIntBE extends Layout {
    constructor($, et) {
        if (super($, et),
        6 < this.span)
            throw new RangeError("span must not exceed 6 bytes")
    }
    decode($, et) {
        return et === void 0 && (et = 0),
        $.readUIntBE(et, this.span)
    }
    encode($, et, tt) {
        return tt === void 0 && (tt = 0),
        et.writeUIntBE($, tt, this.span),
        this.span
    }
}
const V2E32 = Math.pow(2, 32);
function divmodInt64(_e) {
    const $ = Math.floor(_e / V2E32)
      , et = _e - $ * V2E32;
    return {
        hi32: $,
        lo32: et
    }
}
function roundedInt64(_e, $) {
    return _e * V2E32 + $
}
class NearUInt64 extends Layout {
    constructor($) {
        super(8, $)
    }
    decode($, et) {
        et === void 0 && (et = 0);
        const tt = $.readUInt32LE(et)
          , nt = $.readUInt32LE(et + 4);
        return roundedInt64(nt, tt)
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        const nt = divmodInt64($);
        return et.writeUInt32LE(nt.lo32, tt),
        et.writeUInt32LE(nt.hi32, tt + 4),
        8
    }
}
class NearInt64 extends Layout {
    constructor($) {
        super(8, $)
    }
    decode($, et) {
        et === void 0 && (et = 0);
        const tt = $.readUInt32LE(et)
          , nt = $.readInt32LE(et + 4);
        return roundedInt64(nt, tt)
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        const nt = divmodInt64($);
        return et.writeUInt32LE(nt.lo32, tt),
        et.writeInt32LE(nt.hi32, tt + 4),
        8
    }
}
class Structure extends Layout {
    constructor($, et, tt) {
        if (!(Array.isArray($) && $.reduce( (rt, it) => rt && it instanceof Layout, !0)))
            throw new TypeError("fields must be array of Layout instances");
        typeof et == "boolean" && tt === void 0 && (tt = et,
        et = void 0);
        for (const rt of $)
            if (0 > rt.span && rt.property === void 0)
                throw new Error("fields cannot contain unnamed variable-length layout");
        let nt = -1;
        try {
            nt = $.reduce( (rt, it) => rt + it.getSpan(), 0)
        } catch {}
        super(nt, et),
        this.fields = $,
        this.decodePrefixes = !!tt
    }
    getSpan($, et) {
        if (0 <= this.span)
            return this.span;
        et === void 0 && (et = 0);
        let tt = 0;
        try {
            tt = this.fields.reduce( (nt, rt) => {
                const it = rt.getSpan($, et);
                return et += it,
                nt + it
            }
            , 0)
        } catch {
            throw new RangeError("indeterminate span")
        }
        return tt
    }
    decode($, et) {
        et === void 0 && (et = 0);
        const tt = this.makeDestinationObject();
        for (const nt of this.fields)
            if (nt.property !== void 0 && (tt[nt.property] = nt.decode($, et)),
            et += nt.getSpan($, et),
            this.decodePrefixes && $.length === et)
                break;
        return tt
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        const nt = tt;
        let rt = 0
          , it = 0;
        for (const ot of this.fields) {
            let st = ot.span;
            if (it = 0 < st ? st : 0,
            ot.property !== void 0) {
                const lt = $[ot.property];
                lt !== void 0 && (it = ot.encode(lt, et, tt),
                0 > st && (st = ot.getSpan(et, tt)))
            }
            rt = tt,
            tt += st
        }
        return rt + it - nt
    }
    fromArray($) {
        const et = this.makeDestinationObject();
        for (const tt of this.fields)
            tt.property !== void 0 && 0 < $.length && (et[tt.property] = $.shift());
        return et
    }
    layoutFor($) {
        if (typeof $ != "string")
            throw new TypeError("property must be string");
        for (const et of this.fields)
            if (et.property === $)
                return et
    }
    offsetOf($) {
        if (typeof $ != "string")
            throw new TypeError("property must be string");
        let et = 0;
        for (const tt of this.fields) {
            if (tt.property === $)
                return et;
            0 > tt.span ? et = -1 : 0 <= et && (et += tt.span)
        }
    }
}
class UnionDiscriminator {
    constructor($) {
        this.property = $
    }
    decode() {
        throw new Error("UnionDiscriminator is abstract")
    }
    encode() {
        throw new Error("UnionDiscriminator is abstract")
    }
}
class UnionLayoutDiscriminator extends UnionDiscriminator {
    constructor($, et) {
        if (!($ instanceof ExternalLayout && $.isCount()))
            throw new TypeError("layout must be an unsigned integer ExternalLayout");
        super(et || $.property || "variant"),
        this.layout = $
    }
    decode($, et) {
        return this.layout.decode($, et)
    }
    encode($, et, tt) {
        return this.layout.encode($, et, tt)
    }
}
class Union extends Layout {
    constructor($, et, tt) {
        const nt = $ instanceof UInt || $ instanceof UIntBE;
        if (nt)
            $ = new UnionLayoutDiscriminator(new OffsetLayout($));
        else if ($ instanceof ExternalLayout && $.isCount())
            $ = new UnionLayoutDiscriminator($);
        else if (!($ instanceof UnionDiscriminator))
            throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
        if (et === void 0 && (et = null),
        !(et === null || et instanceof Layout))
            throw new TypeError("defaultLayout must be null or a Layout");
        if (et !== null) {
            if (0 > et.span)
                throw new Error("defaultLayout must have constant span");
            et.property === void 0 && (et = et.replicate("content"))
        }
        let rt = -1;
        et && (rt = et.span,
        0 <= rt && nt && (rt += $.layout.span)),
        super(rt, tt),
        this.discriminator = $,
        this.usesPrefixDiscriminator = nt,
        this.defaultLayout = et,
        this.registry = {};
        let it = this.defaultGetSourceVariant.bind(this);
        this.getSourceVariant = function(ot) {
            return it(ot)
        }
        ,
        this.configGetSourceVariant = function(ot) {
            it = ot.bind(this)
        }
    }
    getSpan($, et) {
        if (0 <= this.span)
            return this.span;
        et === void 0 && (et = 0);
        const tt = this.getVariant($, et);
        if (!tt)
            throw new Error("unable to determine span for unrecognized variant");
        return tt.getSpan($, et)
    }
    defaultGetSourceVariant($) {
        if ($.hasOwnProperty(this.discriminator.property)) {
            if (this.defaultLayout && $.hasOwnProperty(this.defaultLayout.property))
                return;
            const et = this.registry[$[this.discriminator.property]];
            if (et && (!et.layout || $.hasOwnProperty(et.property)))
                return et
        } else
            for (const et in this.registry) {
                const tt = this.registry[et];
                if ($.hasOwnProperty(tt.property))
                    return tt
            }
        throw new Error("unable to infer src variant")
    }
    decode($, et) {
        et === void 0 && (et = 0);
        let tt;
        const nt = this.discriminator
          , rt = nt.decode($, et);
        let it = this.registry[rt];
        if (it === void 0) {
            let ot = 0;
            it = this.defaultLayout,
            this.usesPrefixDiscriminator && (ot = nt.layout.span),
            tt = this.makeDestinationObject(),
            tt[nt.property] = rt,
            tt[it.property] = this.defaultLayout.decode($, et + ot)
        } else
            tt = it.decode($, et);
        return tt
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        const nt = this.getSourceVariant($);
        if (nt === void 0) {
            const rt = this.discriminator
              , it = this.defaultLayout;
            let ot = 0;
            return this.usesPrefixDiscriminator && (ot = rt.layout.span),
            rt.encode($[rt.property], et, tt),
            ot + it.encode($[it.property], et, tt + ot)
        }
        return nt.encode($, et, tt)
    }
    addVariant($, et, tt) {
        const nt = new VariantLayout(this,$,et,tt);
        return this.registry[$] = nt,
        nt
    }
    getVariant($, et) {
        let tt = $;
        return Buffer$2.isBuffer($) && (et === void 0 && (et = 0),
        tt = this.discriminator.decode($, et)),
        this.registry[tt]
    }
}
class VariantLayout extends Layout {
    constructor($, et, tt, nt) {
        if (!($ instanceof Union))
            throw new TypeError("union must be a Union");
        if (!Number.isInteger(et) || 0 > et)
            throw new TypeError("variant must be a (non-negative) integer");
        if (typeof tt == "string" && nt === void 0 && (nt = tt,
        tt = null),
        tt) {
            if (!(tt instanceof Layout))
                throw new TypeError("layout must be a Layout");
            if ($.defaultLayout !== null && 0 <= tt.span && tt.span > $.defaultLayout.span)
                throw new Error("variant span exceeds span of containing union");
            if (typeof nt != "string")
                throw new TypeError("variant must have a String property")
        }
        let rt = $.span;
        0 > $.span && (rt = tt ? tt.span : 0,
        0 <= rt && $.usesPrefixDiscriminator && (rt += $.discriminator.layout.span)),
        super(rt, nt),
        this.union = $,
        this.variant = et,
        this.layout = tt || null
    }
    getSpan($, et) {
        if (0 <= this.span)
            return this.span;
        et === void 0 && (et = 0);
        let tt = 0;
        return this.union.usesPrefixDiscriminator && (tt = this.union.discriminator.layout.span),
        tt + this.layout.getSpan($, et + tt)
    }
    decode($, et) {
        const tt = this.makeDestinationObject();
        if (et === void 0 && (et = 0),
        this !== this.union.getVariant($, et))
            throw new Error("variant mismatch");
        let nt = 0;
        return this.union.usesPrefixDiscriminator && (nt = this.union.discriminator.layout.span),
        this.layout ? tt[this.property] = this.layout.decode($, et + nt) : this.property ? tt[this.property] = !0 : this.union.usesPrefixDiscriminator && (tt[this.union.discriminator.property] = this.variant),
        tt
    }
    encode($, et, tt) {
        tt === void 0 && (tt = 0);
        let nt = 0;
        if (this.union.usesPrefixDiscriminator && (nt = this.union.discriminator.layout.span),
        this.layout && !$.hasOwnProperty(this.property))
            throw new TypeError("variant lacks property " + this.property);
        this.union.discriminator.encode(this.variant, et, tt);
        let rt = nt;
        if (this.layout && (this.layout.encode($[this.property], et, tt + nt),
        rt += this.layout.getSpan(et, tt + nt),
        0 <= this.union.span && rt > this.union.span))
            throw new Error("encoded variant overruns containing union");
        return rt
    }
    fromArray($) {
        if (this.layout)
            return this.layout.fromArray($)
    }
}
let Blob$1$1 = class extends Layout {
    constructor($, et) {
        if (!($ instanceof ExternalLayout && $.isCount() || Number.isInteger($) && 0 <= $))
            throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
        let tt = -1;
        $ instanceof ExternalLayout || (tt = $),
        super(tt, et),
        this.length = $
    }
    getSpan($, et) {
        let tt = this.span;
        return 0 > tt && (tt = this.length.decode($, et)),
        tt
    }
    decode($, et) {
        et === void 0 && (et = 0);
        let tt = this.span;
        return 0 > tt && (tt = this.length.decode($, et)),
        $.slice(et, et + tt)
    }
    encode($, et, tt) {
        let nt = this.length;
        if (this.length instanceof ExternalLayout && (nt = $.length),
        !(Buffer$2.isBuffer($) && nt === $.length))
            throw new TypeError(nameWithProperty("Blob.encode", this) + " requires (length " + nt + ") Buffer as src");
        if (tt + nt > et.length)
            throw new RangeError("encoding overruns Buffer");
        return et.write($.toString("hex"), tt, nt, "hex"),
        this.length instanceof ExternalLayout && this.length.encode(nt, et, tt),
        nt
    }
}
;
var offset = (_e, $, et) => new OffsetLayout(_e,$,et)
  , u8 = _e => new UInt(1,_e)
  , u32 = _e => new UInt(4,_e)
  , nu64 = _e => new NearUInt64(_e)
  , ns64 = _e => new NearInt64(_e)
  , struct = (_e, $, et) => new Structure(_e,$,et)
  , union = (_e, $, et) => new Union(_e,$,et)
  , blob = (_e, $) => new Blob$1$1(_e,$);
class RustStringLayout extends Layout_2 {
    constructor($) {
        super(-1, $),
        this.property = $,
        this.layout = struct([u32("length"), u32("lengthPadding"), blob(offset(u32(), -8), "chars")], this.property)
    }
    encode($, et, tt=0) {
        if ($ == null)
            return this.layout.span;
        const nt = {
            chars: Buffer$2.from($, "utf8")
        };
        return this.layout.encode(nt, et, tt)
    }
    decode($, et=0) {
        return this.layout.decode($, et).chars.toString()
    }
    getSpan($, et=0) {
        return u32().span + u32().span + new BN(new Uint8Array($).slice(et, et + 4),10,"le").toNumber()
    }
}
function rustStringLayout(_e) {
    return new RustStringLayout(_e)
}
function publicKey$2(_e) {
    return blob(32, _e)
}
const LAYOUT = union(u32("instruction"));
LAYOUT.addVariant(0, struct([ns64("lamports"), ns64("space"), publicKey$2("owner")]), "createAccount");
LAYOUT.addVariant(1, struct([publicKey$2("owner")]), "assign");
LAYOUT.addVariant(2, struct([ns64("lamports")]), "transfer");
LAYOUT.addVariant(3, struct([publicKey$2("base"), rustStringLayout("seed"), ns64("lamports"), ns64("space"), publicKey$2("owner")]), "createAccountWithSeed");
LAYOUT.addVariant(4, struct([publicKey$2("authorized")]), "advanceNonceAccount");
LAYOUT.addVariant(5, struct([ns64("lamports")]), "withdrawNonceAccount");
LAYOUT.addVariant(6, struct([publicKey$2("authorized")]), "initializeNonceAccount");
LAYOUT.addVariant(7, struct([publicKey$2("authorized")]), "authorizeNonceAccount");
LAYOUT.addVariant(8, struct([ns64("space")]), "allocate");
LAYOUT.addVariant(9, struct([publicKey$2("base"), rustStringLayout("seed"), ns64("space"), publicKey$2("owner")]), "allocateWithSeed");
LAYOUT.addVariant(10, struct([publicKey$2("base"), rustStringLayout("seed"), publicKey$2("owner")]), "assignWithSeed");
LAYOUT.addVariant(11, struct([ns64("lamports"), rustStringLayout("seed"), publicKey$2("owner")]), "transferWithSeed");
Math.max(...Object.values(LAYOUT.registry).map(_e => _e.span));
class WrappedLayout$1 extends Layout_2 {
    constructor($, et, tt, nt) {
        super($.span, nt),
        this.layout = $,
        this.decoder = et,
        this.encoder = tt
    }
    decode($, et) {
        return this.decoder(this.layout.decode($, et))
    }
    encode($, et, tt) {
        return this.layout.encode(this.encoder($), et, tt)
    }
    getSpan($, et) {
        return this.layout.getSpan($, et)
    }
}
function publicKey$1(_e) {
    return new WrappedLayout$1(blob(32),$ => new PublicKey($),$ => $.toBuffer(),_e)
}
struct([u32("version"), u32("state"), publicKey$1("authorizedPubkey"), publicKey$1("nonce"), struct([nu64("lamportsPerSignature")], "feeCalculator")]);
new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
var browserPonyfill = {
    exports: {}
};
(function(_e, $) {
    var et = typeof self < "u" ? self : commonjsGlobal
      , tt = function() {
        function rt() {
            this.fetch = !1,
            this.DOMException = et.DOMException
        }
        return rt.prototype = et,
        new rt
    }();
    (function(rt) {
        (function(it) {
            var ot = {
                searchParams: "URLSearchParams"in rt,
                iterable: "Symbol"in rt && "iterator"in Symbol,
                blob: "FileReader"in rt && "Blob"in rt && function() {
                    try {
                        return new Blob,
                        !0
                    } catch {
                        return !1
                    }
                }(),
                formData: "FormData"in rt,
                arrayBuffer: "ArrayBuffer"in rt
            };
            function st(xt) {
                return xt && DataView.prototype.isPrototypeOf(xt)
            }
            if (ot.arrayBuffer)
                var lt = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"]
                  , ct = ArrayBuffer.isView || function(xt) {
                    return xt && lt.indexOf(Object.prototype.toString.call(xt)) > -1
                }
                ;
            function dt(xt) {
                if (typeof xt != "string" && (xt = String(xt)),
                /[^a-z0-9\-#$%&'*+.^_`|~]/i.test(xt))
                    throw new TypeError("Invalid character in header field name");
                return xt.toLowerCase()
            }
            function pt(xt) {
                return typeof xt != "string" && (xt = String(xt)),
                xt
            }
            function ht(xt) {
                var $t = {
                    next: function() {
                        var Dt = xt.shift();
                        return {
                            done: Dt === void 0,
                            value: Dt
                        }
                    }
                };
                return ot.iterable && ($t[Symbol.iterator] = function() {
                    return $t
                }
                ),
                $t
            }
            function mt(xt) {
                this.map = {},
                xt instanceof mt ? xt.forEach(function($t, Dt) {
                    this.append(Dt, $t)
                }, this) : Array.isArray(xt) ? xt.forEach(function($t) {
                    this.append($t[0], $t[1])
                }, this) : xt && Object.getOwnPropertyNames(xt).forEach(function($t) {
                    this.append($t, xt[$t])
                }, this)
            }
            mt.prototype.append = function(xt, $t) {
                xt = dt(xt),
                $t = pt($t);
                var Dt = this.map[xt];
                this.map[xt] = Dt ? Dt + ", " + $t : $t
            }
            ,
            mt.prototype.delete = function(xt) {
                delete this.map[dt(xt)]
            }
            ,
            mt.prototype.get = function(xt) {
                return xt = dt(xt),
                this.has(xt) ? this.map[xt] : null
            }
            ,
            mt.prototype.has = function(xt) {
                return this.map.hasOwnProperty(dt(xt))
            }
            ,
            mt.prototype.set = function(xt, $t) {
                this.map[dt(xt)] = pt($t)
            }
            ,
            mt.prototype.forEach = function(xt, $t) {
                for (var Dt in this.map)
                    this.map.hasOwnProperty(Dt) && xt.call($t, this.map[Dt], Dt, this)
            }
            ,
            mt.prototype.keys = function() {
                var xt = [];
                return this.forEach(function($t, Dt) {
                    xt.push(Dt)
                }),
                ht(xt)
            }
            ,
            mt.prototype.values = function() {
                var xt = [];
                return this.forEach(function($t) {
                    xt.push($t)
                }),
                ht(xt)
            }
            ,
            mt.prototype.entries = function() {
                var xt = [];
                return this.forEach(function($t, Dt) {
                    xt.push([Dt, $t])
                }),
                ht(xt)
            }
            ,
            ot.iterable && (mt.prototype[Symbol.iterator] = mt.prototype.entries);
            function yt(xt) {
                if (xt.bodyUsed)
                    return Promise.reject(new TypeError("Already read"));
                xt.bodyUsed = !0
            }
            function Et(xt) {
                return new Promise(function($t, Dt) {
                    xt.onload = function() {
                        $t(xt.result)
                    }
                    ,
                    xt.onerror = function() {
                        Dt(xt.error)
                    }
                }
                )
            }
            function _t(xt) {
                var $t = new FileReader
                  , Dt = Et($t);
                return $t.readAsArrayBuffer(xt),
                Dt
            }
            function wt(xt) {
                var $t = new FileReader
                  , Dt = Et($t);
                return $t.readAsText(xt),
                Dt
            }
            function St(xt) {
                for (var $t = new Uint8Array(xt), Dt = new Array($t.length), jt = 0; jt < $t.length; jt++)
                    Dt[jt] = String.fromCharCode($t[jt]);
                return Dt.join("")
            }
            function Ct(xt) {
                if (xt.slice)
                    return xt.slice(0);
                var $t = new Uint8Array(xt.byteLength);
                return $t.set(new Uint8Array(xt)),
                $t.buffer
            }
            function Nt() {
                return this.bodyUsed = !1,
                this._initBody = function(xt) {
                    this._bodyInit = xt,
                    xt ? typeof xt == "string" ? this._bodyText = xt : ot.blob && Blob.prototype.isPrototypeOf(xt) ? this._bodyBlob = xt : ot.formData && FormData.prototype.isPrototypeOf(xt) ? this._bodyFormData = xt : ot.searchParams && URLSearchParams.prototype.isPrototypeOf(xt) ? this._bodyText = xt.toString() : ot.arrayBuffer && ot.blob && st(xt) ? (this._bodyArrayBuffer = Ct(xt.buffer),
                    this._bodyInit = new Blob([this._bodyArrayBuffer])) : ot.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(xt) || ct(xt)) ? this._bodyArrayBuffer = Ct(xt) : this._bodyText = xt = Object.prototype.toString.call(xt) : this._bodyText = "",
                    this.headers.get("content-type") || (typeof xt == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : ot.searchParams && URLSearchParams.prototype.isPrototypeOf(xt) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"))
                }
                ,
                ot.blob && (this.blob = function() {
                    var xt = yt(this);
                    if (xt)
                        return xt;
                    if (this._bodyBlob)
                        return Promise.resolve(this._bodyBlob);
                    if (this._bodyArrayBuffer)
                        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                    if (this._bodyFormData)
                        throw new Error("could not read FormData body as blob");
                    return Promise.resolve(new Blob([this._bodyText]))
                }
                ,
                this.arrayBuffer = function() {
                    return this._bodyArrayBuffer ? yt(this) || Promise.resolve(this._bodyArrayBuffer) : this.blob().then(_t)
                }
                ),
                this.text = function() {
                    var xt = yt(this);
                    if (xt)
                        return xt;
                    if (this._bodyBlob)
                        return wt(this._bodyBlob);
                    if (this._bodyArrayBuffer)
                        return Promise.resolve(St(this._bodyArrayBuffer));
                    if (this._bodyFormData)
                        throw new Error("could not read FormData body as text");
                    return Promise.resolve(this._bodyText)
                }
                ,
                ot.formData && (this.formData = function() {
                    return this.text().then(Jt)
                }
                ),
                this.json = function() {
                    return this.text().then(JSON.parse)
                }
                ,
                this
            }
            var Lt = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
            function kt(xt) {
                var $t = xt.toUpperCase();
                return Lt.indexOf($t) > -1 ? $t : xt
            }
            function Ut(xt, $t) {
                $t = $t || {};
                var Dt = $t.body;
                if (xt instanceof Ut) {
                    if (xt.bodyUsed)
                        throw new TypeError("Already read");
                    this.url = xt.url,
                    this.credentials = xt.credentials,
                    $t.headers || (this.headers = new mt(xt.headers)),
                    this.method = xt.method,
                    this.mode = xt.mode,
                    this.signal = xt.signal,
                    !Dt && xt._bodyInit != null && (Dt = xt._bodyInit,
                    xt.bodyUsed = !0)
                } else
                    this.url = String(xt);
                if (this.credentials = $t.credentials || this.credentials || "same-origin",
                ($t.headers || !this.headers) && (this.headers = new mt($t.headers)),
                this.method = kt($t.method || this.method || "GET"),
                this.mode = $t.mode || this.mode || null,
                this.signal = $t.signal || this.signal,
                this.referrer = null,
                (this.method === "GET" || this.method === "HEAD") && Dt)
                    throw new TypeError("Body not allowed for GET or HEAD requests");
                this._initBody(Dt)
            }
            Ut.prototype.clone = function() {
                return new Ut(this,{
                    body: this._bodyInit
                })
            }
            ;
            function Jt(xt) {
                var $t = new FormData;
                return xt.trim().split("&").forEach(function(Dt) {
                    if (Dt) {
                        var jt = Dt.split("=")
                          , Ft = jt.shift().replace(/\+/g, " ")
                          , Ht = jt.join("=").replace(/\+/g, " ");
                        $t.append(decodeURIComponent(Ft), decodeURIComponent(Ht))
                    }
                }),
                $t
            }
            function Pt(xt) {
                var $t = new mt
                  , Dt = xt.replace(/\r?\n[\t ]+/g, " ");
                return Dt.split(/\r?\n/).forEach(function(jt) {
                    var Ft = jt.split(":")
                      , Ht = Ft.shift().trim();
                    if (Ht) {
                        var qt = Ft.join(":").trim();
                        $t.append(Ht, qt)
                    }
                }),
                $t
            }
            Nt.call(Ut.prototype);
            function Xt(xt, $t) {
                $t || ($t = {}),
                this.type = "default",
                this.status = $t.status === void 0 ? 200 : $t.status,
                this.ok = this.status >= 200 && this.status < 300,
                this.statusText = "statusText"in $t ? $t.statusText : "OK",
                this.headers = new mt($t.headers),
                this.url = $t.url || "",
                this._initBody(xt)
            }
            Nt.call(Xt.prototype),
            Xt.prototype.clone = function() {
                return new Xt(this._bodyInit,{
                    status: this.status,
                    statusText: this.statusText,
                    headers: new mt(this.headers),
                    url: this.url
                })
            }
            ,
            Xt.error = function() {
                var xt = new Xt(null,{
                    status: 0,
                    statusText: ""
                });
                return xt.type = "error",
                xt
            }
            ;
            var rn = [301, 302, 303, 307, 308];
            Xt.redirect = function(xt, $t) {
                if (rn.indexOf($t) === -1)
                    throw new RangeError("Invalid status code");
                return new Xt(null,{
                    status: $t,
                    headers: {
                        location: xt
                    }
                })
            }
            ,
            it.DOMException = rt.DOMException;
            try {
                new it.DOMException
            } catch {
                it.DOMException = function($t, Dt) {
                    this.message = $t,
                    this.name = Dt;
                    var jt = Error($t);
                    this.stack = jt.stack
                }
                ,
                it.DOMException.prototype = Object.create(Error.prototype),
                it.DOMException.prototype.constructor = it.DOMException
            }
            function zt(xt, $t) {
                return new Promise(function(Dt, jt) {
                    var Ft = new Ut(xt,$t);
                    if (Ft.signal && Ft.signal.aborted)
                        return jt(new it.DOMException("Aborted","AbortError"));
                    var Ht = new XMLHttpRequest;
                    function qt() {
                        Ht.abort()
                    }
                    Ht.onload = function() {
                        var Wt = {
                            status: Ht.status,
                            statusText: Ht.statusText,
                            headers: Pt(Ht.getAllResponseHeaders() || "")
                        };
                        Wt.url = "responseURL"in Ht ? Ht.responseURL : Wt.headers.get("X-Request-URL");
                        var Mt = "response"in Ht ? Ht.response : Ht.responseText;
                        Dt(new Xt(Mt,Wt))
                    }
                    ,
                    Ht.onerror = function() {
                        jt(new TypeError("Network request failed"))
                    }
                    ,
                    Ht.ontimeout = function() {
                        jt(new TypeError("Network request failed"))
                    }
                    ,
                    Ht.onabort = function() {
                        jt(new it.DOMException("Aborted","AbortError"))
                    }
                    ,
                    Ht.open(Ft.method, Ft.url, !0),
                    Ft.credentials === "include" ? Ht.withCredentials = !0 : Ft.credentials === "omit" && (Ht.withCredentials = !1),
                    "responseType"in Ht && ot.blob && (Ht.responseType = "blob"),
                    Ft.headers.forEach(function(Wt, Mt) {
                        Ht.setRequestHeader(Mt, Wt)
                    }),
                    Ft.signal && (Ft.signal.addEventListener("abort", qt),
                    Ht.onreadystatechange = function() {
                        Ht.readyState === 4 && Ft.signal.removeEventListener("abort", qt)
                    }
                    ),
                    Ht.send(typeof Ft._bodyInit > "u" ? null : Ft._bodyInit)
                }
                )
            }
            return zt.polyfill = !0,
            rt.fetch || (rt.fetch = zt,
            rt.Headers = mt,
            rt.Request = Ut,
            rt.Response = Xt),
            it.Headers = mt,
            it.Request = Ut,
            it.Response = Xt,
            it.fetch = zt,
            Object.defineProperty(it, "__esModule", {
                value: !0
            }),
            it
        }
        )({})
    }
    )(tt),
    tt.fetch.ponyfill = !0,
    delete tt.fetch.polyfill;
    var nt = tt;
    $ = nt.fetch,
    $.default = nt.fetch,
    $.fetch = nt.fetch,
    $.Headers = nt.Headers,
    $.Request = nt.Request,
    $.Response = nt.Response,
    _e.exports = $
}
)(browserPonyfill, browserPonyfill.exports);
dist$3.rustEnum([dist$3.struct([], "uninitialized"), dist$3.struct([dist$3.option(dist$3.publicKey(), "authorityAddress")], "buffer"), dist$3.struct([dist$3.publicKey("programdataAddress")], "program"), dist$3.struct([dist$3.u64("slot"), dist$3.option(dist$3.publicKey(), "upgradeAuthorityAddress")], "programData")], void 0, dist$3.u32());
function splitArgsAndCtx(_e, $) {
    var et, tt;
    let nt = {};
    const rt = _e.args ? _e.args.length : 0;
    if ($.length > rt) {
        if ($.length !== rt + 1)
            throw new Error(`provided too many arguments ${$} to instruction ${_e == null ? void 0 : _e.name} expecting: ${(tt = (et = _e.args) === null || et === void 0 ? void 0 : et.map(it => it.name)) !== null && tt !== void 0 ? tt : []}`);
        nt = $.pop()
    }
    return [$, nt]
}
class InstructionNamespaceFactory {
    static build($, et, tt) {
        if ($.name === "_inner")
            throw new IdlError("the _inner name is reserved");
        const nt = (...rt) => {
            const [it,ot] = splitArgsAndCtx($, [...rt]);
            validateAccounts($.accounts, ot.accounts),
            validateInstruction($, ...rt);
            const st = nt.accounts(ot.accounts);
            return ot.remainingAccounts !== void 0 && st.push(...ot.remainingAccounts),
            isSet$1("debug-logs"),
            new TransactionInstruction({
                keys: st,
                programId: tt,
                data: et($.name, toInstruction($, ...it))
            })
        }
        ;
        return nt.accounts = rt => InstructionNamespaceFactory.accountsArray(rt, $.accounts, tt, $.name),
        nt
    }
    static accountsArray($, et, tt, nt) {
        return $ ? et.map(rt => {
            if (isCompositeAccounts(rt)) {
                const ct = $[rt.name];
                return InstructionNamespaceFactory.accountsArray(ct, rt.accounts, tt, nt).flat()
            }
            let it;
            try {
                it = translateAddress($[rt.name])
            } catch {
                throw new Error(`Wrong input type for account "${rt.name}" in the instruction accounts object${nt !== void 0 ? ' for instruction "' + nt + '"' : ""}. Expected PublicKey or string.`)
            }
            const ot = rt.optional && it.equals(tt)
              , st = !!(rt.writable && !ot)
              , lt = !!(rt.signer && !ot);
            return {
                pubkey: it,
                isWritable: st,
                isSigner: lt
            }
        }
        ).flat() : []
    }
}
function validateInstruction(_e, ...$) {}
class TransactionFactory {
    static build($, et) {
        return (...nt) => {
            var rt, it, ot;
            const [,st] = splitArgsAndCtx($, [...nt])
              , lt = new Transaction;
            if (st.preInstructions && st.instructions)
                throw new Error("instructions is deprecated, use preInstructions");
            return (rt = st.preInstructions) === null || rt === void 0 || rt.forEach(ct => lt.add(ct)),
            (it = st.instructions) === null || it === void 0 || it.forEach(ct => lt.add(ct)),
            lt.add(et(...nt)),
            (ot = st.postInstructions) === null || ot === void 0 || ot.forEach(ct => lt.add(ct)),
            lt
        }
    }
}
class RpcFactory {
    static build($, et, tt, nt) {
        return async (...it) => {
            var ot;
            const st = et(...it)
              , [,lt] = splitArgsAndCtx($, [...it]);
            if (nt.sendAndConfirm === void 0)
                throw new Error("This function requires 'Provider.sendAndConfirm' to be implemented.");
            try {
                return await nt.sendAndConfirm(st, (ot = lt.signers) !== null && ot !== void 0 ? ot : [], lt.options)
            } catch (ct) {
                throw translateError(ct, tt)
            }
        }
    }
}
class AccountFactory {
    static build($, et, tt, nt) {
        var rt;
        return ((rt = $.accounts) !== null && rt !== void 0 ? rt : []).reduce( (it, ot) => (it[ot.name] = new AccountClient($,ot,tt,nt,et),
        it), {})
    }
}
class AccountClient {
    get size() {
        return this._size
    }
    get programId() {
        return this._programId
    }
    get provider() {
        return this._provider
    }
    get coder() {
        return this._coder
    }
    constructor($, et, tt, nt, rt) {
        this._idlAccount = et,
        this._programId = tt,
        this._provider = nt ?? getProvider(),
        this._coder = rt ?? new BorshCoder($),
        this._size = this._coder.accounts.size(et.name)
    }
    async fetchNullable($, et) {
        const {data: tt} = await this.fetchNullableAndContext($, et);
        return tt
    }
    async fetchNullableAndContext($, et) {
        const tt = await this.getAccountInfoAndContext($, et)
          , {value: nt, context: rt} = tt;
        return {
            data: nt && nt.data.length !== 0 ? this._coder.accounts.decode(this._idlAccount.name, nt.data) : null,
            context: rt
        }
    }
    async fetch($, et) {
        const {data: tt} = await this.fetchNullableAndContext($, et);
        if (tt === null)
            throw new Error(`Account does not exist or has no data ${$.toString()}`);
        return tt
    }
    async fetchAndContext($, et) {
        const {data: tt, context: nt} = await this.fetchNullableAndContext($, et);
        if (tt === null)
            throw new Error(`Account does not exist ${$.toString()}`);
        return {
            data: tt,
            context: nt
        }
    }
    async fetchMultiple($, et) {
        return (await this.fetchMultipleAndContext($, et)).map(nt => nt ? nt.data : null)
    }
    async fetchMultipleAndContext($, et) {
        return (await getMultipleAccountsAndContext(this._provider.connection, $.map(nt => translateAddress(nt)), et)).map(nt => {
            if (nt == null)
                return null;
            const {account: rt, context: it} = nt;
            return {
                data: this._coder.accounts.decode(this._idlAccount.name, rt.data),
                context: it
            }
        }
        )
    }
    async all($) {
        const et = this.coder.accounts.memcmp(this._idlAccount.name, $ instanceof Buffer$2 ? $ : void 0)
          , tt = [];
        return (et == null ? void 0 : et.offset) != null && (et == null ? void 0 : et.bytes) != null && tt.push({
            memcmp: {
                offset: et.offset,
                bytes: et.bytes
            }
        }),
        (et == null ? void 0 : et.dataSize) != null && tt.push({
            dataSize: et.dataSize
        }),
        (await this._provider.connection.getProgramAccounts(this._programId, {
            commitment: this._provider.connection.commitment,
            filters: [...tt, ...Array.isArray($) ? $ : []]
        })).map( ({pubkey: rt, account: it}) => ({
            publicKey: rt,
            account: this._coder.accounts.decode(this._idlAccount.name, it.data)
        }))
    }
    subscribe($, et) {
        const tt = subscriptions.get($.toString());
        if (tt)
            return tt.ee;
        const nt = new EventEmitter;
        $ = translateAddress($);
        const rt = this._provider.connection.onAccountChange($, it => {
            const ot = this._coder.accounts.decode(this._idlAccount.name, it.data);
            nt.emit("change", ot)
        }
        , et);
        return subscriptions.set($.toString(), {
            ee: nt,
            listener: rt
        }),
        nt
    }
    async unsubscribe($) {
        let et = subscriptions.get($.toString());
        et && subscriptions && await this._provider.connection.removeAccountChangeListener(et.listener).then( () => {
            subscriptions.delete($.toString())
        }
        ).catch(console.error)
    }
    async createInstruction($, et) {
        const tt = this.size;
        if (this._provider.publicKey === void 0)
            throw new Error("This function requires the Provider interface implementor to have a 'publicKey' field.");
        return SystemProgram.createAccount({
            fromPubkey: this._provider.publicKey,
            newAccountPubkey: $.publicKey,
            space: et ?? tt,
            lamports: await this._provider.connection.getMinimumBalanceForRentExemption(et ?? tt),
            programId: this._programId
        })
    }
    async getAccountInfo($, et) {
        return await this._provider.connection.getAccountInfo(translateAddress($), et)
    }
    async getAccountInfoAndContext($, et) {
        return await this._provider.connection.getAccountInfoAndContext(translateAddress($), et)
    }
}
const subscriptions = new Map
  , PROGRAM_LOG = "Program log: "
  , PROGRAM_DATA = "Program data: "
  , PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length
  , PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;
class EventManager {
    constructor($, et, tt) {
        this._programId = $,
        this._provider = et,
        this._eventParser = new EventParser($,tt),
        this._eventCallbacks = new Map,
        this._eventListeners = new Map,
        this._listenerIdCount = 0
    }
    addEventListener($, et) {
        var tt;
        let nt = this._listenerIdCount;
        return this._listenerIdCount += 1,
        this._eventListeners.has($) || this._eventListeners.set($, []),
        this._eventListeners.set($, ((tt = this._eventListeners.get($)) !== null && tt !== void 0 ? tt : []).concat(nt)),
        this._eventCallbacks.set(nt, [$, et]),
        this._onLogsSubscriptionId !== void 0 || (this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (rt, it) => {
            if (!rt.err)
                for (const ot of this._eventParser.parseLogs(rt.logs)) {
                    const st = this._eventListeners.get(ot.name);
                    st && st.forEach(lt => {
                        const ct = this._eventCallbacks.get(lt);
                        if (ct) {
                            const [,dt] = ct;
                            dt(ot.data, it.slot, rt.signature)
                        }
                    }
                    )
                }
        }
        )),
        nt
    }
    async removeEventListener($) {
        const et = this._eventCallbacks.get($);
        if (!et)
            throw new Error(`Event listener ${$} doesn't exist!`);
        const [tt] = et;
        let nt = this._eventListeners.get(tt);
        if (!nt)
            throw new Error(`Event listeners don't exist for ${tt}!`);
        if (this._eventCallbacks.delete($),
        nt = nt.filter(rt => rt !== $),
        this._eventListeners.set(tt, nt),
        nt.length === 0 && this._eventListeners.delete(tt),
        this._eventCallbacks.size === 0) {
            if (this._eventListeners.size !== 0)
                throw new Error(`Expected event listeners size to be 0 but got ${this._eventListeners.size}`);
            this._onLogsSubscriptionId !== void 0 && (await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId),
            this._onLogsSubscriptionId = void 0)
        }
    }
}
class EventParser {
    constructor($, et) {
        this.coder = et,
        this.programId = $
    }
    *parseLogs($, et=!1) {
        const tt = new LogScanner($)
          , nt = new ExecutionContext;
        let rt = tt.next();
        for (; rt !== null; ) {
            let[it,ot,st] = this.handleLog(nt, rt, et);
            it && (yield it),
            ot && nt.push(ot),
            st && nt.pop(),
            rt = tt.next()
        }
    }
    handleLog($, et, tt) {
        return $.stack.length > 0 && $.program() === this.programId.toString() ? this.handleProgramLog(et, tt) : [null, ...this.handleSystemLog(et)]
    }
    handleProgramLog($, et) {
        if ($.startsWith(PROGRAM_LOG) || $.startsWith(PROGRAM_DATA)) {
            const tt = $.startsWith(PROGRAM_LOG) ? $.slice(PROGRAM_LOG_START_INDEX) : $.slice(PROGRAM_DATA_START_INDEX)
              , nt = this.coder.events.decode(tt);
            if (et && nt === null)
                throw new Error(`Unable to decode event ${tt}`);
            return [nt, null, !1]
        } else
            return [null, ...this.handleSystemLog($)]
    }
    handleSystemLog($) {
        const et = $.split(":")[0];
        return et.match(/^Program (.*) success/g) !== null ? [null, !0] : et.startsWith(`Program ${this.programId.toString()} invoke`) ? [this.programId.toString(), !1] : et.includes("invoke") ? ["cpi", !1] : [null, !1]
    }
}
class ExecutionContext {
    constructor() {
        this.stack = []
    }
    program() {
        if (!this.stack.length)
            throw new Error("Expected the stack to have elements");
        return this.stack[this.stack.length - 1]
    }
    push($) {
        this.stack.push($)
    }
    pop() {
        if (!this.stack.length)
            throw new Error("Expected the stack to have elements");
        this.stack.pop()
    }
}
class LogScanner {
    constructor($) {
        this.logs = $
    }
    next() {
        if (this.logs.length === 0)
            return null;
        let $ = this.logs[0];
        return this.logs = this.logs.slice(1),
        $
    }
}
class SimulateFactory {
    static build($, et, tt, nt, rt, it, ot) {
        return async (...lt) => {
            var ct;
            const dt = et(...lt)
              , [,pt] = splitArgsAndCtx($, [...lt]);
            let ht;
            if (nt.simulate === void 0)
                throw new Error("This function requires 'Provider.simulate' to be implemented.");
            try {
                ht = await nt.simulate(dt, pt.signers, (ct = pt.options) === null || ct === void 0 ? void 0 : ct.commitment)
            } catch (Et) {
                throw translateError(Et, tt)
            }
            if (ht === void 0)
                throw new Error("Unable to simulate transaction");
            const mt = ht.logs;
            if (!mt)
                throw new Error("Simulated logs not found");
            const yt = [];
            if (ot.events) {
                let Et = new EventParser(it,rt);
                for (const _t of Et.parseLogs(mt))
                    yt.push(_t)
            }
            return {
                events: yt,
                raw: mt
            }
        }
    }
}
function uint64(_e) {
    return new WrappedLayout(blob(8),$ => u64$1.fromBuffer($),$ => $.toBuffer(),_e)
}
function publicKey$3(_e) {
    return new WrappedLayout(blob(32),$ => new PublicKey($),$ => $.toBuffer(),_e)
}
function coption(_e, $) {
    return new COptionLayout(_e,$)
}
class WrappedLayout extends Layout_2 {
    constructor($, et, tt, nt) {
        super($.span, nt),
        this.layout = $,
        this.decoder = et,
        this.encoder = tt
    }
    decode($, et) {
        return this.decoder(this.layout.decode($, et))
    }
    encode($, et, tt) {
        return this.layout.encode(this.encoder($), et, tt)
    }
    getSpan($, et) {
        return this.layout.getSpan($, et)
    }
}
class COptionLayout extends Layout_2 {
    constructor($, et) {
        super(-1, et),
        this.layout = $,
        this.discriminator = u32()
    }
    encode($, et, tt=0) {
        return $ == null ? this.layout.span + this.discriminator.encode(0, et, tt) : (this.discriminator.encode(1, et, tt),
        this.layout.encode($, et, tt + 4) + 4)
    }
    decode($, et=0) {
        const tt = this.discriminator.decode($, et);
        if (tt === 0)
            return null;
        if (tt === 1)
            return this.layout.decode($, et + 4);
        throw new Error("Invalid coption " + this.layout.property)
    }
    getSpan($, et=0) {
        return this.layout.getSpan($, et + 4) + 4
    }
}
let u64$1 = class Y_ extends BN {
    toBuffer() {
        const $ = super.toArray().reverse()
          , et = Buffer$2.from($);
        if (et.length === 8)
            return et;
        if (et.length >= 8)
            throw new Error("u64 too large");
        const tt = Buffer$2.alloc(8);
        return et.copy(tt),
        tt
    }
    static fromBuffer($) {
        if ($.length !== 8)
            throw new Error(`Invalid buffer length: ${$.length}`);
        return new Y_([...$].reverse().map(et => `00${et.toString(16)}`.slice(-2)).join(""),16)
    }
}
;
const TOKEN_ACCOUNT_LAYOUT = struct([publicKey$3("mint"), publicKey$3("owner"), uint64("amount"), coption(publicKey$3(), "delegate"), (_e => {
    const $ = union(u8("discriminator"), null, _e);
    return $.addVariant(0, struct([]), "uninitialized"),
    $.addVariant(1, struct([]), "initialized"),
    $.addVariant(2, struct([]), "frozen"),
    $
}
)("state"), coption(uint64(), "isNative"), uint64("delegatedAmount"), coption(publicKey$3(), "closeAuthority")]);
function decodeTokenAccount(_e) {
    return TOKEN_ACCOUNT_LAYOUT.decode(_e)
}
class AccountsResolver {
    constructor($, et, tt, nt, rt, it, ot, st) {
        this._args = $,
        this._accounts = et,
        this._provider = tt,
        this._programId = nt,
        this._idlIx = rt,
        this._idlTypes = ot,
        this._customResolver = st,
        this._accountStore = new AccountStore(tt,it,nt)
    }
    args($) {
        this._args = $
    }
    async resolve() {
        this.resolveEventCpi(this._idlIx.accounts),
        this.resolveConst(this._idlIx.accounts);
        let $ = 0;
        for (; await this.resolvePdasAndRelations(this._idlIx.accounts) + await this.resolveCustom() > 0; )
            if ($++,
            $ === 16)
                throw new Error("Reached maximum depth for account resolution")
    }
    resolveOptionals($) {
        Object.assign(this._accounts, this.resolveOptionalsHelper($, this._idlIx.accounts))
    }
    get($) {
        const et = $.reduce( (tt, nt) => tt && tt[nt], this._accounts);
        if (et && et.toBase58)
            return et
    }
    set($, et) {
        let tt = this._accounts;
        $.forEach( (nt, rt) => {
            var it;
            rt === $.length - 1 && (tt[nt] = et),
            tt[nt] = (it = tt[nt]) !== null && it !== void 0 ? it : {},
            tt = tt[nt]
        }
        )
    }
    resolveOptionalsHelper($, et) {
        const tt = {};
        for (const nt of et) {
            const rt = nt.name
              , it = $[rt];
            it !== void 0 && (isPartialAccounts(it) ? isCompositeAccounts(nt) ? tt[rt] = this.resolveOptionalsHelper(it, nt.accounts) : tt[rt] = flattenPartialAccounts(it) : it !== null ? tt[rt] = translateAddress(it) : nt.optional && (tt[rt] = this._programId))
        }
        return tt
    }
    async resolveCustom() {
        if (this._customResolver) {
            const {accounts: $, resolved: et} = await this._customResolver({
                args: this._args,
                accounts: this._accounts,
                provider: this._provider,
                programId: this._programId,
                idlIx: this._idlIx
            });
            return this._accounts = $,
            et
        }
        return 0
    }
    resolveEventCpi($, et=[]) {
        for (const tt in $) {
            const nt = $[tt];
            isCompositeAccounts(nt) && this.resolveEventCpi(nt.accounts, [...et, nt.name]);
            const rt = +tt + 1;
            if (rt === $.length)
                return;
            const it = $[tt].name
              , ot = $[rt].name;
            if (it === "eventAuthority" && ot === "program") {
                const st = [...et, it]
                  , lt = [...et, ot];
                this.get(st) || this.set(st, PublicKey.findProgramAddressSync([Buffer$2.from("__event_authority")], this._programId)[0]),
                this.get(lt) || this.set(lt, this._programId);
                return
            }
        }
    }
    resolveConst($, et=[]) {
        for (const tt of $) {
            const nt = tt.name;
            if (isCompositeAccounts(tt))
                this.resolveConst(tt.accounts, [...et, nt]);
            else {
                const rt = tt;
                if ((rt.signer || rt.address) && !this.get([...et, nt])) {
                    if (rt.signer) {
                        if (!this._provider.wallet)
                            throw new Error("This function requires the `Provider` interface implementor to have a `wallet` field.");
                        this.set([...et, nt], this._provider.wallet.publicKey)
                    }
                    rt.address && this.set([...et, nt], translateAddress(rt.address))
                }
            }
        }
    }
    async resolvePdasAndRelations($, et=[]) {
        let tt = 0;
        for (const nt of $) {
            const rt = nt.name;
            if (isCompositeAccounts(nt))
                tt += await this.resolvePdasAndRelations(nt.accounts, [...et, rt]);
            else {
                const it = nt;
                if ((it.pda || it.relations) && !this.get([...et, rt])) {
                    tt++;
                    try {
                        if (it.pda) {
                            const ot = await Promise.all(it.pda.seeds.map(ct => this.toBuffer(ct, et)));
                            if (ot.some(ct => !ct))
                                continue;
                            const st = await this.parseProgramId(it, et)
                              , [lt] = PublicKey.findProgramAddressSync(ot, st);
                            this.set([...et, rt], lt)
                        }
                    } catch {}
                    try {
                        if (it.relations) {
                            const ot = this.get([...et, it.relations[0]]);
                            if (ot) {
                                const st = await this._accountStore.fetchAccount({
                                    publicKey: ot
                                });
                                this.set([...et, rt], st[rt])
                            }
                        }
                    } catch {}
                }
            }
        }
        return tt
    }
    async parseProgramId($, et=[]) {
        var tt;
        if (!(!((tt = $.pda) === null || tt === void 0) && tt.program))
            return this._programId;
        const nt = await this.toBuffer($.pda.program, et);
        if (!nt)
            throw new Error(`Program seed not resolved: ${$.name}`);
        return new PublicKey(nt)
    }
    async toBuffer($, et=[]) {
        switch ($.kind) {
        case "const":
            return this.toBufferConst($);
        case "arg":
            return await this.toBufferArg($);
        case "account":
            return await this.toBufferAccount($, et);
        default:
            throw new Error(`Unexpected seed: ${$}`)
        }
    }
    toBufferConst($) {
        return this.toBufferValue("bytes", $.value)
    }
    async toBufferArg($) {
        const [et,...tt] = $.path.split(".")
          , nt = this._idlIx.args.findIndex(ot => ot.name === et);
        if (nt === -1)
            throw new Error(`Unable to find argument for seed: ${et}`);
        const rt = tt.reduce( (ot, st) => (ot ?? {})[st], this._args[nt]);
        if (rt === void 0)
            return;
        const it = this.getType(this._idlIx.args[nt].type, tt);
        return this.toBufferValue(it, rt)
    }
    async toBufferAccount($, et=[]) {
        const [tt,...nt] = $.path.split(".")
          , rt = this.get([...et, tt]);
        if (!rt)
            return;
        if (!nt.length)
            return this.toBufferValue("pubkey", rt);
        if (!$.account)
            throw new Error(`Seed account is required in order to resolve type: ${$.path}`);
        let ot = await this._accountStore.fetchAccount({
            publicKey: rt,
            name: $.account
        })
          , st = nt;
        for (; st.length > 0; )
            ot = ot[st[0]],
            st = st.slice(1);
        if (ot === void 0)
            return;
        const lt = this.getType({
            defined: {
                name: $.account
            }
        }, nt);
        return this.toBufferValue(lt, ot)
    }
    toBufferValue($, et) {
        switch ($) {
        case "u8":
        case "i8":
            return Buffer$2.from([et]);
        case "u16":
        case "i16":
            return new BN(et).toArrayLike(Buffer$2, "le", 2);
        case "u32":
        case "i32":
            return new BN(et).toArrayLike(Buffer$2, "le", 4);
        case "u64":
        case "i64":
            return new BN(et).toArrayLike(Buffer$2, "le", 8);
        case "u128":
        case "i128":
            return new BN(et).toArrayLike(Buffer$2, "le", 16);
        case "u256":
        case "i256":
            return new BN(et).toArrayLike(Buffer$2, "le", 32);
        case "string":
            return Buffer$2.from(et);
        case "pubkey":
            return et.toBuffer();
        case "bytes":
            return Buffer$2.from(et);
        default:
            if ($ != null && $.array)
                return Buffer$2.from(et);
            throw new Error(`Unexpected seed type: ${$}`)
        }
    }
    getType($, et=[]) {
        var tt;
        const nt = (tt = $ == null ? void 0 : $.defined) === null || tt === void 0 ? void 0 : tt.name;
        if (nt) {
            if (nt === "tokenAccount")
                switch (et.at(0)) {
                case "mint":
                case "owner":
                    return "pubkey";
                case "amount":
                case "delagatedAmount":
                    return "u64";
                default:
                    throw new Error(`Unknown token account path: ${et}`)
                }
            const rt = this._idlTypes.find(ct => ct.name === nt);
            if (!rt)
                throw new Error(`Type not found: ${nt}`);
            const [it,...ot] = et
              , lt = rt.type.fields.find(ct => ct.name === it);
            if (!lt)
                throw new Error(`Field not found: ${it}`);
            return this.getType(lt.type, ot)
        }
        return $
    }
}
class AccountStore {
    constructor($, et, tt) {
        this._provider = $,
        this._cache = new Map,
        this._idls = {},
        this._idls[tt.toBase58()] = et
    }
    async fetchAccount({publicKey: $, name: et}) {
        const tt = $.toBase58();
        if (!this._cache.has(tt)) {
            const nt = await this._provider.connection.getAccountInfo($);
            if (nt === null)
                throw new Error(`Account not found: ${tt}`);
            if (et === "tokenAccount") {
                const rt = decodeTokenAccount(nt.data);
                this._cache.set(tt, rt)
            } else {
                const rt = await this.getAccountsNs(nt.owner);
                if (rt) {
                    const it = Object.values(rt)[0];
                    if (it) {
                        const ot = it.coder.accounts.decodeAny(nt.data);
                        this._cache.set(tt, ot)
                    }
                }
            }
        }
        return this._cache.get(tt)
    }
    async getAccountsNs($) {
        const et = $.toBase58();
        if (!this._idls[et]) {
            const tt = await Program.fetchIdl($, this._provider);
            if (tt) {
                const nt = new Program(tt,this._provider);
                this._idls[et] = nt.account
            }
        }
        return this._idls[et]
    }
}
class MethodsBuilderFactory {
    static build($, et, tt, nt, rt, it, ot, st, lt, ct, dt) {
        return (...pt) => new MethodsBuilder(pt,nt,rt,it,ot,st,$,et,tt,lt,ct,dt)
    }
}
function isPartialAccounts(_e) {
    return typeof _e == "object" && _e !== null && !("_bn"in _e)
}
function flattenPartialAccounts(_e, $) {
    const et = {};
    for (const tt in _e) {
        const nt = _e[tt];
        if (nt === null)
            throw new Error("Failed to resolve optionals due to IDL type mismatch with input accounts!");
        et[tt] = isPartialAccounts(nt) ? flattenPartialAccounts(nt) : translateAddress(nt)
    }
    return et
}
class MethodsBuilder {
    constructor($, et, tt, nt, rt, it, ot, st, lt, ct, dt, pt) {
        this._args = $,
        this._ixFn = et,
        this._txFn = tt,
        this._rpcFn = nt,
        this._simulateFn = rt,
        this._viewFn = it,
        this._accounts = {},
        this._remainingAccounts = [],
        this._signers = [],
        this._preInstructions = [],
        this._postInstructions = [],
        this._resolveAccounts = !0,
        this._accountsResolver = new AccountsResolver($,this._accounts,ot,st,lt,ct,dt,pt)
    }
    args($) {
        this._args = $,
        this._accountsResolver.args($)
    }
    accounts($) {
        return this.accountsPartial($)
    }
    accountsPartial($) {
        return this._resolveAccounts = !0,
        this._accountsResolver.resolveOptionals($),
        this
    }
    accountsStrict($) {
        return this._resolveAccounts = !1,
        this._accountsResolver.resolveOptionals($),
        this
    }
    signers($) {
        return this._signers = this._signers.concat($),
        this
    }
    remainingAccounts($) {
        return this._remainingAccounts = this._remainingAccounts.concat($),
        this
    }
    preInstructions($, et=!1) {
        return et ? this._preInstructions = $.concat(this._preInstructions) : this._preInstructions = this._preInstructions.concat($),
        this
    }
    postInstructions($) {
        return this._postInstructions = this._postInstructions.concat($),
        this
    }
    async pubkeys() {
        return this._resolveAccounts && await this._accountsResolver.resolve(),
        this._accounts
    }
    async rpc($) {
        return this._resolveAccounts && await this._accountsResolver.resolve(),
        this._rpcFn(...this._args, {
            accounts: this._accounts,
            signers: this._signers,
            remainingAccounts: this._remainingAccounts,
            preInstructions: this._preInstructions,
            postInstructions: this._postInstructions,
            options: $
        })
    }
    async rpcAndKeys($) {
        return {
            pubkeys: await this.pubkeys(),
            signature: await this.rpc($)
        }
    }
    async view($) {
        if (this._resolveAccounts && await this._accountsResolver.resolve(),
        !this._viewFn)
            throw new Error("Method does not support views");
        return this._viewFn(...this._args, {
            accounts: this._accounts,
            signers: this._signers,
            remainingAccounts: this._remainingAccounts,
            preInstructions: this._preInstructions,
            postInstructions: this._postInstructions,
            options: $
        })
    }
    async simulate($) {
        return this._resolveAccounts && await this._accountsResolver.resolve(),
        this._simulateFn(...this._args, {
            accounts: this._accounts,
            signers: this._signers,
            remainingAccounts: this._remainingAccounts,
            preInstructions: this._preInstructions,
            postInstructions: this._postInstructions,
            options: $
        })
    }
    async instruction() {
        return this._resolveAccounts && await this._accountsResolver.resolve(),
        this._ixFn(...this._args, {
            accounts: this._accounts,
            signers: this._signers,
            remainingAccounts: this._remainingAccounts,
            preInstructions: this._preInstructions,
            postInstructions: this._postInstructions
        })
    }
    async prepare() {
        return {
            instruction: await this.instruction(),
            pubkeys: await this.pubkeys(),
            signers: this._signers
        }
    }
    async transaction() {
        return this._resolveAccounts && await this._accountsResolver.resolve(),
        this._txFn(...this._args, {
            accounts: this._accounts,
            signers: this._signers,
            remainingAccounts: this._remainingAccounts,
            preInstructions: this._preInstructions,
            postInstructions: this._postInstructions
        })
    }
}
class ViewFactory {
    static build($, et, tt, nt) {
        const rt = et.accounts.find(st => st.writable)
          , it = !!et.returns;
        return rt || !it ? void 0 : async (...st) => {
            let lt = await tt(...st);
            const ct = `Program return: ${$} `;
            let dt = lt.raw.find(yt => yt.startsWith(ct));
            if (!dt)
                throw new Error("View expected return log");
            let pt = decode(dt.slice(ct.length))
              , ht = et.returns;
            if (!ht)
                throw new Error("View expected return type");
            return IdlCoder.fieldLayout({
                type: ht
            }, nt.types).decode(pt)
        }
    }
}
class NamespaceFactory {
    static build($, et, tt, nt, rt) {
        const it = {}
          , ot = {}
          , st = {}
          , lt = {}
          , ct = {}
          , dt = {}
          , pt = parseIdlErrors($)
          , ht = $.accounts ? AccountFactory.build($, et, tt, nt) : {};
        return $.instructions.forEach(mt => {
            const yt = InstructionNamespaceFactory.build(mt, (Lt, kt) => et.instruction.encode(Lt, kt), tt)
              , Et = TransactionFactory.build(mt, yt)
              , _t = RpcFactory.build(mt, Et, pt, nt)
              , wt = SimulateFactory.build(mt, Et, pt, nt, et, tt, $)
              , St = ViewFactory.build(tt, mt, wt, $)
              , Ct = MethodsBuilderFactory.build(nt, tt, mt, yt, Et, _t, wt, St, ht, $.types || [], rt == null ? void 0 : rt(mt))
              , Nt = mt.name;
            ot[Nt] = yt,
            st[Nt] = Et,
            it[Nt] = _t,
            lt[Nt] = wt,
            ct[Nt] = Ct,
            St && (dt[Nt] = St)
        }
        ),
        [it, ot, st, ht, lt, ct, dt]
    }
}
class Program {
    get programId() {
        return this._programId
    }
    get idl() {
        return this._idl
    }
    get rawIdl() {
        return this._rawIdl
    }
    get coder() {
        return this._coder
    }
    get provider() {
        return this._provider
    }
    constructor($, et=getProvider(), tt, nt) {
        const rt = convertIdlToCamelCase($);
        this._idl = rt,
        this._rawIdl = $,
        this._provider = et,
        this._programId = translateAddress($.address),
        this._coder = tt ?? new BorshCoder(rt),
        this._events = new EventManager(this._programId,et,this._coder);
        const [it,ot,st,lt,ct,dt,pt] = NamespaceFactory.build(rt, this._coder, this._programId, et, nt);
        this.rpc = it,
        this.instruction = ot,
        this.transaction = st,
        this.account = lt,
        this.simulate = ct,
        this.methods = dt,
        this.views = pt
    }
    static async at($, et) {
        const tt = translateAddress($)
          , nt = await Program.fetchIdl(tt, et);
        if (!nt)
            throw new Error(`IDL not found for program: ${$.toString()}`);
        return new Program(nt,et)
    }
    static async fetchIdl($, et) {
        et = et ?? getProvider();
        const tt = translateAddress($)
          , nt = await idlAddress(tt)
          , rt = await et.connection.getAccountInfo(nt);
        if (!rt)
            return null;
        let it = decodeIdlAccount(rt.data.slice(8));
        const ot = inflate_1(it.data);
        return JSON.parse(decode$2(ot))
    }
    addEventListener($, et) {
        return this._events.addEventListener($, et)
    }
    async removeEventListener($) {
        return await this._events.removeEventListener($)
    }
}
new PublicKey("11111111111111111111111111111111");
class WalletError extends Error {
    constructor($, et) {
        super($),
        this.error = et
    }
}
class WalletNotReadyError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletNotReadyError"
    }
}
class WalletLoadError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletLoadError"
    }
}
class WalletConfigError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletConfigError"
    }
}
class WalletConnectionError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletConnectionError"
    }
}
class WalletDisconnectedError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletDisconnectedError"
    }
}
class WalletDisconnectionError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletDisconnectionError"
    }
}
class WalletAccountError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletAccountError"
    }
}
class WalletPublicKeyError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletPublicKeyError"
    }
}
class WalletNotConnectedError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletNotConnectedError"
    }
}
class WalletSendTransactionError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletSendTransactionError"
    }
}
class WalletSignTransactionError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletSignTransactionError"
    }
}
class WalletSignMessageError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletSignMessageError"
    }
}
class WalletSignInError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletSignInError"
    }
}
var WalletReadyState;
(function(_e) {
    _e.Installed = "Installed",
    _e.NotDetected = "NotDetected",
    _e.Loadable = "Loadable",
    _e.Unsupported = "Unsupported"
}
)(WalletReadyState || (WalletReadyState = {}));
class BaseWalletAdapter extends EventEmitter {
    get connected() {
        return !!this.publicKey
    }
    async autoConnect() {
        await this.connect()
    }
    async prepareTransaction($, et, tt={}) {
        const nt = this.publicKey;
        if (!nt)
            throw new WalletNotConnectedError;
        return $.feePayer = $.feePayer || nt,
        $.recentBlockhash = $.recentBlockhash || (await et.getLatestBlockhash({
            commitment: tt.preflightCommitment,
            minContextSlot: tt.minContextSlot
        })).blockhash,
        $
    }
}
function scopePollingDetectionStrategy(_e) {
    if (typeof window > "u" || typeof document > "u")
        return;
    const $ = [];
    function et() {
        if (_e())
            for (const rt of $)
                rt()
    }
    const tt = setInterval(et, 1e3);
    $.push( () => clearInterval(tt)),
    document.readyState === "loading" && (document.addEventListener("DOMContentLoaded", et, {
        once: !0
    }),
    $.push( () => document.removeEventListener("DOMContentLoaded", et))),
    document.readyState !== "complete" && (window.addEventListener("load", et, {
        once: !0
    }),
    $.push( () => window.removeEventListener("load", et))),
    et()
}
function isIosAndRedirectable() {
    if (!navigator)
        return !1;
    const _e = navigator.userAgent.toLowerCase()
      , $ = _e.includes("iphone") || _e.includes("ipad")
      , et = _e.includes("safari");
    return $ && et
}
function isVersionedTransaction$1(_e) {
    return "version"in _e
}
class BaseSignerWalletAdapter extends BaseWalletAdapter {
    async sendTransaction($, et, tt={}) {
        let nt = !0;
        try {
            if (isVersionedTransaction$1($)) {
                if (!this.supportedTransactionVersions)
                    throw new WalletSendTransactionError("Sending versioned transactions isn't supported by this wallet");
                if (!this.supportedTransactionVersions.has($.version))
                    throw new WalletSendTransactionError(`Sending transaction version ${$.version} isn't supported by this wallet`);
                try {
                    $ = await this.signTransaction($);
                    const rt = $.serialize();
                    return await et.sendRawTransaction(rt, tt)
                } catch (rt) {
                    throw rt instanceof WalletSignTransactionError ? (nt = !1,
                    rt) : new WalletSendTransactionError(rt == null ? void 0 : rt.message,rt)
                }
            } else
                try {
                    const {signers: rt, ...it} = tt;
                    $ = await this.prepareTransaction($, et, it),
                    rt != null && rt.length && $.partialSign(...rt),
                    $ = await this.signTransaction($);
                    const ot = $.serialize();
                    return await et.sendRawTransaction(ot, it)
                } catch (rt) {
                    throw rt instanceof WalletSignTransactionError ? (nt = !1,
                    rt) : new WalletSendTransactionError(rt == null ? void 0 : rt.message,rt)
                }
        } catch (rt) {
            throw nt && this.emit("error", rt),
            rt
        }
    }
    async signAllTransactions($) {
        for (const tt of $)
            if (isVersionedTransaction$1(tt)) {
                if (!this.supportedTransactionVersions)
                    throw new WalletSignTransactionError("Signing versioned transactions isn't supported by this wallet");
                if (!this.supportedTransactionVersions.has(tt.version))
                    throw new WalletSignTransactionError(`Signing transaction version ${tt.version} isn't supported by this wallet`)
            }
        const et = [];
        for (const tt of $)
            et.push(await this.signTransaction(tt));
        return et
    }
}
class BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {
}
class BaseSignInMessageSignerWalletAdapter extends BaseMessageSignerWalletAdapter {
}
const SolanaSignAndSendTransaction = "solana:signAndSendTransaction"
  , SolanaSignIn = "solana:signIn"
  , SolanaSignMessage = "solana:signMessage"
  , SolanaSignTransaction = "solana:signTransaction"
  , StandardConnect = "standard:connect"
  , StandardDisconnect = "standard:disconnect"
  , StandardEvents = "standard:events";
function isWalletAdapterCompatibleStandardWallet(_e) {
    return StandardConnect in _e.features && StandardEvents in _e.features && (SolanaSignAndSendTransaction in _e.features || SolanaSignTransaction in _e.features)
}
var store2 = {
    exports: {}
};
/*! store2 - v2.14.4 - 2024-12-26
* Copyright (c) 2024 Nathan Bubna; Licensed MIT */
(function(_e) {
    (function($, et) {
        var tt = {
            version: "2.14.4",
            areas: {},
            apis: {},
            nsdelim: ".",
            inherit: function(rt, it) {
                for (var ot in rt)
                    it.hasOwnProperty(ot) || Object.defineProperty(it, ot, Object.getOwnPropertyDescriptor(rt, ot));
                return it
            },
            stringify: function(rt, it) {
                return rt === void 0 || typeof rt == "function" ? rt + "" : JSON.stringify(rt, it || tt.replace)
            },
            parse: function(rt, it) {
                try {
                    return JSON.parse(rt, it || tt.revive)
                } catch {
                    return rt
                }
            },
            fn: function(rt, it) {
                tt.storeAPI[rt] = it;
                for (var ot in tt.apis)
                    tt.apis[ot][rt] = it
            },
            get: function(rt, it) {
                return rt.getItem(it)
            },
            set: function(rt, it, ot) {
                rt.setItem(it, ot)
            },
            remove: function(rt, it) {
                rt.removeItem(it)
            },
            key: function(rt, it) {
                return rt.key(it)
            },
            length: function(rt) {
                return rt.length
            },
            clear: function(rt) {
                rt.clear()
            },
            Store: function(rt, it, ot) {
                var st = tt.inherit(tt.storeAPI, function(ct, dt, pt) {
                    return arguments.length === 0 ? st.getAll() : typeof dt == "function" ? st.transact(ct, dt, pt) : dt !== void 0 ? st.set(ct, dt, pt) : typeof ct == "string" || typeof ct == "number" ? st.get(ct) : typeof ct == "function" ? st.each(ct) : ct ? st.setAll(ct, dt) : st.clear()
                });
                st._id = rt;
                try {
                    var lt = "__store2_test";
                    it.setItem(lt, "ok"),
                    st._area = it,
                    it.removeItem(lt)
                } catch {
                    st._area = tt.storage("fake")
                }
                return st._ns = ot || "",
                tt.areas[rt] || (tt.areas[rt] = st._area),
                tt.apis[st._ns + st._id] || (tt.apis[st._ns + st._id] = st),
                st
            },
            storeAPI: {
                area: function(rt, it) {
                    var ot = this[rt];
                    return (!ot || !ot.area) && (ot = tt.Store(rt, it, this._ns),
                    this[rt] || (this[rt] = ot)),
                    ot
                },
                namespace: function(rt, it, ot) {
                    if (ot = ot || this._delim || tt.nsdelim,
                    !rt)
                        return this._ns ? this._ns.substring(0, this._ns.length - ot.length) : "";
                    var st = rt
                      , lt = this[st];
                    if ((!lt || !lt.namespace) && (lt = tt.Store(this._id, this._area, this._ns + st + ot),
                    lt._delim = ot,
                    this[st] || (this[st] = lt),
                    !it))
                        for (var ct in tt.areas)
                            lt.area(ct, tt.areas[ct]);
                    return lt
                },
                isFake: function(rt) {
                    return rt ? (this._real = this._area,
                    this._area = tt.storage("fake")) : rt === !1 && (this._area = this._real || this._area),
                    this._area.name === "fake"
                },
                toString: function() {
                    return "store" + (this._ns ? "." + this.namespace() : "") + "[" + this._id + "]"
                },
                has: function(rt) {
                    return this._area.has ? this._area.has(this._in(rt)) : this._in(rt)in this._area
                },
                size: function() {
                    return this.keys().length
                },
                each: function(rt, it) {
                    for (var ot = 0, st = tt.length(this._area); ot < st; ot++) {
                        var lt = this._out(tt.key(this._area, ot));
                        if (lt !== void 0 && rt.call(this, lt, this.get(lt), it) === !1)
                            break;
                        st > tt.length(this._area) && (st--,
                        ot--)
                    }
                    return it || this
                },
                keys: function(rt) {
                    return this.each(function(it, ot, st) {
                        st.push(it)
                    }, rt || [])
                },
                get: function(rt, it) {
                    var ot = tt.get(this._area, this._in(rt)), st;
                    return typeof it == "function" && (st = it,
                    it = null),
                    ot !== null ? tt.parse(ot, st) : it ?? ot
                },
                getAll: function(rt) {
                    return this.each(function(it, ot, st) {
                        st[it] = ot
                    }, rt || {})
                },
                transact: function(rt, it, ot) {
                    var st = this.get(rt, ot)
                      , lt = it(st);
                    return this.set(rt, lt === void 0 ? st : lt),
                    this
                },
                set: function(rt, it, ot) {
                    var st = this.get(rt), lt;
                    return st != null && ot === !1 ? it : (typeof ot == "function" && (lt = ot,
                    ot = void 0),
                    tt.set(this._area, this._in(rt), tt.stringify(it, lt), ot) || st)
                },
                setAll: function(rt, it) {
                    var ot, st;
                    for (var lt in rt)
                        st = rt[lt],
                        this.set(lt, st, it) !== st && (ot = !0);
                    return ot
                },
                add: function(rt, it, ot) {
                    var st = this.get(rt);
                    if (st instanceof Array)
                        it = st.concat(it);
                    else if (st !== null) {
                        var lt = typeof st;
                        if (lt === typeof it && lt === "object") {
                            for (var ct in it)
                                st[ct] = it[ct];
                            it = st
                        } else
                            it = st + it
                    }
                    return tt.set(this._area, this._in(rt), tt.stringify(it, ot)),
                    it
                },
                remove: function(rt, it) {
                    var ot = this.get(rt, it);
                    return tt.remove(this._area, this._in(rt)),
                    ot
                },
                clear: function() {
                    return this._ns ? this.each(function(rt) {
                        tt.remove(this._area, this._in(rt))
                    }, 1) : tt.clear(this._area),
                    this
                },
                clearAll: function() {
                    var rt = this._area;
                    for (var it in tt.areas)
                        tt.areas.hasOwnProperty(it) && (this._area = tt.areas[it],
                        this.clear());
                    return this._area = rt,
                    this
                },
                _in: function(rt) {
                    return typeof rt != "string" && (rt = tt.stringify(rt)),
                    this._ns ? this._ns + rt : rt
                },
                _out: function(rt) {
                    return this._ns ? rt && rt.indexOf(this._ns) === 0 ? rt.substring(this._ns.length) : void 0 : rt
                }
            },
            storage: function(rt) {
                return tt.inherit(tt.storageAPI, {
                    items: {},
                    name: rt
                })
            },
            storageAPI: {
                length: 0,
                has: function(rt) {
                    return this.items.hasOwnProperty(rt)
                },
                key: function(rt) {
                    var it = 0;
                    for (var ot in this.items)
                        if (this.has(ot) && rt === it++)
                            return ot
                },
                setItem: function(rt, it) {
                    this.has(rt) || this.length++,
                    this.items[rt] = it
                },
                removeItem: function(rt) {
                    this.has(rt) && (delete this.items[rt],
                    this.length--)
                },
                getItem: function(rt) {
                    return this.has(rt) ? this.items[rt] : null
                },
                clear: function() {
                    for (var rt in this.items)
                        this.removeItem(rt)
                }
            }
        }
          , nt = tt.Store("local", function() {
            try {
                return localStorage
            } catch {}
        }());
        nt.local = nt,
        nt._ = tt,
        nt.area("session", function() {
            try {
                return sessionStorage
            } catch {}
        }()),
        nt.area("page", tt.storage("page")),
        typeof et == "function" && et.amd !== void 0 ? et("store2", [], function() {
            return nt
        }) : _e.exports ? _e.exports = nt : ($.store && (tt.conflict = $.store),
        $.store = nt)
    }
    )(commonjsGlobal$1, commonjsGlobal$1 && commonjsGlobal$1.define)
}
)(store2);
var store2Exports = store2.exports;
const store$2 = getDefaultExportFromCjs$2(store2Exports)
  , ConnectionContext = reactExports.createContext({});
function useConnection() {
    return reactExports.useContext(ConnectionContext)
}
const ConnectionProvider = ({children: _e, endpoint: $, config: et={
    commitment: "confirmed"
}}) => {
    const tt = reactExports.useMemo( () => new Connection($,et), [$, et]);
    return React.createElement(ConnectionContext.Provider, {
        value: {
            connection: tt
        }
    }, _e)
}
;
class WalletNotSelectedError extends WalletError {
    constructor() {
        super(...arguments),
        this.name = "WalletNotSelectedError"
    }
}
const EMPTY_ARRAY = []
  , DEFAULT_CONTEXT = {
    autoConnect: !1,
    connecting: !1,
    connected: !1,
    disconnecting: !1,
    select() {
        logMissingProviderError("call", "select")
    },
    connect() {
        return Promise.reject(logMissingProviderError("call", "connect"))
    },
    disconnect() {
        return Promise.reject(logMissingProviderError("call", "disconnect"))
    },
    sendTransaction() {
        return Promise.reject(logMissingProviderError("call", "sendTransaction"))
    },
    signTransaction() {
        return Promise.reject(logMissingProviderError("call", "signTransaction"))
    },
    signAllTransactions() {
        return Promise.reject(logMissingProviderError("call", "signAllTransactions"))
    },
    signMessage() {
        return Promise.reject(logMissingProviderError("call", "signMessage"))
    },
    signIn() {
        return Promise.reject(logMissingProviderError("call", "signIn"))
    }
};
Object.defineProperty(DEFAULT_CONTEXT, "wallets", {
    get() {
        return logMissingProviderError("read", "wallets"),
        EMPTY_ARRAY
    }
});
Object.defineProperty(DEFAULT_CONTEXT, "wallet", {
    get() {
        return logMissingProviderError("read", "wallet"),
        null
    }
});
Object.defineProperty(DEFAULT_CONTEXT, "publicKey", {
    get() {
        return logMissingProviderError("read", "publicKey"),
        null
    }
});
function logMissingProviderError(_e, $) {
    return new Error(`You have tried to ${_e} "${$}" on a WalletContext without providing one. Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext.`)
}
const WalletContext = reactExports.createContext(DEFAULT_CONTEXT);
function useWallet() {
    return reactExports.useContext(WalletContext)
}
function useLocalStorage(_e, $) {
    const et = reactExports.useState( () => {
        try {
            const rt = localStorage.getItem(_e);
            if (rt)
                return JSON.parse(rt)
        } catch {}
        return $
    }
    )
      , tt = et[0]
      , nt = reactExports.useRef(!0);
    return reactExports.useEffect( () => {
        if (nt.current) {
            nt.current = !1;
            return
        }
        try {
            tt === null ? localStorage.removeItem(_e) : localStorage.setItem(_e, JSON.stringify(tt))
        } catch {}
    }
    , [tt, _e]),
    et
}
function getCommitment(_e) {
    switch (_e) {
    case "processed":
    case "confirmed":
    case "finalized":
    case void 0:
        return _e;
    case "recent":
        return "processed";
    case "single":
    case "singleGossip":
        return "confirmed";
    case "max":
    case "root":
        return "finalized";
    default:
        return
    }
}
const SOLANA_MAINNET_CHAIN = "solana:mainnet"
  , SOLANA_DEVNET_CHAIN = "solana:devnet"
  , SOLANA_TESTNET_CHAIN = "solana:testnet"
  , SOLANA_LOCALNET_CHAIN = "solana:localnet"
  , MAINNET_ENDPOINT = "https://api.mainnet-beta.solana.com";
function getChainForEndpoint(_e) {
    return _e.includes(MAINNET_ENDPOINT) ? SOLANA_MAINNET_CHAIN : /\bdevnet\b/i.test(_e) ? SOLANA_DEVNET_CHAIN : /\btestnet\b/i.test(_e) ? SOLANA_TESTNET_CHAIN : /\blocalhost\b/i.test(_e) || /\b127\.0\.0\.1\b/.test(_e) ? SOLANA_LOCALNET_CHAIN : SOLANA_MAINNET_CHAIN
}
function createSignInMessageText(_e) {
    let $ = `${_e.domain} wants you to sign in with your Solana account:
`;
    $ += `${_e.address}`,
    _e.statement && ($ += `

${_e.statement}`);
    const et = [];
    if (_e.uri && et.push(`URI: ${_e.uri}`),
    _e.version && et.push(`Version: ${_e.version}`),
    _e.chainId && et.push(`Chain ID: ${_e.chainId}`),
    _e.nonce && et.push(`Nonce: ${_e.nonce}`),
    _e.issuedAt && et.push(`Issued At: ${_e.issuedAt}`),
    _e.expirationTime && et.push(`Expiration Time: ${_e.expirationTime}`),
    _e.notBefore && et.push(`Not Before: ${_e.notBefore}`),
    _e.requestId && et.push(`Request ID: ${_e.requestId}`),
    _e.resources) {
        et.push("Resources:");
        for (const tt of _e.resources)
            et.push(`- ${tt}`)
    }
    return et.length && ($ += `

${et.join(`
`)}`),
    $
}
const SolanaMobileWalletAdapterErrorCode = {
    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: "ERROR_ASSOCIATION_PORT_OUT_OF_RANGE",
    ERROR_FORBIDDEN_WALLET_BASE_URL: "ERROR_FORBIDDEN_WALLET_BASE_URL",
    ERROR_SECURE_CONTEXT_REQUIRED: "ERROR_SECURE_CONTEXT_REQUIRED",
    ERROR_SESSION_CLOSED: "ERROR_SESSION_CLOSED",
    ERROR_SESSION_TIMEOUT: "ERROR_SESSION_TIMEOUT",
    ERROR_WALLET_NOT_FOUND: "ERROR_WALLET_NOT_FOUND",
    ERROR_INVALID_PROTOCOL_VERSION: "ERROR_INVALID_PROTOCOL_VERSION"
};
class SolanaMobileWalletAdapterError extends Error {
    constructor(...$) {
        const [et,tt,nt] = $;
        super(tt),
        this.code = et,
        this.data = nt,
        this.name = "SolanaMobileWalletAdapterError"
    }
}
class SolanaMobileWalletAdapterProtocolError extends Error {
    constructor(...$) {
        const [et,tt,nt,rt] = $;
        super(nt),
        this.code = tt,
        this.data = rt,
        this.jsonRpcMessageId = et,
        this.name = "SolanaMobileWalletAdapterProtocolError"
    }
}
function __awaiter$4(_e, $, et, tt) {
    function nt(rt) {
        return rt instanceof et ? rt : new et(function(it) {
            it(rt)
        }
        )
    }
    return new (et || (et = Promise))(function(rt, it) {
        function ot(ct) {
            try {
                lt(tt.next(ct))
            } catch (dt) {
                it(dt)
            }
        }
        function st(ct) {
            try {
                lt(tt.throw(ct))
            } catch (dt) {
                it(dt)
            }
        }
        function lt(ct) {
            ct.done ? rt(ct.value) : nt(ct.value).then(ot, st)
        }
        lt((tt = tt.apply(_e, [])).next())
    }
    )
}
function createHelloReq(_e, $) {
    return __awaiter$4(this, void 0, void 0, function*() {
        const et = yield crypto.subtle.exportKey("raw", _e)
          , tt = yield crypto.subtle.sign({
            hash: "SHA-256",
            name: "ECDSA"
        }, $, et)
          , nt = new Uint8Array(et.byteLength + tt.byteLength);
        return nt.set(new Uint8Array(et), 0),
        nt.set(new Uint8Array(tt), et.byteLength),
        nt
    })
}
function encode$2(_e) {
    return window.btoa(_e)
}
function createSIWSMessage(_e) {
    return createSignInMessageText(_e)
}
function createSIWSMessageBase64(_e) {
    return encode$2(createSIWSMessage(_e))
}
const SolanaSignTransactions = "solana:signTransactions"
  , SolanaCloneAuthorization = "solana:cloneAuthorization";
function createMobileWalletProxy(_e, $) {
    return new Proxy({},{
        get(et, tt) {
            return et[tt] == null && (et[tt] = function(nt) {
                return __awaiter$4(this, void 0, void 0, function*() {
                    const {method: rt, params: it} = handleMobileWalletRequest(tt, nt, _e)
                      , ot = yield $(rt, it);
                    return rt === "authorize" && it.sign_in_payload && !ot.sign_in_result && (ot.sign_in_result = yield signInFallback(it.sign_in_payload, ot, $)),
                    handleMobileWalletResponse(tt, ot, _e)
                })
            }
            ),
            et[tt]
        },
        defineProperty() {
            return !1
        },
        deleteProperty() {
            return !1
        }
    })
}
function handleMobileWalletRequest(_e, $, et) {
    let tt = $
      , nt = _e.toString().replace(/[A-Z]/g, rt => `_${rt.toLowerCase()}`).toLowerCase();
    switch (_e) {
    case "authorize":
        {
            let {chain: rt} = tt;
            if (et === "legacy") {
                switch (rt) {
                case "solana:testnet":
                    {
                        rt = "testnet";
                        break
                    }
                case "solana:devnet":
                    {
                        rt = "devnet";
                        break
                    }
                case "solana:mainnet":
                    {
                        rt = "mainnet-beta";
                        break
                    }
                default:
                    rt = tt.cluster
                }
                tt.cluster = rt
            } else {
                switch (rt) {
                case "testnet":
                case "devnet":
                    {
                        rt = `solana:${rt}`;
                        break
                    }
                case "mainnet-beta":
                    {
                        rt = "solana:mainnet";
                        break
                    }
                }
                tt.chain = rt
            }
        }
    case "reauthorize":
        {
            const {auth_token: rt, identity: it} = tt;
            if (rt)
                switch (et) {
                case "legacy":
                    {
                        nt = "reauthorize",
                        tt = {
                            auth_token: rt,
                            identity: it
                        };
                        break
                    }
                default:
                    {
                        nt = "authorize";
                        break
                    }
                }
            break
        }
    }
    return {
        method: nt,
        params: tt
    }
}
function handleMobileWalletResponse(_e, $, et) {
    switch (_e) {
    case "getCapabilities":
        {
            const tt = $;
            switch (et) {
            case "legacy":
                {
                    const nt = [SolanaSignTransactions];
                    return tt.supports_clone_authorization === !0 && nt.push(SolanaCloneAuthorization),
                    Object.assign(Object.assign({}, tt), {
                        features: nt
                    })
                }
            case "v1":
                return Object.assign(Object.assign({}, tt), {
                    supports_sign_and_send_transactions: !0,
                    supports_clone_authorization: tt.features.includes(SolanaCloneAuthorization)
                })
            }
        }
    }
    return $
}
function signInFallback(_e, $, et) {
    var tt;
    return __awaiter$4(this, void 0, void 0, function*() {
        const nt = (tt = _e.domain) !== null && tt !== void 0 ? tt : window.location.host
          , rt = $.accounts[0].address
          , it = createSIWSMessageBase64(Object.assign(Object.assign({}, _e), {
            domain: nt,
            address: rt
        }))
          , ot = yield et("sign_messages", {
            addresses: [rt],
            payloads: [it]
        });
        return {
            address: rt,
            signed_message: it,
            signature: ot.signed_payloads[0].slice(it.length)
        }
    })
}
const SEQUENCE_NUMBER_BYTES = 4;
function createSequenceNumberVector(_e) {
    if (_e >= 4294967296)
        throw new Error("Outbound sequence number overflow. The maximum sequence number is 32-bytes.");
    const $ = new ArrayBuffer(SEQUENCE_NUMBER_BYTES);
    return new DataView($).setUint32(0, _e, !1),
    new Uint8Array($)
}
const INITIALIZATION_VECTOR_BYTES = 12
  , ENCODED_PUBLIC_KEY_LENGTH_BYTES = 65;
function encryptMessage(_e, $, et) {
    return __awaiter$4(this, void 0, void 0, function*() {
        const tt = createSequenceNumberVector($)
          , nt = new Uint8Array(INITIALIZATION_VECTOR_BYTES);
        crypto.getRandomValues(nt);
        const rt = yield crypto.subtle.encrypt(getAlgorithmParams(tt, nt), et, new TextEncoder().encode(_e))
          , it = new Uint8Array(tt.byteLength + nt.byteLength + rt.byteLength);
        return it.set(new Uint8Array(tt), 0),
        it.set(new Uint8Array(nt), tt.byteLength),
        it.set(new Uint8Array(rt), tt.byteLength + nt.byteLength),
        it
    })
}
function decryptMessage(_e, $) {
    return __awaiter$4(this, void 0, void 0, function*() {
        const et = _e.slice(0, SEQUENCE_NUMBER_BYTES)
          , tt = _e.slice(SEQUENCE_NUMBER_BYTES, SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES)
          , nt = _e.slice(SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES)
          , rt = yield crypto.subtle.decrypt(getAlgorithmParams(et, tt), $, nt);
        return getUtf8Decoder().decode(rt)
    })
}
function getAlgorithmParams(_e, $) {
    return {
        additionalData: _e,
        iv: $,
        name: "AES-GCM",
        tagLength: 128
    }
}
let _utf8Decoder;
function getUtf8Decoder() {
    return _utf8Decoder === void 0 && (_utf8Decoder = new TextDecoder("utf-8")),
    _utf8Decoder
}
function generateAssociationKeypair() {
    return __awaiter$4(this, void 0, void 0, function*() {
        return yield crypto.subtle.generateKey({
            name: "ECDSA",
            namedCurve: "P-256"
        }, !1, ["sign"])
    })
}
function generateECDHKeypair() {
    return __awaiter$4(this, void 0, void 0, function*() {
        return yield crypto.subtle.generateKey({
            name: "ECDH",
            namedCurve: "P-256"
        }, !1, ["deriveKey", "deriveBits"])
    })
}
function encryptJsonRpcMessage(_e, $) {
    return __awaiter$4(this, void 0, void 0, function*() {
        const et = JSON.stringify(_e)
          , tt = _e.id;
        return encryptMessage(et, tt, $)
    })
}
function decryptJsonRpcMessage(_e, $) {
    return __awaiter$4(this, void 0, void 0, function*() {
        const et = yield decryptMessage(_e, $)
          , tt = JSON.parse(et);
        if (Object.hasOwnProperty.call(tt, "error"))
            throw new SolanaMobileWalletAdapterProtocolError(tt.id,tt.error.code,tt.error.message);
        return tt
    })
}
function parseHelloRsp(_e, $, et) {
    return __awaiter$4(this, void 0, void 0, function*() {
        const [tt,nt] = yield Promise.all([crypto.subtle.exportKey("raw", $), crypto.subtle.importKey("raw", _e.slice(0, ENCODED_PUBLIC_KEY_LENGTH_BYTES), {
            name: "ECDH",
            namedCurve: "P-256"
        }, !1, [])])
          , rt = yield crypto.subtle.deriveBits({
            name: "ECDH",
            public: nt
        }, et, 256)
          , it = yield crypto.subtle.importKey("raw", rt, "HKDF", !1, ["deriveKey"]);
        return yield crypto.subtle.deriveKey({
            name: "HKDF",
            hash: "SHA-256",
            salt: new Uint8Array(tt),
            info: new Uint8Array
        }, it, {
            name: "AES-GCM",
            length: 128
        }, !1, ["encrypt", "decrypt"])
    })
}
function parseSessionProps(_e, $) {
    return __awaiter$4(this, void 0, void 0, function*() {
        const et = yield decryptMessage(_e, $)
          , tt = JSON.parse(et);
        let nt = "legacy";
        if (Object.hasOwnProperty.call(tt, "v"))
            switch (tt.v) {
            case 1:
            case "1":
            case "v1":
                nt = "v1";
                break;
            case "legacy":
                nt = "legacy";
                break;
            default:
                throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_INVALID_PROTOCOL_VERSION,`Unknown/unsupported protocol version: ${tt.v}`)
            }
        return {
            protocol_version: nt
        }
    })
}
function getRandomAssociationPort() {
    return assertAssociationPort(49152 + Math.floor(Math.random() * 16384))
}
function assertAssociationPort(_e) {
    if (_e < 49152 || _e > 65535)
        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE,`Association port number must be between 49152 and 65535. ${_e} given.`,{
            port: _e
        });
    return _e
}
function arrayBufferToBase64String(_e) {
    let $ = "";
    const et = new Uint8Array(_e)
      , tt = et.byteLength;
    for (let nt = 0; nt < tt; nt++)
        $ += String.fromCharCode(et[nt]);
    return window.btoa($)
}
function getStringWithURLUnsafeCharactersReplaced(_e) {
    return _e.replace(/[/+=]/g, $ => ({
        "/": "_",
        "+": "-",
        "=": "."
    })[$])
}
const INTENT_NAME = "solana-wallet";
function getPathParts(_e) {
    return _e.replace(/(^\/+|\/+$)/g, "").split("/")
}
function getIntentURL(_e, $) {
    let et = null;
    if ($) {
        try {
            et = new URL($)
        } catch {}
        if ((et == null ? void 0 : et.protocol) !== "https:")
            throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL,"Base URLs supplied by wallets must be valid `https` URLs")
    }
    et || (et = new URL(`${INTENT_NAME}:/`));
    const tt = _e.startsWith("/") ? _e : [...getPathParts(et.pathname), ...getPathParts(_e)].join("/");
    return new URL(tt,et)
}
function getAssociateAndroidIntentURL(_e, $, et, tt=["v1"]) {
    return __awaiter$4(this, void 0, void 0, function*() {
        const nt = assertAssociationPort($)
          , rt = yield crypto.subtle.exportKey("raw", _e)
          , it = arrayBufferToBase64String(rt)
          , ot = getIntentURL("v1/associate/local", et);
        return ot.searchParams.set("association", getStringWithURLUnsafeCharactersReplaced(it)),
        ot.searchParams.set("port", `${nt}`),
        tt.forEach(st => {
            ot.searchParams.set("v", st)
        }
        ),
        ot
    })
}
const Browser = {
    Firefox: 0,
    Other: 1
};
function assertUnreachable(_e) {
    return _e
}
function getBrowser$1() {
    return navigator.userAgent.indexOf("Firefox/") !== -1 ? Browser.Firefox : Browser.Other
}
function getDetectionPromise() {
    return new Promise( (_e, $) => {
        function et() {
            clearTimeout(nt),
            window.removeEventListener("blur", tt)
        }
        function tt() {
            et(),
            _e()
        }
        window.addEventListener("blur", tt);
        const nt = setTimeout( () => {
            et(),
            $()
        }
        , 2e3)
    }
    )
}
let _frame = null;
function launchUrlThroughHiddenFrame(_e) {
    _frame == null && (_frame = document.createElement("iframe"),
    _frame.style.display = "none",
    document.body.appendChild(_frame)),
    _frame.contentWindow.location.href = _e.toString()
}
function launchAssociation(_e) {
    return __awaiter$4(this, void 0, void 0, function*() {
        if (_e.protocol === "https:")
            window.location.assign(_e);
        else
            try {
                const $ = getBrowser$1();
                switch ($) {
                case Browser.Firefox:
                    launchUrlThroughHiddenFrame(_e);
                    break;
                case Browser.Other:
                    {
                        const et = getDetectionPromise();
                        window.location.assign(_e),
                        yield et;
                        break
                    }
                default:
                }
            } catch {
                throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND,"Found no installed wallet that supports the mobile wallet protocol.")
            }
    })
}
function startSession$1(_e, $) {
    return __awaiter$4(this, void 0, void 0, function*() {
        const et = getRandomAssociationPort()
          , tt = yield getAssociateAndroidIntentURL(_e, et, $);
        return yield launchAssociation(tt),
        et
    })
}
const WEBSOCKET_CONNECTION_CONFIG = {
    retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1e3],
    timeoutMs: 3e4
}
  , WEBSOCKET_PROTOCOL = "com.solana.mobilewalletadapter.v1";
function assertSecureContext() {
    if (typeof window > "u" || window.isSecureContext !== !0)
        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SECURE_CONTEXT_REQUIRED,"The mobile wallet adapter protocol must be used in a secure context (`https`).")
}
function assertSecureEndpointSpecificURI(_e) {
    let $;
    try {
        $ = new URL(_e)
    } catch {
        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL,"Invalid base URL supplied by wallet")
    }
    if ($.protocol !== "https:")
        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL,"Base URLs supplied by wallets must be valid `https` URLs")
}
function getSequenceNumberFromByteArray(_e) {
    return new DataView(_e).getUint32(0, !1)
}
function transact$1(_e, $) {
    return __awaiter$4(this, void 0, void 0, function*() {
        assertSecureContext();
        const et = yield generateAssociationKeypair()
          , nt = `ws://localhost:${yieldstartSession$1(et.publicKey, $ == null ? void 0 : $.baseUri)}/solana-wallet`;
        let rt;
        const it = ( () => {
            const ct = [...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs];
            return () => ct.length > 1 ? ct.shift() : ct[0]
        }
        )();
        let ot = 1
          , st = 0
          , lt = {
            __type: "disconnected"
        };
        return new Promise( (ct, dt) => {
            let pt;
            const ht = {}
              , mt = () => __awaiter$4(this, void 0, void 0, function*() {
                if (lt.__type !== "connecting")
                    return;
                pt.removeEventListener("open", mt);
                const {associationKeypair: Nt} = lt
                  , Lt = yield generateECDHKeypair();
                pt.send(yield createHelloReq(Lt.publicKey, Nt.privateKey)),
                lt = {
                    __type: "hello_req_sent",
                    associationPublicKey: Nt.publicKey,
                    ecdhPrivateKey: Lt.privateKey
                }
            })
              , yt = Nt => {
                Nt.wasClean ? lt = {
                    __type: "disconnected"
                } : dt(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED,`The wallet session dropped unexpectedly (${Nt.code}: ${Nt.reason}).`,{
                    closeEvent: Nt
                })),
                wt()
            }
              , Et = Nt => __awaiter$4(this, void 0, void 0, function*() {
                wt(),
                Date.now() - rt >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs ? dt(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT,`Failed to connect to the wallet websocket at ${nt}.`)) : (yield new Promise(Lt => {
                    const kt = it();
                    St = window.setTimeout(Lt, kt)
                }
                ),
                Ct())
            })
              , _t = Nt => __awaiter$4(this, void 0, void 0, function*() {
                const Lt = yield Nt.data.arrayBuffer();
                switch (lt.__type) {
                case "connecting":
                    if (Lt.byteLength !== 0)
                        throw new Error("Encountered unexpected message while connecting");
                    const kt = yield generateECDHKeypair();
                    pt.send(yield createHelloReq(kt.publicKey, et.privateKey)),
                    lt = {
                        __type: "hello_req_sent",
                        associationPublicKey: et.publicKey,
                        ecdhPrivateKey: kt.privateKey
                    };
                    break;
                case "connected":
                    try {
                        const Ut = Lt.slice(0, SEQUENCE_NUMBER_BYTES)
                          , Jt = getSequenceNumberFromByteArray(Ut);
                        if (Jt !== st + 1)
                            throw new Error("Encrypted message has invalid sequence number");
                        st = Jt;
                        const Pt = yield decryptJsonRpcMessage(Lt, lt.sharedSecret)
                          , Xt = ht[Pt.id];
                        delete ht[Pt.id],
                        Xt.resolve(Pt.result)
                    } catch (Ut) {
                        if (Ut instanceof SolanaMobileWalletAdapterProtocolError) {
                            const Jt = ht[Ut.jsonRpcMessageId];
                            delete ht[Ut.jsonRpcMessageId],
                            Jt.reject(Ut)
                        } else
                            throw Ut
                    }
                    break;
                case "hello_req_sent":
                    {
                        if (Lt.byteLength === 0) {
                            const rn = yield generateECDHKeypair();
                            pt.send(yield createHelloReq(rn.publicKey, et.privateKey)),
                            lt = {
                                __type: "hello_req_sent",
                                associationPublicKey: et.publicKey,
                                ecdhPrivateKey: rn.privateKey
                            };
                            break
                        }
                        const Ut = yield parseHelloRsp(Lt, lt.associationPublicKey, lt.ecdhPrivateKey)
                          , Jt = Lt.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES)
                          , Pt = Jt.byteLength !== 0 ? yield __awaiter$4(this, void 0, void 0, function*() {
                            const rn = Jt.slice(0, SEQUENCE_NUMBER_BYTES)
                              , zt = getSequenceNumberFromByteArray(rn);
                            if (zt !== st + 1)
                                throw new Error("Encrypted message has invalid sequence number");
                            return st = zt,
                            parseSessionProps(Jt, Ut)
                        }) : {
                            protocol_version: "legacy"
                        };
                        lt = {
                            __type: "connected",
                            sharedSecret: Ut,
                            sessionProperties: Pt
                        };
                        const Xt = createMobileWalletProxy(Pt.protocol_version, (rn, zt) => __awaiter$4(this, void 0, void 0, function*() {
                            const xt = ot++;
                            return pt.send(yield encryptJsonRpcMessage({
                                id: xt,
                                jsonrpc: "2.0",
                                method: rn,
                                params: zt ?? {}
                            }, Ut)),
                            new Promise( ($t, Dt) => {
                                ht[xt] = {
                                    resolve(jt) {
                                        switch (rn) {
                                        case "authorize":
                                        case "reauthorize":
                                            {
                                                const {wallet_uri_base: Ft} = jt;
                                                if (Ft != null)
                                                    try {
                                                        assertSecureEndpointSpecificURI(Ft)
                                                    } catch (Ht) {
                                                        Dt(Ht);
                                                        return
                                                    }
                                                break
                                            }
                                        }
                                        $t(jt)
                                    },
                                    reject: Dt
                                }
                            }
                            )
                        }));
                        try {
                            ct(yield _e(Xt))
                        } catch (rn) {
                            dt(rn)
                        } finally {
                            wt(),
                            pt.close()
                        }
                        break
                    }
                }
            });
            let wt, St;
            const Ct = () => {
                wt && wt(),
                lt = {
                    __type: "connecting",
                    associationKeypair: et
                },
                rt === void 0 && (rt = Date.now()),
                pt = new WebSocket(nt,[WEBSOCKET_PROTOCOL]),
                pt.addEventListener("open", mt),
                pt.addEventListener("close", yt),
                pt.addEventListener("error", Et),
                pt.addEventListener("message", _t),
                wt = () => {
                    window.clearTimeout(St),
                    pt.removeEventListener("open", mt),
                    pt.removeEventListener("close", yt),
                    pt.removeEventListener("error", Et),
                    pt.removeEventListener("message", _t)
                }
            }
            ;
            Ct()
        }
        )
    })
}
function base$1(_e) {
    if (_e.length >= 255)
        throw new TypeError("Alphabet too long");
    for (var $ = new Uint8Array(256), et = 0; et < $.length; et++)
        $[et] = 255;
    for (var tt = 0; tt < _e.length; tt++) {
        var nt = _e.charAt(tt)
          , rt = nt.charCodeAt(0);
        if ($[rt] !== 255)
            throw new TypeError(nt + " is ambiguous");
        $[rt] = tt
    }
    var it = _e.length
      , ot = _e.charAt(0)
      , st = Math.log(it) / Math.log(256)
      , lt = Math.log(256) / Math.log(it);
    function ct(ht) {
        if (ht instanceof Uint8Array || (ArrayBuffer.isView(ht) ? ht = new Uint8Array(ht.buffer,ht.byteOffset,ht.byteLength) : Array.isArray(ht) && (ht = Uint8Array.from(ht))),
        !(ht instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (ht.length === 0)
            return "";
        for (var mt = 0, yt = 0, Et = 0, _t = ht.length; Et !== _t && ht[Et] === 0; )
            Et++,
            mt++;
        for (var wt = (_t - Et) * lt + 1 >>> 0, St = new Uint8Array(wt); Et !== _t; ) {
            for (var Ct = ht[Et], Nt = 0, Lt = wt - 1; (Ct !== 0 || Nt < yt) && Lt !== -1; Lt--,
            Nt++)
                Ct += 256 * St[Lt] >>> 0,
                St[Lt] = Ct % it >>> 0,
                Ct = Ct / it >>> 0;
            if (Ct !== 0)
                throw new Error("Non-zero carry");
            yt = Nt,
            Et++
        }
        for (var kt = wt - yt; kt !== wt && St[kt] === 0; )
            kt++;
        for (var Ut = ot.repeat(mt); kt < wt; ++kt)
            Ut += _e.charAt(St[kt]);
        return Ut
    }
    function dt(ht) {
        if (typeof ht != "string")
            throw new TypeError("Expected String");
        if (ht.length === 0)
            return new Uint8Array;
        for (var mt = 0, yt = 0, Et = 0; ht[mt] === ot; )
            yt++,
            mt++;
        for (var _t = (ht.length - mt) * st + 1 >>> 0, wt = new Uint8Array(_t); ht[mt]; ) {
            var St = $[ht.charCodeAt(mt)];
            if (St === 255)
                return;
            for (var Ct = 0, Nt = _t - 1; (St !== 0 || Ct < Et) && Nt !== -1; Nt--,
            Ct++)
                St += it * wt[Nt] >>> 0,
                wt[Nt] = St % 256 >>> 0,
                St = St / 256 >>> 0;
            if (St !== 0)
                throw new Error("Non-zero carry");
            Et = Ct,
            mt++
        }
        for (var Lt = _t - Et; Lt !== _t && wt[Lt] === 0; )
            Lt++;
        for (var kt = new Uint8Array(yt + (_t - Lt)), Ut = yt; Lt !== _t; )
            kt[Ut++] = wt[Lt++];
        return kt
    }
    function pt(ht) {
        var mt = dt(ht);
        if (mt)
            return mt;
        throw new Error("Non-base" + it + " character")
    }
    return {
        encode: ct,
        decodeUnsafe: dt,
        decode: pt
    }
}
var src = base$1;
const basex = src
  , ALPHABET$2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bs58$1 = basex(ALPHABET$2);
const base58 = getDefaultExportFromCjs$2(bs58$1);
function __rest$2(_e, $) {
    var et = {};
    for (var tt in _e)
        Object.prototype.hasOwnProperty.call(_e, tt) && $.indexOf(tt) < 0 && (et[tt] = _e[tt]);
    if (_e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var nt = 0, tt = Object.getOwnPropertySymbols(_e); nt < tt.length; nt++)
            $.indexOf(tt[nt]) < 0 && Object.prototype.propertyIsEnumerable.call(_e, tt[nt]) && (et[tt[nt]] = _e[tt[nt]]);
    return et
}
function __awaiter$3(_e, $, et, tt) {
    function nt(rt) {
        return rt instanceof et ? rt : new et(function(it) {
            it(rt)
        }
        )
    }
    return new (et || (et = Promise))(function(rt, it) {
        function ot(ct) {
            try {
                lt(tt.next(ct))
            } catch (dt) {
                it(dt)
            }
        }
        function st(ct) {
            try {
                lt(tt.throw(ct))
            } catch (dt) {
                it(dt)
            }
        }
        function lt(ct) {
            ct.done ? rt(ct.value) : nt(ct.value).then(ot, st)
        }
        lt((tt = tt.apply(_e, [])).next())
    }
    )
}
function fromUint8Array(_e) {
    return window.btoa(String.fromCharCode.call(null, ..._e))
}
function toUint8Array$1(_e) {
    return new Uint8Array(window.atob(_e).split("").map($ => $.charCodeAt(0)))
}
function getPayloadFromTransaction(_e) {
    const $ = "version"in _e ? _e.serialize() : _e.serialize({
        requireAllSignatures: !1,
        verifySignatures: !1
    });
    return fromUint8Array($)
}
function getTransactionFromWireMessage(_e) {
    const et = _e[0] * SIGNATURE_LENGTH_IN_BYTES + 1;
    return VersionedMessage.deserializeMessageVersion(_e.slice(et, _e.length)) === "legacy" ? Transaction.from(_e) : VersionedTransaction.deserialize(_e)
}
function transact(_e, $) {
    return __awaiter$3(this, void 0, void 0, function*() {
        return yield transact$1(tt => {
            const nt = new Proxy({},{
                get(rt, it) {
                    if (rt[it] == null)
                        switch (it) {
                        case "signAndSendTransactions":
                            rt[it] = function(ot) {
                                var {minContextSlot: st, commitment: lt, skipPreflight: ct, maxRetries: dt, waitForCommitmentToSendNextTransaction: pt, transactions: ht} = ot
                                  , mt = __rest$2(ot, ["minContextSlot", "commitment", "skipPreflight", "maxRetries", "waitForCommitmentToSendNextTransaction", "transactions"]);
                                return __awaiter$3(this, void 0, void 0, function*() {
                                    const yt = ht.map(getPayloadFromTransaction)
                                      , Et = {
                                        min_context_slot: st,
                                        commitment: lt,
                                        skip_preflight: ct,
                                        max_retries: dt,
                                        wait_for_commitment_to_send_next_transaction: pt
                                    }
                                      , {signatures: _t} = yield tt.signAndSendTransactions(Object.assign(Object.assign(Object.assign({}, mt), Object.values(Et).some(St => St != null) ? {
                                        options: Et
                                    } : null), {
                                        payloads: yt
                                    }));
                                    return _t.map(toUint8Array$1).map(base58.encode)
                                })
                            }
                            ;
                            break;
                        case "signMessages":
                            rt[it] = function(ot) {
                                var {payloads: st} = ot
                                  , lt = __rest$2(ot, ["payloads"]);
                                return __awaiter$3(this, void 0, void 0, function*() {
                                    const ct = st.map(fromUint8Array)
                                      , {signed_payloads: dt} = yield tt.signMessages(Object.assign(Object.assign({}, lt), {
                                        payloads: ct
                                    }));
                                    return dt.map(toUint8Array$1)
                                })
                            }
                            ;
                            break;
                        case "signTransactions":
                            rt[it] = function(ot) {
                                var {transactions: st} = ot
                                  , lt = __rest$2(ot, ["transactions"]);
                                return __awaiter$3(this, void 0, void 0, function*() {
                                    const ct = st.map(getPayloadFromTransaction)
                                      , {signed_payloads: dt} = yield tt.signTransactions(Object.assign(Object.assign({}, lt), {
                                        payloads: ct
                                    }));
                                    return dt.map(toUint8Array$1).map(getTransactionFromWireMessage)
                                })
                            }
                            ;
                            break;
                        default:
                            {
                                rt[it] = tt[it];
                                break
                            }
                        }
                    return rt[it]
                },
                defineProperty() {
                    return !1
                },
                deleteProperty() {
                    return !1
                }
            });
            return _e(nt)
        }
        , $)
    })
}
var canPromise$1 = function() {
    return typeof Promise == "function" && Promise.prototype && Promise.prototype.then
}
  , qrcode = {}
  , utils$3 = {};
let toSJISFunction;
const CODEWORDS_COUNT = [0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706];
utils$3.getSymbolSize = function($) {
    if (!$)
        throw new Error('"version" cannot be null or undefined');
    if ($ < 1 || $ > 40)
        throw new Error('"version" should be in range from 1 to 40');
    return $ * 4 + 17
}
;
utils$3.getSymbolTotalCodewords = function($) {
    return CODEWORDS_COUNT[$]
}
;
utils$3.getBCHDigit = function(_e) {
    let $ = 0;
    for (; _e !== 0; )
        $++,
        _e >>>= 1;
    return $
}
;
utils$3.setToSJISFunction = function($) {
    if (typeof $ != "function")
        throw new Error('"toSJISFunc" is not a valid function.');
    toSJISFunction = $
}
;
utils$3.isKanjiModeEnabled = function() {
    return typeof toSJISFunction < "u"
}
;
utils$3.toSJIS = function($) {
    return toSJISFunction($)
}
;
var errorCorrectionLevel = {};
(function(_e) {
    _e.L = {
        bit: 1
    },
    _e.M = {
        bit: 0
    },
    _e.Q = {
        bit: 3
    },
    _e.H = {
        bit: 2
    };
    function $(et) {
        if (typeof et != "string")
            throw new Error("Param is not a string");
        switch (et.toLowerCase()) {
        case "l":
        case "low":
            return _e.L;
        case "m":
        case "medium":
            return _e.M;
        case "q":
        case "quartile":
            return _e.Q;
        case "h":
        case "high":
            return _e.H;
        default:
            throw new Error("Unknown EC Level: " + et)
        }
    }
    _e.isValid = function(tt) {
        return tt && typeof tt.bit < "u" && tt.bit >= 0 && tt.bit < 4
    }
    ,
    _e.from = function(tt, nt) {
        if (_e.isValid(tt))
            return tt;
        try {
            return $(tt)
        } catch {
            return nt
        }
    }
}
)(errorCorrectionLevel);
function BitBuffer$1() {
    this.buffer = [],
    this.length = 0
}
BitBuffer$1.prototype = {
    get: function(_e) {
        const $ = Math.floor(_e / 8);
        return (this.buffer[$] >>> 7 - _e % 8 & 1) === 1
    },
    put: function(_e, $) {
        for (let et = 0; et < $; et++)
            this.putBit((_e >>> $ - et - 1 & 1) === 1)
    },
    getLengthInBits: function() {
        return this.length
    },
    putBit: function(_e) {
        const $ = Math.floor(this.length / 8);
        this.buffer.length <= $ && this.buffer.push(0),
        _e && (this.buffer[$] |= 128 >>> this.length % 8),
        this.length++
    }
};
var bitBuffer = BitBuffer$1;
function BitMatrix$1(_e) {
    if (!_e || _e < 1)
        throw new Error("BitMatrix size must be defined and greater than 0");
    this.size = _e,
    this.data = new Uint8Array(_e * _e),
    this.reservedBit = new Uint8Array(_e * _e)
}
BitMatrix$1.prototype.set = function(_e, $, et, tt) {
    const nt = _e * this.size + $;
    this.data[nt] = et,
    tt && (this.reservedBit[nt] = !0)
}
;
BitMatrix$1.prototype.get = function(_e, $) {
    return this.data[_e * this.size + $]
}
;
BitMatrix$1.prototype.xor = function(_e, $, et) {
    this.data[_e * this.size + $] ^= et
}
;
BitMatrix$1.prototype.isReserved = function(_e, $) {
    return this.reservedBit[_e * this.size + $]
}
;
var bitMatrix = BitMatrix$1
  , alignmentPattern = {};
(function(_e) {
    const $ = utils$3.getSymbolSize;
    _e.getRowColCoords = function(tt) {
        if (tt === 1)
            return [];
        const nt = Math.floor(tt / 7) + 2
          , rt = $(tt)
          , it = rt === 145 ? 26 : Math.ceil((rt - 13) / (2 * nt - 2)) * 2
          , ot = [rt - 7];
        for (let st = 1; st < nt - 1; st++)
            ot[st] = ot[st - 1] - it;
        return ot.push(6),
        ot.reverse()
    }
    ,
    _e.getPositions = function(tt) {
        const nt = []
          , rt = _e.getRowColCoords(tt)
          , it = rt.length;
        for (let ot = 0; ot < it; ot++)
            for (let st = 0; st < it; st++)
                ot === 0 && st === 0 || ot === 0 && st === it - 1 || ot === it - 1 && st === 0 || nt.push([rt[ot], rt[st]]);
        return nt
    }
}
)(alignmentPattern);
var finderPattern = {};
const getSymbolSize = utils$3.getSymbolSize
  , FINDER_PATTERN_SIZE = 7;
finderPattern.getPositions = function($) {
    const et = getSymbolSize($);
    return [[0, 0], [et - FINDER_PATTERN_SIZE, 0], [0, et - FINDER_PATTERN_SIZE]]
}
;
var maskPattern = {};
(function(_e) {
    _e.Patterns = {
        PATTERN000: 0,
        PATTERN001: 1,
        PATTERN010: 2,
        PATTERN011: 3,
        PATTERN100: 4,
        PATTERN101: 5,
        PATTERN110: 6,
        PATTERN111: 7
    };
    const $ = {
        N1: 3,
        N2: 3,
        N3: 40,
        N4: 10
    };
    _e.isValid = function(nt) {
        return nt != null && nt !== "" && !isNaN(nt) && nt >= 0 && nt <= 7
    }
    ,
    _e.from = function(nt) {
        return _e.isValid(nt) ? parseInt(nt, 10) : void 0
    }
    ,
    _e.getPenaltyN1 = function(nt) {
        const rt = nt.size;
        let it = 0
          , ot = 0
          , st = 0
          , lt = null
          , ct = null;
        for (let dt = 0; dt < rt; dt++) {
            ot = st = 0,
            lt = ct = null;
            for (let pt = 0; pt < rt; pt++) {
                let ht = nt.get(dt, pt);
                ht === lt ? ot++ : (ot >= 5 && (it += $.N1 + (ot - 5)),
                lt = ht,
                ot = 1),
                ht = nt.get(pt, dt),
                ht === ct ? st++ : (st >= 5 && (it += $.N1 + (st - 5)),
                ct = ht,
                st = 1)
            }
            ot >= 5 && (it += $.N1 + (ot - 5)),
            st >= 5 && (it += $.N1 + (st - 5))
        }
        return it
    }
    ,
    _e.getPenaltyN2 = function(nt) {
        const rt = nt.size;
        let it = 0;
        for (let ot = 0; ot < rt - 1; ot++)
            for (let st = 0; st < rt - 1; st++) {
                const lt = nt.get(ot, st) + nt.get(ot, st + 1) + nt.get(ot + 1, st) + nt.get(ot + 1, st + 1);
                (lt === 4 || lt === 0) && it++
            }
        return it * $.N2
    }
    ,
    _e.getPenaltyN3 = function(nt) {
        const rt = nt.size;
        let it = 0
          , ot = 0
          , st = 0;
        for (let lt = 0; lt < rt; lt++) {
            ot = st = 0;
            for (let ct = 0; ct < rt; ct++)
                ot = ot << 1 & 2047 | nt.get(lt, ct),
                ct >= 10 && (ot === 1488 || ot === 93) && it++,
                st = st << 1 & 2047 | nt.get(ct, lt),
                ct >= 10 && (st === 1488 || st === 93) && it++
        }
        return it * $.N3
    }
    ,
    _e.getPenaltyN4 = function(nt) {
        let rt = 0;
        const it = nt.data.length;
        for (let st = 0; st < it; st++)
            rt += nt.data[st];
        return Math.abs(Math.ceil(rt * 100 / it / 5) - 10) * $.N4
    }
    ;
    function et(tt, nt, rt) {
        switch (tt) {
        case _e.Patterns.PATTERN000:
            return (nt + rt) % 2 === 0;
        case _e.Patterns.PATTERN001:
            return nt % 2 === 0;
        case _e.Patterns.PATTERN010:
            return rt % 3 === 0;
        case _e.Patterns.PATTERN011:
            return (nt + rt) % 3 === 0;
        case _e.Patterns.PATTERN100:
            return (Math.floor(nt / 2) + Math.floor(rt / 3)) % 2 === 0;
        case _e.Patterns.PATTERN101:
            return nt * rt % 2 + nt * rt % 3 === 0;
        case _e.Patterns.PATTERN110:
            return (nt * rt % 2 + nt * rt % 3) % 2 === 0;
        case _e.Patterns.PATTERN111:
            return (nt * rt % 3 + (nt + rt) % 2) % 2 === 0;
        default:
            throw new Error("bad maskPattern:" + tt)
        }
    }
    _e.applyMask = function(nt, rt) {
        const it = rt.size;
        for (let ot = 0; ot < it; ot++)
            for (let st = 0; st < it; st++)
                rt.isReserved(st, ot) || rt.xor(st, ot, et(nt, st, ot))
    }
    ,
    _e.getBestMask = function(nt, rt) {
        const it = Object.keys(_e.Patterns).length;
        let ot = 0
          , st = 1 / 0;
        for (let lt = 0; lt < it; lt++) {
            rt(lt),
            _e.applyMask(lt, nt);
            const ct = _e.getPenaltyN1(nt) + _e.getPenaltyN2(nt) + _e.getPenaltyN3(nt) + _e.getPenaltyN4(nt);
            _e.applyMask(lt, nt),
            ct < st && (st = ct,
            ot = lt)
        }
        return ot
    }
}
)(maskPattern);
var errorCorrectionCode = {};
const ECLevel$1 = errorCorrectionLevel
  , EC_BLOCKS_TABLE = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4, 6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12, 16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21, 7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10, 20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42, 14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48, 57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45, 62, 74, 24, 47, 65, 77, 25, 49, 68, 81]
  , EC_CODEWORDS_TABLE = [7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88, 36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72, 130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120, 216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532, 180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644, 750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588, 870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260, 420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924, 1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590, 1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220, 720, 1316, 1950, 2310, 750, 1372, 2040, 2430];
errorCorrectionCode.getBlocksCount = function($, et) {
    switch (et) {
    case ECLevel$1.L:
        return EC_BLOCKS_TABLE[($ - 1) * 4 + 0];
    case ECLevel$1.M:
        return EC_BLOCKS_TABLE[($ - 1) * 4 + 1];
    case ECLevel$1.Q:
        return EC_BLOCKS_TABLE[($ - 1) * 4 + 2];
    case ECLevel$1.H:
        return EC_BLOCKS_TABLE[($ - 1) * 4 + 3];
    default:
        return
    }
}
;
errorCorrectionCode.getTotalCodewordsCount = function($, et) {
    switch (et) {
    case ECLevel$1.L:
        return EC_CODEWORDS_TABLE[($ - 1) * 4 + 0];
    case ECLevel$1.M:
        return EC_CODEWORDS_TABLE[($ - 1) * 4 + 1];
    case ECLevel$1.Q:
        return EC_CODEWORDS_TABLE[($ - 1) * 4 + 2];
    case ECLevel$1.H:
        return EC_CODEWORDS_TABLE[($ - 1) * 4 + 3];
    default:
        return
    }
}
;
var polynomial = {}
  , galoisField = {};
const EXP_TABLE = new Uint8Array(512)
  , LOG_TABLE = new Uint8Array(256);
(function() {
    let $ = 1;
    for (let et = 0; et < 255; et++)
        EXP_TABLE[et] = $,
        LOG_TABLE[$] = et,
        $ <<= 1,
        $ & 256 && ($ ^= 285);
    for (let et = 255; et < 512; et++)
        EXP_TABLE[et] = EXP_TABLE[et - 255]
}
)();
galoisField.log = function($) {
    if ($ < 1)
        throw new Error("log(" + $ + ")");
    return LOG_TABLE[$]
}
;
galoisField.exp = function($) {
    return EXP_TABLE[$]
}
;
galoisField.mul = function($, et) {
    return $ === 0 || et === 0 ? 0 : EXP_TABLE[LOG_TABLE[$] + LOG_TABLE[et]]
}
;
(function(_e) {
    const $ = galoisField;
    _e.mul = function(tt, nt) {
        const rt = new Uint8Array(tt.length + nt.length - 1);
        for (let it = 0; it < tt.length; it++)
            for (let ot = 0; ot < nt.length; ot++)
                rt[it + ot] ^= $.mul(tt[it], nt[ot]);
        return rt
    }
    ,
    _e.mod = function(tt, nt) {
        let rt = new Uint8Array(tt);
        for (; rt.length - nt.length >= 0; ) {
            const it = rt[0];
            for (let st = 0; st < nt.length; st++)
                rt[st] ^= $.mul(nt[st], it);
            let ot = 0;
            for (; ot < rt.length && rt[ot] === 0; )
                ot++;
            rt = rt.slice(ot)
        }
        return rt
    }
    ,
    _e.generateECPolynomial = function(tt) {
        let nt = new Uint8Array([1]);
        for (let rt = 0; rt < tt; rt++)
            nt = _e.mul(nt, new Uint8Array([1, $.exp(rt)]));
        return nt
    }
}
)(polynomial);
const Polynomial = polynomial;
function ReedSolomonEncoder$1(_e) {
    this.genPoly = void 0,
    this.degree = _e,
    this.degree && this.initialize(this.degree)
}
ReedSolomonEncoder$1.prototype.initialize = function($) {
    this.degree = $,
    this.genPoly = Polynomial.generateECPolynomial(this.degree)
}
;
ReedSolomonEncoder$1.prototype.encode = function($) {
    if (!this.genPoly)
        throw new Error("Encoder not initialized");
    const et = new Uint8Array($.length + this.degree);
    et.set($);
    const tt = Polynomial.mod(et, this.genPoly)
      , nt = this.degree - tt.length;
    if (nt > 0) {
        const rt = new Uint8Array(this.degree);
        return rt.set(tt, nt),
        rt
    }
    return tt
}
;
var reedSolomonEncoder = ReedSolomonEncoder$1
  , version = {}
  , mode = {}
  , versionCheck = {};
versionCheck.isValid = function($) {
    return !isNaN($) && $ >= 1 && $ <= 40
}
;
var regex$1 = {};
const numeric = "[0-9]+"
  , alphanumeric = "[A-Z $%*+\\-./:]+";
let kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
kanji = kanji.replace(/u/g, "\\u");
const byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + `)(?:.|[\r
]))+`;
regex$1.KANJI = new RegExp(kanji,"g");
regex$1.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+","g");
regex$1.BYTE = new RegExp(byte,"g");
regex$1.NUMERIC = new RegExp(numeric,"g");
regex$1.ALPHANUMERIC = new RegExp(alphanumeric,"g");
const TEST_KANJI = new RegExp("^" + kanji + "$")
  , TEST_NUMERIC = new RegExp("^" + numeric + "$")
  , TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
regex$1.testKanji = function($) {
    return TEST_KANJI.test($)
}
;
regex$1.testNumeric = function($) {
    return TEST_NUMERIC.test($)
}
;
regex$1.testAlphanumeric = function($) {
    return TEST_ALPHANUMERIC.test($)
}
;
(function(_e) {
    const $ = versionCheck
      , et = regex$1;
    _e.NUMERIC = {
        id: "Numeric",
        bit: 1,
        ccBits: [10, 12, 14]
    },
    _e.ALPHANUMERIC = {
        id: "Alphanumeric",
        bit: 2,
        ccBits: [9, 11, 13]
    },
    _e.BYTE = {
        id: "Byte",
        bit: 4,
        ccBits: [8, 16, 16]
    },
    _e.KANJI = {
        id: "Kanji",
        bit: 8,
        ccBits: [8, 10, 12]
    },
    _e.MIXED = {
        bit: -1
    },
    _e.getCharCountIndicator = function(rt, it) {
        if (!rt.ccBits)
            throw new Error("Invalid mode: " + rt);
        if (!$.isValid(it))
            throw new Error("Invalid version: " + it);
        return it >= 1 && it < 10 ? rt.ccBits[0] : it < 27 ? rt.ccBits[1] : rt.ccBits[2]
    }
    ,
    _e.getBestModeForData = function(rt) {
        return et.testNumeric(rt) ? _e.NUMERIC : et.testAlphanumeric(rt) ? _e.ALPHANUMERIC : et.testKanji(rt) ? _e.KANJI : _e.BYTE
    }
    ,
    _e.toString = function(rt) {
        if (rt && rt.id)
            return rt.id;
        throw new Error("Invalid mode")
    }
    ,
    _e.isValid = function(rt) {
        return rt && rt.bit && rt.ccBits
    }
    ;
    function tt(nt) {
        if (typeof nt != "string")
            throw new Error("Param is not a string");
        switch (nt.toLowerCase()) {
        case "numeric":
            return _e.NUMERIC;
        case "alphanumeric":
            return _e.ALPHANUMERIC;
        case "kanji":
            return _e.KANJI;
        case "byte":
            return _e.BYTE;
        default:
            throw new Error("Unknown mode: " + nt)
        }
    }
    _e.from = function(rt, it) {
        if (_e.isValid(rt))
            return rt;
        try {
            return tt(rt)
        } catch {
            return it
        }
    }
}
)(mode);
(function(_e) {
    const $ = utils$3
      , et = errorCorrectionCode
      , tt = errorCorrectionLevel
      , nt = mode
      , rt = versionCheck
      , it = 7973
      , ot = $.getBCHDigit(it);
    function st(pt, ht, mt) {
        for (let yt = 1; yt <= 40; yt++)
            if (ht <= _e.getCapacity(yt, mt, pt))
                return yt
    }
    function lt(pt, ht) {
        return nt.getCharCountIndicator(pt, ht) + 4
    }
    function ct(pt, ht) {
        let mt = 0;
        return pt.forEach(function(yt) {
            const Et = lt(yt.mode, ht);
            mt += Et + yt.getBitsLength()
        }),
        mt
    }
    function dt(pt, ht) {
        for (let mt = 1; mt <= 40; mt++)
            if (ct(pt, mt) <= _e.getCapacity(mt, ht, nt.MIXED))
                return mt
    }
    _e.from = function(ht, mt) {
        return rt.isValid(ht) ? parseInt(ht, 10) : mt
    }
    ,
    _e.getCapacity = function(ht, mt, yt) {
        if (!rt.isValid(ht))
            throw new Error("Invalid QR Code version");
        typeof yt > "u" && (yt = nt.BYTE);
        const Et = $.getSymbolTotalCodewords(ht)
          , _t = et.getTotalCodewordsCount(ht, mt)
          , wt = (Et - _t) * 8;
        if (yt === nt.MIXED)
            return wt;
        const St = wt - lt(yt, ht);
        switch (yt) {
        case nt.NUMERIC:
            return Math.floor(St / 10 * 3);
        case nt.ALPHANUMERIC:
            return Math.floor(St / 11 * 2);
        case nt.KANJI:
            return Math.floor(St / 13);
        case nt.BYTE:
        default:
            return Math.floor(St / 8)
        }
    }
    ,
    _e.getBestVersionForData = function(ht, mt) {
        let yt;
        const Et = tt.from(mt, tt.M);
        if (Array.isArray(ht)) {
            if (ht.length > 1)
                return dt(ht, Et);
            if (ht.length === 0)
                return 1;
            yt = ht[0]
        } else
            yt = ht;
        return st(yt.mode, yt.getLength(), Et)
    }
    ,
    _e.getEncodedBits = function(ht) {
        if (!rt.isValid(ht) || ht < 7)
            throw new Error("Invalid QR Code version");
        let mt = ht << 12;
        for (; $.getBCHDigit(mt) - ot >= 0; )
            mt ^= it << $.getBCHDigit(mt) - ot;
        return ht << 12 | mt
    }
}
)(version);
var formatInfo = {};
const Utils$3 = utils$3
  , G15 = 1335
  , G15_MASK = 21522
  , G15_BCH = Utils$3.getBCHDigit(G15);
formatInfo.getEncodedBits = function($, et) {
    const tt = $.bit << 3 | et;
    let nt = tt << 10;
    for (; Utils$3.getBCHDigit(nt) - G15_BCH >= 0; )
        nt ^= G15 << Utils$3.getBCHDigit(nt) - G15_BCH;
    return (tt << 10 | nt) ^ G15_MASK
}
;
var segments = {};
const Mode$4 = mode;
function NumericData(_e) {
    this.mode = Mode$4.NUMERIC,
    this.data = _e.toString()
}
NumericData.getBitsLength = function($) {
    return 10 * Math.floor($ / 3) + ($ % 3 ? $ % 3 * 3 + 1 : 0)
}
;
NumericData.prototype.getLength = function() {
    return this.data.length
}
;
NumericData.prototype.getBitsLength = function() {
    return NumericData.getBitsLength(this.data.length)
}
;
NumericData.prototype.write = function($) {
    let et, tt, nt;
    for (et = 0; et + 3 <= this.data.length; et += 3)
        tt = this.data.substr(et, 3),
        nt = parseInt(tt, 10),
        $.put(nt, 10);
    const rt = this.data.length - et;
    rt > 0 && (tt = this.data.substr(et),
    nt = parseInt(tt, 10),
    $.put(nt, rt * 3 + 1))
}
;
var numericData = NumericData;
const Mode$3 = mode
  , ALPHA_NUM_CHARS = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", " ", "$", "%", "*", "+", "-", ".", "/", ":"];
function AlphanumericData(_e) {
    this.mode = Mode$3.ALPHANUMERIC,
    this.data = _e
}
AlphanumericData.getBitsLength = function($) {
    return 11 * Math.floor($ / 2) + 6 * ($ % 2)
}
;
AlphanumericData.prototype.getLength = function() {
    return this.data.length
}
;
AlphanumericData.prototype.getBitsLength = function() {
    return AlphanumericData.getBitsLength(this.data.length)
}
;
AlphanumericData.prototype.write = function($) {
    let et;
    for (et = 0; et + 2 <= this.data.length; et += 2) {
        let tt = ALPHA_NUM_CHARS.indexOf(this.data[et]) * 45;
        tt += ALPHA_NUM_CHARS.indexOf(this.data[et + 1]),
        $.put(tt, 11)
    }
    this.data.length % 2 && $.put(ALPHA_NUM_CHARS.indexOf(this.data[et]), 6)
}
;
var alphanumericData = AlphanumericData;
const Mode$2 = mode;
function ByteData(_e) {
    this.mode = Mode$2.BYTE,
    typeof _e == "string" ? this.data = new TextEncoder().encode(_e) : this.data = new Uint8Array(_e)
}
ByteData.getBitsLength = function($) {
    return $ * 8
}
;
ByteData.prototype.getLength = function() {
    return this.data.length
}
;
ByteData.prototype.getBitsLength = function() {
    return ByteData.getBitsLength(this.data.length)
}
;
ByteData.prototype.write = function(_e) {
    for (let $ = 0, et = this.data.length; $ < et; $++)
        _e.put(this.data[$], 8)
}
;
var byteData = ByteData;
const Mode$1 = mode
  , Utils$2 = utils$3;
function KanjiData(_e) {
    this.mode = Mode$1.KANJI,
    this.data = _e
}
KanjiData.getBitsLength = function($) {
    return $ * 13
}
;
KanjiData.prototype.getLength = function() {
    return this.data.length
}
;
KanjiData.prototype.getBitsLength = function() {
    return KanjiData.getBitsLength(this.data.length)
}
;
KanjiData.prototype.write = function(_e) {
    let $;
    for ($ = 0; $ < this.data.length; $++) {
        let et = Utils$2.toSJIS(this.data[$]);
        if (et >= 33088 && et <= 40956)
            et -= 33088;
        else if (et >= 57408 && et <= 60351)
            et -= 49472;
        else
            throw new Error("Invalid SJIS character: " + this.data[$] + `
Make sure your charset is UTF-8`);
        et = (et >>> 8 & 255) * 192 + (et & 255),
        _e.put(et, 13)
    }
}
;
var kanjiData = KanjiData
  , dijkstra = {
    exports: {}
};
(function(_e) {
    var $ = {
        single_source_shortest_paths: function(et, tt, nt) {
            var rt = {}
              , it = {};
            it[tt] = 0;
            var ot = $.PriorityQueue.make();
            ot.push(tt, 0);
            for (var st, lt, ct, dt, pt, ht, mt, yt, Et; !ot.empty(); ) {
                st = ot.pop(),
                lt = st.value,
                dt = st.cost,
                pt = et[lt] || {};
                for (ct in pt)
                    pt.hasOwnProperty(ct) && (ht = pt[ct],
                    mt = dt + ht,
                    yt = it[ct],
                    Et = typeof it[ct] > "u",
                    (Et || yt > mt) && (it[ct] = mt,
                    ot.push(ct, mt),
                    rt[ct] = lt))
            }
            if (typeof nt < "u" && typeof it[nt] > "u") {
                var _t = ["Could not find a path from ", tt, " to ", nt, "."].join("");
                throw new Error(_t)
            }
            return rt
        },
        extract_shortest_path_from_predecessor_list: function(et, tt) {
            for (var nt = [], rt = tt; rt; )
                nt.push(rt),
                et[rt],
                rt = et[rt];
            return nt.reverse(),
            nt
        },
        find_path: function(et, tt, nt) {
            var rt = $.single_source_shortest_paths(et, tt, nt);
            return $.extract_shortest_path_from_predecessor_list(rt, nt)
        },
        PriorityQueue: {
            make: function(et) {
                var tt = $.PriorityQueue, nt = {}, rt;
                et = et || {};
                for (rt in tt)
                    tt.hasOwnProperty(rt) && (nt[rt] = tt[rt]);
                return nt.queue = [],
                nt.sorter = et.sorter || tt.default_sorter,
                nt
            },
            default_sorter: function(et, tt) {
                return et.cost - tt.cost
            },
            push: function(et, tt) {
                var nt = {
                    value: et,
                    cost: tt
                };
                this.queue.push(nt),
                this.queue.sort(this.sorter)
            },
            pop: function() {
                return this.queue.shift()
            },
            empty: function() {
                return this.queue.length === 0
            }
        }
    };
    _e.exports = $
}
)(dijkstra);
var dijkstraExports = dijkstra.exports;
(function(_e) {
    const $ = mode
      , et = numericData
      , tt = alphanumericData
      , nt = byteData
      , rt = kanjiData
      , it = regex$1
      , ot = utils$3
      , st = dijkstraExports;
    function lt(_t) {
        return unescape(encodeURIComponent(_t)).length
    }
    function ct(_t, wt, St) {
        const Ct = [];
        let Nt;
        for (; (Nt = _t.exec(St)) !== null; )
            Ct.push({
                data: Nt[0],
                index: Nt.index,
                mode: wt,
                length: Nt[0].length
            });
        return Ct
    }
    function dt(_t) {
        const wt = ct(it.NUMERIC, $.NUMERIC, _t)
          , St = ct(it.ALPHANUMERIC, $.ALPHANUMERIC, _t);
        let Ct, Nt;
        return ot.isKanjiModeEnabled() ? (Ct = ct(it.BYTE, $.BYTE, _t),
        Nt = ct(it.KANJI, $.KANJI, _t)) : (Ct = ct(it.BYTE_KANJI, $.BYTE, _t),
        Nt = []),
        wt.concat(St, Ct, Nt).sort(function(kt, Ut) {
            return kt.index - Ut.index
        }).map(function(kt) {
            return {
                data: kt.data,
                mode: kt.mode,
                length: kt.length
            }
        })
    }
    function pt(_t, wt) {
        switch (wt) {
        case $.NUMERIC:
            return et.getBitsLength(_t);
        case $.ALPHANUMERIC:
            return tt.getBitsLength(_t);
        case $.KANJI:
            return rt.getBitsLength(_t);
        case $.BYTE:
            return nt.getBitsLength(_t)
        }
    }
    function ht(_t) {
        return _t.reduce(function(wt, St) {
            const Ct = wt.length - 1 >= 0 ? wt[wt.length - 1] : null;
            return Ct && Ct.mode === St.mode ? (wt[wt.length - 1].data += St.data,
            wt) : (wt.push(St),
            wt)
        }, [])
    }
    function mt(_t) {
        const wt = [];
        for (let St = 0; St < _t.length; St++) {
            const Ct = _t[St];
            switch (Ct.mode) {
            case $.NUMERIC:
                wt.push([Ct, {
                    data: Ct.data,
                    mode: $.ALPHANUMERIC,
                    length: Ct.length
                }, {
                    data: Ct.data,
                    mode: $.BYTE,
                    length: Ct.length
                }]);
                break;
            case $.ALPHANUMERIC:
                wt.push([Ct, {
                    data: Ct.data,
                    mode: $.BYTE,
                    length: Ct.length
                }]);
                break;
            case $.KANJI:
                wt.push([Ct, {
                    data: Ct.data,
                    mode: $.BYTE,
                    length: lt(Ct.data)
                }]);
                break;
            case $.BYTE:
                wt.push([{
                    data: Ct.data,
                    mode: $.BYTE,
                    length: lt(Ct.data)
                }])
            }
        }
        return wt
    }
    function yt(_t, wt) {
        const St = {}
          , Ct = {
            start: {}
        };
        let Nt = ["start"];
        for (let Lt = 0; Lt < _t.length; Lt++) {
            const kt = _t[Lt]
              , Ut = [];
            for (let Jt = 0; Jt < kt.length; Jt++) {
                const Pt = kt[Jt]
                  , Xt = "" + Lt + Jt;
                Ut.push(Xt),
                St[Xt] = {
                    node: Pt,
                    lastCount: 0
                },
                Ct[Xt] = {};
                for (let rn = 0; rn < Nt.length; rn++) {
                    const zt = Nt[rn];
                    St[zt] && St[zt].node.mode === Pt.mode ? (Ct[zt][Xt] = pt(St[zt].lastCount + Pt.length, Pt.mode) - pt(St[zt].lastCount, Pt.mode),
                    St[zt].lastCount += Pt.length) : (St[zt] && (St[zt].lastCount = Pt.length),
                    Ct[zt][Xt] = pt(Pt.length, Pt.mode) + 4 + $.getCharCountIndicator(Pt.mode, wt))
                }
            }
            Nt = Ut
        }
        for (let Lt = 0; Lt < Nt.length; Lt++)
            Ct[Nt[Lt]].end = 0;
        return {
            map: Ct,
            table: St
        }
    }
    function Et(_t, wt) {
        let St;
        const Ct = $.getBestModeForData(_t);
        if (St = $.from(wt, Ct),
        St !== $.BYTE && St.bit < Ct.bit)
            throw new Error('"' + _t + '" cannot be encoded with mode ' + $.toString(St) + `.
 Suggested mode is: ` + $.toString(Ct));
        switch (St === $.KANJI && !ot.isKanjiModeEnabled() && (St = $.BYTE),
        St) {
        case $.NUMERIC:
            return new et(_t);
        case $.ALPHANUMERIC:
            return new tt(_t);
        case $.KANJI:
            return new rt(_t);
        case $.BYTE:
            return new nt(_t)
        }
    }
    _e.fromArray = function(wt) {
        return wt.reduce(function(St, Ct) {
            return typeof Ct == "string" ? St.push(Et(Ct, null)) : Ct.data && St.push(Et(Ct.data, Ct.mode)),
            St
        }, [])
    }
    ,
    _e.fromString = function(wt, St) {
        const Ct = dt(wt, ot.isKanjiModeEnabled())
          , Nt = mt(Ct)
          , Lt = yt(Nt, St)
          , kt = st.find_path(Lt.map, "start", "end")
          , Ut = [];
        for (let Jt = 1; Jt < kt.length - 1; Jt++)
            Ut.push(Lt.table[kt[Jt]].node);
        return _e.fromArray(ht(Ut))
    }
    ,
    _e.rawSplit = function(wt) {
        return _e.fromArray(dt(wt, ot.isKanjiModeEnabled()))
    }
}
)(segments);
const Utils$1 = utils$3
  , ECLevel = errorCorrectionLevel
  , BitBuffer = bitBuffer
  , BitMatrix = bitMatrix
  , AlignmentPattern = alignmentPattern
  , FinderPattern = finderPattern
  , MaskPattern = maskPattern
  , ECCode = errorCorrectionCode
  , ReedSolomonEncoder = reedSolomonEncoder
  , Version = version
  , FormatInfo = formatInfo
  , Mode = mode
  , Segments = segments;
function setupFinderPattern(_e, $) {
    const et = _e.size
      , tt = FinderPattern.getPositions($);
    for (let nt = 0; nt < tt.length; nt++) {
        const rt = tt[nt][0]
          , it = tt[nt][1];
        for (let ot = -1; ot <= 7; ot++)
            if (!(rt + ot <= -1 || et <= rt + ot))
                for (let st = -1; st <= 7; st++)
                    it + st <= -1 || et <= it + st || (ot >= 0 && ot <= 6 && (st === 0 || st === 6) || st >= 0 && st <= 6 && (ot === 0 || ot === 6) || ot >= 2 && ot <= 4 && st >= 2 && st <= 4 ? _e.set(rt + ot, it + st, !0, !0) : _e.set(rt + ot, it + st, !1, !0))
    }
}
function setupTimingPattern(_e) {
    const $ = _e.size;
    for (let et = 8; et < $ - 8; et++) {
        const tt = et % 2 === 0;
        _e.set(et, 6, tt, !0),
        _e.set(6, et, tt, !0)
    }
}
function setupAlignmentPattern(_e, $) {
    const et = AlignmentPattern.getPositions($);
    for (let tt = 0; tt < et.length; tt++) {
        const nt = et[tt][0]
          , rt = et[tt][1];
        for (let it = -2; it <= 2; it++)
            for (let ot = -2; ot <= 2; ot++)
                it === -2 || it === 2 || ot === -2 || ot === 2 || it === 0 && ot === 0 ? _e.set(nt + it, rt + ot, !0, !0) : _e.set(nt + it, rt + ot, !1, !0)
    }
}
function setupVersionInfo(_e, $) {
    const et = _e.size
      , tt = Version.getEncodedBits($);
    let nt, rt, it;
    for (let ot = 0; ot < 18; ot++)
        nt = Math.floor(ot / 3),
        rt = ot % 3 + et - 8 - 3,
        it = (tt >> ot & 1) === 1,
        _e.set(nt, rt, it, !0),
        _e.set(rt, nt, it, !0)
}
function setupFormatInfo(_e, $, et) {
    const tt = _e.size
      , nt = FormatInfo.getEncodedBits($, et);
    let rt, it;
    for (rt = 0; rt < 15; rt++)
        it = (nt >> rt & 1) === 1,
        rt < 6 ? _e.set(rt, 8, it, !0) : rt < 8 ? _e.set(rt + 1, 8, it, !0) : _e.set(tt - 15 + rt, 8, it, !0),
        rt < 8 ? _e.set(8, tt - rt - 1, it, !0) : rt < 9 ? _e.set(8, 15 - rt - 1 + 1, it, !0) : _e.set(8, 15 - rt - 1, it, !0);
    _e.set(tt - 8, 8, 1, !0)
}
function setupData(_e, $) {
    const et = _e.size;
    let tt = -1
      , nt = et - 1
      , rt = 7
      , it = 0;
    for (let ot = et - 1; ot > 0; ot -= 2)
        for (ot === 6 && ot--; ; ) {
            for (let st = 0; st < 2; st++)
                if (!_e.isReserved(nt, ot - st)) {
                    let lt = !1;
                    it < $.length && (lt = ($[it] >>> rt & 1) === 1),
                    _e.set(nt, ot - st, lt),
                    rt--,
                    rt === -1 && (it++,
                    rt = 7)
                }
            if (nt += tt,
            nt < 0 || et <= nt) {
                nt -= tt,
                tt = -tt;
                break
            }
        }
}
function createData(_e, $, et) {
    const tt = new BitBuffer;
    et.forEach(function(st) {
        tt.put(st.mode.bit, 4),
        tt.put(st.getLength(), Mode.getCharCountIndicator(st.mode, _e)),
        st.write(tt)
    });
    const nt = Utils$1.getSymbolTotalCodewords(_e)
      , rt = ECCode.getTotalCodewordsCount(_e, $)
      , it = (nt - rt) * 8;
    for (tt.getLengthInBits() + 4 <= it && tt.put(0, 4); tt.getLengthInBits() % 8 !== 0; )
        tt.putBit(0);
    const ot = (it - tt.getLengthInBits()) / 8;
    for (let st = 0; st < ot; st++)
        tt.put(st % 2 ? 17 : 236, 8);
    return createCodewords(tt, _e, $)
}
function createCodewords(_e, $, et) {
    const tt = Utils$1.getSymbolTotalCodewords($)
      , nt = ECCode.getTotalCodewordsCount($, et)
      , rt = tt - nt
      , it = ECCode.getBlocksCount($, et)
      , ot = tt % it
      , st = it - ot
      , lt = Math.floor(tt / it)
      , ct = Math.floor(rt / it)
      , dt = ct + 1
      , pt = lt - ct
      , ht = new ReedSolomonEncoder(pt);
    let mt = 0;
    const yt = new Array(it)
      , Et = new Array(it);
    let _t = 0;
    const wt = new Uint8Array(_e.buffer);
    for (let kt = 0; kt < it; kt++) {
        const Ut = kt < st ? ct : dt;
        yt[kt] = wt.slice(mt, mt + Ut),
        Et[kt] = ht.encode(yt[kt]),
        mt += Ut,
        _t = Math.max(_t, Ut)
    }
    const St = new Uint8Array(tt);
    let Ct = 0, Nt, Lt;
    for (Nt = 0; Nt < _t; Nt++)
        for (Lt = 0; Lt < it; Lt++)
            Nt < yt[Lt].length && (St[Ct++] = yt[Lt][Nt]);
    for (Nt = 0; Nt < pt; Nt++)
        for (Lt = 0; Lt < it; Lt++)
            St[Ct++] = Et[Lt][Nt];
    return St
}
function createSymbol(_e, $, et, tt) {
    let nt;
    if (Array.isArray(_e))
        nt = Segments.fromArray(_e);
    else if (typeof _e == "string") {
        let lt = $;
        if (!lt) {
            const ct = Segments.rawSplit(_e);
            lt = Version.getBestVersionForData(ct, et)
        }
        nt = Segments.fromString(_e, lt || 40)
    } else
        throw new Error("Invalid data");
    const rt = Version.getBestVersionForData(nt, et);
    if (!rt)
        throw new Error("The amount of data is too big to be stored in a QR Code");
    if (!$)
        $ = rt;
    else if ($ < rt)
        throw new Error(`
The chosen QR Code version cannot contain this amount of data.
Minimum version required to store current data is: ` + rt + `.
`);
    const it = createData($, et, nt)
      , ot = Utils$1.getSymbolSize($)
      , st = new BitMatrix(ot);
    return setupFinderPattern(st, $),
    setupTimingPattern(st),
    setupAlignmentPattern(st, $),
    setupFormatInfo(st, et, 0),
    $ >= 7 && setupVersionInfo(st, $),
    setupData(st, it),
    isNaN(tt) && (tt = MaskPattern.getBestMask(st, setupFormatInfo.bind(null, st, et))),
    MaskPattern.applyMask(tt, st),
    setupFormatInfo(st, et, tt),
    {
        modules: st,
        version: $,
        errorCorrectionLevel: et,
        maskPattern: tt,
        segments: nt
    }
}
qrcode.create = function($, et) {
    if (typeof $ > "u" || $ === "")
        throw new Error("No input text");
    let tt = ECLevel.M, nt, rt;
    return typeof et < "u" && (tt = ECLevel.from(et.errorCorrectionLevel, ECLevel.M),
    nt = Version.from(et.version),
    rt = MaskPattern.from(et.maskPattern),
    et.toSJISFunc && Utils$1.setToSJISFunction(et.toSJISFunc)),
    createSymbol($, nt, tt, rt)
}
;
var canvas = {}
  , utils$2 = {};
(function(_e) {
    function $(et) {
        if (typeof et == "number" && (et = et.toString()),
        typeof et != "string")
            throw new Error("Color should be defined as hex string");
        let tt = et.slice().replace("#", "").split("");
        if (tt.length < 3 || tt.length === 5 || tt.length > 8)
            throw new Error("Invalid hex color: " + et);
        (tt.length === 3 || tt.length === 4) && (tt = Array.prototype.concat.apply([], tt.map(function(rt) {
            return [rt, rt]
        }))),
        tt.length === 6 && tt.push("F", "F");
        const nt = parseInt(tt.join(""), 16);
        return {
            r: nt >> 24 & 255,
            g: nt >> 16 & 255,
            b: nt >> 8 & 255,
            a: nt & 255,
            hex: "#" + tt.slice(0, 6).join("")
        }
    }
    _e.getOptions = function(tt) {
        tt || (tt = {}),
        tt.color || (tt.color = {});
        const nt = typeof tt.margin > "u" || tt.margin === null || tt.margin < 0 ? 4 : tt.margin
          , rt = tt.width && tt.width >= 21 ? tt.width : void 0
          , it = tt.scale || 4;
        return {
            width: rt,
            scale: rt ? 4 : it,
            margin: nt,
            color: {
                dark: $(tt.color.dark || "#000000ff"),
                light: $(tt.color.light || "#ffffffff")
            },
            type: tt.type,
            rendererOpts: tt.rendererOpts || {}
        }
    }
    ,
    _e.getScale = function(tt, nt) {
        return nt.width && nt.width >= tt + nt.margin * 2 ? nt.width / (tt + nt.margin * 2) : nt.scale
    }
    ,
    _e.getImageWidth = function(tt, nt) {
        const rt = _e.getScale(tt, nt);
        return Math.floor((tt + nt.margin * 2) * rt)
    }
    ,
    _e.qrToImageData = function(tt, nt, rt) {
        const it = nt.modules.size
          , ot = nt.modules.data
          , st = _e.getScale(it, rt)
          , lt = Math.floor((it + rt.margin * 2) * st)
          , ct = rt.margin * st
          , dt = [rt.color.light, rt.color.dark];
        for (let pt = 0; pt < lt; pt++)
            for (let ht = 0; ht < lt; ht++) {
                let mt = (pt * lt + ht) * 4
                  , yt = rt.color.light;
                if (pt >= ct && ht >= ct && pt < lt - ct && ht < lt - ct) {
                    const Et = Math.floor((pt - ct) / st)
                      , _t = Math.floor((ht - ct) / st);
                    yt = dt[ot[Et * it + _t] ? 1 : 0]
                }
                tt[mt++] = yt.r,
                tt[mt++] = yt.g,
                tt[mt++] = yt.b,
                tt[mt] = yt.a
            }
    }
}
)(utils$2);
(function(_e) {
    const $ = utils$2;
    function et(nt, rt, it) {
        nt.clearRect(0, 0, rt.width, rt.height),
        rt.style || (rt.style = {}),
        rt.height = it,
        rt.width = it,
        rt.style.height = it + "px",
        rt.style.width = it + "px"
    }
    function tt() {
        try {
            return document.createElement("canvas")
        } catch {
            throw new Error("You need to specify a canvas element")
        }
    }
    _e.render = function(rt, it, ot) {
        let st = ot
          , lt = it;
        typeof st > "u" && (!it || !it.getContext) && (st = it,
        it = void 0),
        it || (lt = tt()),
        st = $.getOptions(st);
        const ct = $.getImageWidth(rt.modules.size, st)
          , dt = lt.getContext("2d")
          , pt = dt.createImageData(ct, ct);
        return $.qrToImageData(pt.data, rt, st),
        et(dt, lt, ct),
        dt.putImageData(pt, 0, 0),
        lt
    }
    ,
    _e.renderToDataURL = function(rt, it, ot) {
        let st = ot;
        typeof st > "u" && (!it || !it.getContext) && (st = it,
        it = void 0),
        st || (st = {});
        const lt = _e.render(rt, it, st)
          , ct = st.type || "image/png"
          , dt = st.rendererOpts || {};
        return lt.toDataURL(ct, dt.quality)
    }
}
)(canvas);
var svgTag = {};
const Utils = utils$2;
function getColorAttrib(_e, $) {
    const et = _e.a / 255
      , tt = $ + '="' + _e.hex + '"';
    return et < 1 ? tt + " " + $ + '-opacity="' + et.toFixed(2).slice(1) + '"' : tt
}
function svgCmd(_e, $, et) {
    let tt = _e + $;
    return typeof et < "u" && (tt += " " + et),
    tt
}
function qrToPath(_e, $, et) {
    let tt = ""
      , nt = 0
      , rt = !1
      , it = 0;
    for (let ot = 0; ot < _e.length; ot++) {
        const st = Math.floor(ot % $)
          , lt = Math.floor(ot / $);
        !st && !rt && (rt = !0),
        _e[ot] ? (it++,
        ot > 0 && st > 0 && _e[ot - 1] || (tt += rt ? svgCmd("M", st + et, .5 + lt + et) : svgCmd("m", nt, 0),
        nt = 0,
        rt = !1),
        st + 1 < $ && _e[ot + 1] || (tt += svgCmd("h", it),
        it = 0)) : nt++
    }
    return tt
}
svgTag.render = function($, et, tt) {
    const nt = Utils.getOptions(et)
      , rt = $.modules.size
      , it = $.modules.data
      , ot = rt + nt.margin * 2
      , st = nt.color.light.a ? "<path " + getColorAttrib(nt.color.light, "fill") + ' d="M0 0h' + ot + "v" + ot + 'H0z"/>' : ""
      , lt = "<path " + getColorAttrib(nt.color.dark, "stroke") + ' d="' + qrToPath(it, rt, nt.margin) + '"/>'
      , ct = 'viewBox="0 0 ' + ot + " " + ot + '"'
      , pt = '<svg xmlns="http://www.w3.org/2000/svg" ' + (nt.width ? 'width="' + nt.width + '" height="' + nt.width + '" ' : "") + ct + ' shape-rendering="crispEdges">' + st + lt + `</svg>
`;
    return typeof tt == "function" && tt(null, pt),
    pt
}
;
const canPromise = canPromise$1
  , QRCode = qrcode
  , CanvasRenderer = canvas
  , SvgRenderer = svgTag;
function renderCanvas(_e, $, et, tt, nt) {
    const rt = [].slice.call(arguments, 1)
      , it = rt.length
      , ot = typeof rt[it - 1] == "function";
    if (!ot && !canPromise())
        throw new Error("Callback required as last argument");
    if (ot) {
        if (it < 2)
            throw new Error("Too few arguments provided");
        it === 2 ? (nt = et,
        et = $,
        $ = tt = void 0) : it === 3 && ($.getContext && typeof nt > "u" ? (nt = tt,
        tt = void 0) : (nt = tt,
        tt = et,
        et = $,
        $ = void 0))
    } else {
        if (it < 1)
            throw new Error("Too few arguments provided");
        return it === 1 ? (et = $,
        $ = tt = void 0) : it === 2 && !$.getContext && (tt = et,
        et = $,
        $ = void 0),
        new Promise(function(st, lt) {
            try {
                const ct = QRCode.create(et, tt);
                st(_e(ct, $, tt))
            } catch (ct) {
                lt(ct)
            }
        }
        )
    }
    try {
        const st = QRCode.create(et, tt);
        nt(null, _e(st, $, tt))
    } catch (st) {
        nt(st)
    }
}
QRCode.create;
renderCanvas.bind(null, CanvasRenderer.render);
renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
renderCanvas.bind(null, function(_e, $, et) {
    return SvgRenderer.render(_e, et)
});
function __awaiter$2(_e, $, et, tt) {
    function nt(rt) {
        return rt instanceof et ? rt : new et(function(it) {
            it(rt)
        }
        )
    }
    return new (et || (et = Promise))(function(rt, it) {
        function ot(ct) {
            try {
                lt(tt.next(ct))
            } catch (dt) {
                it(dt)
            }
        }
        function st(ct) {
            try {
                lt(tt.throw(ct))
            } catch (dt) {
                it(dt)
            }
        }
        function lt(ct) {
            ct.done ? rt(ct.value) : nt(ct.value).then(ot, st)
        }
        lt((tt = tt.apply(_e, [])).next())
    }
    )
}
function toUint8Array(_e) {
    return new Uint8Array(window.atob(_e).split("").map($ => $.charCodeAt(0)))
}
function getIsSupported$1() {
    return typeof window < "u" && window.isSecureContext && typeof document < "u" && /android/i.test(navigator.userAgent)
}
const SolanaMobileWalletAdapterWalletName = "Mobile Wallet Adapter"
  , SIGNATURE_LENGTH_IN_BYTES$1 = 64;
function getPublicKeyFromAddress$1(_e) {
    const $ = toUint8Array(_e);
    return new PublicKey($)
}
function isVersionedTransaction(_e) {
    return "version"in _e
}
function clusterToChainId(_e) {
    switch (_e) {
    case "mainnet-beta":
        return "solana:mainnet";
    case "testnet":
        return "solana:testnet";
    case "devnet":
        return "solana:devnet"
    }
}
class SolanaMobileWalletAdapter extends BaseSignInMessageSignerWalletAdapter {
    constructor($) {
        var et;
        super(),
        this.supportedTransactionVersions = new Set(["legacy", 0]),
        this.name = SolanaMobileWalletAdapterWalletName,
        this.url = "https://solanamobile.com/wallets",
        this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==",
        this._connecting = !1,
        this._connectionGeneration = 0,
        this._readyState = getIsSupported$1() ? WalletReadyState.Loadable : WalletReadyState.Unsupported,
        this._authorizationResultCache = $.authorizationResultCache,
        this._addressSelector = $.addressSelector,
        this._appIdentity = $.appIdentity,
        this._chain = (et = $.chain) !== null && et !== void 0 ? et : clusterToChainId($.cluster),
        this._hostAuthority = $.remoteHostAuthority,
        this._onWalletNotFound = $.onWalletNotFound,
        this._readyState !== WalletReadyState.Unsupported && this._authorizationResultCache.get().then(tt => {
            tt && this.declareWalletAsInstalled()
        }
        )
    }
    get publicKey() {
        if (this._publicKey == null && this._selectedAddress != null)
            try {
                this._publicKey = getPublicKeyFromAddress$1(this._selectedAddress)
            } catch ($) {
                throw new WalletPublicKeyError($ instanceof Error && ($ == null ? void 0 : $.message) || "Unknown error",$)
            }
        return this._publicKey ? this._publicKey : null
    }
    get connected() {
        return !!this._authorizationResult
    }
    get connecting() {
        return this._connecting
    }
    get readyState() {
        return this._readyState
    }
    declareWalletAsInstalled() {
        this._readyState !== WalletReadyState.Installed && this.emit("readyStateChange", this._readyState = WalletReadyState.Installed)
    }
    runWithGuard($) {
        return __awaiter$2(this, void 0, void 0, function*() {
            try {
                return yield $()
            } catch (et) {
                throw this.emit("error", et),
                et
            }
        })
    }
    autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {
        return __awaiter$2(this, void 0, void 0, function*() {
            return yield this.autoConnect()
        })
    }
    autoConnect() {
        return __awaiter$2(this, void 0, void 0, function*() {
            if (!(this.connecting || this.connected))
                return yield this.runWithGuard( () => __awaiter$2(this, void 0, void 0, function*() {
                    if (this._readyState !== WalletReadyState.Installed && this._readyState !== WalletReadyState.Loadable)
                        throw new WalletNotReadyError;
                    this._connecting = !0;
                    try {
                        const $ = yield this._authorizationResultCache.get();
                        $ && this.handleAuthorizationResult($)
                    } catch ($) {
                        throw new WalletConnectionError($ instanceof Error && $.message || "Unknown error",$)
                    } finally {
                        this._connecting = !1
                    }
                }))
        })
    }
    connect() {
        return __awaiter$2(this, void 0, void 0, function*() {
            if (!(this.connecting || this.connected))
                return yield this.runWithGuard( () => __awaiter$2(this, void 0, void 0, function*() {
                    if (this._readyState !== WalletReadyState.Installed && this._readyState !== WalletReadyState.Loadable)
                        throw new WalletNotReadyError;
                    this._connecting = !0;
                    try {
                        yield this.performAuthorization()
                    } catch ($) {
                        throw new WalletConnectionError($ instanceof Error && $.message || "Unknown error",$)
                    } finally {
                        this._connecting = !1
                    }
                }))
        })
    }
    performAuthorization($) {
        return __awaiter$2(this, void 0, void 0, function*() {
            try {
                const et = yield this._authorizationResultCache.get();
                return et ? (this.handleAuthorizationResult(et),
                et) : yield this.transact(tt => __awaiter$2(this, void 0, void 0, function*() {
                    const nt = yield tt.authorize({
                        chain: this._chain,
                        identity: this._appIdentity,
                        sign_in_payload: $
                    });
                    return Promise.all([this._authorizationResultCache.set(nt), this.handleAuthorizationResult(nt)]),
                    nt
                }))
            } catch (et) {
                throw new WalletConnectionError(et instanceof Error && et.message || "Unknown error",et)
            }
        })
    }
    handleAuthorizationResult($) {
        var et;
        return __awaiter$2(this, void 0, void 0, function*() {
            const tt = this._authorizationResult == null || ((et = this._authorizationResult) === null || et === void 0 ? void 0 : et.accounts.length) !== $.accounts.length || this._authorizationResult.accounts.some( (nt, rt) => nt.address !== $.accounts[rt].address);
            if (this._authorizationResult = $,
            this.declareWalletAsInstalled(),
            tt) {
                const nt = yield this._addressSelector.select($.accounts.map( ({address: rt}) => rt));
                nt !== this._selectedAddress && (this._selectedAddress = nt,
                delete this._publicKey,
                this.emit("connect", this.publicKey))
            }
        })
    }
    performReauthorization($, et) {
        return __awaiter$2(this, void 0, void 0, function*() {
            try {
                const tt = yield $.authorize({
                    auth_token: et,
                    identity: this._appIdentity
                });
                Promise.all([this._authorizationResultCache.set(tt), this.handleAuthorizationResult(tt)])
            } catch (tt) {
                throw this.disconnect(),
                new WalletDisconnectedError(tt instanceof Error && (tt == null ? void 0 : tt.message) || "Unknown error",tt)
            }
        })
    }
    disconnect() {
        return __awaiter$2(this, void 0, void 0, function*() {
            this._authorizationResultCache.clear(),
            this._connecting = !1,
            this._connectionGeneration++,
            delete this._authorizationResult,
            delete this._publicKey,
            delete this._selectedAddress,
            this.emit("disconnect")
        })
    }
    transact($) {
        var et;
        return __awaiter$2(this, void 0, void 0, function*() {
            const tt = (et = this._authorizationResult) === null || et === void 0 ? void 0 : et.wallet_uri_base
              , nt = tt ? {
                baseUri: tt
            } : void 0
              , rt = this._hostAuthority ? {
                remoteHostAuthority: this._hostAuthority
            } : void 0
              , it = this._connectionGeneration;
            try {
                return yield transact($, Object.assign(Object.assign({}, nt), rt))
            } catch (ot) {
                throw this._connectionGeneration !== it && (yield new Promise( () => {}
                )),
                ot instanceof Error && ot.name === "SolanaMobileWalletAdapterError" && ot.code === "ERROR_WALLET_NOT_FOUND" && (yield this._onWalletNotFound(this)),
                ot
            }
        })
    }
    assertIsAuthorized() {
        if (!this._authorizationResult || !this._selectedAddress)
            throw new WalletNotConnectedError;
        return {
            authToken: this._authorizationResult.auth_token,
            selectedAddress: this._selectedAddress
        }
    }
    performSignTransactions($) {
        return __awaiter$2(this, void 0, void 0, function*() {
            const {authToken: et} = this.assertIsAuthorized();
            try {
                return yield this.transact(tt => __awaiter$2(this, void 0, void 0, function*() {
                    return yield this.performReauthorization(tt, et),
                    yield tt.signTransactions({
                        transactions: $
                    })
                }))
            } catch (tt) {
                throw new WalletSignTransactionError(tt == null ? void 0 : tt.message,tt)
            }
        })
    }
    sendTransaction($, et, tt) {
        return __awaiter$2(this, void 0, void 0, function*() {
            return yield this.runWithGuard( () => __awaiter$2(this, void 0, void 0, function*() {
                const {authToken: nt} = this.assertIsAuthorized()
                  , rt = tt == null ? void 0 : tt.minContextSlot;
                try {
                    return yield this.transact(it => __awaiter$2(this, void 0, void 0, function*() {
                        function ot() {
                            let dt;
                            switch (et.commitment) {
                            case "confirmed":
                            case "finalized":
                            case "processed":
                                dt = et.commitment;
                                break;
                            default:
                                dt = "finalized"
                            }
                            let pt;
                            switch (tt == null ? void 0 : tt.preflightCommitment) {
                            case "confirmed":
                            case "finalized":
                            case "processed":
                                pt = tt.preflightCommitment;
                                break;
                            case void 0:
                                pt = dt;
                                break;
                            default:
                                pt = "finalized"
                            }
                            return (pt === "finalized" ? 2 : pt === "confirmed" ? 1 : 0) < (dt === "finalized" ? 2 : dt === "confirmed" ? 1 : 0) ? pt : dt
                        }
                        const [st,lt,ct] = yield Promise.all([it.getCapabilities(), this.performReauthorization(it, nt), isVersionedTransaction($) ? null : __awaiter$2(this, void 0, void 0, function*() {
                            var dt;
                            if ($.feePayer || ($.feePayer = (dt = this.publicKey) !== null && dt !== void 0 ? dt : void 0),
                            $.recentBlockhash == null) {
                                const {blockhash: pt} = yield et.getLatestBlockhash({
                                    commitment: ot()
                                });
                                $.recentBlockhash = pt
                            }
                        })]);
                        if (st.supports_sign_and_send_transactions)
                            return (yield it.signAndSendTransactions({
                                minContextSlot: rt,
                                transactions: [$]
                            }))[0];
                        {
                            const [dt] = yield it.signTransactions({
                                transactions: [$]
                            });
                            if (isVersionedTransaction(dt))
                                return yield et.sendTransaction(dt);
                            {
                                const pt = dt.serialize();
                                return yield et.sendRawTransaction(pt, Object.assign(Object.assign({}, tt), {
                                    preflightCommitment: ot()
                                }))
                            }
                        }
                    }))
                } catch (it) {
                    throw new WalletSendTransactionError(it == null ? void 0 : it.message,it)
                }
            }))
        })
    }
    signTransaction($) {
        return __awaiter$2(this, void 0, void 0, function*() {
            return yield this.runWithGuard( () => __awaiter$2(this, void 0, void 0, function*() {
                const [et] = yield this.performSignTransactions([$]);
                return et
            }))
        })
    }
    signAllTransactions($) {
        return __awaiter$2(this, void 0, void 0, function*() {
            return yield this.runWithGuard( () => __awaiter$2(this, void 0, void 0, function*() {
                return yield this.performSignTransactions($)
            }))
        })
    }
    signMessage($) {
        return __awaiter$2(this, void 0, void 0, function*() {
            return yield this.runWithGuard( () => __awaiter$2(this, void 0, void 0, function*() {
                const {authToken: et, selectedAddress: tt} = this.assertIsAuthorized();
                try {
                    return yield this.transact(nt => __awaiter$2(this, void 0, void 0, function*() {
                        yield this.performReauthorization(nt, et);
                        const [rt] = yield nt.signMessages({
                            addresses: [tt],
                            payloads: [$]
                        });
                        return rt.slice(-SIGNATURE_LENGTH_IN_BYTES$1)
                    }))
                } catch (nt) {
                    throw new WalletSignMessageError(nt == null ? void 0 : nt.message,nt)
                }
            }))
        })
    }
    signIn($) {
        return __awaiter$2(this, void 0, void 0, function*() {
            return yield this.runWithGuard( () => __awaiter$2(this, void 0, void 0, function*() {
                var et, tt;
                if (this._readyState !== WalletReadyState.Installed && this._readyState !== WalletReadyState.Loadable)
                    throw new WalletNotReadyError;
                this._connecting = !0;
                try {
                    const nt = yield this.performAuthorization(Object.assign(Object.assign({}, $), {
                        domain: (et = $ == null ? void 0 : $.domain) !== null && et !== void 0 ? et : window.location.host
                    }));
                    if (!nt.sign_in_result)
                        throw new Error("Sign in failed, no sign in result returned by wallet");
                    const rt = nt.sign_in_result.address;
                    return {
                        account: Object.assign(Object.assign({}, (tt = nt.accounts.find(ot => ot.address == rt)) !== null && tt !== void 0 ? tt : {
                            address: rt
                        }), {
                            publicKey: toUint8Array(rt)
                        }),
                        signedMessage: toUint8Array(nt.sign_in_result.signed_message),
                        signature: toUint8Array(nt.sign_in_result.signature)
                    }
                } catch (nt) {
                    throw new WalletConnectionError(nt instanceof Error && nt.message || "Unknown error",nt)
                } finally {
                    this._connecting = !1
                }
            }))
        })
    }
}
function createDefaultAddressSelector() {
    return {
        select(_e) {
            return __awaiter$2(this, void 0, void 0, function*() {
                return _e[0]
            })
        }
    }
}
const CACHE_KEY = "SolanaMobileWalletAdapterDefaultAuthorizationCache";
function createDefaultAuthorizationResultCache() {
    let _e;
    try {
        _e = window.localStorage
    } catch {}
    return {
        clear() {
            return __awaiter$2(this, void 0, void 0, function*() {
                if (_e)
                    try {
                        _e.removeItem(CACHE_KEY)
                    } catch {}
            })
        },
        get() {
            return __awaiter$2(this, void 0, void 0, function*() {
                if (_e)
                    try {
                        return JSON.parse(_e.getItem(CACHE_KEY)) || void 0
                    } catch {}
            })
        },
        set($) {
            return __awaiter$2(this, void 0, void 0, function*() {
                if (_e)
                    try {
                        _e.setItem(CACHE_KEY, JSON.stringify($))
                    } catch {}
            })
        }
    }
}
function defaultWalletNotFoundHandler(_e) {
    return __awaiter$2(this, void 0, void 0, function*() {
        typeof window < "u" && window.location.assign(_e.url)
    })
}
function createDefaultWalletNotFoundHandler() {
    return defaultWalletNotFoundHandler
}
var __classPrivateFieldGet$3 = function(_e, $, et, tt) {
    if (et === "a" && !tt)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof $ == "function" ? _e !== $ || !tt : !$.has(_e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return et === "m" ? tt : et === "a" ? tt.call(_e) : tt ? tt.value : $.get(_e)
}, __classPrivateFieldSet$3 = function(_e, $, et, tt, nt) {
    if (tt === "m")
        throw new TypeError("Private method is not writable");
    if (tt === "a" && !nt)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof $ == "function" ? _e !== $ || !nt : !$.has(_e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return tt === "a" ? nt.call(_e, et) : nt ? nt.value = et : $.set(_e, et),
    et
}, _RegisterWalletEvent_detail;
function registerWallet(_e) {
    const $ = ({register: et}) => et(_e);
    try {
        window.dispatchEvent(new RegisterWalletEvent($))
    } catch {}
    try {
        window.addEventListener("wallet-standard:app-ready", ({detail: et}) => $(et))
    } catch {}
}
class RegisterWalletEvent extends Event {
    get detail() {
        return __classPrivateFieldGet$3(this, _RegisterWalletEvent_detail, "f")
    }
    get type() {
        return "wallet-standard:register-wallet"
    }
    constructor($) {
        super("wallet-standard:register-wallet", {
            bubbles: !1,
            cancelable: !1,
            composed: !1
        }),
        _RegisterWalletEvent_detail.set(this, void 0),
        __classPrivateFieldSet$3(this, _RegisterWalletEvent_detail, $, "f")
    }
    preventDefault() {
        throw new Error("preventDefault cannot be called")
    }
    stopImmediatePropagation() {
        throw new Error("stopImmediatePropagation cannot be called")
    }
    stopPropagation() {
        throw new Error("stopPropagation cannot be called")
    }
}
_RegisterWalletEvent_detail = new WeakMap;
function arraysEqual(_e, $) {
    if (_e === $)
        return !0;
    const et = _e.length;
    if (et !== $.length)
        return !1;
    for (let tt = 0; tt < et; tt++)
        if (_e[tt] !== $[tt])
            return !1;
    return !0
}
function base(_e) {
    if (_e.length >= 255)
        throw new TypeError("Alphabet too long");
    const $ = new Uint8Array(256);
    for (let lt = 0; lt < $.length; lt++)
        $[lt] = 255;
    for (let lt = 0; lt < _e.length; lt++) {
        const ct = _e.charAt(lt)
          , dt = ct.charCodeAt(0);
        if ($[dt] !== 255)
            throw new TypeError(ct + " is ambiguous");
        $[dt] = lt
    }
    const et = _e.length
      , tt = _e.charAt(0)
      , nt = Math.log(et) / Math.log(256)
      , rt = Math.log(256) / Math.log(et);
    function it(lt) {
        if (lt instanceof Uint8Array || (ArrayBuffer.isView(lt) ? lt = new Uint8Array(lt.buffer,lt.byteOffset,lt.byteLength) : Array.isArray(lt) && (lt = Uint8Array.from(lt))),
        !(lt instanceof Uint8Array))
            throw new TypeError("Expected Uint8Array");
        if (lt.length === 0)
            return "";
        let ct = 0
          , dt = 0
          , pt = 0;
        const ht = lt.length;
        for (; pt !== ht && lt[pt] === 0; )
            pt++,
            ct++;
        const mt = (ht - pt) * rt + 1 >>> 0
          , yt = new Uint8Array(mt);
        for (; pt !== ht; ) {
            let wt = lt[pt]
              , St = 0;
            for (let Ct = mt - 1; (wt !== 0 || St < dt) && Ct !== -1; Ct--,
            St++)
                wt += 256 * yt[Ct] >>> 0,
                yt[Ct] = wt % et >>> 0,
                wt = wt / et >>> 0;
            if (wt !== 0)
                throw new Error("Non-zero carry");
            dt = St,
            pt++
        }
        let Et = mt - dt;
        for (; Et !== mt && yt[Et] === 0; )
            Et++;
        let _t = tt.repeat(ct);
        for (; Et < mt; ++Et)
            _t += _e.charAt(yt[Et]);
        return _t
    }
    function ot(lt) {
        if (typeof lt != "string")
            throw new TypeError("Expected String");
        if (lt.length === 0)
            return new Uint8Array;
        let ct = 0
          , dt = 0
          , pt = 0;
        for (; lt[ct] === tt; )
            dt++,
            ct++;
        const ht = (lt.length - ct) * nt + 1 >>> 0
          , mt = new Uint8Array(ht);
        for (; lt[ct]; ) {
            let wt = $[lt.charCodeAt(ct)];
            if (wt === 255)
                return;
            let St = 0;
            for (let Ct = ht - 1; (wt !== 0 || St < pt) && Ct !== -1; Ct--,
            St++)
                wt += et * mt[Ct] >>> 0,
                mt[Ct] = wt % 256 >>> 0,
                wt = wt / 256 >>> 0;
            if (wt !== 0)
                throw new Error("Non-zero carry");
            pt = St,
            ct++
        }
        let yt = ht - pt;
        for (; yt !== ht && mt[yt] === 0; )
            yt++;
        const Et = new Uint8Array(dt + (ht - yt));
        let _t = dt;
        for (; yt !== ht; )
            Et[_t++] = mt[yt++];
        return Et
    }
    function st(lt) {
        const ct = ot(lt);
        if (ct)
            return ct;
        throw new Error("Non-base" + et + " character")
    }
    return {
        encode: it,
        decodeUnsafe: ot,
        decode: st
    }
}
var ALPHABET$1 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
const bs58 = base(ALPHABET$1);
var __classPrivateFieldGet$2 = function(_e, $, et, tt) {
    if (et === "a" && !tt)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof $ == "function" ? _e !== $ || !tt : !$.has(_e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return et === "m" ? tt : et === "a" ? tt.call(_e) : tt ? tt.value : $.get(_e)
}, __classPrivateFieldSet$2 = function(_e, $, et, tt, nt) {
    if (tt === "m")
        throw new TypeError("Private method is not writable");
    if (tt === "a" && !nt)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof $ == "function" ? _e !== $ || !nt : !$.has(_e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return tt === "a" ? nt.call(_e, et) : nt ? nt.value = et : $.set(_e, et),
    et
}, _StandardWalletAdapter_instances, _StandardWalletAdapter_account, _StandardWalletAdapter_publicKey, _StandardWalletAdapter_connecting, _StandardWalletAdapter_disconnecting, _StandardWalletAdapter_off, _StandardWalletAdapter_supportedTransactionVersions, _StandardWalletAdapter_wallet, _StandardWalletAdapter_readyState, _StandardWalletAdapter_connect, _StandardWalletAdapter_connected, _StandardWalletAdapter_disconnected, _StandardWalletAdapter_reset, _StandardWalletAdapter_changed, _StandardWalletAdapter_signTransaction, _StandardWalletAdapter_signAllTransactions, _StandardWalletAdapter_signMessage, _StandardWalletAdapter_signIn;
class StandardWalletAdapter extends BaseWalletAdapter {
    get name() {
        return __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").name
    }
    get url() {
        return "https://github.com/solana-labs/wallet-standard"
    }
    get icon() {
        return __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").icon
    }
    get readyState() {
        return __classPrivateFieldGet$2(this, _StandardWalletAdapter_readyState, "f")
    }
    get publicKey() {
        return __classPrivateFieldGet$2(this, _StandardWalletAdapter_publicKey, "f")
    }
    get connecting() {
        return __classPrivateFieldGet$2(this, _StandardWalletAdapter_connecting, "f")
    }
    get supportedTransactionVersions() {
        return __classPrivateFieldGet$2(this, _StandardWalletAdapter_supportedTransactionVersions, "f")
    }
    get wallet() {
        return __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f")
    }
    get standard() {
        return !0
    }
    constructor({wallet: $}) {
        super(),
        _StandardWalletAdapter_instances.add(this),
        _StandardWalletAdapter_account.set(this, void 0),
        _StandardWalletAdapter_publicKey.set(this, void 0),
        _StandardWalletAdapter_connecting.set(this, void 0),
        _StandardWalletAdapter_disconnecting.set(this, void 0),
        _StandardWalletAdapter_off.set(this, void 0),
        _StandardWalletAdapter_supportedTransactionVersions.set(this, void 0),
        _StandardWalletAdapter_wallet.set(this, void 0),
        _StandardWalletAdapter_readyState.set(this, typeof window > "u" || typeof document > "u" ? WalletReadyState.Unsupported : WalletReadyState.Installed),
        _StandardWalletAdapter_changed.set(this, et => {
            if ("accounts"in et) {
                const tt = __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").accounts[0];
                __classPrivateFieldGet$2(this, _StandardWalletAdapter_account, "f") && !__classPrivateFieldGet$2(this, _StandardWalletAdapter_disconnecting, "f") && tt !== __classPrivateFieldGet$2(this, _StandardWalletAdapter_account, "f") && (tt ? __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connected).call(this, tt) : (this.emit("error", new WalletDisconnectedError),
                __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_disconnected).call(this)))
            }
            "features"in et && __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_reset).call(this)
        }
        ),
        __classPrivateFieldSet$2(this, _StandardWalletAdapter_wallet, $, "f"),
        __classPrivateFieldSet$2(this, _StandardWalletAdapter_account, null, "f"),
        __classPrivateFieldSet$2(this, _StandardWalletAdapter_publicKey, null, "f"),
        __classPrivateFieldSet$2(this, _StandardWalletAdapter_connecting, !1, "f"),
        __classPrivateFieldSet$2(this, _StandardWalletAdapter_disconnecting, !1, "f"),
        __classPrivateFieldSet$2(this, _StandardWalletAdapter_off, __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features[StandardEvents].on("change", __classPrivateFieldGet$2(this, _StandardWalletAdapter_changed, "f")), "f"),
        __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_reset).call(this)
    }
    destroy() {
        __classPrivateFieldSet$2(this, _StandardWalletAdapter_account, null, "f"),
        __classPrivateFieldSet$2(this, _StandardWalletAdapter_publicKey, null, "f"),
        __classPrivateFieldSet$2(this, _StandardWalletAdapter_connecting, !1, "f"),
        __classPrivateFieldSet$2(this, _StandardWalletAdapter_disconnecting, !1, "f");
        const $ = __classPrivateFieldGet$2(this, _StandardWalletAdapter_off, "f");
        $ && (__classPrivateFieldSet$2(this, _StandardWalletAdapter_off, null, "f"),
        $())
    }
    async autoConnect() {
        return __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connect).call(this, {
            silent: !0
        })
    }
    async connect() {
        return __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connect).call(this)
    }
    async disconnect() {
        if (StandardDisconnect in __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features)
            try {
                __classPrivateFieldSet$2(this, _StandardWalletAdapter_disconnecting, !0, "f"),
                await __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features[StandardDisconnect].disconnect()
            } catch ($) {
                this.emit("error", new WalletDisconnectionError($ == null ? void 0 : $.message,$))
            } finally {
                __classPrivateFieldSet$2(this, _StandardWalletAdapter_disconnecting, !1, "f")
            }
        __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_disconnected).call(this)
    }
    async sendTransaction($, et, tt={}) {
        try {
            const nt = __classPrivateFieldGet$2(this, _StandardWalletAdapter_account, "f");
            if (!nt)
                throw new WalletNotConnectedError;
            let rt;
            if (SolanaSignAndSendTransaction in __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features)
                if (nt.features.includes(SolanaSignAndSendTransaction))
                    rt = SolanaSignAndSendTransaction;
                else if (SolanaSignTransaction in __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features && nt.features.includes(SolanaSignTransaction))
                    rt = SolanaSignTransaction;
                else
                    throw new WalletAccountError;
            else if (SolanaSignTransaction in __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features) {
                if (!nt.features.includes(SolanaSignTransaction))
                    throw new WalletAccountError;
                rt = SolanaSignTransaction
            } else
                throw new WalletConfigError;
            const it = getChainForEndpoint(et.rpcEndpoint);
            if (!nt.chains.includes(it))
                throw new WalletSendTransactionError;
            try {
                const {signers: ot, ...st} = tt;
                let lt;
                if (isVersionedTransaction$1($) ? (ot != null && ot.length && $.sign(ot),
                lt = $.serialize()) : ($ = await this.prepareTransaction($, et, st),
                ot != null && ot.length && $.partialSign(...ot),
                lt = new Uint8Array($.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))),
                rt === SolanaSignAndSendTransaction) {
                    const [ct] = await __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignAndSendTransaction].signAndSendTransaction({
                        account: nt,
                        chain: it,
                        transaction: lt,
                        options: {
                            preflightCommitment: getCommitment(st.preflightCommitment || et.commitment),
                            skipPreflight: st.skipPreflight,
                            maxRetries: st.maxRetries,
                            minContextSlot: st.minContextSlot
                        }
                    });
                    return bs58.encode(ct.signature)
                } else {
                    const [ct] = await __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignTransaction].signTransaction({
                        account: nt,
                        chain: it,
                        transaction: lt,
                        options: {
                            preflightCommitment: getCommitment(st.preflightCommitment || et.commitment),
                            minContextSlot: st.minContextSlot
                        }
                    });
                    return await et.sendRawTransaction(ct.signedTransaction, {
                        ...st,
                        preflightCommitment: getCommitment(st.preflightCommitment || et.commitment)
                    })
                }
            } catch (ot) {
                throw ot instanceof WalletError ? ot : new WalletSendTransactionError(ot == null ? void 0 : ot.message,ot)
            }
        } catch (nt) {
            throw this.emit("error", nt),
            nt
        }
    }
}
_StandardWalletAdapter_account = new WeakMap,
_StandardWalletAdapter_publicKey = new WeakMap,
_StandardWalletAdapter_connecting = new WeakMap,
_StandardWalletAdapter_disconnecting = new WeakMap,
_StandardWalletAdapter_off = new WeakMap,
_StandardWalletAdapter_supportedTransactionVersions = new WeakMap,
_StandardWalletAdapter_wallet = new WeakMap,
_StandardWalletAdapter_readyState = new WeakMap,
_StandardWalletAdapter_changed = new WeakMap,
_StandardWalletAdapter_instances = new WeakSet,
_StandardWalletAdapter_connect = async function($) {
    try {
        if (this.connected || this.connecting)
            return;
        if (__classPrivateFieldGet$2(this, _StandardWalletAdapter_readyState, "f") !== WalletReadyState.Installed)
            throw new WalletNotReadyError;
        if (__classPrivateFieldSet$2(this, _StandardWalletAdapter_connecting, !0, "f"),
        !__classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").accounts.length)
            try {
                await __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features[StandardConnect].connect($)
            } catch (tt) {
                throw new WalletConnectionError(tt == null ? void 0 : tt.message,tt)
            }
        const et = __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").accounts[0];
        if (!et)
            throw new WalletAccountError;
        __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connected).call(this, et)
    } catch (et) {
        throw this.emit("error", et),
        et
    } finally {
        __classPrivateFieldSet$2(this, _StandardWalletAdapter_connecting, !1, "f")
    }
}
,
_StandardWalletAdapter_connected = function($) {
    let et;
    try {
        et = new PublicKey($.address)
    } catch (tt) {
        throw new WalletPublicKeyError(tt == null ? void 0 : tt.message,tt)
    }
    __classPrivateFieldSet$2(this, _StandardWalletAdapter_account, $, "f"),
    __classPrivateFieldSet$2(this, _StandardWalletAdapter_publicKey, et, "f"),
    __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_reset).call(this),
    this.emit("connect", et)
}
,
_StandardWalletAdapter_disconnected = function() {
    __classPrivateFieldSet$2(this, _StandardWalletAdapter_account, null, "f"),
    __classPrivateFieldSet$2(this, _StandardWalletAdapter_publicKey, null, "f"),
    __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_reset).call(this),
    this.emit("disconnect")
}
,
_StandardWalletAdapter_reset = function() {
    var et, tt;
    const $ = SolanaSignAndSendTransaction in __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features ? __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignAndSendTransaction].supportedTransactionVersions : __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignTransaction].supportedTransactionVersions;
    __classPrivateFieldSet$2(this, _StandardWalletAdapter_supportedTransactionVersions, arraysEqual($, ["legacy"]) ? null : new Set($), "f"),
    SolanaSignTransaction in __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features && ((et = __classPrivateFieldGet$2(this, _StandardWalletAdapter_account, "f")) != null && et.features.includes(SolanaSignTransaction)) ? (this.signTransaction = __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_signTransaction),
    this.signAllTransactions = __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_signAllTransactions)) : (delete this.signTransaction,
    delete this.signAllTransactions),
    SolanaSignMessage in __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features && ((tt = __classPrivateFieldGet$2(this, _StandardWalletAdapter_account, "f")) != null && tt.features.includes(SolanaSignMessage)) ? this.signMessage = __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_signMessage) : delete this.signMessage,
    SolanaSignIn in __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features ? this.signIn = __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_signIn) : delete this.signIn
}
,
_StandardWalletAdapter_signTransaction = async function($) {
    try {
        const et = __classPrivateFieldGet$2(this, _StandardWalletAdapter_account, "f");
        if (!et)
            throw new WalletNotConnectedError;
        if (!(SolanaSignTransaction in __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features))
            throw new WalletConfigError;
        if (!et.features.includes(SolanaSignTransaction))
            throw new WalletAccountError;
        try {
            const nt = (await __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignTransaction].signTransaction({
                account: et,
                transaction: isVersionedTransaction$1($) ? $.serialize() : new Uint8Array($.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))
            }))[0].signedTransaction;
            return isVersionedTransaction$1($) ? VersionedTransaction.deserialize(nt) : Transaction.from(nt)
        } catch (tt) {
            throw tt instanceof WalletError ? tt : new WalletSignTransactionError(tt == null ? void 0 : tt.message,tt)
        }
    } catch (et) {
        throw this.emit("error", et),
        et
    }
}
,
_StandardWalletAdapter_signAllTransactions = async function($) {
    try {
        const et = __classPrivateFieldGet$2(this, _StandardWalletAdapter_account, "f");
        if (!et)
            throw new WalletNotConnectedError;
        if (!(SolanaSignTransaction in __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features))
            throw new WalletConfigError;
        if (!et.features.includes(SolanaSignTransaction))
            throw new WalletAccountError;
        try {
            const tt = await __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignTransaction].signTransaction(...$.map(nt => ({
                account: et,
                transaction: isVersionedTransaction$1(nt) ? nt.serialize() : new Uint8Array(nt.serialize({
                    requireAllSignatures: !1,
                    verifySignatures: !1
                }))
            })));
            return $.map( (nt, rt) => {
                const it = tt[rt].signedTransaction;
                return isVersionedTransaction$1(nt) ? VersionedTransaction.deserialize(it) : Transaction.from(it)
            }
            )
        } catch (tt) {
            throw new WalletSignTransactionError(tt == null ? void 0 : tt.message,tt)
        }
    } catch (et) {
        throw this.emit("error", et),
        et
    }
}
,
_StandardWalletAdapter_signMessage = async function($) {
    try {
        const et = __classPrivateFieldGet$2(this, _StandardWalletAdapter_account, "f");
        if (!et)
            throw new WalletNotConnectedError;
        if (!(SolanaSignMessage in __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features))
            throw new WalletConfigError;
        if (!et.features.includes(SolanaSignMessage))
            throw new WalletAccountError;
        try {
            return (await __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignMessage].signMessage({
                account: et,
                message: $
            }))[0].signature
        } catch (tt) {
            throw new WalletSignMessageError(tt == null ? void 0 : tt.message,tt)
        }
    } catch (et) {
        throw this.emit("error", et),
        et
    }
}
,
_StandardWalletAdapter_signIn = async function($={}) {
    try {
        if (!(SolanaSignIn in __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features))
            throw new WalletConfigError;
        let et;
        try {
            [et] = await __classPrivateFieldGet$2(this, _StandardWalletAdapter_wallet, "f").features[SolanaSignIn].signIn($)
        } catch (tt) {
            throw new WalletSignInError(tt == null ? void 0 : tt.message,tt)
        }
        if (!et)
            throw new WalletSignInError;
        return __classPrivateFieldGet$2(this, _StandardWalletAdapter_instances, "m", _StandardWalletAdapter_connected).call(this, et.account),
        et
    } catch (et) {
        throw this.emit("error", et),
        et
    }
}
;
const isWalletAdapterCompatibleWallet = isWalletAdapterCompatibleStandardWallet;
var __classPrivateFieldGet$1 = function(_e, $, et, tt) {
    if (et === "a" && !tt)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof $ == "function" ? _e !== $ || !tt : !$.has(_e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return et === "m" ? tt : et === "a" ? tt.call(_e) : tt ? tt.value : $.get(_e)
}, __classPrivateFieldSet$1 = function(_e, $, et, tt, nt) {
    if (tt === "m")
        throw new TypeError("Private method is not writable");
    if (tt === "a" && !nt)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof $ == "function" ? _e !== $ || !nt : !$.has(_e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return tt === "a" ? nt.call(_e, et) : nt ? nt.value = et : $.set(_e, et),
    et
}, _AppReadyEvent_detail;
let wallets;
const registeredWalletsSet = new Set;
function addRegisteredWallet(_e) {
    cachedWalletsArray = void 0,
    registeredWalletsSet.add(_e)
}
function removeRegisteredWallet(_e) {
    cachedWalletsArray = void 0,
    registeredWalletsSet.delete(_e)
}
const listeners = {};
function getWallets() {
    if (wallets || (wallets = Object.freeze({
        register: register$1,
        get: get$3,
        on: on$1
    }),
    typeof window > "u"))
        return wallets;
    const _e = Object.freeze({
        register: register$1
    });
    try {
        window.addEventListener("wallet-standard:register-wallet", ({detail: $}) => $(_e))
    } catch {}
    try {
        window.dispatchEvent(new AppReadyEvent(_e))
    } catch {}
    return wallets
}
function register$1(..._e) {
    var $;
    return _e = _e.filter(et => !registeredWalletsSet.has(et)),
    _e.length ? (_e.forEach(et => addRegisteredWallet(et)),
    ($ = listeners.register) == null || $.forEach(et => guard( () => et(..._e))),
    function() {
        var tt;
        _e.forEach(nt => removeRegisteredWallet(nt)),
        (tt = listeners.unregister) == null || tt.forEach(nt => guard( () => nt(..._e)))
    }
    ) : () => {}
}
let cachedWalletsArray;
function get$3() {
    return cachedWalletsArray || (cachedWalletsArray = [...registeredWalletsSet]),
    cachedWalletsArray
}
function on$1(_e, $) {
    var et;
    return (et = listeners[_e]) != null && et.push($) || (listeners[_e] = [$]),
    function() {
        var nt;
        listeners[_e] = (nt = listeners[_e]) == null ? void 0 : nt.filter(rt => $ !== rt)
    }
}
function guard(_e) {
    try {
        _e()
    } catch {}
}
class AppReadyEvent extends Event {
    get detail() {
        return __classPrivateFieldGet$1(this, _AppReadyEvent_detail, "f")
    }
    get type() {
        return "wallet-standard:app-ready"
    }
    constructor($) {
        super("wallet-standard:app-ready", {
            bubbles: !1,
            cancelable: !1,
            composed: !1
        }),
        _AppReadyEvent_detail.set(this, void 0),
        __classPrivateFieldSet$1(this, _AppReadyEvent_detail, $, "f")
    }
    preventDefault() {
        throw new Error("preventDefault cannot be called")
    }
    stopImmediatePropagation() {
        throw new Error("stopImmediatePropagation cannot be called")
    }
    stopPropagation() {
        throw new Error("stopPropagation cannot be called")
    }
}
_AppReadyEvent_detail = new WeakMap;
function DEPRECATED_getWallets() {
    if (wallets || (wallets = getWallets(),
    typeof window > "u"))
        return wallets;
    const _e = window.navigator.wallets || [];
    if (!Array.isArray(_e))
        return wallets;
    const {register: $} = wallets
      , et = (...tt) => tt.forEach(nt => guard( () => nt({
        register: $
    })));
    try {
        Object.defineProperty(window.navigator, "wallets", {
            value: Object.freeze({
                push: et
            })
        })
    } catch {
        return wallets
    }
    return et(..._e),
    wallets
}
function useStandardWalletAdapters(_e) {
    const $ = useConstant( () => new Set)
      , {get: et, on: tt} = useConstant( () => DEPRECATED_getWallets())
      , [nt,rt] = reactExports.useState( () => wrapWalletsWithAdapters(et()));
    reactExports.useEffect( () => {
        const ot = [tt("register", (...st) => rt(lt => [...lt, ...wrapWalletsWithAdapters(st)])), tt("unregister", (...st) => rt(lt => lt.filter(ct => st.some(dt => dt === ct.wallet))))];
        return () => ot.forEach(st => st())
    }
    , [tt]);
    const it = usePrevious(nt);
    return reactExports.useEffect( () => {
        if (!it)
            return;
        const ot = new Set(nt);
        new Set(it.filter(lt => !ot.has(lt))).forEach(lt => lt.destroy())
    }
    , [it, nt]),
    reactExports.useEffect( () => () => nt.forEach(ot => ot.destroy()), []),
    reactExports.useMemo( () => [...nt, ..._e.filter( ({name: ot}) => nt.some(st => st.name === ot) ? ($.has(ot) || $.add(ot),
    !1) : !0)], [nt, _e, $])
}
function useConstant(_e) {
    const $ = reactExports.useRef(void 0);
    return $.current === void 0 && ($.current = {
        value: _e()
    }),
    $.current.value
}
function usePrevious(_e) {
    const $ = reactExports.useRef(void 0);
    return reactExports.useEffect( () => {
        $.current = _e
    }
    ),
    $.current
}
function wrapWalletsWithAdapters(_e) {
    return _e.filter(isWalletAdapterCompatibleWallet).map($ => new StandardWalletAdapter({
        wallet: $
    }))
}
var Environment;
(function(_e) {
    _e[_e.DESKTOP_WEB = 0] = "DESKTOP_WEB",
    _e[_e.MOBILE_WEB = 1] = "MOBILE_WEB"
}
)(Environment || (Environment = {}));
function isWebView(_e) {
    return /(WebView|Version\/.+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+)|; wv\).+(Chrome)\/(\d+)\.(\d+)\.(\d+)\.(\d+))/i.test(_e)
}
function getEnvironment({adapters: _e, userAgentString: $}) {
    return _e.some(et => et.name !== SolanaMobileWalletAdapterWalletName && et.readyState === WalletReadyState.Installed) ? Environment.DESKTOP_WEB : $ && /android/i.test($) && !isWebView($) ? Environment.MOBILE_WEB : Environment.DESKTOP_WEB
}
function getInferredClusterFromEndpoint(_e) {
    return _e ? /devnet/i.test(_e) ? "devnet" : /testnet/i.test(_e) ? "testnet" : "mainnet-beta" : "mainnet-beta"
}
function WalletProviderBase({children: _e, wallets: $, adapter: et, isUnloadingRef: tt, onAutoConnectRequest: nt, onConnectError: rt, onError: it, onSelectWallet: ot}) {
    const st = reactExports.useRef(!1)
      , [lt,ct] = reactExports.useState(!1)
      , dt = reactExports.useRef(!1)
      , [pt,ht] = reactExports.useState(!1)
      , [mt,yt] = reactExports.useState( () => (et == null ? void 0 : et.publicKey) ?? null)
      , [Et,_t] = reactExports.useState( () => (et == null ? void 0 : et.connected) ?? !1)
      , wt = reactExports.useRef(it);
    reactExports.useEffect( () => (wt.current = it,
    () => {
        wt.current = void 0
    }
    ), [it]);
    const St = reactExports.useRef( ($t, Dt) => (tt.current || (wt.current ? wt.current($t, Dt) : $t instanceof WalletNotReadyError && typeof window < "u" && Dt && window.open(Dt.url, "_blank")),
    $t))
      , [Ct,Nt] = reactExports.useState( () => $.map($t => ({
        adapter: $t,
        readyState: $t.readyState
    })).filter( ({readyState: $t}) => $t !== WalletReadyState.Unsupported));
    reactExports.useEffect( () => {
        Nt(Dt => $.map( (jt, Ft) => {
            const Ht = Dt[Ft];
            return Ht && Ht.adapter === jt && Ht.readyState === jt.readyState ? Ht : {
                adapter: jt,
                readyState: jt.readyState
            }
        }
        ).filter( ({readyState: jt}) => jt !== WalletReadyState.Unsupported));
        function $t(Dt) {
            Nt(jt => {
                const Ft = jt.findIndex( ({adapter: qt}) => qt === this);
                if (Ft === -1)
                    return jt;
                const {adapter: Ht} = jt[Ft];
                return [...jt.slice(0, Ft), {
                    adapter: Ht,
                    readyState: Dt
                }, ...jt.slice(Ft + 1)].filter( ({readyState: qt}) => qt !== WalletReadyState.Unsupported)
            }
            )
        }
        return $.forEach(Dt => Dt.on("readyStateChange", $t, Dt)),
        () => {
            $.forEach(Dt => Dt.off("readyStateChange", $t, Dt))
        }
    }
    , [et, $]);
    const Lt = reactExports.useMemo( () => Ct.find($t => $t.adapter === et) ?? null, [et, Ct]);
    reactExports.useEffect( () => {
        if (!et)
            return;
        const $t = Ft => {
            yt(Ft),
            st.current = !1,
            ct(!1),
            _t(!0),
            dt.current = !1,
            ht(!1)
        }
          , Dt = () => {
            tt.current || (yt(null),
            st.current = !1,
            ct(!1),
            _t(!1),
            dt.current = !1,
            ht(!1))
        }
          , jt = Ft => {
            St.current(Ft, et)
        }
        ;
        return et.on("connect", $t),
        et.on("disconnect", Dt),
        et.on("error", jt),
        () => {
            et.off("connect", $t),
            et.off("disconnect", Dt),
            et.off("error", jt),
            Dt()
        }
    }
    , [et, tt]);
    const kt = reactExports.useRef(!1);
    reactExports.useEffect( () => () => {
        kt.current = !1
    }
    , [et]),
    reactExports.useEffect( () => {
        kt.current || st.current || Et || !nt || !((Lt == null ? void 0 : Lt.readyState) === WalletReadyState.Installed || (Lt == null ? void 0 : Lt.readyState) === WalletReadyState.Loadable) || (st.current = !0,
        ct(!0),
        kt.current = !0,
        async function() {
            try {
                await nt()
            } catch {
                rt()
            } finally {
                ct(!1),
                st.current = !1
            }
        }())
    }
    , [Et, nt, rt, Lt]);
    const Ut = reactExports.useCallback(async ($t, Dt, jt) => {
        if (!et)
            throw St.current(new WalletNotSelectedError);
        if (!Et)
            throw St.current(new WalletNotConnectedError, et);
        return await et.sendTransaction($t, Dt, jt)
    }
    , [et, Et])
      , Jt = reactExports.useMemo( () => et && "signTransaction"in et ? async $t => {
        if (!Et)
            throw St.current(new WalletNotConnectedError, et);
        return await et.signTransaction($t)
    }
    : void 0, [et, Et])
      , Pt = reactExports.useMemo( () => et && "signAllTransactions"in et ? async $t => {
        if (!Et)
            throw St.current(new WalletNotConnectedError, et);
        return await et.signAllTransactions($t)
    }
    : void 0, [et, Et])
      , Xt = reactExports.useMemo( () => et && "signMessage"in et ? async $t => {
        if (!Et)
            throw St.current(new WalletNotConnectedError, et);
        return await et.signMessage($t)
    }
    : void 0, [et, Et])
      , rn = reactExports.useMemo( () => et && "signIn"in et ? async $t => await et.signIn($t) : void 0, [et])
      , zt = reactExports.useCallback(async () => {
        if (st.current || dt.current || Lt != null && Lt.adapter.connected)
            return;
        if (!Lt)
            throw St.current(new WalletNotSelectedError);
        const {adapter: $t, readyState: Dt} = Lt;
        if (!(Dt === WalletReadyState.Installed || Dt === WalletReadyState.Loadable))
            throw St.current(new WalletNotReadyError, $t);
        st.current = !0,
        ct(!0);
        try {
            await $t.connect()
        } catch (jt) {
            throw rt(),
            jt
        } finally {
            ct(!1),
            st.current = !1
        }
    }
    , [rt, Lt])
      , xt = reactExports.useCallback(async () => {
        if (!dt.current && et) {
            dt.current = !0,
            ht(!0);
            try {
                await et.disconnect()
            } finally {
                ht(!1),
                dt.current = !1
            }
        }
    }
    , [et]);
    return React.createElement(WalletContext.Provider, {
        value: {
            autoConnect: !!nt,
            wallets: Ct,
            wallet: Lt,
            publicKey: mt,
            connected: Et,
            connecting: lt,
            disconnecting: pt,
            select: ot,
            connect: zt,
            disconnect: xt,
            sendTransaction: Ut,
            signTransaction: Jt,
            signAllTransactions: Pt,
            signMessage: Xt,
            signIn: rn
        }
    }, _e)
}
let _userAgent;
function getUserAgent() {
    var _e;
    return _userAgent === void 0 && (_userAgent = ((_e = globalThis.navigator) == null ? void 0 : _e.userAgent) ?? null),
    _userAgent
}
function getIsMobile(_e) {
    const $ = getUserAgent();
    return getEnvironment({
        adapters: _e,
        userAgentString: $
    }) === Environment.MOBILE_WEB
}
function getUriForAppIdentity() {
    const _e = globalThis.location;
    if (_e)
        return `${_e.protocol}//${_e.host}`
}
function WalletProvider({children: _e, wallets: $, autoConnect: et, localStorageKey: tt="walletName", onError: nt}) {
    const {connection: rt} = useConnection()
      , it = useStandardWalletAdapters($)
      , ot = reactExports.useMemo( () => {
        if (!getIsMobile(it))
            return null;
        const wt = it.find(St => St.name === SolanaMobileWalletAdapterWalletName);
        return wt || new SolanaMobileWalletAdapter({
            addressSelector: createDefaultAddressSelector(),
            appIdentity: {
                uri: getUriForAppIdentity()
            },
            authorizationResultCache: createDefaultAuthorizationResultCache(),
            cluster: getInferredClusterFromEndpoint(rt == null ? void 0 : rt.rpcEndpoint),
            onWalletNotFound: createDefaultWalletNotFoundHandler()
        })
    }
    , [it, rt == null ? void 0 : rt.rpcEndpoint])
      , st = reactExports.useMemo( () => ot == null || it.indexOf(ot) !== -1 ? it : [ot, ...it], [it, ot])
      , [lt,ct] = useLocalStorage(tt, getIsMobile(it) ? SolanaMobileWalletAdapterWalletName : null)
      , dt = reactExports.useMemo( () => st.find(wt => wt.name === lt) ?? null, [st, lt])
      , pt = reactExports.useCallback(wt => {
        lt !== wt && (dt && dt.name !== SolanaMobileWalletAdapterWalletName && dt.disconnect(),
        ct(wt))
    }
    , [dt, ct, lt]);
    reactExports.useEffect( () => {
        if (!dt)
            return;
        function wt() {
            yt.current || lt === SolanaMobileWalletAdapterWalletName && getIsMobile(it) || ct(null)
        }
        return dt.on("disconnect", wt),
        () => {
            dt.off("disconnect", wt)
        }
    }
    , [dt, it, ct, lt]);
    const ht = reactExports.useRef(!1)
      , mt = reactExports.useMemo( () => {
        if (!(!et || !dt))
            return async () => {
                (et === !0 || await et(dt)) && (ht.current ? await dt.connect() : await dt.autoConnect())
            }
    }
    , [et, dt])
      , yt = reactExports.useRef(!1);
    reactExports.useEffect( () => {
        if (lt === SolanaMobileWalletAdapterWalletName && getIsMobile(it)) {
            yt.current = !1;
            return
        }
        function wt() {
            yt.current = !0
        }
        return window.addEventListener("beforeunload", wt),
        () => {
            window.removeEventListener("beforeunload", wt)
        }
    }
    , [it, lt]);
    const Et = reactExports.useCallback( () => {
        dt && dt.name !== SolanaMobileWalletAdapterWalletName && pt(null)
    }
    , [dt, pt])
      , _t = reactExports.useCallback(wt => {
        ht.current = !0,
        pt(wt)
    }
    , [pt]);
    return React.createElement(WalletProviderBase, {
        wallets: st,
        adapter: dt,
        isUnloadingRef: yt,
        onAutoConnectRequest: mt,
        onConnectError: Et,
        onError: nt,
        onSelectWallet: _t
    }, _e)
}
const scriptRel = "modulepreload"
  , assetsURL = function(_e) {
    return "/" + _e
}
  , seen = {}
  , __vitePreload = function($, et, tt) {
    let nt = Promise.resolve();
    if (et && et.length > 0) {
        document.getElementsByTagName("link");
        const it = document.querySelector("meta[property=csp-nonce]")
          , ot = (it == null ? void 0 : it.nonce) || (it == null ? void 0 : it.getAttribute("nonce"));
        nt = Promise.allSettled(et.map(st => {
            if (st = assetsURL(st),
            st in seen)
                return;
            seen[st] = !0;
            const lt = st.endsWith(".css")
              , ct = lt ? '[rel="stylesheet"]' : "";
            if (document.querySelector(`link[href="${st}"]${ct}`))
                return;
            const dt = document.createElement("link");
            if (dt.rel = lt ? "stylesheet" : scriptRel,
            lt || (dt.as = "script"),
            dt.crossOrigin = "",
            dt.href = st,
            ot && dt.setAttribute("nonce", ot),
            document.head.appendChild(dt),
            lt)
                return new Promise( (pt, ht) => {
                    dt.addEventListener("load", pt),
                    dt.addEventListener("error", () => ht(new Error(`Unable to preload CSS for ${st}`)))
                }
                )
        }
        ))
    }
    function rt(it) {
        const ot = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (ot.payload = it,
        window.dispatchEvent(ot),
        !ot.defaultPrevented)
            throw it
    }
    return nt.then(it => {
        for (const ot of it || [])
            ot.status === "rejected" && rt(ot.reason);
        return $().catch(rt)
    }
    )
}
  , PhantomWalletName = "Phantom";
class PhantomWalletAdapter extends BaseMessageSignerWalletAdapter {
    constructor($={}) {
        super(),
        this.name = PhantomWalletName,
        this.url = "https://phantom.app",
        this.icon = "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiB2aWV3Qm94PSIwIDAgMTA4IDEwOCIgZmlsbD0ibm9uZSI+CjxyZWN0IHdpZHRoPSIxMDgiIGhlaWdodD0iMTA4IiByeD0iMjYiIGZpbGw9IiNBQjlGRjIiLz4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik00Ni41MjY3IDY5LjkyMjlDNDIuMDA1NCA3Ni44NTA5IDM0LjQyOTIgODUuNjE4MiAyNC4zNDggODUuNjE4MkMxOS41ODI0IDg1LjYxODIgMTUgODMuNjU2MyAxNSA3NS4xMzQyQzE1IDUzLjQzMDUgNDQuNjMyNiAxOS44MzI3IDcyLjEyNjggMTkuODMyN0M4Ny43NjggMTkuODMyNyA5NCAzMC42ODQ2IDk0IDQzLjAwNzlDOTQgNTguODI1OCA4My43MzU1IDc2LjkxMjIgNzMuNTMyMSA3Ni45MTIyQzcwLjI5MzkgNzYuOTEyMiA2OC43MDUzIDc1LjEzNDIgNjguNzA1MyA3Mi4zMTRDNjguNzA1MyA3MS41NzgzIDY4LjgyNzUgNzAuNzgxMiA2OS4wNzE5IDY5LjkyMjlDNjUuNTg5MyA3NS44Njk5IDU4Ljg2ODUgODEuMzg3OCA1Mi41NzU0IDgxLjM4NzhDNDcuOTkzIDgxLjM4NzggNDUuNjcxMyA3OC41MDYzIDQ1LjY3MTMgNzQuNDU5OEM0NS42NzEzIDcyLjk4ODQgNDUuOTc2OCA3MS40NTU2IDQ2LjUyNjcgNjkuOTIyOVpNODMuNjc2MSA0Mi41Nzk0QzgzLjY3NjEgNDYuMTcwNCA4MS41NTc1IDQ3Ljk2NTggNzkuMTg3NSA0Ny45NjU4Qzc2Ljc4MTYgNDcuOTY1OCA3NC42OTg5IDQ2LjE3MDQgNzQuNjk4OSA0Mi41Nzk0Qzc0LjY5ODkgMzguOTg4NSA3Ni43ODE2IDM3LjE5MzEgNzkuMTg3NSAzNy4xOTMxQzgxLjU1NzUgMzcuMTkzMSA4My42NzYxIDM4Ljk4ODUgODMuNjc2MSA0Mi41Nzk0Wk03MC4yMTAzIDQyLjU3OTVDNzAuMjEwMyA0Ni4xNzA0IDY4LjA5MTYgNDcuOTY1OCA2NS43MjE2IDQ3Ljk2NThDNjMuMzE1NyA0Ny45NjU4IDYxLjIzMyA0Ni4xNzA0IDYxLjIzMyA0Mi41Nzk1QzYxLjIzMyAzOC45ODg1IDYzLjMxNTcgMzcuMTkzMSA2NS43MjE2IDM3LjE5MzFDNjguMDkxNiAzNy4xOTMxIDcwLjIxMDMgMzguOTg4NSA3MC4yMTAzIDQyLjU3OTVaIiBmaWxsPSIjRkZGREY4Ii8+Cjwvc3ZnPg==",
        this.supportedTransactionVersions = new Set(["legacy", 0]),
        this._readyState = typeof window > "u" || typeof document > "u" ? WalletReadyState.Unsupported : WalletReadyState.NotDetected,
        this._disconnected = () => {
            const et = this._wallet;
            et && (et.off("disconnect", this._disconnected),
            et.off("accountChanged", this._accountChanged),
            this._wallet = null,
            this._publicKey = null,
            this.emit("error", new WalletDisconnectedError),
            this.emit("disconnect"))
        }
        ,
        this._accountChanged = et => {
            const tt = this._publicKey;
            if (tt) {
                try {
                    et = new PublicKey(et.toBytes())
                } catch (nt) {
                    this.emit("error", new WalletPublicKeyError(nt == null ? void 0 : nt.message,nt));
                    return
                }
                tt.equals(et) || (this._publicKey = et,
                this.emit("connect", et))
            }
        }
        ,
        this._connecting = !1,
        this._wallet = null,
        this._publicKey = null,
        this._readyState !== WalletReadyState.Unsupported && (isIosAndRedirectable() ? (this._readyState = WalletReadyState.Loadable,
        this.emit("readyStateChange", this._readyState)) : scopePollingDetectionStrategy( () => {
            var et, tt, nt;
            return (tt = (et = window.phantom) == null ? void 0 : et.solana) != null && tt.isPhantom || (nt = window.solana) != null && nt.isPhantom ? (this._readyState = WalletReadyState.Installed,
            this.emit("readyStateChange", this._readyState),
            !0) : !1
        }
        ))
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get readyState() {
        return this._readyState
    }
    async autoConnect() {
        this.readyState === WalletReadyState.Installed && await this.connect()
    }
    async connect() {
        var $;
        try {
            if (this.connected || this.connecting)
                return;
            if (this.readyState === WalletReadyState.Loadable) {
                const nt = encodeURIComponent(window.location.href)
                  , rt = encodeURIComponent(window.location.origin);
                window.location.href = `https://phantom.app/ul/browse/${nt}?ref=${rt}`;
                return
            }
            if (this.readyState !== WalletReadyState.Installed)
                throw new WalletNotReadyError;
            this._connecting = !0;
            const et = (($ = window.phantom) == null ? void 0 : $.solana) || window.solana;
            if (!et.isConnected)
                try {
                    await et.connect()
                } catch (nt) {
                    throw new WalletConnectionError(nt == null ? void 0 : nt.message,nt)
                }
            if (!et.publicKey)
                throw new WalletAccountError;
            let tt;
            try {
                tt = new PublicKey(et.publicKey.toBytes())
            } catch (nt) {
                throw new WalletPublicKeyError(nt == null ? void 0 : nt.message,nt)
            }
            et.on("disconnect", this._disconnected),
            et.on("accountChanged", this._accountChanged),
            this._wallet = et,
            this._publicKey = tt,
            this.emit("connect", tt)
        } catch (et) {
            throw this.emit("error", et),
            et
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const $ = this._wallet;
        if ($) {
            $.off("disconnect", this._disconnected),
            $.off("accountChanged", this._accountChanged),
            this._wallet = null,
            this._publicKey = null;
            try {
                await $.disconnect()
            } catch (et) {
                this.emit("error", new WalletDisconnectionError(et == null ? void 0 : et.message,et))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction($, et, tt={}) {
        try {
            const nt = this._wallet;
            if (!nt)
                throw new WalletNotConnectedError;
            try {
                const {signers: rt, ...it} = tt;
                isVersionedTransaction$1($) ? rt != null && rt.length && $.sign(rt) : ($ = await this.prepareTransaction($, et, it),
                rt != null && rt.length && $.partialSign(...rt)),
                it.preflightCommitment = it.preflightCommitment || et.commitment;
                const {signature: ot} = await nt.signAndSendTransaction($, it);
                return ot
            } catch (rt) {
                throw rt instanceof WalletError ? rt : new WalletSendTransactionError(rt == null ? void 0 : rt.message,rt)
            }
        } catch (nt) {
            throw this.emit("error", nt),
            nt
        }
    }
    async signTransaction($) {
        try {
            const et = this._wallet;
            if (!et)
                throw new WalletNotConnectedError;
            try {
                return await et.signTransaction($) || $
            } catch (tt) {
                throw new WalletSignTransactionError(tt == null ? void 0 : tt.message,tt)
            }
        } catch (et) {
            throw this.emit("error", et),
            et
        }
    }
    async signAllTransactions($) {
        try {
            const et = this._wallet;
            if (!et)
                throw new WalletNotConnectedError;
            try {
                return await et.signAllTransactions($) || $
            } catch (tt) {
                throw new WalletSignTransactionError(tt == null ? void 0 : tt.message,tt)
            }
        } catch (et) {
            throw this.emit("error", et),
            et
        }
    }
    async signMessage($) {
        try {
            const et = this._wallet;
            if (!et)
                throw new WalletNotConnectedError;
            try {
                const {signature: tt} = await et.signMessage($);
                return tt
            } catch (tt) {
                throw new WalletSignMessageError(tt == null ? void 0 : tt.message,tt)
            }
        } catch (et) {
            throw this.emit("error", et),
            et
        }
    }
}
const icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjMxIiB2aWV3Qm94PSIwIDAgMzEgMzEiIHdpZHRoPSIzMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgeDE9IjIwLjI1IiB4Mj0iMjYuNTcxIiB5MT0iMjcuMTczIiB5Mj0iMTkuODU4Ij48c3RvcCBvZmZzZXQ9Ii4wOCIgc3RvcC1jb2xvcj0iIzk5NDVmZiIvPjxzdG9wIG9mZnNldD0iLjMiIHN0b3AtY29sb3I9IiM4NzUyZjMiLz48c3RvcCBvZmZzZXQ9Ii41IiBzdG9wLWNvbG9yPSIjNTQ5N2Q1Ii8+PHN0b3Agb2Zmc2V0PSIuNiIgc3RvcC1jb2xvcj0iIzQzYjRjYSIvPjxzdG9wIG9mZnNldD0iLjcyIiBzdG9wLWNvbG9yPSIjMjhlMGI5Ii8+PHN0b3Agb2Zmc2V0PSIuOTciIHN0b3AtY29sb3I9IiMxOWZiOWIiLz48L2xpbmVhckdyYWRpZW50PjxnIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iLjA5NCI+PHBhdGggZD0ibTI2LjEwOSAzLjY0My05LjM2OSA2Ljk1OSAxLjczMy00LjEwNSA3LjYzNy0yLjg1M3oiIGZpbGw9IiNlMjc2MWIiIHN0cm9rZT0iI2UyNzYxYiIvPjxnIGZpbGw9IiNlNDc2MWIiIHN0cm9rZT0iI2U0NzYxYiI+PHBhdGggZD0ibTQuNDgxIDMuNjQzIDkuMjk0IDcuMDI0LTEuNjQ4LTQuMTcxem0xOC4yNTggMTYuMTMtMi40OTUgMy44MjMgNS4zMzkgMS40NjkgMS41MzUtNS4yMDctNC4zNzgtLjA4NXptLTE5LjI0Ny4wODUgMS41MjUgNS4yMDcgNS4zMzktMS40NjktMi40OTUtMy44MjN6Ii8+PHBhdGggZD0ibTEwLjA1NSAxMy4zMTMtMS40ODggMi4yNTEgNS4zMDEuMjM1LS4xODgtNS42OTd6bTEwLjQ4IDAtMy42NzItMy4yNzctLjEyMiA1Ljc2MyA1LjI5Mi0uMjM1LTEuNDk3LTIuMjUxem0tMTAuMTc4IDEwLjI4MyAzLjE4My0xLjU1NC0yLjc0OS0yLjE0Ny0uNDMzIDMuNzAxem02LjY5NS0xLjU1NCAzLjE5MiAxLjU1NC0uNDQzLTMuNzAxeiIvPjwvZz48cGF0aCBkPSJtMjAuMjQ0IDIzLjU5Ni0zLjE5Mi0xLjU1NC4yNTQgMi4wODEtLjAyOC44NzZ6bS05Ljg4NyAwIDIuOTY2IDEuNDAzLS4wMTktLjg3Ni4yMzUtMi4wODEtMy4xODMgMS41NTR6IiBmaWxsPSIjZDdjMWIzIiBzdHJva2U9IiNkN2MxYjMiLz48cGF0aCBkPSJtMTMuMzY5IDE4LjUyMS0yLjY1NS0uNzgxIDEuODc0LS44NTd6bTMuODUxIDAgLjc4MS0xLjYzOCAxLjg4My44NTctMi42NjUuNzgxeiIgZmlsbD0iIzIzMzQ0NyIgc3Ryb2tlPSIjMjMzNDQ3Ii8+PHBhdGggZD0ibTEwLjM1NyAyMy41OTYuNDUyLTMuODIzLTIuOTQ3LjA4NXptOS40MzUtMy44MjMuNDUyIDMuODIzIDIuNDk1LTMuNzM4em0yLjI0MS00LjIwOS01LjI5Mi4yMzUuNDkgMi43MjEuNzgyLTEuNjM4IDEuODgzLjg1N3ptLTExLjMxOCAyLjE3NSAxLjg4My0uODU3Ljc3MiAxLjYzOC40OTktMi43MjEtNS4zMDEtLjIzNXoiIGZpbGw9IiNjZDYxMTYiIHN0cm9rZT0iI2NkNjExNiIvPjxwYXRoIGQ9Im04LjU2NyAxNS41NjQgMi4yMjIgNC4zMzEtLjA3NS0yLjE1NnptMTEuMzI4IDIuMTc1LS4wOTQgMi4xNTYgMi4yMzItNC4zMzEtMi4xMzcgMi4xNzV6bS02LjAyNi0xLjk0LS40OTkgMi43MjEuNjIxIDMuMjExLjE0MS00LjIyOC0uMjY0LTEuNzA0em0yLjg3MiAwLS4yNTQgMS42OTUuMTEzIDQuMjM3LjYzMS0zLjIxMXoiIGZpbGw9IiNlNDc1MWYiIHN0cm9rZT0iI2U0NzUxZiIvPjxwYXRoIGQ9Im0xNy4yMyAxOC41Mi0uNjMxIDMuMjExLjQ1Mi4zMTEgMi43NS0yLjE0Ny4wOTQtMi4xNTZ6bS02LjUxNi0uNzgxLjA3NSAyLjE1NiAyLjc1IDIuMTQ3LjQ1Mi0uMzExLS42MjItMy4yMTF6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48cGF0aCBkPSJtMTcuMjc3IDI0Ljk5OS4wMjgtLjg3Ni0uMjM1LS4yMDdoLTMuNTVsLS4yMTcuMjA3LjAxOS44NzYtMi45NjYtMS40MDMgMS4wMzYuODQ4IDIuMSAxLjQ1OWgzLjYwNmwyLjEwOS0xLjQ1OSAxLjAzNi0uODQ4eiIgZmlsbD0iI2MwYWQ5ZSIgc3Ryb2tlPSIjYzBhZDllIi8+PHBhdGggZD0ibTE3LjA1MSAyMi4wNDItLjQ1Mi0uMzExaC0yLjYwOGwtLjQ1Mi4zMTEtLjIzNSAyLjA4MS4yMTctLjIwN2gzLjU1bC4yMzUuMjA3LS4yNTQtMi4wODF6IiBmaWxsPSIjMTYxNjE2IiBzdHJva2U9IiMxNjE2MTYiLz48cGF0aCBkPSJtMjYuNTA1IDExLjA1My44LTMuODQyLTEuMTk2LTMuNTY5LTkuMDU4IDYuNzIzIDMuNDg0IDIuOTQ3IDQuOTI1IDEuNDQxIDEuMDkyLTEuMjcxLS40NzEtLjMzOS43NTMtLjY4Ny0uNTg0LS40NTIuNzUzLS41NzQtLjQ5OS0uMzc3em0tMjMuMjExLTMuODQxLjggMy44NDItLjUwOC4zNzcuNzUzLjU3NC0uNTc0LjQ1Mi43NTMuNjg3LS40NzEuMzM5IDEuMDgzIDEuMjcxIDQuOTI1LTEuNDQxIDMuNDg0LTIuOTQ3LTkuMDU5LTYuNzIzeiIgZmlsbD0iIzc2M2QxNiIgc3Ryb2tlPSIjNzYzZDE2Ii8+PHBhdGggZD0ibTI1LjQ2IDE0Ljc1NC00LjkyNS0xLjQ0MSAxLjQ5NyAyLjI1MS0yLjIzMiA0LjMzMSAyLjkzOC0uMDM4aDQuMzc4bC0xLjY1Ny01LjEwNHptLTE1LjQwNS0xLjQ0MS00LjkyNSAxLjQ0MS0xLjYzOCA1LjEwNGg0LjM2OWwyLjkyOC4wMzgtMi4yMjItNC4zMzEgMS40ODgtMi4yNTF6bTYuNjg1IDIuNDg2LjMxMS01LjQzMyAxLjQzMS0zLjg3aC02LjM1NmwxLjQxMyAzLjg3LjMyOSA1LjQzMy4xMTMgMS43MTQuMDA5IDQuMjE5aDIuNjFsLjAxOS00LjIxOS4xMjItMS43MTR6IiBmaWxsPSIjZjY4NTFiIiBzdHJva2U9IiNmNjg1MWIiLz48L2c+PGNpcmNsZSBjeD0iMjMuNSIgY3k9IjIzLjUiIGZpbGw9IiMwMDAiIHI9IjYuNSIvPjxwYXRoIGQ9Im0yNy40NzMgMjUuNTQ1LTEuMzEgMS4zNjhjLS4wMjkuMDMtLjA2My4wNTMtLjEwMS4wN2EuMzEuMzEgMCAwIDEgLS4xMjEuMDI0aC02LjIwOWMtLjAzIDAtLjA1OS0uMDA4LS4wODMtLjAyNGEuMTUuMTUgMCAwIDEgLS4wNTYtLjA2NWMtLjAxMi0uMDI2LS4wMTUtLjA1Ni0uMDEtLjA4NHMuMDE4LS4wNTUuMDM5LS4wNzZsMS4zMTEtMS4zNjhjLjAyOC0uMDMuMDYzLS4wNTMuMTAxLS4wNjlhLjMxLjMxIDAgMCAxIC4xMjEtLjAyNWg2LjIwOGMuMDMgMCAuMDU5LjAwOC4wODMuMDI0YS4xNS4xNSAwIDAgMSAuMDU2LjA2NWMuMDEyLjAyNi4wMTUuMDU2LjAxLjA4NHMtLjAxOC4wNTUtLjAzOS4wNzZ6bS0xLjMxLTIuNzU2Yy0uMDI5LS4wMy0uMDYzLS4wNTMtLjEwMS0uMDdhLjMxLjMxIDAgMCAwIC0uMTIxLS4wMjRoLTYuMjA5Yy0uMDMgMC0uMDU5LjAwOC0uMDgzLjAyNHMtLjA0NC4wMzgtLjA1Ni4wNjUtLjAxNS4wNTYtLjAxLjA4NC4wMTguMDU1LjAzOS4wNzZsMS4zMTEgMS4zNjhjLjAyOC4wMy4wNjMuMDUzLjEwMS4wNjlhLjMxLjMxIDAgMCAwIC4xMjEuMDI1aDYuMjA4Yy4wMyAwIC4wNTktLjAwOC4wODMtLjAyNGEuMTUuMTUgMCAwIDAgLjA1Ni0uMDY1Yy4wMTItLjAyNi4wMTUtLjA1Ni4wMS0uMDg0cy0uMDE4LS4wNTUtLjAzOS0uMDc2em0tNi40MzEtLjk4M2g2LjIwOWEuMzEuMzEgMCAwIDAgLjEyMS0uMDI0Yy4wMzgtLjAxNi4wNzMtLjA0LjEwMS0uMDdsMS4zMS0xLjM2OGMuMDItLjAyMS4wMzQtLjA0Ny4wMzktLjA3NnMuMDAxLS4wNTgtLjAxLS4wODRhLjE1LjE1IDAgMCAwIC0uMDU2LS4wNjVjLS4wMjUtLjAxNi0uMDU0LS4wMjQtLjA4My0uMDI0aC02LjIwOGEuMzEuMzEgMCAwIDAgLS4xMjEuMDI1Yy0uMDM4LjAxNi0uMDcyLjA0LS4xMDEuMDY5bC0xLjMxIDEuMzY4Yy0uMDIuMDIxLS4wMzQuMDQ3LS4wMzkuMDc2cy0uMDAxLjA1OC4wMS4wODQuMDMxLjA0OS4wNTYuMDY1LjA1NC4wMjQuMDgzLjAyNHoiIGZpbGw9InVybCgjYSkiLz48L3N2Zz4=";
var __classPrivateFieldGet = function(_e, $, et, tt) {
    if (et === "a" && !tt)
        throw new TypeError("Private accessor was defined without a getter");
    if (typeof $ == "function" ? _e !== $ || !tt : !$.has(_e))
        throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return et === "m" ? tt : et === "a" ? tt.call(_e) : tt ? tt.value : $.get(_e)
}, __classPrivateFieldSet = function(_e, $, et, tt, nt) {
    if (tt === "m")
        throw new TypeError("Private method is not writable");
    if (tt === "a" && !nt)
        throw new TypeError("Private accessor was defined without a setter");
    if (typeof $ == "function" ? _e !== $ || !nt : !$.has(_e))
        throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return tt === "a" ? nt.call(_e, et) : nt ? nt.value = et : $.set(_e, et),
    et
}, _SolflareMetaMaskWallet_instances, _SolflareMetaMaskWallet_listeners, _SolflareMetaMaskWallet_version, _SolflareMetaMaskWallet_name, _SolflareMetaMaskWallet_icon, _SolflareMetaMaskWallet_solflareMetaMask, _SolflareMetaMaskWallet_on, _SolflareMetaMaskWallet_emit, _SolflareMetaMaskWallet_off, _SolflareMetaMaskWallet_connect, _SolflareMetaMaskWallet_disconnect, _SolflareMetaMaskWallet_signAndSendTransaction, _SolflareMetaMaskWallet_signTransaction, _SolflareMetaMaskWallet_signMessage;
class SolflareMetaMaskWallet {
    constructor() {
        _SolflareMetaMaskWallet_instances.add(this),
        _SolflareMetaMaskWallet_listeners.set(this, {}),
        _SolflareMetaMaskWallet_version.set(this, "1.0.0"),
        _SolflareMetaMaskWallet_name.set(this, "MetaMask"),
        _SolflareMetaMaskWallet_icon.set(this, icon),
        _SolflareMetaMaskWallet_solflareMetaMask.set(this, null),
        _SolflareMetaMaskWallet_on.set(this, ($, et) => {
            var tt;
            return (tt = __classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[$]) != null && tt.push(et) || (__classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[$] = [et]),
            () => __classPrivateFieldGet(this, _SolflareMetaMaskWallet_instances, "m", _SolflareMetaMaskWallet_off).call(this, $, et)
        }
        ),
        _SolflareMetaMaskWallet_connect.set(this, async () => {
            if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f")) {
                let $;
                try {
                    $ = (await __vitePreload(async () => {
                        const {default: et} = await import("./index-DuKqJIQz.js");
                        return {
                            default: et
                        }
                    }
                    , __vite__mapDeps([0, 1]))).default
                } catch {
                    throw new Error("Unable to load Solflare MetaMask SDK")
                }
                __classPrivateFieldSet(this, _SolflareMetaMaskWallet_solflareMetaMask, new $, "f"),
                __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").on("standard_change", et => __classPrivateFieldGet(this, _SolflareMetaMaskWallet_instances, "m", _SolflareMetaMaskWallet_emit).call(this, "change", et))
            }
            return this.accounts.length || await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").connect(),
            {
                accounts: this.accounts
            }
        }
        ),
        _SolflareMetaMaskWallet_disconnect.set(this, async () => {
            __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f") && await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").disconnect()
        }
        ),
        _SolflareMetaMaskWallet_signAndSendTransaction.set(this, async (...$) => {
            if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f"))
                throw new WalletNotConnectedError;
            return await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardSignAndSendTransaction(...$)
        }
        ),
        _SolflareMetaMaskWallet_signTransaction.set(this, async (...$) => {
            if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f"))
                throw new WalletNotConnectedError;
            return await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardSignTransaction(...$)
        }
        ),
        _SolflareMetaMaskWallet_signMessage.set(this, async (...$) => {
            if (!__classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f"))
                throw new WalletNotConnectedError;
            return await __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardSignMessage(...$)
        }
        )
    }
    get version() {
        return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_version, "f")
    }
    get name() {
        return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_name, "f")
    }
    get icon() {
        return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_icon, "f")
    }
    get chains() {
        return [SOLANA_MAINNET_CHAIN, SOLANA_DEVNET_CHAIN, SOLANA_TESTNET_CHAIN]
    }
    get features() {
        return {
            [StandardConnect]: {
                version: "1.0.0",
                connect: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_connect, "f")
            },
            [StandardDisconnect]: {
                version: "1.0.0",
                disconnect: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_disconnect, "f")
            },
            [StandardEvents]: {
                version: "1.0.0",
                on: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_on, "f")
            },
            [SolanaSignAndSendTransaction]: {
                version: "1.0.0",
                supportedTransactionVersions: ["legacy", 0],
                signAndSendTransaction: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_signAndSendTransaction, "f")
            },
            [SolanaSignTransaction]: {
                version: "1.0.0",
                supportedTransactionVersions: ["legacy", 0],
                signTransaction: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_signTransaction, "f")
            },
            [SolanaSignMessage]: {
                version: "1.0.0",
                signMessage: __classPrivateFieldGet(this, _SolflareMetaMaskWallet_signMessage, "f")
            }
        }
    }
    get accounts() {
        return __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f") ? __classPrivateFieldGet(this, _SolflareMetaMaskWallet_solflareMetaMask, "f").standardAccounts : []
    }
}
_SolflareMetaMaskWallet_listeners = new WeakMap,
_SolflareMetaMaskWallet_version = new WeakMap,
_SolflareMetaMaskWallet_name = new WeakMap,
_SolflareMetaMaskWallet_icon = new WeakMap,
_SolflareMetaMaskWallet_solflareMetaMask = new WeakMap,
_SolflareMetaMaskWallet_on = new WeakMap,
_SolflareMetaMaskWallet_connect = new WeakMap,
_SolflareMetaMaskWallet_disconnect = new WeakMap,
_SolflareMetaMaskWallet_signAndSendTransaction = new WeakMap,
_SolflareMetaMaskWallet_signTransaction = new WeakMap,
_SolflareMetaMaskWallet_signMessage = new WeakMap,
_SolflareMetaMaskWallet_instances = new WeakSet,
_SolflareMetaMaskWallet_emit = function($, ...et) {
    var tt;
    (tt = __classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[$]) == null || tt.forEach(nt => nt.apply(null, et))
}
,
_SolflareMetaMaskWallet_off = function($, et) {
    var tt;
    __classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[$] = (tt = __classPrivateFieldGet(this, _SolflareMetaMaskWallet_listeners, "f")[$]) == null ? void 0 : tt.filter(nt => et !== nt)
}
;
let registered = !1;
function register() {
    registered || (registerWallet(new SolflareMetaMaskWallet),
    registered = !0)
}
async function detectAndRegisterSolflareMetaMaskWallet() {
    const _e = "solflare-detect-metamask";
    function $() {
        window.postMessage({
            target: "metamask-contentscript",
            data: {
                name: "metamask-provider",
                data: {
                    id: _e,
                    jsonrpc: "2.0",
                    method: "wallet_getSnaps"
                }
            }
        }, window.location.origin)
    }
    function et(tt) {
        var rt, it;
        const nt = tt.data;
        (nt == null ? void 0 : nt.target) === "metamask-inpage" && ((rt = nt.data) == null ? void 0 : rt.name) === "metamask-provider" && (((it = nt.data.data) == null ? void 0 : it.id) === _e ? (window.removeEventListener("message", et),
        nt.data.data.error || register()) : $())
    }
    window.addEventListener("message", et),
    window.setTimeout( () => window.removeEventListener("message", et), 5e3),
    $()
}
const SolflareWalletName = "Solflare";
class SolflareWalletAdapter extends BaseMessageSignerWalletAdapter {
    constructor($={}) {
        super(),
        this.name = SolflareWalletName,
        this.url = "https://solflare.com",
        this.icon = "data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjUwIiB2aWV3Qm94PSIwIDAgNTAgNTAiIHdpZHRoPSI1MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayI+PGxpbmVhckdyYWRpZW50IGlkPSJhIj48c3RvcCBvZmZzZXQ9IjAiIHN0b3AtY29sb3I9IiNmZmMxMGIiLz48c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNmYjNmMmUiLz48L2xpbmVhckdyYWRpZW50PjxsaW5lYXJHcmFkaWVudCBpZD0iYiIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHgxPSI2LjQ3ODM1IiB4Mj0iMzQuOTEwNyIgeGxpbms6aHJlZj0iI2EiIHkxPSI3LjkyIiB5Mj0iMzMuNjU5MyIvPjxyYWRpYWxHcmFkaWVudCBpZD0iYyIgY3g9IjAiIGN5PSIwIiBncmFkaWVudFRyYW5zZm9ybT0ibWF0cml4KDQuOTkyMTg4MzIgMTIuMDYzODc5NjMgLTEyLjE4MTEzNjU1IDUuMDQwNzEwNzQgMjIuNTIwMiAyMC42MTgzKSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIHI9IjEiIHhsaW5rOmhyZWY9IiNhIi8+PHBhdGggZD0ibTI1LjE3MDggNDcuOTEwNGMuNTI1IDAgLjk1MDcuNDIxLjk1MDcuOTQwM3MtLjQyNTcuOTQwMi0uOTUwNy45NDAyLS45NTA3LS40MjA5LS45NTA3LS45NDAyLjQyNTctLjk0MDMuOTUwNy0uOTQwM3ptLTEuMDMyOC00NC45MTU2NWMuNDY0Ni4wMzgzNi44Mzk4LjM5MDQuOTAyNy44NDY4MWwxLjEzMDcgOC4yMTU3NGMuMzc5OCAyLjcxNDMgMy42NTM1IDMuODkwNCA1LjY3NDMgMi4wNDU5bDExLjMyOTEtMTAuMzExNThjLjI3MzMtLjI0ODczLjY5ODktLjIzMTQ5Ljk1MDcuMDM4NTEuMjMwOS4yNDc3Mi4yMzc5LjYyNjk3LjAxNjEuODgyNzdsLTkuODc5MSAxMS4zOTU4Yy0xLjgxODcgMi4wOTQyLS40NzY4IDUuMzY0MyAyLjI5NTYgNS41OTc4bDguNzE2OC44NDAzYy40MzQxLjA0MTguNzUxNy40MjM0LjcwOTMuODUyNC0uMDM0OS4zNTM3LS4zMDc0LjYzOTUtLjY2MjguNjk0OWwtOS4xNTk0IDEuNDMwMmMtMi42NTkzLjM2MjUtMy44NjM2IDMuNTExNy0yLjEzMzkgNS41NTc2bDMuMjIgMy43OTYxYy4yNTk0LjMwNTguMjE4OC43NjE1LS4wOTA4IDEuMDE3OC0uMjYyMi4yMTcyLS42NDE5LjIyNTYtLjkxMzguMDIwM2wtMy45Njk0LTIuOTk3OGMtMi4xNDIxLTEuNjEwOS01LjIyOTctLjI0MTctNS40NTYxIDIuNDI0M2wtLjg3NDcgMTAuMzk3NmMtLjAzNjIuNDI5NS0uNDE3OC43NDg3LS44NTI1LjcxMy0uMzY5LS4wMzAzLS42NjcxLS4zMDk3LS43MTcxLS42NzIxbC0xLjM4NzEtMTAuMDQzN2MtLjM3MTctMi43MTQ0LTMuNjQ1NC0zLjg5MDQtNS42NzQzLTIuMDQ1OWwtMTIuMDUxOTUgMTAuOTc0Yy0uMjQ5NDcuMjI3MS0uNjM4MDkuMjExNC0uODY4LS4wMzUtLjIxMDk0LS4yMjYyLS4yMTczNS0uNTcyNC0uMDE0OTMtLjgwNmwxMC41MTgxOC0xMi4xMzg1YzEuODE4Ny0yLjA5NDIuNDg0OS01LjM2NDQtMi4yODc2LTUuNTk3OGwtOC43MTg3Mi0uODQwNWMtLjQzNDEzLS4wNDE4LS43NTE3Mi0uNDIzNS0uNzA5MzYtLjg1MjQuMDM0OTMtLjM1MzcuMzA3MzktLjYzOTQuNjYyNy0uNjk1bDkuMTUzMzgtMS40Mjk5YzIuNjU5NC0uMzYyNSAzLjg3MTgtMy41MTE3IDIuMTQyMS01LjU1NzZsLTIuMTkyLTIuNTg0MWMtLjMyMTctLjM3OTItLjI3MTMtLjk0NDMuMTEyNi0xLjI2MjEuMzI1My0uMjY5NC43OTYzLS4yNzk3IDEuMTMzNC0uMDI0OWwyLjY5MTggMi4wMzQ3YzIuMTQyMSAxLjYxMDkgNS4yMjk3LjI0MTcgNS40NTYxLTIuNDI0M2wuNzI0MS04LjU1OTk4Yy4wNDU3LS41NDA4LjUyNjUtLjk0MjU3IDEuMDczOS0uODk3Mzd6bS0yMy4xODczMyAyMC40Mzk2NWMuNTI1MDQgMCAuOTUwNjcuNDIxLjk1MDY3Ljk0MDNzLS40MjU2My45NDAzLS45NTA2Ny45NDAzYy0uNTI1MDQxIDAtLjk1MDY3LS40MjEtLjk1MDY3LS45NDAzcy40MjU2MjktLjk0MDMuOTUwNjctLjk0MDN6bTQ3LjY3OTczLS45NTQ3Yy41MjUgMCAuOTUwNy40MjEuOTUwNy45NDAzcy0uNDI1Ny45NDAyLS45NTA3Ljk0MDItLjk1MDctLjQyMDktLjk1MDctLjk0MDIuNDI1Ny0uOTQwMy45NTA3LS45NDAzem0tMjQuNjI5Ni0yMi40Nzk3Yy41MjUgMCAuOTUwNi40MjA5NzMuOTUwNi45NDAyNyAwIC41MTkzLS40MjU2Ljk0MDI3LS45NTA2Ljk0MDI3LS41MjUxIDAtLjk1MDctLjQyMDk3LS45NTA3LS45NDAyNyAwLS41MTkyOTcuNDI1Ni0uOTQwMjcuOTUwNy0uOTQwMjd6IiBmaWxsPSJ1cmwoI2IpIi8+PHBhdGggZD0ibTI0LjU3MSAzMi43NzkyYzQuOTU5NiAwIDguOTgwMi0zLjk3NjUgOC45ODAyLTguODgxOSAwLTQuOTA1My00LjAyMDYtOC44ODE5LTguOTgwMi04Ljg4MTlzLTguOTgwMiAzLjk3NjYtOC45ODAyIDguODgxOWMwIDQuOTA1NCA0LjAyMDYgOC44ODE5IDguOTgwMiA4Ljg4MTl6IiBmaWxsPSJ1cmwoI2MpIi8+PC9zdmc+",
        this.supportedTransactionVersions = new Set(["legacy", 0]),
        this._readyState = typeof window > "u" || typeof document > "u" ? WalletReadyState.Unsupported : WalletReadyState.Loadable,
        this._disconnected = () => {
            const et = this._wallet;
            et && (et.off("disconnect", this._disconnected),
            this._wallet = null,
            this._publicKey = null,
            this.emit("error", new WalletDisconnectedError),
            this.emit("disconnect"))
        }
        ,
        this._accountChanged = et => {
            if (!et)
                return;
            const tt = this._publicKey;
            if (tt) {
                try {
                    et = new PublicKey(et.toBytes())
                } catch (nt) {
                    this.emit("error", new WalletPublicKeyError(nt == null ? void 0 : nt.message,nt));
                    return
                }
                tt.equals(et) || (this._publicKey = et,
                this.emit("connect", et))
            }
        }
        ,
        this._connecting = !1,
        this._publicKey = null,
        this._wallet = null,
        this._config = $,
        this._readyState !== WalletReadyState.Unsupported && (scopePollingDetectionStrategy( () => {
            var et;
            return (et = window.solflare) != null && et.isSolflare || window.SolflareApp ? (this._readyState = WalletReadyState.Installed,
            this.emit("readyStateChange", this._readyState),
            !0) : !1
        }
        ),
        detectAndRegisterSolflareMetaMaskWallet())
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        var $;
        return !!(($ = this._wallet) != null && $.connected)
    }
    get readyState() {
        return this._readyState
    }
    async autoConnect() {
        this.readyState === WalletReadyState.Loadable && isIosAndRedirectable() || await this.connect()
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this._readyState !== WalletReadyState.Loadable && this._readyState !== WalletReadyState.Installed)
                throw new WalletNotReadyError;
            if (this.readyState === WalletReadyState.Loadable && isIosAndRedirectable()) {
                const nt = encodeURIComponent(window.location.href)
                  , rt = encodeURIComponent(window.location.origin);
                window.location.href = `https://solflare.com/ul/v1/browse/${nt}?ref=${rt}`;
                return
            }
            let $;
            try {
                $ = (await __vitePreload(async () => {
                    const {default: nt} = await import("./index-BZqns2nd.js");
                    return {
                        default: nt
                    }
                }
                , __vite__mapDeps([2, 1]))).default
            } catch (nt) {
                throw new WalletLoadError(nt == null ? void 0 : nt.message,nt)
            }
            let et;
            try {
                et = new $({
                    network: this._config.network
                })
            } catch (nt) {
                throw new WalletConfigError(nt == null ? void 0 : nt.message,nt)
            }
            if (this._connecting = !0,
            !et.connected)
                try {
                    await et.connect()
                } catch (nt) {
                    throw new WalletConnectionError(nt == null ? void 0 : nt.message,nt)
                }
            if (!et.publicKey)
                throw new WalletConnectionError;
            let tt;
            try {
                tt = new PublicKey(et.publicKey.toBytes())
            } catch (nt) {
                throw new WalletPublicKeyError(nt == null ? void 0 : nt.message,nt)
            }
            et.on("disconnect", this._disconnected),
            et.on("accountChanged", this._accountChanged),
            this._wallet = et,
            this._publicKey = tt,
            this.emit("connect", tt)
        } catch ($) {
            throw this.emit("error", $),
            $
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const $ = this._wallet;
        if ($) {
            $.off("disconnect", this._disconnected),
            $.off("accountChanged", this._accountChanged),
            this._wallet = null,
            this._publicKey = null;
            try {
                await $.disconnect()
            } catch (et) {
                this.emit("error", new WalletDisconnectionError(et == null ? void 0 : et.message,et))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction($, et, tt={}) {
        try {
            const nt = this._wallet;
            if (!nt)
                throw new WalletNotConnectedError;
            try {
                const {signers: rt, ...it} = tt;
                return isVersionedTransaction$1($) ? rt != null && rt.length && $.sign(rt) : ($ = await this.prepareTransaction($, et, it),
                rt != null && rt.length && $.partialSign(...rt)),
                it.preflightCommitment = it.preflightCommitment || et.commitment,
                await nt.signAndSendTransaction($, it)
            } catch (rt) {
                throw rt instanceof WalletError ? rt : new WalletSendTransactionError(rt == null ? void 0 : rt.message,rt)
            }
        } catch (nt) {
            throw this.emit("error", nt),
            nt
        }
    }
    async signTransaction($) {
        try {
            const et = this._wallet;
            if (!et)
                throw new WalletNotConnectedError;
            try {
                return await et.signTransaction($) || $
            } catch (tt) {
                throw new WalletSignTransactionError(tt == null ? void 0 : tt.message,tt)
            }
        } catch (et) {
            throw this.emit("error", et),
            et
        }
    }
    async signAllTransactions($) {
        try {
            const et = this._wallet;
            if (!et)
                throw new WalletNotConnectedError;
            try {
                return await et.signAllTransactions($) || $
            } catch (tt) {
                throw new WalletSignTransactionError(tt == null ? void 0 : tt.message,tt)
            }
        } catch (et) {
            throw this.emit("error", et),
            et
        }
    }
    async signMessage($) {
        try {
            const et = this._wallet;
            if (!et)
                throw new WalletNotConnectedError;
            try {
                return await et.signMessage($, "utf8")
            } catch (tt) {
                throw new WalletSignMessageError(tt == null ? void 0 : tt.message,tt)
            }
        } catch (et) {
            throw this.emit("error", et),
            et
        }
    }
}
const TorusWalletName = "Torus";
class TorusWalletAdapter extends BaseMessageSignerWalletAdapter {
    constructor({params: $={
        showTorusButton: !1
    }}={
        params: {
            showTorusButton: !1
        }
    }) {
        super(),
        this.name = TorusWalletName,
        this.url = "https://tor.us",
        this.icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzMiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMyAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPGNpcmNsZSBjeD0iMTYuNSIgY3k9IjE2IiByPSIxNiIgZmlsbD0iIzAzNjRGRiIvPgo8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTExLjIxODYgOS40OTIxOUMxMC40NTM5IDkuNDkyMTkgOS44MzM5OCAxMC4xMTIxIDkuODMzOTggMTAuODc2OFYxMi40ODk4QzkuODMzOTggMTMuMjU0NSAxMC40NTM5IDEzLjg3NDQgMTEuMjE4NiAxMy44NzQ0SDEzLjY2ODRWMjIuODk3NkMxMy42Njg0IDIzLjY2MjMgMTQuMjg4MyAyNC4yODIyIDE1LjA1MyAyNC4yODIySDE2LjY2NkMxNy40MzA3IDI0LjI4MjIgMTguMDUwNiAyMy42NjIzIDE4LjA1MDYgMjIuODk3NlYxMi41MDE1QzE4LjA1MDYgMTIuNDk3NiAxOC4wNTA2IDEyLjQ5MzcgMTguMDUwNiAxMi40ODk4VjEwLjg3NjhDMTguMDUwNiAxMC4xMTIxIDE3LjQzMDcgOS40OTIxOSAxNi42NjYgOS40OTIxOUgxNS4wNTNIMTEuMjE4NloiIGZpbGw9IndoaXRlIi8+CjxwYXRoIGQ9Ik0yMS4zMzc2IDEzLjg3NDRDMjIuNTQ3NyAxMy44NzQ0IDIzLjUyODcgMTIuODkzNCAyMy41Mjg3IDExLjY4MzNDMjMuNTI4NyAxMC40NzMyIDIyLjU0NzcgOS40OTIxOSAyMS4zMzc2IDkuNDkyMTlDMjAuMTI3NSA5LjQ5MjE5IDE5LjE0NjUgMTAuNDczMiAxOS4xNDY1IDExLjY4MzNDMTkuMTQ2NSAxMi44OTM0IDIwLjEyNzUgMTMuODc0NCAyMS4zMzc2IDEzLjg3NDRaIiBmaWxsPSJ3aGl0ZSIvPgo8L3N2Zz4K",
        this.supportedTransactionVersions = null,
        this._readyState = typeof window > "u" || typeof document > "u" ? WalletReadyState.Unsupported : WalletReadyState.Loadable,
        this._connecting = !1,
        this._wallet = null,
        this._publicKey = null,
        this._params = $
    }
    get publicKey() {
        return this._publicKey
    }
    get connecting() {
        return this._connecting
    }
    get connected() {
        var $;
        return !!(($ = this._wallet) != null && $.isLoggedIn)
    }
    get readyState() {
        return this._readyState
    }
    async connect() {
        try {
            if (this.connected || this.connecting)
                return;
            if (this._readyState !== WalletReadyState.Loadable)
                throw new WalletNotReadyError;
            this._connecting = !0;
            let $;
            try {
                $ = (await __vitePreload(async () => {
                    const {default: rt} = await import("./solanaEmbed.esm-CiiaZgXr.js");
                    return {
                        default: rt
                    }
                }
                , __vite__mapDeps([3, 4]))).default
            } catch (rt) {
                throw new WalletLoadError(rt == null ? void 0 : rt.message,rt)
            }
            let et;
            try {
                et = window.torus || new $
            } catch (rt) {
                throw new WalletConfigError(rt == null ? void 0 : rt.message,rt)
            }
            if (!et.isInitialized)
                try {
                    await et.init(this._params)
                } catch (rt) {
                    throw new WalletConnectionError(rt == null ? void 0 : rt.message,rt)
                }
            let tt;
            try {
                tt = await et.login()
            } catch (rt) {
                throw new WalletAccountError(rt == null ? void 0 : rt.message,rt)
            }
            let nt;
            try {
                nt = new PublicKey(tt[0])
            } catch (rt) {
                throw new WalletPublicKeyError(rt == null ? void 0 : rt.message,rt)
            }
            this._wallet = et,
            this._publicKey = nt,
            this.emit("connect", nt)
        } catch ($) {
            throw this.emit("error", $),
            $
        } finally {
            this._connecting = !1
        }
    }
    async disconnect() {
        const $ = this._wallet;
        if ($) {
            this._wallet = null,
            this._publicKey = null;
            try {
                $.isLoggedIn && await $.cleanUp()
            } catch (et) {
                this.emit("error", new WalletDisconnectionError(et == null ? void 0 : et.message,et))
            }
        }
        this.emit("disconnect")
    }
    async sendTransaction($, et, tt={}) {
        try {
            const nt = this._wallet;
            if (!nt)
                throw new WalletNotConnectedError;
            try {
                const {signers: rt, ...it} = tt;
                $ = await this.prepareTransaction($, et, it),
                rt != null && rt.length && $.partialSign(...rt),
                it.preflightCommitment = it.preflightCommitment || et.commitment;
                const {signature: ot} = await nt.signAndSendTransaction($, it);
                return ot
            } catch (rt) {
                throw rt instanceof WalletError ? rt : new WalletSendTransactionError(rt == null ? void 0 : rt.message,rt)
            }
        } catch (nt) {
            throw this.emit("error", nt),
            nt
        }
    }
    async signTransaction($) {
        try {
            const et = this._wallet;
            if (!et)
                throw new WalletNotConnectedError;
            try {
                return await et.signTransaction($) || $
            } catch (tt) {
                throw new WalletSignTransactionError(tt == null ? void 0 : tt.message,tt)
            }
        } catch (et) {
            throw this.emit("error", et),
            et
        }
    }
    async signAllTransactions($) {
        try {
            const et = this._wallet;
            if (!et)
                throw new WalletNotConnectedError;
            try {
                return await et.signAllTransactions($) || $
            } catch (tt) {
                throw new WalletSignTransactionError(tt == null ? void 0 : tt.message,tt)
            }
        } catch (et) {
            throw this.emit("error", et),
            et
        }
    }
    async signMessage($) {
        try {
            const et = this._wallet;
            if (!et)
                throw new WalletNotConnectedError;
            try {
                return await et.signMessage($)
            } catch (tt) {
                throw new WalletSignMessageError(tt == null ? void 0 : tt.message,tt)
            }
        } catch (et) {
            throw this.emit("error", et),
            et
        }
    }
}
const WalletDialogContext = reactExports.createContext({});
function useWalletDialog() {
    return reactExports.useContext(WalletDialogContext)
}
function useWalletMultiButton({onSelectWallet: _e}) {
    const {connect: $, connected: et, connecting: tt, disconnect: nt, disconnecting: rt, publicKey: it, select: ot, wallet: st, wallets: lt} = useWallet();
    let ct;
    tt ? ct = "connecting" : et ? ct = "connected" : rt ? ct = "disconnecting" : st ? ct = "has-wallet" : ct = "no-wallet";
    const dt = reactExports.useCallback( () => {
        $().catch( () => {}
        )
    }
    , [$])
      , pt = reactExports.useCallback( () => {
        nt().catch( () => {}
        )
    }
    , [nt])
      , ht = reactExports.useCallback( () => {
        _e({
            onSelectWallet: ot,
            wallets: lt
        })
    }
    , [_e, ot, lt]);
    return {
        buttonState: ct,
        onConnect: ct === "has-wallet" ? dt : void 0,
        onDisconnect: ct !== "disconnecting" && ct !== "no-wallet" ? pt : void 0,
        onSelectWallet: ht,
        publicKey: it ?? void 0,
        walletIcon: st == null ? void 0 : st.adapter.icon,
        walletName: st == null ? void 0 : st.adapter.name
    }
}
const common = {
    black: "#000",
    white: "#fff"
}
  , red = {
    300: "#e57373",
    400: "#ef5350",
    500: "#f44336",
    700: "#d32f2f",
    800: "#c62828"
}
  , purple = {
    50: "#f3e5f5",
    200: "#ce93d8",
    300: "#ba68c8",
    400: "#ab47bc",
    500: "#9c27b0",
    700: "#7b1fa2"
}
  , blue = {
    50: "#e3f2fd",
    200: "#90caf9",
    400: "#42a5f5",
    700: "#1976d2",
    800: "#1565c0"
}
  , lightBlue = {
    300: "#4fc3f7",
    400: "#29b6f6",
    500: "#03a9f4",
    700: "#0288d1",
    900: "#01579b"
}
  , green = {
    300: "#81c784",
    400: "#66bb6a",
    500: "#4caf50",
    700: "#388e3c",
    800: "#2e7d32",
    900: "#1b5e20"
}
  , orange = {
    300: "#ffb74d",
    400: "#ffa726",
    500: "#ff9800",
    700: "#f57c00",
    900: "#e65100"
}
  , grey = {
    50: "#fafafa",
    100: "#f5f5f5",
    200: "#eeeeee",
    300: "#e0e0e0",
    400: "#bdbdbd",
    500: "#9e9e9e",
    600: "#757575",
    700: "#616161",
    800: "#424242",
    900: "#212121",
    A100: "#f5f5f5",
    A200: "#eeeeee",
    A400: "#bdbdbd",
    A700: "#616161"
};
function formatMuiErrorMessage(_e, ...$) {
    const et = new URL(`https://mui.com/production-error/?code=${_e}`);
    return $.forEach(tt => et.searchParams.append("args[]", tt)),
    `Minified MUI error #${_e}; visit ${et} for the full message.`
}
const THEME_ID = "$$material";
function _extends$3() {
    return _extends$3 = Object.assign ? Object.assign.bind() : function(_e) {
        for (var $ = 1; $ < arguments.length; $++) {
            var et = arguments[$];
            for (var tt in et)
                ({}).hasOwnProperty.call(et, tt) && (_e[tt] = et[tt])
        }
        return _e
    }
    ,
    _extends$3.apply(null, arguments)
}
function sheetForTag(_e) {
    if (_e.sheet)
        return _e.sheet;
    for (var $ = 0; $ < document.styleSheets.length; $++)
        if (document.styleSheets[$].ownerNode === _e)
            return document.styleSheets[$]
}
function createStyleElement(_e) {
    var $ = document.createElement("style");
    return $.setAttribute("data-emotion", _e.key),
    _e.nonce !== void 0 && $.setAttribute("nonce", _e.nonce),
    $.appendChild(document.createTextNode("")),
    $.setAttribute("data-s", ""),
    $
}
var StyleSheet = function() {
    function _e(et) {
        var tt = this;
        this._insertTag = function(nt) {
            var rt;
            tt.tags.length === 0 ? tt.insertionPoint ? rt = tt.insertionPoint.nextSibling : tt.prepend ? rt = tt.container.firstChild : rt = tt.before : rt = tt.tags[tt.tags.length - 1].nextSibling,
            tt.container.insertBefore(nt, rt),
            tt.tags.push(nt)
        }
        ,
        this.isSpeedy = et.speedy === void 0 ? !0 : et.speedy,
        this.tags = [],
        this.ctr = 0,
        this.nonce = et.nonce,
        this.key = et.key,
        this.container = et.container,
        this.prepend = et.prepend,
        this.insertionPoint = et.insertionPoint,
        this.before = null
    }
    var $ = _e.prototype;
    return $.hydrate = function(tt) {
        tt.forEach(this._insertTag)
    }
    ,
    $.insert = function(tt) {
        this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(createStyleElement(this));
        var nt = this.tags[this.tags.length - 1];
        if (this.isSpeedy) {
            var rt = sheetForTag(nt);
            try {
                rt.insertRule(tt, rt.cssRules.length)
            } catch {}
        } else
            nt.appendChild(document.createTextNode(tt));
        this.ctr++
    }
    ,
    $.flush = function() {
        this.tags.forEach(function(tt) {
            var nt;
            return (nt = tt.parentNode) == null ? void 0 : nt.removeChild(tt)
        }),
        this.tags = [],
        this.ctr = 0
    }
    ,
    _e
}()
  , MS = "-ms-"
  , MOZ = "-moz-"
  , WEBKIT = "-webkit-"
  , COMMENT = "comm"
  , RULESET = "rule"
  , DECLARATION = "decl"
  , IMPORT = "@import"
  , KEYFRAMES = "@keyframes"
  , LAYER = "@layer"
  , abs$2 = Math.abs
  , from = String.fromCharCode
  , assign = Object.assign;
function hash(_e, $) {
    return charat(_e, 0) ^ 45 ? ((($ << 2 ^ charat(_e, 0)) << 2 ^ charat(_e, 1)) << 2 ^ charat(_e, 2)) << 2 ^ charat(_e, 3) : 0
}
function trim$1(_e) {
    return _e.trim()
}
function match(_e, $) {
    return (_e = $.exec(_e)) ? _e[0] : _e
}
function replace(_e, $, et) {
    return _e.replace($, et)
}
function indexof(_e, $) {
    return _e.indexOf($)
}
function charat(_e, $) {
    return _e.charCodeAt($) | 0
}
function substr(_e, $, et) {
    return _e.slice($, et)
}
function strlen(_e) {
    return _e.length
}
function sizeof(_e) {
    return _e.length
}
function append(_e, $) {
    return $.push(_e),
    _e
}
function combine(_e, $) {
    return _e.map($).join("")
}
var line = 1
  , column = 1
  , length = 0
  , position = 0
  , character = 0
  , characters = "";
function node(_e, $, et, tt, nt, rt, it) {
    return {
        value: _e,
        root: $,
        parent: et,
        type: tt,
        props: nt,
        children: rt,
        line,
        column,
        length: it,
        return: ""
    }
}
function copy$2(_e, $) {
    return assign(node("", null, null, "", null, null, 0), _e, {
        length: -_e.length
    }, $)
}
function char() {
    return character
}
function prev() {
    return character = position > 0 ? charat(characters, --position) : 0,
    column--,
    character === 10 && (column = 1,
    line--),
    character
}
function next() {
    return character = position < length ? charat(characters, position++) : 0,
    column++,
    character === 10 && (column = 1,
    line++),
    character
}
function peek() {
    return charat(characters, position)
}
function caret() {
    return position
}
function slice(_e, $) {
    return substr(characters, _e, $)
}
function token(_e) {
    switch (_e) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
        return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
        return 4;
    case 58:
        return 3;
    case 34:
    case 39:
    case 40:
    case 91:
        return 2;
    case 41:
    case 93:
        return 1
    }
    return 0
}
function alloc(_e) {
    return line = column = 1,
    length = strlen(characters = _e),
    position = 0,
    []
}
function dealloc(_e) {
    return characters = "",
    _e
}
function delimit(_e) {
    return trim$1(slice(position - 1, delimiter(_e === 91 ? _e + 2 : _e === 40 ? _e + 1 : _e)))
}
function whitespace(_e) {
    for (; (character = peek()) && character < 33; )
        next();
    return token(_e) > 2 || token(character) > 3 ? "" : " "
}
function escaping(_e, $) {
    for (; --$ && next() && !(character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97); )
        ;
    return slice(_e, caret() + ($ < 6 && peek() == 32 && next() == 32))
}
function delimiter(_e) {
    for (; next(); )
        switch (character) {
        case _e:
            return position;
        case 34:
        case 39:
            _e !== 34 && _e !== 39 && delimiter(character);
            break;
        case 40:
            _e === 41 && delimiter(_e);
            break;
        case 92:
            next();
            break
        }
    return position
}
function commenter(_e, $) {
    for (; next() && _e + character !== 57; )
        if (_e + character === 84 && peek() === 47)
            break;
    return "/*" + slice($, position - 1) + "*" + from(_e === 47 ? _e : next())
}
function identifier(_e) {
    for (; !token(peek()); )
        next();
    return slice(_e, position)
}
function compile(_e) {
    return dealloc(parse$1("", null, null, null, [""], _e = alloc(_e), 0, [0], _e))
}
function parse$1(_e, $, et, tt, nt, rt, it, ot, st) {
    for (var lt = 0, ct = 0, dt = it, pt = 0, ht = 0, mt = 0, yt = 1, Et = 1, _t = 1, wt = 0, St = "", Ct = nt, Nt = rt, Lt = tt, kt = St; Et; )
        switch (mt = wt,
        wt = next()) {
        case 40:
            if (mt != 108 && charat(kt, dt - 1) == 58) {
                indexof(kt += replace(delimit(wt), "&", "&\f"), "&\f") != -1 && (_t = -1);
                break
            }
        case 34:
        case 39:
        case 91:
            kt += delimit(wt);
            break;
        case 9:
        case 10:
        case 13:
        case 32:
            kt += whitespace(mt);
            break;
        case 92:
            kt += escaping(caret() - 1, 7);
            continue;
        case 47:
            switch (peek()) {
            case 42:
            case 47:
                append(comment(commenter(next(), caret()), $, et), st);
                break;
            default:
                kt += "/"
            }
            break;
        case 123 * yt:
            ot[lt++] = strlen(kt) * _t;
        case 125 * yt:
        case 59:
        case 0:
            switch (wt) {
            case 0:
            case 125:
                Et = 0;
            case 59 + ct:
                _t == -1 && (kt = replace(kt, /\f/g, "")),
                ht > 0 && strlen(kt) - dt && append(ht > 32 ? declaration(kt + ";", tt, et, dt - 1) : declaration(replace(kt, " ", "") + ";", tt, et, dt - 2), st);
                break;
            case 59:
                kt += ";";
            default:
                if (append(Lt = ruleset(kt, $, et, lt, ct, nt, ot, St, Ct = [], Nt = [], dt), rt),
                wt === 123)
                    if (ct === 0)
                        parse$1(kt, $, Lt, Lt, Ct, rt, dt, ot, Nt);
                    else
                        switch (pt === 99 && charat(kt, 3) === 110 ? 100 : pt) {
                        case 100:
                        case 108:
                        case 109:
                        case 115:
                            parse$1(_e, Lt, Lt, tt && append(ruleset(_e, Lt, Lt, 0, 0, nt, ot, St, nt, Ct = [], dt), Nt), nt, Nt, dt, ot, tt ? Ct : Nt);
                            break;
                        default:
                            parse$1(kt, Lt, Lt, Lt, [""], Nt, 0, ot, Nt)
                        }
            }
            lt = ct = ht = 0,
            yt = _t = 1,
            St = kt = "",
            dt = it;
            break;
        case 58:
            dt = 1 + strlen(kt),
            ht = mt;
        default:
            if (yt < 1) {
                if (wt == 123)
                    --yt;
                else if (wt == 125 && yt++ == 0 && prev() == 125)
                    continue
            }
            switch (kt += from(wt),
            wt * yt) {
            case 38:
                _t = ct > 0 ? 1 : (kt += "\f",
                -1);
                break;
            case 44:
                ot[lt++] = (strlen(kt) - 1) * _t,
                _t = 1;
                break;
            case 64:
                peek() === 45 && (kt += delimit(next())),
                pt = peek(),
                ct = dt = strlen(St = kt += identifier(caret())),
                wt++;
                break;
            case 45:
                mt === 45 && strlen(kt) == 2 && (yt = 0)
            }
        }
    return rt
}
function ruleset(_e, $, et, tt, nt, rt, it, ot, st, lt, ct) {
    for (var dt = nt - 1, pt = nt === 0 ? rt : [""], ht = sizeof(pt), mt = 0, yt = 0, Et = 0; mt < tt; ++mt)
        for (var _t = 0, wt = substr(_e, dt + 1, dt = abs$2(yt = it[mt])), St = _e; _t < ht; ++_t)
            (St = trim$1(yt > 0 ? pt[_t] + " " + wt : replace(wt, /&\f/g, pt[_t]))) && (st[Et++] = St);
    return node(_e, $, et, nt === 0 ? RULESET : ot, st, lt, ct)
}
function comment(_e, $, et) {
    return node(_e, $, et, COMMENT, from(char()), substr(_e, 2, -2), 0)
}
function declaration(_e, $, et, tt) {
    return node(_e, $, et, DECLARATION, substr(_e, 0, tt), substr(_e, tt + 1, -1), tt)
}
function serialize(_e, $) {
    for (var et = "", tt = sizeof(_e), nt = 0; nt < tt; nt++)
        et += $(_e[nt], nt, _e, $) || "";
    return et
}
function stringify(_e, $, et, tt) {
    switch (_e.type) {
    case LAYER:
        if (_e.children.length)
            break;
    case IMPORT:
    case DECLARATION:
        return _e.return = _e.return || _e.value;
    case COMMENT:
        return "";
    case KEYFRAMES:
        return _e.return = _e.value + "{" + serialize(_e.children, tt) + "}";
    case RULESET:
        _e.value = _e.props.join(",")
    }
    return strlen(et = serialize(_e.children, tt)) ? _e.return = _e.value + "{" + et + "}" : ""
}
function middleware(_e) {
    var $ = sizeof(_e);
    return function(et, tt, nt, rt) {
        for (var it = "", ot = 0; ot < $; ot++)
            it += _e[ot](et, tt, nt, rt) || "";
        return it
    }
}
function rulesheet(_e) {
    return function($) {
        $.root || ($ = $.return) && _e($)
    }
}
function memoize$5(_e) {
    var $ = Object.create(null);
    return function(et) {
        return $[et] === void 0 && ($[et] = _e(et)),
        $[et]
    }
}
var identifierWithPointTracking = function($, et, tt) {
    for (var nt = 0, rt = 0; nt = rt,
    rt = peek(),
    nt === 38 && rt === 12 && (et[tt] = 1),
    !token(rt); )
        next();
    return slice($, position)
}
  , toRules = function($, et) {
    var tt = -1
      , nt = 44;
    do
        switch (token(nt)) {
        case 0:
            nt === 38 && peek() === 12 && (et[tt] = 1),
            $[tt] += identifierWithPointTracking(position - 1, et, tt);
            break;
        case 2:
            $[tt] += delimit(nt);
            break;
        case 4:
            if (nt === 44) {
                $[++tt] = peek() === 58 ? "&\f" : "",
                et[tt] = $[tt].length;
                break
            }
        default:
            $[tt] += from(nt)
        }
    while (nt = next());
    return $
}
  , getRules = function($, et) {
    return dealloc(toRules(alloc($), et))
}
  , fixedElements = new WeakMap
  , compat = function($) {
    if (!($.type !== "rule" || !$.parent || $.length < 1)) {
        for (var et = $.value, tt = $.parent, nt = $.column === tt.column && $.line === tt.line; tt.type !== "rule"; )
            if (tt = tt.parent,
            !tt)
                return;
        if (!($.props.length === 1 && et.charCodeAt(0) !== 58 && !fixedElements.get(tt)) && !nt) {
            fixedElements.set($, !0);
            for (var rt = [], it = getRules(et, rt), ot = tt.props, st = 0, lt = 0; st < it.length; st++)
                for (var ct = 0; ct < ot.length; ct++,
                lt++)
                    $.props[lt] = rt[st] ? it[st].replace(/&\f/g, ot[ct]) : ot[ct] + " " + it[st]
        }
    }
}
  , removeLabel = function($) {
    if ($.type === "decl") {
        var et = $.value;
        et.charCodeAt(0) === 108 && et.charCodeAt(2) === 98 && ($.return = "",
        $.value = "")
    }
};
function prefix(_e, $) {
    switch (hash(_e, $)) {
    case 5103:
        return WEBKIT + "print-" + _e + _e;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
        return WEBKIT + _e + _e;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
        return WEBKIT + _e + MOZ + _e + MS + _e + _e;
    case 6828:
    case 4268:
        return WEBKIT + _e + MS + _e + _e;
    case 6165:
        return WEBKIT + _e + MS + "flex-" + _e + _e;
    case 5187:
        return WEBKIT + _e + replace(_e, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + _e;
    case 5443:
        return WEBKIT + _e + MS + "flex-item-" + replace(_e, /flex-|-self/, "") + _e;
    case 4675:
        return WEBKIT + _e + MS + "flex-line-pack" + replace(_e, /align-content|flex-|-self/, "") + _e;
    case 5548:
        return WEBKIT + _e + MS + replace(_e, "shrink", "negative") + _e;
    case 5292:
        return WEBKIT + _e + MS + replace(_e, "basis", "preferred-size") + _e;
    case 6060:
        return WEBKIT + "box-" + replace(_e, "-grow", "") + WEBKIT + _e + MS + replace(_e, "grow", "positive") + _e;
    case 4554:
        return WEBKIT + replace(_e, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + _e;
    case 6187:
        return replace(replace(replace(_e, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), _e, "") + _e;
    case 5495:
    case 3959:
        return replace(_e, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
        return replace(replace(_e, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + _e + _e;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
        return replace(_e, /(.+)-inline(.+)/, WEBKIT + "$1$2") + _e;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
        if (strlen(_e) - 1 - $ > 6)
            switch (charat(_e, $ + 1)) {
            case 109:
                if (charat(_e, $ + 4) !== 45)
                    break;
            case 102:
                return replace(_e, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(_e, $ + 3) == 108 ? "$3" : "$2-$3")) + _e;
            case 115:
                return ~indexof(_e, "stretch") ? prefix(replace(_e, "stretch", "fill-available"), $) + _e : _e
            }
        break;
    case 4949:
        if (charat(_e, $ + 1) !== 115)
            break;
    case 6444:
        switch (charat(_e, strlen(_e) - 3 - (~indexof(_e, "!important") && 10))) {
        case 107:
            return replace(_e, ":", ":" + WEBKIT) + _e;
        case 101:
            return replace(_e, /(.+:)([^;!]+)(;|!.+)?/, "$1" + WEBKIT + (charat(_e, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + _e
        }
        break;
    case 5936:
        switch (charat(_e, $ + 11)) {
        case 114:
            return WEBKIT + _e + MS + replace(_e, /[svh]\w+-[tblr]{2}/, "tb") + _e;
        case 108:
            return WEBKIT + _e + MS + replace(_e, /[svh]\w+-[tblr]{2}/, "tb-rl") + _e;
        case 45:
            return WEBKIT + _e + MS + replace(_e, /[svh]\w+-[tblr]{2}/, "lr") + _e
        }
        return WEBKIT + _e + MS + _e + _e
    }
    return _e
}
var prefixer = function($, et, tt, nt) {
    if ($.length > -1 && !$.return)
        switch ($.type) {
        case DECLARATION:
            $.return = prefix($.value, $.length);
            break;
        case KEYFRAMES:
            return serialize([copy$2($, {
                value: replace($.value, "@", "@" + WEBKIT)
            })], nt);
        case RULESET:
            if ($.length)
                return combine($.props, function(rt) {
                    switch (match(rt, /(::plac\w+|:read-\w+)/)) {
                    case ":read-only":
                    case ":read-write":
                        return serialize([copy$2($, {
                            props: [replace(rt, /:(read-\w+)/, ":" + MOZ + "$1")]
                        })], nt);
                    case "::placeholder":
                        return serialize([copy$2($, {
                            props: [replace(rt, /:(plac\w+)/, ":" + WEBKIT + "input-$1")]
                        }), copy$2($, {
                            props: [replace(rt, /:(plac\w+)/, ":" + MOZ + "$1")]
                        }), copy$2($, {
                            props: [replace(rt, /:(plac\w+)/, MS + "input-$1")]
                        })], nt)
                    }
                    return ""
                })
        }
}
  , defaultStylisPlugins = [prefixer]
  , createCache = function($) {
    var et = $.key;
    if (et === "css") {
        var tt = document.querySelectorAll("style[data-emotion]:not([data-s])");
        Array.prototype.forEach.call(tt, function(yt) {
            var Et = yt.getAttribute("data-emotion");
            Et.indexOf(" ") !== -1 && (document.head.appendChild(yt),
            yt.setAttribute("data-s", ""))
        })
    }
    var nt = $.stylisPlugins || defaultStylisPlugins, rt = {}, it, ot = [];
    it = $.container || document.head,
    Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="' + et + ' "]'), function(yt) {
        for (var Et = yt.getAttribute("data-emotion").split(" "), _t = 1; _t < Et.length; _t++)
            rt[Et[_t]] = !0;
        ot.push(yt)
    });
    var st, lt = [compat, removeLabel];
    {
        var ct, dt = [stringify, rulesheet(function(yt) {
            ct.insert(yt)
        })], pt = middleware(lt.concat(nt, dt)), ht = function(Et) {
            return serialize(compile(Et), pt)
        };
        st = function(Et, _t, wt, St) {
            ct = wt,
            ht(Et ? Et + "{" + _t.styles + "}" : _t.styles),
            St && (mt.inserted[_t.name] = !0)
        }
    }
    var mt = {
        key: et,
        sheet: new StyleSheet({
            key: et,
            container: it,
            nonce: $.nonce,
            speedy: $.speedy,
            prepend: $.prepend,
            insertionPoint: $.insertionPoint
        }),
        nonce: $.nonce,
        inserted: rt,
        registered: {},
        insert: st
    };
    return mt.sheet.hydrate(ot),
    mt
}
  , reactIs$2 = {
    exports: {}
}
  , reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = typeof Symbol == "function" && Symbol.for
  , c = b ? Symbol.for("react.element") : 60103
  , d = b ? Symbol.for("react.portal") : 60106
  , e = b ? Symbol.for("react.fragment") : 60107
  , f = b ? Symbol.for("react.strict_mode") : 60108
  , g = b ? Symbol.for("react.profiler") : 60114
  , h = b ? Symbol.for("react.provider") : 60109
  , k$1 = b ? Symbol.for("react.context") : 60110
  , l = b ? Symbol.for("react.async_mode") : 60111
  , m = b ? Symbol.for("react.concurrent_mode") : 60111
  , n = b ? Symbol.for("react.forward_ref") : 60112
  , p = b ? Symbol.for("react.suspense") : 60113
  , q = b ? Symbol.for("react.suspense_list") : 60120
  , r$1 = b ? Symbol.for("react.memo") : 60115
  , t = b ? Symbol.for("react.lazy") : 60116
  , v = b ? Symbol.for("react.block") : 60121
  , w = b ? Symbol.for("react.fundamental") : 60117
  , x = b ? Symbol.for("react.responder") : 60118
  , y = b ? Symbol.for("react.scope") : 60119;
function z(_e) {
    if (typeof _e == "object" && _e !== null) {
        var $ = _e.$$typeof;
        switch ($) {
        case c:
            switch (_e = _e.type,
            _e) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
                return _e;
            default:
                switch (_e = _e && _e.$$typeof,
                _e) {
                case k$1:
                case n:
                case t:
                case r$1:
                case h:
                    return _e;
                default:
                    return $
                }
            }
        case d:
            return $
        }
    }
}
function A(_e) {
    return z(_e) === m
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k$1;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r$1;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function(_e) {
    return A(_e) || z(_e) === l
}
;
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(_e) {
    return z(_e) === k$1
}
;
reactIs_production_min.isContextProvider = function(_e) {
    return z(_e) === h
}
;
reactIs_production_min.isElement = function(_e) {
    return typeof _e == "object" && _e !== null && _e.$$typeof === c
}
;
reactIs_production_min.isForwardRef = function(_e) {
    return z(_e) === n
}
;
reactIs_production_min.isFragment = function(_e) {
    return z(_e) === e
}
;
reactIs_production_min.isLazy = function(_e) {
    return z(_e) === t
}
;
reactIs_production_min.isMemo = function(_e) {
    return z(_e) === r$1
}
;
reactIs_production_min.isPortal = function(_e) {
    return z(_e) === d
}
;
reactIs_production_min.isProfiler = function(_e) {
    return z(_e) === g
}
;
reactIs_production_min.isStrictMode = function(_e) {
    return z(_e) === f
}
;
reactIs_production_min.isSuspense = function(_e) {
    return z(_e) === p
}
;
reactIs_production_min.isValidElementType = function(_e) {
    return typeof _e == "string" || typeof _e == "function" || _e === e || _e === m || _e === g || _e === f || _e === p || _e === q || typeof _e == "object" && _e !== null && (_e.$$typeof === t || _e.$$typeof === r$1 || _e.$$typeof === h || _e.$$typeof === k$1 || _e.$$typeof === n || _e.$$typeof === w || _e.$$typeof === x || _e.$$typeof === y || _e.$$typeof === v)
}
;
reactIs_production_min.typeOf = z;
reactIs$2.exports = reactIs_production_min;
var reactIsExports$1 = reactIs$2.exports
  , reactIs$1 = reactIsExports$1
  , FORWARD_REF_STATICS = {
    $$typeof: !0,
    render: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0
}
  , MEMO_STATICS = {
    $$typeof: !0,
    compare: !0,
    defaultProps: !0,
    displayName: !0,
    propTypes: !0,
    type: !0
}
  , TYPE_STATICS = {};
TYPE_STATICS[reactIs$1.ForwardRef] = FORWARD_REF_STATICS;
TYPE_STATICS[reactIs$1.Memo] = MEMO_STATICS;
var isBrowser$1 = !0;
function getRegisteredStyles(_e, $, et) {
    var tt = "";
    return et.split(" ").forEach(function(nt) {
        _e[nt] !== void 0 ? $.push(_e[nt] + ";") : nt && (tt += nt + " ")
    }),
    tt
}
var registerStyles = function($, et, tt) {
    var nt = $.key + "-" + et.name;
    (tt === !1 || isBrowser$1 === !1) && $.registered[nt] === void 0 && ($.registered[nt] = et.styles)
}
  , insertStyles = function($, et, tt) {
    registerStyles($, et, tt);
    var nt = $.key + "-" + et.name;
    if ($.inserted[et.name] === void 0) {
        var rt = et;
        do
            $.insert(et === rt ? "." + nt : "", rt, $.sheet, !0),
            rt = rt.next;
        while (rt !== void 0)
    }
};
function murmur2(_e) {
    for (var $ = 0, et, tt = 0, nt = _e.length; nt >= 4; ++tt,
    nt -= 4)
        et = _e.charCodeAt(tt) & 255 | (_e.charCodeAt(++tt) & 255) << 8 | (_e.charCodeAt(++tt) & 255) << 16 | (_e.charCodeAt(++tt) & 255) << 24,
        et = (et & 65535) * 1540483477 + ((et >>> 16) * 59797 << 16),
        et ^= et >>> 24,
        $ = (et & 65535) * 1540483477 + ((et >>> 16) * 59797 << 16) ^ ($ & 65535) * 1540483477 + (($ >>> 16) * 59797 << 16);
    switch (nt) {
    case 3:
        $ ^= (_e.charCodeAt(tt + 2) & 255) << 16;
    case 2:
        $ ^= (_e.charCodeAt(tt + 1) & 255) << 8;
    case 1:
        $ ^= _e.charCodeAt(tt) & 255,
        $ = ($ & 65535) * 1540483477 + (($ >>> 16) * 59797 << 16)
    }
    return $ ^= $ >>> 13,
    $ = ($ & 65535) * 1540483477 + (($ >>> 16) * 59797 << 16),
    (($ ^ $ >>> 15) >>> 0).toString(36)
}
var unitlessKeys = {
    animationIterationCount: 1,
    aspectRatio: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    scale: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
}
  , hyphenateRegex = /[A-Z]|^ms/g
  , animationRegex = /_EMO_([^_]+?)_([^]*?)_EMO_/g
  , isCustomProperty = function($) {
    return $.charCodeAt(1) === 45
}
  , isProcessableValue = function($) {
    return $ != null && typeof $ != "boolean"
}
  , processStyleName = memoize$5(function(_e) {
    return isCustomProperty(_e) ? _e : _e.replace(hyphenateRegex, "-$&").toLowerCase()
})
  , processStyleValue = function($, et) {
    switch ($) {
    case "animation":
    case "animationName":
        if (typeof et == "string")
            return et.replace(animationRegex, function(tt, nt, rt) {
                return cursor = {
                    name: nt,
                    styles: rt,
                    next: cursor
                },
                nt
            })
    }
    return unitlessKeys[$] !== 1 && !isCustomProperty($) && typeof et == "number" && et !== 0 ? et + "px" : et
};
function handleInterpolation(_e, $, et) {
    if (et == null)
        return "";
    var tt = et;
    if (tt.__emotion_styles !== void 0)
        return tt;
    switch (typeof et) {
    case "boolean":
        return "";
    case "object":
        {
            var nt = et;
            if (nt.anim === 1)
                return cursor = {
                    name: nt.name,
                    styles: nt.styles,
                    next: cursor
                },
                nt.name;
            var rt = et;
            if (rt.styles !== void 0) {
                var it = rt.next;
                if (it !== void 0)
                    for (; it !== void 0; )
                        cursor = {
                            name: it.name,
                            styles: it.styles,
                            next: cursor
                        },
                        it = it.next;
                var ot = rt.styles + ";";
                return ot
            }
            return createStringFromObject(_e, $, et)
        }
    case "function":
        {
            if (_e !== void 0) {
                var st = cursor
                  , lt = et(_e);
                return cursor = st,
                handleInterpolation(_e, $, lt)
            }
            break
        }
    }
    var ct = et;
    if ($ == null)
        return ct;
    var dt = $[ct];
    return dt !== void 0 ? dt : ct
}
function createStringFromObject(_e, $, et) {
    var tt = "";
    if (Array.isArray(et))
        for (var nt = 0; nt < et.length; nt++)
            tt += handleInterpolation(_e, $, et[nt]) + ";";
    else
        for (var rt in et) {
            var it = et[rt];
            if (typeof it != "object") {
                var ot = it;
                $ != null && $[ot] !== void 0 ? tt += rt + "{" + $[ot] + "}" : isProcessableValue(ot) && (tt += processStyleName(rt) + ":" + processStyleValue(rt, ot) + ";")
            } else if (Array.isArray(it) && typeof it[0] == "string" && ($ == null || $[it[0]] === void 0))
                for (var st = 0; st < it.length; st++)
                    isProcessableValue(it[st]) && (tt += processStyleName(rt) + ":" + processStyleValue(rt, it[st]) + ";");
            else {
                var lt = handleInterpolation(_e, $, it);
                switch (rt) {
                case "animation":
                case "animationName":
                    {
                        tt += processStyleName(rt) + ":" + lt + ";";
                        break
                    }
                default:
                    tt += rt + "{" + lt + "}"
                }
            }
        }
    return tt
}
var labelPattern = /label:\s*([^\s;{]+)\s*(;|$)/g, cursor;
function serializeStyles(_e, $, et) {
    if (_e.length === 1 && typeof _e[0] == "object" && _e[0] !== null && _e[0].styles !== void 0)
        return _e[0];
    var tt = !0
      , nt = "";
    cursor = void 0;
    var rt = _e[0];
    if (rt == null || rt.raw === void 0)
        tt = !1,
        nt += handleInterpolation(et, $, rt);
    else {
        var it = rt;
        nt += it[0]
    }
    for (var ot = 1; ot < _e.length; ot++)
        if (nt += handleInterpolation(et, $, _e[ot]),
        tt) {
            var st = rt;
            nt += st[ot]
        }
    labelPattern.lastIndex = 0;
    for (var lt = "", ct; (ct = labelPattern.exec(nt)) !== null; )
        lt += "-" + ct[1];
    var dt = murmur2(nt) + lt;
    return {
        name: dt,
        styles: nt,
        next: cursor
    }
}
var syncFallback = function($) {
    return $()
}
  , useInsertionEffect = React$1.useInsertionEffect ? React$1.useInsertionEffect : !1
  , useInsertionEffectAlwaysWithSyncFallback = useInsertionEffect || syncFallback
  , useInsertionEffectWithLayoutFallback = useInsertionEffect || reactExports.useLayoutEffect
  , EmotionCacheContext = reactExports.createContext(typeof HTMLElement < "u" ? createCache({
    key: "css"
}) : null);
EmotionCacheContext.Provider;
var withEmotionCache = function($) {
    return reactExports.forwardRef(function(et, tt) {
        var nt = reactExports.useContext(EmotionCacheContext);
        return $(et, nt, tt)
    })
}
  , ThemeContext$1 = reactExports.createContext({})
  , hasOwn = {}.hasOwnProperty
  , typePropName = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__"
  , createEmotionProps = function($, et) {
    var tt = {};
    for (var nt in et)
        hasOwn.call(et, nt) && (tt[nt] = et[nt]);
    return tt[typePropName] = $,
    tt
}
  , Insertion$1 = function($) {
    var et = $.cache
      , tt = $.serialized
      , nt = $.isStringTag;
    return registerStyles(et, tt, nt),
    useInsertionEffectAlwaysWithSyncFallback(function() {
        return insertStyles(et, tt, nt)
    }),
    null
}
  , Emotion = withEmotionCache(function(_e, $, et) {
    var tt = _e.css;
    typeof tt == "string" && $.registered[tt] !== void 0 && (tt = $.registered[tt]);
    var nt = _e[typePropName]
      , rt = [tt]
      , it = "";
    typeof _e.className == "string" ? it = getRegisteredStyles($.registered, rt, _e.className) : _e.className != null && (it = _e.className + " ");
    var ot = serializeStyles(rt, void 0, reactExports.useContext(ThemeContext$1));
    it += $.key + "-" + ot.name;
    var st = {};
    for (var lt in _e)
        hasOwn.call(_e, lt) && lt !== "css" && lt !== typePropName && (st[lt] = _e[lt]);
    return st.className = it,
    et && (st.ref = et),
    reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Insertion$1, {
        cache: $,
        serialized: ot,
        isStringTag: typeof nt == "string"
    }), reactExports.createElement(nt, st))
})
  , Emotion$1 = Emotion
  , jsx = function($, et) {
    var tt = arguments;
    if (et == null || !hasOwn.call(et, "css"))
        return reactExports.createElement.apply(void 0, tt);
    var nt = tt.length
      , rt = new Array(nt);
    rt[0] = Emotion$1,
    rt[1] = createEmotionProps($, et);
    for (var it = 2; it < nt; it++)
        rt[it] = tt[it];
    return reactExports.createElement.apply(null, rt)
};
(function(_e) {
    var $;
    $ || ($ = _e.JSX || (_e.JSX = {}))
}
)(jsx || (jsx = {}));
var Global = withEmotionCache(function(_e, $) {
    var et = _e.styles
      , tt = serializeStyles([et], void 0, reactExports.useContext(ThemeContext$1))
      , nt = reactExports.useRef();
    return useInsertionEffectWithLayoutFallback(function() {
        var rt = $.key + "-global"
          , it = new $.sheet.constructor({
            key: rt,
            nonce: $.sheet.nonce,
            container: $.sheet.container,
            speedy: $.sheet.isSpeedy
        })
          , ot = !1
          , st = document.querySelector('style[data-emotion="' + rt + " " + tt.name + '"]');
        return $.sheet.tags.length && (it.before = $.sheet.tags[0]),
        st !== null && (ot = !0,
        st.setAttribute("data-emotion", rt),
        it.hydrate([st])),
        nt.current = [it, ot],
        function() {
            it.flush()
        }
    }, [$]),
    useInsertionEffectWithLayoutFallback(function() {
        var rt = nt.current
          , it = rt[0]
          , ot = rt[1];
        if (ot) {
            rt[1] = !1;
            return
        }
        if (tt.next !== void 0 && insertStyles($, tt.next, !0),
        it.tags.length) {
            var st = it.tags[it.tags.length - 1].nextElementSibling;
            it.before = st,
            it.flush()
        }
        $.insert("", tt, it, !1)
    }, [$, tt.name]),
    null
});
function css() {
    for (var _e = arguments.length, $ = new Array(_e), et = 0; et < _e; et++)
        $[et] = arguments[et];
    return serializeStyles($)
}
function keyframes() {
    var _e = css.apply(void 0, arguments)
      , $ = "animation-" + _e.name;
    return {
        name: $,
        styles: "@keyframes " + $ + "{" + _e.styles + "}",
        anim: 1,
        toString: function() {
            return "_EMO_" + this.name + "_" + this.styles + "_EMO_"
        }
    }
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/
  , isPropValid = memoize$5(function(_e) {
    return reactPropsRegex.test(_e) || _e.charCodeAt(0) === 111 && _e.charCodeAt(1) === 110 && _e.charCodeAt(2) < 91
})
  , testOmitPropsOnStringTag = isPropValid
  , testOmitPropsOnComponent = function($) {
    return $ !== "theme"
}
  , getDefaultShouldForwardProp = function($) {
    return typeof $ == "string" && $.charCodeAt(0) > 96 ? testOmitPropsOnStringTag : testOmitPropsOnComponent
}
  , composeShouldForwardProps = function($, et, tt) {
    var nt;
    if (et) {
        var rt = et.shouldForwardProp;
        nt = $.__emotion_forwardProp && rt ? function(it) {
            return $.__emotion_forwardProp(it) && rt(it)
        }
        : rt
    }
    return typeof nt != "function" && tt && (nt = $.__emotion_forwardProp),
    nt
}
  , Insertion = function($) {
    var et = $.cache
      , tt = $.serialized
      , nt = $.isStringTag;
    return registerStyles(et, tt, nt),
    useInsertionEffectAlwaysWithSyncFallback(function() {
        return insertStyles(et, tt, nt)
    }),
    null
}
  , createStyled$1 = function _e($, et) {
    var tt = $.__emotion_real === $, nt = tt && $.__emotion_base || $, rt, it;
    et !== void 0 && (rt = et.label,
    it = et.target);
    var ot = composeShouldForwardProps($, et, tt)
      , st = ot || getDefaultShouldForwardProp(nt)
      , lt = !st("as");
    return function() {
        var ct = arguments
          , dt = tt && $.__emotion_styles !== void 0 ? $.__emotion_styles.slice(0) : [];
        if (rt !== void 0 && dt.push("label:" + rt + ";"),
        ct[0] == null || ct[0].raw === void 0)
            dt.push.apply(dt, ct);
        else {
            var pt = ct[0];
            dt.push(pt[0]);
            for (var ht = ct.length, mt = 1; mt < ht; mt++)
                dt.push(ct[mt], pt[mt])
        }
        var yt = withEmotionCache(function(Et, _t, wt) {
            var St = lt && Et.as || nt
              , Ct = ""
              , Nt = []
              , Lt = Et;
            if (Et.theme == null) {
                Lt = {};
                for (var kt in Et)
                    Lt[kt] = Et[kt];
                Lt.theme = reactExports.useContext(ThemeContext$1)
            }
            typeof Et.className == "string" ? Ct = getRegisteredStyles(_t.registered, Nt, Et.className) : Et.className != null && (Ct = Et.className + " ");
            var Ut = serializeStyles(dt.concat(Nt), _t.registered, Lt);
            Ct += _t.key + "-" + Ut.name,
            it !== void 0 && (Ct += " " + it);
            var Jt = lt && ot === void 0 ? getDefaultShouldForwardProp(St) : st
              , Pt = {};
            for (var Xt in Et)
                lt && Xt === "as" || Jt(Xt) && (Pt[Xt] = Et[Xt]);
            return Pt.className = Ct,
            wt && (Pt.ref = wt),
            reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(Insertion, {
                cache: _t,
                serialized: Ut,
                isStringTag: typeof St == "string"
            }), reactExports.createElement(St, Pt))
        });
        return yt.displayName = rt !== void 0 ? rt : "Styled(" + (typeof nt == "string" ? nt : nt.displayName || nt.name || "Component") + ")",
        yt.defaultProps = $.defaultProps,
        yt.__emotion_real = yt,
        yt.__emotion_base = nt,
        yt.__emotion_styles = dt,
        yt.__emotion_forwardProp = ot,
        Object.defineProperty(yt, "toString", {
            value: function() {
                return "." + it
            }
        }),
        yt.withComponent = function(Et, _t) {
            var wt = _e(Et, _extends$3({}, et, _t, {
                shouldForwardProp: composeShouldForwardProps(yt, _t, !0)
            }));
            return wt.apply(void 0, dt)
        }
        ,
        yt
    }
}
  , tags = ["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]
  , newStyled = createStyled$1.bind(null);
tags.forEach(function(_e) {
    newStyled[_e] = newStyled(_e)
});
var propTypes = {
    exports: {}
}
  , ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"
  , ReactPropTypesSecret_1 = ReactPropTypesSecret$1
  , ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {}
function emptyFunctionWithReset() {}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
    function _e(tt, nt, rt, it, ot, st) {
        if (st !== ReactPropTypesSecret) {
            var lt = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
            throw lt.name = "Invariant Violation",
            lt
        }
    }
    _e.isRequired = _e;
    function $() {
        return _e
    }
    var et = {
        array: _e,
        bigint: _e,
        bool: _e,
        func: _e,
        number: _e,
        object: _e,
        string: _e,
        symbol: _e,
        any: _e,
        arrayOf: $,
        element: _e,
        elementType: _e,
        instanceOf: $,
        node: _e,
        objectOf: $,
        oneOf: $,
        oneOfType: $,
        shape: $,
        exact: $,
        checkPropTypes: emptyFunctionWithReset,
        resetWarningCache: emptyFunction
    };
    return et.PropTypes = et,
    et
};
propTypes.exports = factoryWithThrowingShims();
var propTypesExports = propTypes.exports;
const PropTypes = getDefaultExportFromCjs$2(propTypesExports);
function isEmpty$1(_e) {
    return _e == null || Object.keys(_e).length === 0
}
function GlobalStyles$3(_e) {
    const {styles: $, defaultTheme: et={}} = _e
      , tt = typeof $ == "function" ? nt => $(isEmpty$1(nt) ? et : nt) : $;
    return jsxRuntimeExports.jsx(Global, {
        styles: tt
    })
}
/**
 * @mui/styled-engine v6.4.3
 *
 * @license MIT
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
function styled$2(_e, $) {
    return newStyled(_e, $)
}
function internal_mutateStyles(_e, $) {
    Array.isArray(_e.__emotion_styles) && (_e.__emotion_styles = $(_e.__emotion_styles))
}
const wrapper = [];
function internal_serializeStyles(_e) {
    return wrapper[0] = _e,
    serializeStyles(wrapper)
}
var reactIs = {
    exports: {}
}
  , reactIs_production = {};
/**
 * @license React
 * react-is.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var REACT_ELEMENT_TYPE$1 = Symbol.for("react.transitional.element")
  , REACT_PORTAL_TYPE = Symbol.for("react.portal")
  , REACT_FRAGMENT_TYPE = Symbol.for("react.fragment")
  , REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode")
  , REACT_PROFILER_TYPE = Symbol.for("react.profiler")
  , REACT_CONSUMER_TYPE = Symbol.for("react.consumer")
  , REACT_CONTEXT_TYPE = Symbol.for("react.context")
  , REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref")
  , REACT_SUSPENSE_TYPE = Symbol.for("react.suspense")
  , REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list")
  , REACT_MEMO_TYPE = Symbol.for("react.memo")
  , REACT_LAZY_TYPE = Symbol.for("react.lazy")
  , REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen")
  , REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
function typeOf(_e) {
    if (typeof _e == "object" && _e !== null) {
        var $ = _e.$$typeof;
        switch ($) {
        case REACT_ELEMENT_TYPE$1:
            switch (_e = _e.type,
            _e) {
            case REACT_FRAGMENT_TYPE:
            case REACT_PROFILER_TYPE:
            case REACT_STRICT_MODE_TYPE:
            case REACT_SUSPENSE_TYPE:
            case REACT_SUSPENSE_LIST_TYPE:
                return _e;
            default:
                switch (_e = _e && _e.$$typeof,
                _e) {
                case REACT_CONTEXT_TYPE:
                case REACT_FORWARD_REF_TYPE:
                case REACT_LAZY_TYPE:
                case REACT_MEMO_TYPE:
                    return _e;
                case REACT_CONSUMER_TYPE:
                    return _e;
                default:
                    return $
                }
            }
        case REACT_PORTAL_TYPE:
            return $
        }
    }
}
reactIs_production.ContextConsumer = REACT_CONSUMER_TYPE;
reactIs_production.ContextProvider = REACT_CONTEXT_TYPE;
reactIs_production.Element = REACT_ELEMENT_TYPE$1;
reactIs_production.ForwardRef = REACT_FORWARD_REF_TYPE;
reactIs_production.Fragment = REACT_FRAGMENT_TYPE;
reactIs_production.Lazy = REACT_LAZY_TYPE;
reactIs_production.Memo = REACT_MEMO_TYPE;
reactIs_production.Portal = REACT_PORTAL_TYPE;
reactIs_production.Profiler = REACT_PROFILER_TYPE;
reactIs_production.StrictMode = REACT_STRICT_MODE_TYPE;
reactIs_production.Suspense = REACT_SUSPENSE_TYPE;
reactIs_production.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
reactIs_production.isContextConsumer = function(_e) {
    return typeOf(_e) === REACT_CONSUMER_TYPE
}
;
reactIs_production.isContextProvider = function(_e) {
    return typeOf(_e) === REACT_CONTEXT_TYPE
}
;
reactIs_production.isElement = function(_e) {
    return typeof _e == "object" && _e !== null && _e.$$typeof === REACT_ELEMENT_TYPE$1
}
;
reactIs_production.isForwardRef = function(_e) {
    return typeOf(_e) === REACT_FORWARD_REF_TYPE
}
;
reactIs_production.isFragment = function(_e) {
    return typeOf(_e) === REACT_FRAGMENT_TYPE
}
;
reactIs_production.isLazy = function(_e) {
    return typeOf(_e) === REACT_LAZY_TYPE
}
;
reactIs_production.isMemo = function(_e) {
    return typeOf(_e) === REACT_MEMO_TYPE
}
;
reactIs_production.isPortal = function(_e) {
    return typeOf(_e) === REACT_PORTAL_TYPE
}
;
reactIs_production.isProfiler = function(_e) {
    return typeOf(_e) === REACT_PROFILER_TYPE
}
;
reactIs_production.isStrictMode = function(_e) {
    return typeOf(_e) === REACT_STRICT_MODE_TYPE
}
;
reactIs_production.isSuspense = function(_e) {
    return typeOf(_e) === REACT_SUSPENSE_TYPE
}
;
reactIs_production.isSuspenseList = function(_e) {
    return typeOf(_e) === REACT_SUSPENSE_LIST_TYPE
}
;
reactIs_production.isValidElementType = function(_e) {
    return typeof _e == "string" || typeof _e == "function" || _e === REACT_FRAGMENT_TYPE || _e === REACT_PROFILER_TYPE || _e === REACT_STRICT_MODE_TYPE || _e === REACT_SUSPENSE_TYPE || _e === REACT_SUSPENSE_LIST_TYPE || _e === REACT_OFFSCREEN_TYPE || typeof _e == "object" && _e !== null && (_e.$$typeof === REACT_LAZY_TYPE || _e.$$typeof === REACT_MEMO_TYPE || _e.$$typeof === REACT_CONTEXT_TYPE || _e.$$typeof === REACT_CONSUMER_TYPE || _e.$$typeof === REACT_FORWARD_REF_TYPE || _e.$$typeof === REACT_CLIENT_REFERENCE || _e.getModuleId !== void 0)
}
;
reactIs_production.typeOf = typeOf;
reactIs.exports = reactIs_production;
var reactIsExports = reactIs.exports;
function isPlainObject$3(_e) {
    if (typeof _e != "object" || _e === null)
        return !1;
    const $ = Object.getPrototypeOf(_e);
    return ($ === null || $ === Object.prototype || Object.getPrototypeOf($) === null) && !(Symbol.toStringTag in _e) && !(Symbol.iterator in _e)
}
function deepClone(_e) {
    if (reactExports.isValidElement(_e) || reactIsExports.isValidElementType(_e) || !isPlainObject$3(_e))
        return _e;
    const $ = {};
    return Object.keys(_e).forEach(et => {
        $[et] = deepClone(_e[et])
    }
    ),
    $
}
function deepmerge$1(_e, $, et={
    clone: !0
}) {
    const tt = et.clone ? {
        ..._e
    } : _e;
    return isPlainObject$3(_e) && isPlainObject$3($) && Object.keys($).forEach(nt => {
        reactExports.isValidElement($[nt]) || reactIsExports.isValidElementType($[nt]) ? tt[nt] = $[nt] : isPlainObject$3($[nt]) && Object.prototype.hasOwnProperty.call(_e, nt) && isPlainObject$3(_e[nt]) ? tt[nt] = deepmerge$1(_e[nt], $[nt], et) : et.clone ? tt[nt] = isPlainObject$3($[nt]) ? deepClone($[nt]) : $[nt] : tt[nt] = $[nt]
    }
    ),
    tt
}
const sortBreakpointsValues = _e => {
    const $ = Object.keys(_e).map(et => ({
        key: et,
        val: _e[et]
    })) || [];
    return $.sort( (et, tt) => et.val - tt.val),
    $.reduce( (et, tt) => ({
        ...et,
        [tt.key]: tt.val
    }), {})
}
;
function createBreakpoints(_e) {
    const {values: $={
        xs: 0,
        sm: 600,
        md: 900,
        lg: 1200,
        xl: 1536
    }, unit: et="px", step: tt=5, ...nt} = _e
      , rt = sortBreakpointsValues($)
      , it = Object.keys(rt);
    function ot(pt) {
        return `@media (min-width:${typeof $[pt] == "number" ? $[pt] : pt}${et})`
    }
    function st(pt) {
        return `@media (max-width:${(typeof $[pt] == "number" ? $[pt] : pt) - tt / 100}${et})`
    }
    function lt(pt, ht) {
        const mt = it.indexOf(ht);
        return `@media (min-width:${typeof $[pt] == "number" ? $[pt] : pt}${et}) and (max-width:${(mt !== -1 && typeof $[it[mt]] == "number" ? $[it[mt]] : ht) - tt / 100}${et})`
    }
    function ct(pt) {
        return it.indexOf(pt) + 1 < it.length ? lt(pt, it[it.indexOf(pt) + 1]) : ot(pt)
    }
    function dt(pt) {
        const ht = it.indexOf(pt);
        return ht === 0 ? ot(it[1]) : ht === it.length - 1 ? st(it[ht]) : lt(pt, it[it.indexOf(pt) + 1]).replace("@media", "@media not all and")
    }
    return {
        keys: it,
        values: rt,
        up: ot,
        down: st,
        between: lt,
        only: ct,
        not: dt,
        unit: et,
        ...nt
    }
}
function sortContainerQueries(_e, $) {
    if (!_e.containerQueries)
        return $;
    const et = Object.keys($).filter(tt => tt.startsWith("@container")).sort( (tt, nt) => {
        var it, ot;
        const rt = /min-width:\s*([0-9.]+)/;
        return +(((it = tt.match(rt)) == null ? void 0 : it[1]) || 0) - +(((ot = nt.match(rt)) == null ? void 0 : ot[1]) || 0)
    }
    );
    return et.length ? et.reduce( (tt, nt) => {
        const rt = $[nt];
        return delete tt[nt],
        tt[nt] = rt,
        tt
    }
    , {
        ...$
    }) : $
}
function isCqShorthand(_e, $) {
    return $ === "@" || $.startsWith("@") && (_e.some(et => $.startsWith(`@${et}`)) || !!$.match(/^@\d/))
}
function getContainerQuery(_e, $) {
    const et = $.match(/^@([^/]+)?\/?(.+)?$/);
    if (!et)
        return null;
    const [,tt,nt] = et
      , rt = Number.isNaN(+tt) ? tt || 0 : +tt;
    return _e.containerQueries(nt).up(rt)
}
function cssContainerQueries(_e) {
    const $ = (rt, it) => rt.replace("@media", it ? `@container ${it}` : "@container");
    function et(rt, it) {
        rt.up = (...ot) => $(_e.breakpoints.up(...ot), it),
        rt.down = (...ot) => $(_e.breakpoints.down(...ot), it),
        rt.between = (...ot) => $(_e.breakpoints.between(...ot), it),
        rt.only = (...ot) => $(_e.breakpoints.only(...ot), it),
        rt.not = (...ot) => {
            const st = $(_e.breakpoints.not(...ot), it);
            return st.includes("not all and") ? st.replace("not all and ", "").replace("min-width:", "width<").replace("max-width:", "width>").replace("and", "or") : st
        }
    }
    const tt = {}
      , nt = rt => (et(tt, rt),
    tt);
    return et(nt),
    {
        ..._e,
        containerQueries: nt
    }
}
const shape = {
    borderRadius: 4
};
function merge$2(_e, $) {
    return $ ? deepmerge$1(_e, $, {
        clone: !1
    }) : _e
}
const values$1 = {
    xs: 0,
    sm: 600,
    md: 900,
    lg: 1200,
    xl: 1536
}
  , defaultBreakpoints = {
    keys: ["xs", "sm", "md", "lg", "xl"],
    up: _e => `@media (min-width:${values$1[_e]}px)`
}
  , defaultContainerQueries = {
    containerQueries: _e => ({
        up: $ => {
            let et = typeof $ == "number" ? $ : values$1[$] || $;
            return typeof et == "number" && (et = `${et}px`),
            _e ? `@container ${_e} (min-width:${et})` : `@container (min-width:${et})`
        }
    })
};
function handleBreakpoints(_e, $, et) {
    const tt = _e.theme || {};
    if (Array.isArray($)) {
        const rt = tt.breakpoints || defaultBreakpoints;
        return $.reduce( (it, ot, st) => (it[rt.up(rt.keys[st])] = et($[st]),
        it), {})
    }
    if (typeof $ == "object") {
        const rt = tt.breakpoints || defaultBreakpoints;
        return Object.keys($).reduce( (it, ot) => {
            if (isCqShorthand(rt.keys, ot)) {
                const st = getContainerQuery(tt.containerQueries ? tt : defaultContainerQueries, ot);
                st && (it[st] = et($[ot], ot))
            } else if (Object.keys(rt.values || values$1).includes(ot)) {
                const st = rt.up(ot);
                it[st] = et($[ot], ot)
            } else {
                const st = ot;
                it[st] = $[st]
            }
            return it
        }
        , {})
    }
    return et($)
}
function createEmptyBreakpointObject(_e={}) {
    var et;
    return ((et = _e.keys) == null ? void 0 : et.reduce( (tt, nt) => {
        const rt = _e.up(nt);
        return tt[rt] = {},
        tt
    }
    , {})) || {}
}
function removeUnusedBreakpoints(_e, $) {
    return _e.reduce( (et, tt) => {
        const nt = et[tt];
        return (!nt || Object.keys(nt).length === 0) && delete et[tt],
        et
    }
    , $)
}
function mergeBreakpointsInOrder(_e, ...$) {
    const et = createEmptyBreakpointObject(_e)
      , tt = [et, ...$].reduce( (nt, rt) => deepmerge$1(nt, rt), {});
    return removeUnusedBreakpoints(Object.keys(et), tt)
}
function computeBreakpointsBase(_e, $) {
    if (typeof _e != "object")
        return {};
    const et = {}
      , tt = Object.keys($);
    return Array.isArray(_e) ? tt.forEach( (nt, rt) => {
        rt < _e.length && (et[nt] = !0)
    }
    ) : tt.forEach(nt => {
        _e[nt] != null && (et[nt] = !0)
    }
    ),
    et
}
function resolveBreakpointValues({values: _e, breakpoints: $, base: et}) {
    const tt = et || computeBreakpointsBase(_e, $)
      , nt = Object.keys(tt);
    if (nt.length === 0)
        return _e;
    let rt;
    return nt.reduce( (it, ot, st) => (Array.isArray(_e) ? (it[ot] = _e[st] != null ? _e[st] : _e[rt],
    rt = st) : typeof _e == "object" ? (it[ot] = _e[ot] != null ? _e[ot] : _e[rt],
    rt = ot) : it[ot] = _e,
    it), {})
}
function capitalize(_e) {
    if (typeof _e != "string")
        throw new Error(formatMuiErrorMessage(7));
    return _e.charAt(0).toUpperCase() + _e.slice(1)
}
function getPath(_e, $, et=!0) {
    if (!$ || typeof $ != "string")
        return null;
    if (_e && _e.vars && et) {
        const tt = `vars.${$}`.split(".").reduce( (nt, rt) => nt && nt[rt] ? nt[rt] : null, _e);
        if (tt != null)
            return tt
    }
    return $.split(".").reduce( (tt, nt) => tt && tt[nt] != null ? tt[nt] : null, _e)
}
function getStyleValue$1(_e, $, et, tt=et) {
    let nt;
    return typeof _e == "function" ? nt = _e(et) : Array.isArray(_e) ? nt = _e[et] || tt : nt = getPath(_e, et) || tt,
    $ && (nt = $(nt, tt, _e)),
    nt
}
function style$2(_e) {
    const {prop: $, cssProperty: et=_e.prop, themeKey: tt, transform: nt} = _e
      , rt = it => {
        if (it[$] == null)
            return null;
        const ot = it[$]
          , st = it.theme
          , lt = getPath(st, tt) || {};
        return handleBreakpoints(it, ot, dt => {
            let pt = getStyleValue$1(lt, nt, dt);
            return dt === pt && typeof dt == "string" && (pt = getStyleValue$1(lt, nt, `${$}${dt === "default" ? "" : capitalize(dt)}`, dt)),
            et === !1 ? pt : {
                [et]: pt
            }
        }
        )
    }
    ;
    return rt.propTypes = {},
    rt.filterProps = [$],
    rt
}
function memoize$4(_e) {
    const $ = {};
    return et => ($[et] === void 0 && ($[et] = _e(et)),
    $[et])
}
const properties = {
    m: "margin",
    p: "padding"
}
  , directions = {
    t: "Top",
    r: "Right",
    b: "Bottom",
    l: "Left",
    x: ["Left", "Right"],
    y: ["Top", "Bottom"]
}
  , aliases = {
    marginX: "mx",
    marginY: "my",
    paddingX: "px",
    paddingY: "py"
}
  , getCssProperties = memoize$4(_e => {
    if (_e.length > 2)
        if (aliases[_e])
            _e = aliases[_e];
        else
            return [_e];
    const [$,et] = _e.split("")
      , tt = properties[$]
      , nt = directions[et] || "";
    return Array.isArray(nt) ? nt.map(rt => tt + rt) : [tt + nt]
}
)
  , marginKeys = ["m", "mt", "mr", "mb", "ml", "mx", "my", "margin", "marginTop", "marginRight", "marginBottom", "marginLeft", "marginX", "marginY", "marginInline", "marginInlineStart", "marginInlineEnd", "marginBlock", "marginBlockStart", "marginBlockEnd"]
  , paddingKeys = ["p", "pt", "pr", "pb", "pl", "px", "py", "padding", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "paddingX", "paddingY", "paddingInline", "paddingInlineStart", "paddingInlineEnd", "paddingBlock", "paddingBlockStart", "paddingBlockEnd"];
[...marginKeys, ...paddingKeys];
function createUnaryUnit(_e, $, et, tt) {
    const nt = getPath(_e, $, !0) ?? et;
    return typeof nt == "number" || typeof nt == "string" ? rt => typeof rt == "string" ? rt : typeof nt == "string" ? `calc(${rt} * ${nt})` : nt * rt : Array.isArray(nt) ? rt => {
        if (typeof rt == "string")
            return rt;
        const it = Math.abs(rt)
          , ot = nt[it];
        return rt >= 0 ? ot : typeof ot == "number" ? -ot : `-${ot}`
    }
    : typeof nt == "function" ? nt : () => {}
}
function createUnarySpacing(_e) {
    return createUnaryUnit(_e, "spacing", 8)
}
function getValue$4(_e, $) {
    return typeof $ == "string" || $ == null ? $ : _e($)
}
function getStyleFromPropValue(_e, $) {
    return et => _e.reduce( (tt, nt) => (tt[nt] = getValue$4($, et),
    tt), {})
}
function resolveCssProperty(_e, $, et, tt) {
    if (!$.includes(et))
        return null;
    const nt = getCssProperties(et)
      , rt = getStyleFromPropValue(nt, tt)
      , it = _e[et];
    return handleBreakpoints(_e, it, rt)
}
function style$1(_e, $) {
    const et = createUnarySpacing(_e.theme);
    return Object.keys(_e).map(tt => resolveCssProperty(_e, $, tt, et)).reduce(merge$2, {})
}
function margin(_e) {
    return style$1(_e, marginKeys)
}
margin.propTypes = {};
margin.filterProps = marginKeys;
function padding(_e) {
    return style$1(_e, paddingKeys)
}
padding.propTypes = {};
padding.filterProps = paddingKeys;
function createSpacing(_e=8, $=createUnarySpacing({
    spacing: _e
})) {
    if (_e.mui)
        return _e;
    const et = (...tt) => (tt.length === 0 ? [1] : tt).map(rt => {
        const it = $(rt);
        return typeof it == "number" ? `${it}px` : it
    }
    ).join(" ");
    return et.mui = !0,
    et
}
function compose(..._e) {
    const $ = _e.reduce( (tt, nt) => (nt.filterProps.forEach(rt => {
        tt[rt] = nt
    }
    ),
    tt), {})
      , et = tt => Object.keys(tt).reduce( (nt, rt) => $[rt] ? merge$2(nt, $[rt](tt)) : nt, {});
    return et.propTypes = {},
    et.filterProps = _e.reduce( (tt, nt) => tt.concat(nt.filterProps), []),
    et
}
function borderTransform(_e) {
    return typeof _e != "number" ? _e : `${_e}px solid`
}
function createBorderStyle(_e, $) {
    return style$2({
        prop: _e,
        themeKey: "borders",
        transform: $
    })
}
const border = createBorderStyle("border", borderTransform)
  , borderTop = createBorderStyle("borderTop", borderTransform)
  , borderRight = createBorderStyle("borderRight", borderTransform)
  , borderBottom = createBorderStyle("borderBottom", borderTransform)
  , borderLeft = createBorderStyle("borderLeft", borderTransform)
  , borderColor = createBorderStyle("borderColor")
  , borderTopColor = createBorderStyle("borderTopColor")
  , borderRightColor = createBorderStyle("borderRightColor")
  , borderBottomColor = createBorderStyle("borderBottomColor")
  , borderLeftColor = createBorderStyle("borderLeftColor")
  , outline = createBorderStyle("outline", borderTransform)
  , outlineColor = createBorderStyle("outlineColor")
  , borderRadius = _e => {
    if (_e.borderRadius !== void 0 && _e.borderRadius !== null) {
        const $ = createUnaryUnit(_e.theme, "shape.borderRadius", 4)
          , et = tt => ({
            borderRadius: getValue$4($, tt)
        });
        return handleBreakpoints(_e, _e.borderRadius, et)
    }
    return null
}
;
borderRadius.propTypes = {};
borderRadius.filterProps = ["borderRadius"];
compose(border, borderTop, borderRight, borderBottom, borderLeft, borderColor, borderTopColor, borderRightColor, borderBottomColor, borderLeftColor, borderRadius, outline, outlineColor);
const gap = _e => {
    if (_e.gap !== void 0 && _e.gap !== null) {
        const $ = createUnaryUnit(_e.theme, "spacing", 8)
          , et = tt => ({
            gap: getValue$4($, tt)
        });
        return handleBreakpoints(_e, _e.gap, et)
    }
    return null
}
;
gap.propTypes = {};
gap.filterProps = ["gap"];
const columnGap = _e => {
    if (_e.columnGap !== void 0 && _e.columnGap !== null) {
        const $ = createUnaryUnit(_e.theme, "spacing", 8)
          , et = tt => ({
            columnGap: getValue$4($, tt)
        });
        return handleBreakpoints(_e, _e.columnGap, et)
    }
    return null
}
;
columnGap.propTypes = {};
columnGap.filterProps = ["columnGap"];
const rowGap = _e => {
    if (_e.rowGap !== void 0 && _e.rowGap !== null) {
        const $ = createUnaryUnit(_e.theme, "spacing", 8)
          , et = tt => ({
            rowGap: getValue$4($, tt)
        });
        return handleBreakpoints(_e, _e.rowGap, et)
    }
    return null
}
;
rowGap.propTypes = {};
rowGap.filterProps = ["rowGap"];
const gridColumn = style$2({
    prop: "gridColumn"
})
  , gridRow = style$2({
    prop: "gridRow"
})
  , gridAutoFlow = style$2({
    prop: "gridAutoFlow"
})
  , gridAutoColumns = style$2({
    prop: "gridAutoColumns"
})
  , gridAutoRows = style$2({
    prop: "gridAutoRows"
})
  , gridTemplateColumns = style$2({
    prop: "gridTemplateColumns"
})
  , gridTemplateRows = style$2({
    prop: "gridTemplateRows"
})
  , gridTemplateAreas = style$2({
    prop: "gridTemplateAreas"
})
  , gridArea = style$2({
    prop: "gridArea"
});
compose(gap, columnGap, rowGap, gridColumn, gridRow, gridAutoFlow, gridAutoColumns, gridAutoRows, gridTemplateColumns, gridTemplateRows, gridTemplateAreas, gridArea);
function paletteTransform(_e, $) {
    return $ === "grey" ? $ : _e
}
const color = style$2({
    prop: "color",
    themeKey: "palette",
    transform: paletteTransform
})
  , bgcolor = style$2({
    prop: "bgcolor",
    cssProperty: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform
})
  , backgroundColor = style$2({
    prop: "backgroundColor",
    themeKey: "palette",
    transform: paletteTransform
});
compose(color, bgcolor, backgroundColor);
function sizingTransform(_e) {
    return _e <= 1 && _e !== 0 ? `${_e * 100}%` : _e
}
const width = style$2({
    prop: "width",
    transform: sizingTransform
})
  , maxWidth = _e => {
    if (_e.maxWidth !== void 0 && _e.maxWidth !== null) {
        const $ = et => {
            var nt, rt, it, ot, st;
            const tt = ((it = (rt = (nt = _e.theme) == null ? void 0 : nt.breakpoints) == null ? void 0 : rt.values) == null ? void 0 : it[et]) || values$1[et];
            return tt ? ((st = (ot = _e.theme) == null ? void 0 : ot.breakpoints) == null ? void 0 : st.unit) !== "px" ? {
                maxWidth: `${tt}${_e.theme.breakpoints.unit}`
            } : {
                maxWidth: tt
            } : {
                maxWidth: sizingTransform(et)
            }
        }
        ;
        return handleBreakpoints(_e, _e.maxWidth, $)
    }
    return null
}
;
maxWidth.filterProps = ["maxWidth"];
const minWidth = style$2({
    prop: "minWidth",
    transform: sizingTransform
})
  , height = style$2({
    prop: "height",
    transform: sizingTransform
})
  , maxHeight = style$2({
    prop: "maxHeight",
    transform: sizingTransform
})
  , minHeight = style$2({
    prop: "minHeight",
    transform: sizingTransform
});
style$2({
    prop: "size",
    cssProperty: "width",
    transform: sizingTransform
});
style$2({
    prop: "size",
    cssProperty: "height",
    transform: sizingTransform
});
const boxSizing = style$2({
    prop: "boxSizing"
});
compose(width, maxWidth, minWidth, height, maxHeight, minHeight, boxSizing);
const defaultSxConfig = {
    border: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderTop: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderRight: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderBottom: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderLeft: {
        themeKey: "borders",
        transform: borderTransform
    },
    borderColor: {
        themeKey: "palette"
    },
    borderTopColor: {
        themeKey: "palette"
    },
    borderRightColor: {
        themeKey: "palette"
    },
    borderBottomColor: {
        themeKey: "palette"
    },
    borderLeftColor: {
        themeKey: "palette"
    },
    outline: {
        themeKey: "borders",
        transform: borderTransform
    },
    outlineColor: {
        themeKey: "palette"
    },
    borderRadius: {
        themeKey: "shape.borderRadius",
        style: borderRadius
    },
    color: {
        themeKey: "palette",
        transform: paletteTransform
    },
    bgcolor: {
        themeKey: "palette",
        cssProperty: "backgroundColor",
        transform: paletteTransform
    },
    backgroundColor: {
        themeKey: "palette",
        transform: paletteTransform
    },
    p: {
        style: padding
    },
    pt: {
        style: padding
    },
    pr: {
        style: padding
    },
    pb: {
        style: padding
    },
    pl: {
        style: padding
    },
    px: {
        style: padding
    },
    py: {
        style: padding
    },
    padding: {
        style: padding
    },
    paddingTop: {
        style: padding
    },
    paddingRight: {
        style: padding
    },
    paddingBottom: {
        style: padding
    },
    paddingLeft: {
        style: padding
    },
    paddingX: {
        style: padding
    },
    paddingY: {
        style: padding
    },
    paddingInline: {
        style: padding
    },
    paddingInlineStart: {
        style: padding
    },
    paddingInlineEnd: {
        style: padding
    },
    paddingBlock: {
        style: padding
    },
    paddingBlockStart: {
        style: padding
    },
    paddingBlockEnd: {
        style: padding
    },
    m: {
        style: margin
    },
    mt: {
        style: margin
    },
    mr: {
        style: margin
    },
    mb: {
        style: margin
    },
    ml: {
        style: margin
    },
    mx: {
        style: margin
    },
    my: {
        style: margin
    },
    margin: {
        style: margin
    },
    marginTop: {
        style: margin
    },
    marginRight: {
        style: margin
    },
    marginBottom: {
        style: margin
    },
    marginLeft: {
        style: margin
    },
    marginX: {
        style: margin
    },
    marginY: {
        style: margin
    },
    marginInline: {
        style: margin
    },
    marginInlineStart: {
        style: margin
    },
    marginInlineEnd: {
        style: margin
    },
    marginBlock: {
        style: margin
    },
    marginBlockStart: {
        style: margin
    },
    marginBlockEnd: {
        style: margin
    },
    displayPrint: {
        cssProperty: !1,
        transform: _e => ({
            "@media print": {
                display: _e
            }
        })
    },
    display: {},
    overflow: {},
    textOverflow: {},
    visibility: {},
    whiteSpace: {},
    flexBasis: {},
    flexDirection: {},
    flexWrap: {},
    justifyContent: {},
    alignItems: {},
    alignContent: {},
    order: {},
    flex: {},
    flexGrow: {},
    flexShrink: {},
    alignSelf: {},
    justifyItems: {},
    justifySelf: {},
    gap: {
        style: gap
    },
    rowGap: {
        style: rowGap
    },
    columnGap: {
        style: columnGap
    },
    gridColumn: {},
    gridRow: {},
    gridAutoFlow: {},
    gridAutoColumns: {},
    gridAutoRows: {},
    gridTemplateColumns: {},
    gridTemplateRows: {},
    gridTemplateAreas: {},
    gridArea: {},
    position: {},
    zIndex: {
        themeKey: "zIndex"
    },
    top: {},
    right: {},
    bottom: {},
    left: {},
    boxShadow: {
        themeKey: "shadows"
    },
    width: {
        transform: sizingTransform
    },
    maxWidth: {
        style: maxWidth
    },
    minWidth: {
        transform: sizingTransform
    },
    height: {
        transform: sizingTransform
    },
    maxHeight: {
        transform: sizingTransform
    },
    minHeight: {
        transform: sizingTransform
    },
    boxSizing: {},
    font: {
        themeKey: "font"
    },
    fontFamily: {
        themeKey: "typography"
    },
    fontSize: {
        themeKey: "typography"
    },
    fontStyle: {
        themeKey: "typography"
    },
    fontWeight: {
        themeKey: "typography"
    },
    letterSpacing: {},
    textTransform: {},
    lineHeight: {},
    textAlign: {},
    typography: {
        cssProperty: !1,
        themeKey: "typography"
    }
};
function objectsHaveSameKeys(..._e) {
    const $ = _e.reduce( (tt, nt) => tt.concat(Object.keys(nt)), [])
      , et = new Set($);
    return _e.every(tt => et.size === Object.keys(tt).length)
}
function callIfFn(_e, $) {
    return typeof _e == "function" ? _e($) : _e
}
function unstable_createStyleFunctionSx() {
    function _e(et, tt, nt, rt) {
        const it = {
            [et]: tt,
            theme: nt
        }
          , ot = rt[et];
        if (!ot)
            return {
                [et]: tt
            };
        const {cssProperty: st=et, themeKey: lt, transform: ct, style: dt} = ot;
        if (tt == null)
            return null;
        if (lt === "typography" && tt === "inherit")
            return {
                [et]: tt
            };
        const pt = getPath(nt, lt) || {};
        return dt ? dt(it) : handleBreakpoints(it, tt, mt => {
            let yt = getStyleValue$1(pt, ct, mt);
            return mt === yt && typeof mt == "string" && (yt = getStyleValue$1(pt, ct, `${et}${mt === "default" ? "" : capitalize(mt)}`, mt)),
            st === !1 ? yt : {
                [st]: yt
            }
        }
        )
    }
    function $(et) {
        const {sx: tt, theme: nt={}} = et || {};
        if (!tt)
            return null;
        const rt = nt.unstable_sxConfig ?? defaultSxConfig;
        function it(ot) {
            let st = ot;
            if (typeof ot == "function")
                st = ot(nt);
            else if (typeof ot != "object")
                return ot;
            if (!st)
                return null;
            const lt = createEmptyBreakpointObject(nt.breakpoints)
              , ct = Object.keys(lt);
            let dt = lt;
            return Object.keys(st).forEach(pt => {
                const ht = callIfFn(st[pt], nt);
                if (ht != null)
                    if (typeof ht == "object")
                        if (rt[pt])
                            dt = merge$2(dt, _e(pt, ht, nt, rt));
                        else {
                            const mt = handleBreakpoints({
                                theme: nt
                            }, ht, yt => ({
                                [pt]: yt
                            }));
                            objectsHaveSameKeys(mt, ht) ? dt[pt] = $({
                                sx: ht,
                                theme: nt
                            }) : dt = merge$2(dt, mt)
                        }
                    else
                        dt = merge$2(dt, _e(pt, ht, nt, rt))
            }
            ),
            sortContainerQueries(nt, removeUnusedBreakpoints(ct, dt))
        }
        return Array.isArray(tt) ? tt.map(it) : it(tt)
    }
    return $
}
const styleFunctionSx = unstable_createStyleFunctionSx();
styleFunctionSx.filterProps = ["sx"];
function applyStyles(_e, $) {
    var tt;
    const et = this;
    if (et.vars) {
        if (!((tt = et.colorSchemes) != null && tt[_e]) || typeof et.getColorSchemeSelector != "function")
            return {};
        let nt = et.getColorSchemeSelector(_e);
        return nt === "&" ? $ : ((nt.includes("data-") || nt.includes(".")) && (nt = `*:where(${nt.replace(/\s*&$/, "")}) &`),
        {
            [nt]: $
        })
    }
    return et.palette.mode === _e ? $ : {}
}
function createTheme$1(_e={}, ...$) {
    const {breakpoints: et={}, palette: tt={}, spacing: nt, shape: rt={}, ...it} = _e
      , ot = createBreakpoints(et)
      , st = createSpacing(nt);
    let lt = deepmerge$1({
        breakpoints: ot,
        direction: "ltr",
        components: {},
        palette: {
            mode: "light",
            ...tt
        },
        spacing: st,
        shape: {
            ...shape,
            ...rt
        }
    }, it);
    return lt = cssContainerQueries(lt),
    lt.applyStyles = applyStyles,
    lt = $.reduce( (ct, dt) => deepmerge$1(ct, dt), lt),
    lt.unstable_sxConfig = {
        ...defaultSxConfig,
        ...it == null ? void 0 : it.unstable_sxConfig
    },
    lt.unstable_sx = function(dt) {
        return styleFunctionSx({
            sx: dt,
            theme: this
        })
    }
    ,
    lt
}
function isObjectEmpty$2(_e) {
    return Object.keys(_e).length === 0
}
function useTheme$3(_e=null) {
    const $ = reactExports.useContext(ThemeContext$1);
    return !$ || isObjectEmpty$2($) ? _e : $
}
const systemDefaultTheme$1 = createTheme$1();
function useTheme$2(_e=systemDefaultTheme$1) {
    return useTheme$3(_e)
}
function GlobalStyles$2({styles: _e, themeId: $, defaultTheme: et={}}) {
    const tt = useTheme$2(et)
      , nt = typeof _e == "function" ? _e($ && tt[$] || tt) : _e;
    return jsxRuntimeExports.jsx(GlobalStyles$3, {
        styles: nt
    })
}
const splitProps = _e => {
    var tt;
    const $ = {
        systemProps: {},
        otherProps: {}
    }
      , et = ((tt = _e == null ? void 0 : _e.theme) == null ? void 0 : tt.unstable_sxConfig) ?? defaultSxConfig;
    return Object.keys(_e).forEach(nt => {
        et[nt] ? $.systemProps[nt] = _e[nt] : $.otherProps[nt] = _e[nt]
    }
    ),
    $
}
;
function extendSxProp$1(_e) {
    const {sx: $, ...et} = _e
      , {systemProps: tt, otherProps: nt} = splitProps(et);
    let rt;
    return Array.isArray($) ? rt = [tt, ...$] : typeof $ == "function" ? rt = (...it) => {
        const ot = $(...it);
        return isPlainObject$3(ot) ? {
            ...tt,
            ...ot
        } : tt
    }
    : rt = {
        ...tt,
        ...$
    },
    {
        ...nt,
        sx: rt
    }
}
const defaultGenerator = _e => _e
  , createClassNameGenerator = () => {
    let _e = defaultGenerator;
    return {
        configure($) {
            _e = $
        },
        generate($) {
            return _e($)
        },
        reset() {
            _e = defaultGenerator
        }
    }
}
  , ClassNameGenerator = createClassNameGenerator();
function r(_e) {
    var $, et, tt = "";
    if (typeof _e == "string" || typeof _e == "number")
        tt += _e;
    else if (typeof _e == "object")
        if (Array.isArray(_e)) {
            var nt = _e.length;
            for ($ = 0; $ < nt; $++)
                _e[$] && (et = r(_e[$])) && (tt && (tt += " "),
                tt += et)
        } else
            for (et in _e)
                _e[et] && (tt && (tt += " "),
                tt += et);
    return tt
}
function clsx() {
    for (var _e, $, et = 0, tt = "", nt = arguments.length; et < nt; et++)
        (_e = arguments[et]) && ($ = r(_e)) && (tt && (tt += " "),
        tt += $);
    return tt
}
function createBox(_e={}) {
    const {themeId: $, defaultTheme: et, defaultClassName: tt="MuiBox-root", generateClassName: nt} = _e
      , rt = styled$2("div", {
        shouldForwardProp: ot => ot !== "theme" && ot !== "sx" && ot !== "as"
    })(styleFunctionSx);
    return reactExports.forwardRef(function(st, lt) {
        const ct = useTheme$2(et)
          , {className: dt, component: pt="div", ...ht} = extendSxProp$1(st);
        return jsxRuntimeExports.jsx(rt, {
            as: pt,
            ref: lt,
            className: clsx(dt, nt ? nt(tt) : tt),
            theme: $ && ct[$] || ct,
            ...ht
        })
    })
}
const globalStateClasses = {
    active: "active",
    checked: "checked",
    completed: "completed",
    disabled: "disabled",
    error: "error",
    expanded: "expanded",
    focused: "focused",
    focusVisible: "focusVisible",
    open: "open",
    readOnly: "readOnly",
    required: "required",
    selected: "selected"
};
function generateUtilityClass(_e, $, et="Mui") {
    const tt = globalStateClasses[$];
    return tt ? `${et}-${tt}` : `${ClassNameGenerator.generate(_e)}-${$}`
}
function generateUtilityClasses(_e, $, et="Mui") {
    const tt = {};
    return $.forEach(nt => {
        tt[nt] = generateUtilityClass(_e, nt, et)
    }
    ),
    tt
}
function preprocessStyles(_e) {
    const {variants: $, ...et} = _e
      , tt = {
        variants: $,
        style: internal_serializeStyles(et),
        isProcessed: !0
    };
    return tt.style === et || $ && $.forEach(nt => {
        typeof nt.style != "function" && (nt.style = internal_serializeStyles(nt.style))
    }
    ),
    tt
}
const systemDefaultTheme = createTheme$1();
function shouldForwardProp(_e) {
    return _e !== "ownerState" && _e !== "theme" && _e !== "sx" && _e !== "as"
}
function defaultOverridesResolver(_e) {
    return _e ? ($, et) => et[_e] : null
}
function attachTheme(_e, $, et) {
    _e.theme = isObjectEmpty$1(_e.theme) ? et : _e.theme[$] || _e.theme
}
function processStyle(_e, $) {
    const et = typeof $ == "function" ? $(_e) : $;
    if (Array.isArray(et))
        return et.flatMap(tt => processStyle(_e, tt));
    if (Array.isArray(et == null ? void 0 : et.variants)) {
        let tt;
        if (et.isProcessed)
            tt = et.style;
        else {
            const {variants: nt, ...rt} = et;
            tt = rt
        }
        return processStyleVariants(_e, et.variants, [tt])
    }
    return et != null && et.isProcessed ? et.style : et
}
function processStyleVariants(_e, $, et=[]) {
    var nt;
    let tt;
    e: for (let rt = 0; rt < $.length; rt += 1) {
        const it = $[rt];
        if (typeof it.props == "function") {
            if (tt ?? (tt = {
                ..._e,
                ..._e.ownerState,
                ownerState: _e.ownerState
            }),
            !it.props(tt))
                continue
        } else
            for (const ot in it.props)
                if (_e[ot] !== it.props[ot] && ((nt = _e.ownerState) == null ? void 0 : nt[ot]) !== it.props[ot])
                    continue e;
        typeof it.style == "function" ? (tt ?? (tt = {
            ..._e,
            ..._e.ownerState,
            ownerState: _e.ownerState
        }),
        et.push(it.style(tt))) : et.push(it.style)
    }
    return et
}
function createStyled(_e={}) {
    const {themeId: $, defaultTheme: et=systemDefaultTheme, rootShouldForwardProp: tt=shouldForwardProp, slotShouldForwardProp: nt=shouldForwardProp} = _e;
    function rt(ot) {
        attachTheme(ot, $, et)
    }
    return (ot, st={}) => {
        internal_mutateStyles(ot, Nt => Nt.filter(Lt => Lt !== styleFunctionSx));
        const {name: lt, slot: ct, skipVariantsResolver: dt, skipSx: pt, overridesResolver: ht=defaultOverridesResolver(lowercaseFirstLetter(ct)), ...mt} = st
          , yt = dt !== void 0 ? dt : ct && ct !== "Root" && ct !== "root" || !1
          , Et = pt || !1;
        let _t = shouldForwardProp;
        ct === "Root" || ct === "root" ? _t = tt : ct ? _t = nt : isStringTag(ot) && (_t = void 0);
        const wt = styled$2(ot, {
            shouldForwardProp: _t,
            label: generateStyledLabel(),
            ...mt
        })
          , St = Nt => {
            if (typeof Nt == "function" && Nt.__emotion_real !== Nt)
                return function(kt) {
                    return processStyle(kt, Nt)
                }
                ;
            if (isPlainObject$3(Nt)) {
                const Lt = preprocessStyles(Nt);
                return Lt.variants ? function(Ut) {
                    return processStyle(Ut, Lt)
                }
                : Lt.style
            }
            return Nt
        }
          , Ct = (...Nt) => {
            const Lt = []
              , kt = Nt.map(St)
              , Ut = [];
            if (Lt.push(rt),
            lt && ht && Ut.push(function(rn) {
                var Dt, jt;
                const xt = (jt = (Dt = rn.theme.components) == null ? void 0 : Dt[lt]) == null ? void 0 : jt.styleOverrides;
                if (!xt)
                    return null;
                const $t = {};
                for (const Ft in xt)
                    $t[Ft] = processStyle(rn, xt[Ft]);
                return ht(rn, $t)
            }),
            lt && !yt && Ut.push(function(rn) {
                var $t, Dt;
                const zt = rn.theme
                  , xt = (Dt = ($t = zt == null ? void 0 : zt.components) == null ? void 0 : $t[lt]) == null ? void 0 : Dt.variants;
                return xt ? processStyleVariants(rn, xt) : null
            }),
            Et || Ut.push(styleFunctionSx),
            Array.isArray(kt[0])) {
                const Xt = kt.shift()
                  , rn = new Array(Lt.length).fill("")
                  , zt = new Array(Ut.length).fill("");
                let xt;
                xt = [...rn, ...Xt, ...zt],
                xt.raw = [...rn, ...Xt.raw, ...zt],
                Lt.unshift(xt)
            }
            const Jt = [...Lt, ...kt, ...Ut]
              , Pt = wt(...Jt);
            return ot.muiName && (Pt.muiName = ot.muiName),
            Pt
        }
        ;
        return wt.withConfig && (Ct.withConfig = wt.withConfig),
        Ct
    }
}
function generateStyledLabel(_e, $) {
    return void 0
}
function isObjectEmpty$1(_e) {
    for (const $ in _e)
        return !1;
    return !0
}
function isStringTag(_e) {
    return typeof _e == "string" && _e.charCodeAt(0) > 96
}
function lowercaseFirstLetter(_e) {
    return _e && _e.charAt(0).toLowerCase() + _e.slice(1)
}
const styled$1 = createStyled();
function resolveProps(_e, $) {
    const et = {
        ...$
    };
    for (const tt in _e)
        if (Object.prototype.hasOwnProperty.call(_e, tt)) {
            const nt = tt;
            if (nt === "components" || nt === "slots")
                et[nt] = {
                    ..._e[nt],
                    ...et[nt]
                };
            else if (nt === "componentsProps" || nt === "slotProps") {
                const rt = _e[nt]
                  , it = $[nt];
                if (!it)
                    et[nt] = rt || {};
                else if (!rt)
                    et[nt] = it;
                else {
                    et[nt] = {
                        ...it
                    };
                    for (const ot in rt)
                        if (Object.prototype.hasOwnProperty.call(rt, ot)) {
                            const st = ot;
                            et[nt][st] = resolveProps(rt[st], it[st])
                        }
                }
            } else
                et[nt] === void 0 && (et[nt] = _e[nt])
        }
    return et
}
function getThemeProps$1(_e) {
    const {theme: $, name: et, props: tt} = _e;
    return !$ || !$.components || !$.components[et] || !$.components[et].defaultProps ? tt : resolveProps($.components[et].defaultProps, tt)
}
function useThemeProps({props: _e, name: $, defaultTheme: et, themeId: tt}) {
    let nt = useTheme$2(et);
    return tt && (nt = nt[tt] || nt),
    getThemeProps$1({
        theme: nt,
        name: $,
        props: _e
    })
}
const useEnhancedEffect = typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useMediaQueryOld(_e, $, et, tt, nt) {
    const [rt,it] = reactExports.useState( () => nt && et ? et(_e).matches : tt ? tt(_e).matches : $);
    return useEnhancedEffect( () => {
        if (!et)
            return;
        const ot = et(_e)
          , st = () => {
            it(ot.matches)
        }
        ;
        return st(),
        ot.addEventListener("change", st),
        () => {
            ot.removeEventListener("change", st)
        }
    }
    , [_e, et]),
    rt
}
const safeReact$1 = {
    ...React$1
}
  , maybeReactUseSyncExternalStore = safeReact$1.useSyncExternalStore;
function useMediaQueryNew(_e, $, et, tt, nt) {
    const rt = reactExports.useCallback( () => $, [$])
      , it = reactExports.useMemo( () => {
        if (nt && et)
            return () => et(_e).matches;
        if (tt !== null) {
            const {matches: ct} = tt(_e);
            return () => ct
        }
        return rt
    }
    , [rt, _e, tt, nt, et])
      , [ot,st] = reactExports.useMemo( () => {
        if (et === null)
            return [rt, () => () => {}
            ];
        const ct = et(_e);
        return [ () => ct.matches, dt => (ct.addEventListener("change", dt),
        () => {
            ct.removeEventListener("change", dt)
        }
        )]
    }
    , [rt, et, _e]);
    return maybeReactUseSyncExternalStore(st, ot, it)
}
function unstable_createUseMediaQuery(_e={}) {
    const {themeId: $} = _e;
    return function(tt, nt={}) {
        let rt = useTheme$3();
        rt && $ && (rt = rt[$] || rt);
        const it = typeof window < "u" && typeof window.matchMedia < "u"
          , {defaultMatches: ot=!1, matchMedia: st=it ? window.matchMedia : null, ssrMatchMedia: lt=null, noSsr: ct=!1} = getThemeProps$1({
            name: "MuiUseMediaQuery",
            props: nt,
            theme: rt
        });
        let dt = typeof tt == "function" ? tt(rt) : tt;
        return dt = dt.replace(/^@media( ?)/m, ""),
        (maybeReactUseSyncExternalStore !== void 0 ? useMediaQueryNew : useMediaQueryOld)(dt, ot, st, lt, ct)
    }
}
unstable_createUseMediaQuery();
function clamp$1(_e, $=Number.MIN_SAFE_INTEGER, et=Number.MAX_SAFE_INTEGER) {
    return Math.max($, Math.min(_e, et))
}
function clampWrapper(_e, $=0, et=1) {
    return clamp$1(_e, $, et)
}
function hexToRgb(_e) {
    _e = _e.slice(1);
    const $ = new RegExp(`.{1,${_e.length >= 6 ? 2 : 1}}`,"g");
    let et = _e.match($);
    return et && et[0].length === 1 && (et = et.map(tt => tt + tt)),
    et ? `rgb${et.length === 4 ? "a" : ""}(${et.map( (tt, nt) => nt < 3 ? parseInt(tt, 16) : Math.round(parseInt(tt, 16) / 255 * 1e3) / 1e3).join(", ")})` : ""
}
function decomposeColor(_e) {
    if (_e.type)
        return _e;
    if (_e.charAt(0) === "#")
        return decomposeColor(hexToRgb(_e));
    const $ = _e.indexOf("(")
      , et = _e.substring(0, $);
    if (!["rgb", "rgba", "hsl", "hsla", "color"].includes(et))
        throw new Error(formatMuiErrorMessage(9, _e));
    let tt = _e.substring($ + 1, _e.length - 1), nt;
    if (et === "color") {
        if (tt = tt.split(" "),
        nt = tt.shift(),
        tt.length === 4 && tt[3].charAt(0) === "/" && (tt[3] = tt[3].slice(1)),
        !["srgb", "display-p3", "a98-rgb", "prophoto-rgb", "rec-2020"].includes(nt))
            throw new Error(formatMuiErrorMessage(10, nt))
    } else
        tt = tt.split(",");
    return tt = tt.map(rt => parseFloat(rt)),
    {
        type: et,
        values: tt,
        colorSpace: nt
    }
}
const colorChannel = _e => {
    const $ = decomposeColor(_e);
    return $.values.slice(0, 3).map( (et, tt) => $.type.includes("hsl") && tt !== 0 ? `${et}%` : et).join(" ")
}
  , private_safeColorChannel = (_e, $) => {
    try {
        return colorChannel(_e)
    } catch {
        return _e
    }
}
;
function recomposeColor(_e) {
    const {type: $, colorSpace: et} = _e;
    let {values: tt} = _e;
    return $.includes("rgb") ? tt = tt.map( (nt, rt) => rt < 3 ? parseInt(nt, 10) : nt) : $.includes("hsl") && (tt[1] = `${tt[1]}%`,
    tt[2] = `${tt[2]}%`),
    $.includes("color") ? tt = `${et} ${tt.join(" ")}` : tt = `${tt.join(", ")}`,
    `${$}(${tt})`
}
function hslToRgb(_e) {
    _e = decomposeColor(_e);
    const {values: $} = _e
      , et = $[0]
      , tt = $[1] / 100
      , nt = $[2] / 100
      , rt = tt * Math.min(nt, 1 - nt)
      , it = (lt, ct=(lt + et / 30) % 12) => nt - rt * Math.max(Math.min(ct - 3, 9 - ct, 1), -1);
    let ot = "rgb";
    const st = [Math.round(it(0) * 255), Math.round(it(8) * 255), Math.round(it(4) * 255)];
    return _e.type === "hsla" && (ot += "a",
    st.push($[3])),
    recomposeColor({
        type: ot,
        values: st
    })
}
function getLuminance(_e) {
    _e = decomposeColor(_e);
    let $ = _e.type === "hsl" || _e.type === "hsla" ? decomposeColor(hslToRgb(_e)).values : _e.values;
    return $ = $.map(et => (_e.type !== "color" && (et /= 255),
    et <= .03928 ? et / 12.92 : ((et + .055) / 1.055) ** 2.4)),
    Number((.2126 * $[0] + .7152 * $[1] + .0722 * $[2]).toFixed(3))
}
function getContrastRatio(_e, $) {
    const et = getLuminance(_e)
      , tt = getLuminance($);
    return (Math.max(et, tt) + .05) / (Math.min(et, tt) + .05)
}
function alpha(_e, $) {
    return _e = decomposeColor(_e),
    $ = clampWrapper($),
    (_e.type === "rgb" || _e.type === "hsl") && (_e.type += "a"),
    _e.type === "color" ? _e.values[3] = `/${$}` : _e.values[3] = $,
    recomposeColor(_e)
}
function private_safeAlpha(_e, $, et) {
    try {
        return alpha(_e, $)
    } catch {
        return _e
    }
}
function darken(_e, $) {
    if (_e = decomposeColor(_e),
    $ = clampWrapper($),
    _e.type.includes("hsl"))
        _e.values[2] *= 1 - $;
    else if (_e.type.includes("rgb") || _e.type.includes("color"))
        for (let et = 0; et < 3; et += 1)
            _e.values[et] *= 1 - $;
    return recomposeColor(_e)
}
function private_safeDarken(_e, $, et) {
    try {
        return darken(_e, $)
    } catch {
        return _e
    }
}
function lighten(_e, $) {
    if (_e = decomposeColor(_e),
    $ = clampWrapper($),
    _e.type.includes("hsl"))
        _e.values[2] += (100 - _e.values[2]) * $;
    else if (_e.type.includes("rgb"))
        for (let et = 0; et < 3; et += 1)
            _e.values[et] += (255 - _e.values[et]) * $;
    else if (_e.type.includes("color"))
        for (let et = 0; et < 3; et += 1)
            _e.values[et] += (1 - _e.values[et]) * $;
    return recomposeColor(_e)
}
function private_safeLighten(_e, $, et) {
    try {
        return lighten(_e, $)
    } catch {
        return _e
    }
}
function emphasize(_e, $=.15) {
    return getLuminance(_e) > .5 ? darken(_e, $) : lighten(_e, $)
}
function private_safeEmphasize(_e, $, et) {
    try {
        return emphasize(_e, $)
    } catch {
        return _e
    }
}
function createChainedFunction(..._e) {
    return _e.reduce( ($, et) => et == null ? $ : function(...nt) {
        $.apply(this, nt),
        et.apply(this, nt)
    }
    , () => {}
    )
}
function debounce(_e, $=166) {
    let et;
    function tt(...nt) {
        const rt = () => {
            _e.apply(this, nt)
        }
        ;
        clearTimeout(et),
        et = setTimeout(rt, $)
    }
    return tt.clear = () => {
        clearTimeout(et)
    }
    ,
    tt
}
function isMuiElement(_e, $) {
    var et, tt, nt;
    return reactExports.isValidElement(_e) && $.indexOf(_e.type.muiName ?? ((nt = (tt = (et = _e.type) == null ? void 0 : et._payload) == null ? void 0 : tt.value) == null ? void 0 : nt.muiName)) !== -1
}
function ownerDocument(_e) {
    return _e && _e.ownerDocument || document
}
function ownerWindow(_e) {
    return ownerDocument(_e).defaultView || window
}
function setRef(_e, $) {
    typeof _e == "function" ? _e($) : _e && (_e.current = $)
}
let globalId = 0;
function useGlobalId(_e) {
    const [$,et] = reactExports.useState(_e)
      , tt = _e || $;
    return reactExports.useEffect( () => {
        $ == null && (globalId += 1,
        et(`mui-${globalId}`))
    }
    , [$]),
    tt
}
const safeReact = {
    ...React$1
}
  , maybeReactUseId = safeReact.useId;
function useId(_e) {
    if (maybeReactUseId !== void 0) {
        const $ = maybeReactUseId();
        return _e ?? $
    }
    return useGlobalId(_e)
}
function useControlled({controlled: _e, default: $, name: et, state: tt="value"}) {
    const {current: nt} = reactExports.useRef(_e !== void 0)
      , [rt,it] = reactExports.useState($)
      , ot = nt ? _e : rt
      , st = reactExports.useCallback(lt => {
        nt || it(lt)
    }
    , []);
    return [ot, st]
}
function useEventCallback$1(_e) {
    const $ = reactExports.useRef(_e);
    return useEnhancedEffect( () => {
        $.current = _e
    }
    ),
    reactExports.useRef( (...et) => (0,
    $.current)(...et)).current
}
function useForkRef(..._e) {
    return reactExports.useMemo( () => _e.every($ => $ == null) ? null : $ => {
        _e.forEach(et => {
            setRef(et, $)
        }
        )
    }
    , _e)
}
const UNINITIALIZED = {};
function useLazyRef(_e, $) {
    const et = reactExports.useRef(UNINITIALIZED);
    return et.current === UNINITIALIZED && (et.current = _e($)),
    et
}
const EMPTY = [];
function useOnMount(_e) {
    reactExports.useEffect(_e, EMPTY)
}
class Timeout {
    constructor() {
        Br(this, "currentId", null);
        Br(this, "clear", () => {
            this.currentId !== null && (clearTimeout(this.currentId),
            this.currentId = null)
        }
        );
        Br(this, "disposeEffect", () => this.clear)
    }
    static create() {
        return new Timeout
    }
    start($, et) {
        this.clear(),
        this.currentId = setTimeout( () => {
            this.currentId = null,
            et()
        }
        , $)
    }
}
function useTimeout() {
    const _e = useLazyRef(Timeout.create).current;
    return useOnMount(_e.disposeEffect),
    _e
}
function isFocusVisible(_e) {
    try {
        return _e.matches(":focus-visible")
    } catch {}
    return !1
}
function getScrollbarSize(_e=window) {
    const $ = _e.document.documentElement.clientWidth;
    return _e.innerWidth - $
}
function composeClasses(_e, $, et=void 0) {
    const tt = {};
    for (const nt in _e) {
        const rt = _e[nt];
        let it = ""
          , ot = !0;
        for (let st = 0; st < rt.length; st += 1) {
            const lt = rt[st];
            lt && (it += (ot === !0 ? "" : " ") + $(lt),
            ot = !1,
            et && et[lt] && (it += " " + et[lt]))
        }
        tt[nt] = it
    }
    return tt
}
function isHostComponent$1(_e) {
    return typeof _e == "string"
}
function appendOwnerState(_e, $, et) {
    return _e === void 0 || isHostComponent$1(_e) ? $ : {
        ...$,
        ownerState: {
            ...$.ownerState,
            ...et
        }
    }
}
function extractEventHandlers(_e, $=[]) {
    if (_e === void 0)
        return {};
    const et = {};
    return Object.keys(_e).filter(tt => tt.match(/^on[A-Z]/) && typeof _e[tt] == "function" && !$.includes(tt)).forEach(tt => {
        et[tt] = _e[tt]
    }
    ),
    et
}
function omitEventHandlers(_e) {
    if (_e === void 0)
        return {};
    const $ = {};
    return Object.keys(_e).filter(et => !(et.match(/^on[A-Z]/) && typeof _e[et] == "function")).forEach(et => {
        $[et] = _e[et]
    }
    ),
    $
}
function mergeSlotProps(_e) {
    const {getSlotProps: $, additionalProps: et, externalSlotProps: tt, externalForwardedProps: nt, className: rt} = _e;
    if (!$) {
        const ht = clsx(et == null ? void 0 : et.className, rt, nt == null ? void 0 : nt.className, tt == null ? void 0 : tt.className)
          , mt = {
            ...et == null ? void 0 : et.style,
            ...nt == null ? void 0 : nt.style,
            ...tt == null ? void 0 : tt.style
        }
          , yt = {
            ...et,
            ...nt,
            ...tt
        };
        return ht.length > 0 && (yt.className = ht),
        Object.keys(mt).length > 0 && (yt.style = mt),
        {
            props: yt,
            internalRef: void 0
        }
    }
    const it = extractEventHandlers({
        ...nt,
        ...tt
    })
      , ot = omitEventHandlers(tt)
      , st = omitEventHandlers(nt)
      , lt = $(it)
      , ct = clsx(lt == null ? void 0 : lt.className, et == null ? void 0 : et.className, rt, nt == null ? void 0 : nt.className, tt == null ? void 0 : tt.className)
      , dt = {
        ...lt == null ? void 0 : lt.style,
        ...et == null ? void 0 : et.style,
        ...nt == null ? void 0 : nt.style,
        ...tt == null ? void 0 : tt.style
    }
      , pt = {
        ...lt,
        ...et,
        ...st,
        ...ot
    };
    return ct.length > 0 && (pt.className = ct),
    Object.keys(dt).length > 0 && (pt.style = dt),
    {
        props: pt,
        internalRef: lt.ref
    }
}
function resolveComponentProps(_e, $, et) {
    return typeof _e == "function" ? _e($, et) : _e
}
function useSlotProps(_e) {
    var dt;
    const {elementType: $, externalSlotProps: et, ownerState: tt, skipResolvingSlotProps: nt=!1, ...rt} = _e
      , it = nt ? {} : resolveComponentProps(et, tt)
      , {props: ot, internalRef: st} = mergeSlotProps({
        ...rt,
        externalSlotProps: it
    })
      , lt = useForkRef(st, it == null ? void 0 : it.ref, (dt = _e.additionalProps) == null ? void 0 : dt.ref);
    return appendOwnerState($, {
        ...ot,
        ref: lt
    }, tt)
}
function getReactElementRef(_e) {
    var $;
    return parseInt(reactExports.version, 10) >= 19 ? (($ = _e == null ? void 0 : _e.props) == null ? void 0 : $.ref) || null : (_e == null ? void 0 : _e.ref) || null
}
const ThemeContext = reactExports.createContext(null);
function useTheme$1() {
    return reactExports.useContext(ThemeContext)
}
const hasSymbol = typeof Symbol == "function" && Symbol.for
  , nested = hasSymbol ? Symbol.for("mui.nested") : "__THEME_NESTED__";
function mergeOuterLocalTheme(_e, $) {
    return typeof $ == "function" ? $(_e) : {
        ..._e,
        ...$
    }
}
function ThemeProvider$2(_e) {
    const {children: $, theme: et} = _e
      , tt = useTheme$1()
      , nt = reactExports.useMemo( () => {
        const rt = tt === null ? {
            ...et
        } : mergeOuterLocalTheme(tt, et);
        return rt != null && (rt[nested] = tt !== null),
        rt
    }
    , [et, tt]);
    return jsxRuntimeExports.jsx(ThemeContext.Provider, {
        value: nt,
        children: $
    })
}
const RtlContext = reactExports.createContext();
function RtlProvider({value: _e, ...$}) {
    return jsxRuntimeExports.jsx(RtlContext.Provider, {
        value: _e ?? !0,
        ...$
    })
}
const useRtl = () => reactExports.useContext(RtlContext) ?? !1
  , PropsContext = reactExports.createContext(void 0);
function DefaultPropsProvider({value: _e, children: $}) {
    return jsxRuntimeExports.jsx(PropsContext.Provider, {
        value: _e,
        children: $
    })
}
function getThemeProps(_e) {
    const {theme: $, name: et, props: tt} = _e;
    if (!$ || !$.components || !$.components[et])
        return tt;
    const nt = $.components[et];
    return nt.defaultProps ? resolveProps(nt.defaultProps, tt) : !nt.styleOverrides && !nt.variants ? resolveProps(nt, tt) : tt
}
function useDefaultProps$1({props: _e, name: $}) {
    const et = reactExports.useContext(PropsContext);
    return getThemeProps({
        props: _e,
        name: $,
        theme: {
            components: et
        }
    })
}
const EMPTY_THEME = {};
function useThemeScoping(_e, $, et, tt=!1) {
    return reactExports.useMemo( () => {
        const nt = _e && $[_e] || $;
        if (typeof et == "function") {
            const rt = et(nt)
              , it = _e ? {
                ...$,
                [_e]: rt
            } : rt;
            return tt ? () => it : it
        }
        return _e ? {
            ...$,
            [_e]: et
        } : {
            ...$,
            ...et
        }
    }
    , [_e, $, et, tt])
}
function ThemeProvider$1(_e) {
    const {children: $, theme: et, themeId: tt} = _e
      , nt = useTheme$3(EMPTY_THEME)
      , rt = useTheme$1() || EMPTY_THEME
      , it = useThemeScoping(tt, nt, et)
      , ot = useThemeScoping(tt, rt, et, !0)
      , st = (tt ? it[tt] : it).direction === "rtl";
    return jsxRuntimeExports.jsx(ThemeProvider$2, {
        theme: ot,
        children: jsxRuntimeExports.jsx(ThemeContext$1.Provider, {
            value: it,
            children: jsxRuntimeExports.jsx(RtlProvider, {
                value: st,
                children: jsxRuntimeExports.jsx(DefaultPropsProvider, {
                    value: tt ? it[tt].components : it.components,
                    children: $
                })
            })
        })
    })
}
const arg = {
    theme: void 0
};
function unstable_memoTheme(_e) {
    let $, et;
    return function(nt) {
        let rt = $;
        return (rt === void 0 || nt.theme !== et) && (arg.theme = nt.theme,
        rt = preprocessStyles(_e(arg)),
        $ = rt,
        et = nt.theme),
        rt
    }
}
const DEFAULT_MODE_STORAGE_KEY = "mode"
  , DEFAULT_COLOR_SCHEME_STORAGE_KEY = "color-scheme"
  , DEFAULT_ATTRIBUTE = "data-color-scheme";
function InitColorSchemeScript(_e) {
    const {defaultMode: $="system", defaultLightColorScheme: et="light", defaultDarkColorScheme: tt="dark", modeStorageKey: nt=DEFAULT_MODE_STORAGE_KEY, colorSchemeStorageKey: rt=DEFAULT_COLOR_SCHEME_STORAGE_KEY, attribute: it=DEFAULT_ATTRIBUTE, colorSchemeNode: ot="document.documentElement", nonce: st} = _e || {};
    let lt = ""
      , ct = it;
    if (it === "class" && (ct = ".%s"),
    it === "data" && (ct = "[data-%s]"),
    ct.startsWith(".")) {
        const pt = ct.substring(1);
        lt += `${ot}.classList.remove('${pt}'.replace('%s', light), '${pt}'.replace('%s', dark));
      ${ot}.classList.add('${pt}'.replace('%s', colorScheme));`
    }
    const dt = ct.match(/\[([^\]]+)\]/);
    if (dt) {
        const [pt,ht] = dt[1].split("=");
        ht || (lt += `${ot}.removeAttribute('${pt}'.replace('%s', light));
      ${ot}.removeAttribute('${pt}'.replace('%s', dark));`),
        lt += `
      ${ot}.setAttribute('${pt}'.replace('%s', colorScheme), ${ht ? `${ht}.replace('%s', colorScheme)` : '""'});`
    } else
        lt += `${ot}.setAttribute('${ct}', colorScheme);`;
    return jsxRuntimeExports.jsx("script", {
        suppressHydrationWarning: !0,
        nonce: typeof window > "u" ? st : "",
        dangerouslySetInnerHTML: {
            __html: `(function() {
try {
  let colorScheme = '';
  const mode = localStorage.getItem('${nt}') || '${$}';
  const dark = localStorage.getItem('${rt}-dark') || '${tt}';
  const light = localStorage.getItem('${rt}-light') || '${et}';
  if (mode === 'system') {
    // handle system mode
    const mql = window.matchMedia('(prefers-color-scheme: dark)');
    if (mql.matches) {
      colorScheme = dark
    } else {
      colorScheme = light
    }
  }
  if (mode === 'light') {
    colorScheme = light;
  }
  if (mode === 'dark') {
    colorScheme = dark;
  }
  if (colorScheme) {
    ${lt}
  }
} catch(e){}})();`
        }
    }, "mui-color-scheme-init")
}
function getSystemMode(_e) {
    if (typeof window < "u" && typeof window.matchMedia == "function" && _e === "system")
        return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
}
function processState(_e, $) {
    if (_e.mode === "light" || _e.mode === "system" && _e.systemMode === "light")
        return $("light");
    if (_e.mode === "dark" || _e.mode === "system" && _e.systemMode === "dark")
        return $("dark")
}
function getColorScheme(_e) {
    return processState(_e, $ => {
        if ($ === "light")
            return _e.lightColorScheme;
        if ($ === "dark")
            return _e.darkColorScheme
    }
    )
}
function initializeValue(_e, $) {
    if (typeof window > "u")
        return;
    let et;
    try {
        et = localStorage.getItem(_e) || void 0,
        et || localStorage.setItem(_e, $)
    } catch {}
    return et || $
}
function useCurrentColorScheme(_e) {
    const {defaultMode: $="light", defaultLightColorScheme: et, defaultDarkColorScheme: tt, supportedColorSchemes: nt=[], modeStorageKey: rt=DEFAULT_MODE_STORAGE_KEY, colorSchemeStorageKey: it=DEFAULT_COLOR_SCHEME_STORAGE_KEY, storageWindow: ot=typeof window > "u" ? void 0 : window, noSsr: st=!1} = _e
      , lt = nt.join(",")
      , ct = nt.length > 1
      , [dt,pt] = reactExports.useState( () => {
        const Ct = initializeValue(rt, $)
          , Nt = initializeValue(`${it}-light`, et)
          , Lt = initializeValue(`${it}-dark`, tt);
        return {
            mode: Ct,
            systemMode: getSystemMode(Ct),
            lightColorScheme: Nt,
            darkColorScheme: Lt
        }
    }
    )
      , [ht,mt] = reactExports.useState(st || !ct);
    reactExports.useEffect( () => {
        mt(!0)
    }
    , []);
    const yt = getColorScheme(dt)
      , Et = reactExports.useCallback(Ct => {
        pt(Nt => {
            if (Ct === Nt.mode)
                return Nt;
            const Lt = Ct ?? $;
            try {
                localStorage.setItem(rt, Lt)
            } catch {}
            return {
                ...Nt,
                mode: Lt,
                systemMode: getSystemMode(Lt)
            }
        }
        )
    }
    , [rt, $])
      , _t = reactExports.useCallback(Ct => {
        Ct ? typeof Ct == "string" ? Ct && !lt.includes(Ct) || pt(Nt => {
            const Lt = {
                ...Nt
            };
            return processState(Nt, kt => {
                try {
                    localStorage.setItem(`${it}-${kt}`, Ct)
                } catch {}
                kt === "light" && (Lt.lightColorScheme = Ct),
                kt === "dark" && (Lt.darkColorScheme = Ct)
            }
            ),
            Lt
        }
        ) : pt(Nt => {
            const Lt = {
                ...Nt
            }
              , kt = Ct.light === null ? et : Ct.light
              , Ut = Ct.dark === null ? tt : Ct.dark;
            if (kt && lt.includes(kt)) {
                Lt.lightColorScheme = kt;
                try {
                    localStorage.setItem(`${it}-light`, kt)
                } catch {}
            }
            if (Ut && lt.includes(Ut)) {
                Lt.darkColorScheme = Ut;
                try {
                    localStorage.setItem(`${it}-dark`, Ut)
                } catch {}
            }
            return Lt
        }
        ) : pt(Nt => {
            try {
                localStorage.setItem(`${it}-light`, et),
                localStorage.setItem(`${it}-dark`, tt)
            } catch {}
            return {
                ...Nt,
                lightColorScheme: et,
                darkColorScheme: tt
            }
        }
        )
    }
    , [lt, it, et, tt])
      , wt = reactExports.useCallback(Ct => {
        dt.mode === "system" && pt(Nt => {
            const Lt = Ct != null && Ct.matches ? "dark" : "light";
            return Nt.systemMode === Lt ? Nt : {
                ...Nt,
                systemMode: Lt
            }
        }
        )
    }
    , [dt.mode])
      , St = reactExports.useRef(wt);
    return St.current = wt,
    reactExports.useEffect( () => {
        if (typeof window.matchMedia != "function" || !ct)
            return;
        const Ct = (...Lt) => St.current(...Lt)
          , Nt = window.matchMedia("(prefers-color-scheme: dark)");
        return Nt.addListener(Ct),
        Ct(Nt),
        () => {
            Nt.removeListener(Ct)
        }
    }
    , [ct]),
    reactExports.useEffect( () => {
        if (ot && ct) {
            const Ct = Nt => {
                const Lt = Nt.newValue;
                typeof Nt.key == "string" && Nt.key.startsWith(it) && (!Lt || lt.match(Lt)) && (Nt.key.endsWith("light") && _t({
                    light: Lt
                }),
                Nt.key.endsWith("dark") && _t({
                    dark: Lt
                })),
                Nt.key === rt && (!Lt || ["light", "dark", "system"].includes(Lt)) && Et(Lt || $)
            }
            ;
            return ot.addEventListener("storage", Ct),
            () => {
                ot.removeEventListener("storage", Ct)
            }
        }
    }
    , [_t, Et, rt, it, lt, $, ot, ct]),
    {
        ...dt,
        mode: ht ? dt.mode : void 0,
        systemMode: ht ? dt.systemMode : void 0,
        colorScheme: ht ? yt : void 0,
        setMode: Et,
        setColorScheme: _t
    }
}
const DISABLE_CSS_TRANSITION = "*{-webkit-transition:none!important;-moz-transition:none!important;-o-transition:none!important;-ms-transition:none!important;transition:none!important}";
function createCssVarsProvider(_e) {
    const {themeId: $, theme: et={}, modeStorageKey: tt=DEFAULT_MODE_STORAGE_KEY, colorSchemeStorageKey: nt=DEFAULT_COLOR_SCHEME_STORAGE_KEY, disableTransitionOnChange: rt=!1, defaultColorScheme: it, resolveTheme: ot} = _e
      , st = {
        allColorSchemes: [],
        colorScheme: void 0,
        darkColorScheme: void 0,
        lightColorScheme: void 0,
        mode: void 0,
        setColorScheme: () => {}
        ,
        setMode: () => {}
        ,
        systemMode: void 0
    }
      , lt = reactExports.createContext(void 0)
      , ct = () => reactExports.useContext(lt) || st
      , dt = {}
      , pt = {};
    function ht(_t) {
        var Vn, qn, dr, or;
        const {children: wt, theme: St, modeStorageKey: Ct=tt, colorSchemeStorageKey: Nt=nt, disableTransitionOnChange: Lt=rt, storageWindow: kt=typeof window > "u" ? void 0 : window, documentNode: Ut=typeof document > "u" ? void 0 : document, colorSchemeNode: Jt=typeof document > "u" ? void 0 : document.documentElement, disableNestedContext: Pt=!1, disableStyleSheetGeneration: Xt=!1, defaultMode: rn="system", noSsr: zt} = _t
          , xt = reactExports.useRef(!1)
          , $t = useTheme$1()
          , Dt = reactExports.useContext(lt)
          , jt = !!Dt && !Pt
          , Ft = reactExports.useMemo( () => St || (typeof et == "function" ? et() : et), [St])
          , Ht = Ft[$]
          , qt = Ht || Ft
          , {colorSchemes: Wt=dt, components: Mt=pt, cssVarPrefix: Yt} = qt
          , un = Object.keys(Wt).filter(ir => !!Wt[ir]).join(",")
          , hn = reactExports.useMemo( () => un.split(","), [un])
          , _n = typeof it == "string" ? it : it.light
          , kn = typeof it == "string" ? it : it.dark
          , Dn = Wt[_n] && Wt[kn] ? rn : ((qn = (Vn = Wt[qt.defaultColorScheme]) == null ? void 0 : Vn.palette) == null ? void 0 : qn.mode) || ((dr = qt.palette) == null ? void 0 : dr.mode)
          , {mode: jn, setMode: Bn, systemMode: Un, lightColorScheme: Hn, darkColorScheme: cr, colorScheme: Gn, setColorScheme: Mn} = useCurrentColorScheme({
            supportedColorSchemes: hn,
            defaultLightColorScheme: _n,
            defaultDarkColorScheme: kn,
            modeStorageKey: Ct,
            colorSchemeStorageKey: Nt,
            defaultMode: Dn,
            storageWindow: kt,
            noSsr: zt
        });
        let rr = jn
          , Zn = Gn;
        jt && (rr = Dt.mode,
        Zn = Dt.colorScheme);
        const pr = reactExports.useMemo( () => {
            var an;
            const ir = Zn || qt.defaultColorScheme
              , Cr = ((an = qt.generateThemeVars) == null ? void 0 : an.call(qt)) || qt.vars
              , br = {
                ...qt,
                components: Mt,
                colorSchemes: Wt,
                cssVarPrefix: Yt,
                vars: Cr
            };
            if (typeof br.generateSpacing == "function" && (br.spacing = br.generateSpacing()),
            ir) {
                const Kt = Wt[ir];
                Kt && typeof Kt == "object" && Object.keys(Kt).forEach(Gt => {
                    Kt[Gt] && typeof Kt[Gt] == "object" ? br[Gt] = {
                        ...br[Gt],
                        ...Kt[Gt]
                    } : br[Gt] = Kt[Gt]
                }
                )
            }
            return ot ? ot(br) : br
        }
        , [qt, Zn, Mt, Wt, Yt])
          , Ur = qt.colorSchemeSelector;
        useEnhancedEffect( () => {
            if (Zn && Jt && Ur && Ur !== "media") {
                const ir = Ur;
                let Cr = Ur;
                if (ir === "class" && (Cr = ".%s"),
                ir === "data" && (Cr = "[data-%s]"),
                ir != null && ir.startsWith("data-") && !ir.includes("%s") && (Cr = `[${ir}="%s"]`),
                Cr.startsWith("."))
                    Jt.classList.remove(...hn.map(br => Cr.substring(1).replace("%s", br))),
                    Jt.classList.add(Cr.substring(1).replace("%s", Zn));
                else {
                    const br = Cr.replace("%s", Zn).match(/\[([^\]]+)\]/);
                    if (br) {
                        const [an,Kt] = br[1].split("=");
                        Kt || hn.forEach(Gt => {
                            Jt.removeAttribute(an.replace(Zn, Gt))
                        }
                        ),
                        Jt.setAttribute(an, Kt ? Kt.replace(/"|'/g, "") : "")
                    } else
                        Jt.setAttribute(Cr, Zn)
                }
            }
        }
        , [Zn, Ur, Jt, hn]),
        reactExports.useEffect( () => {
            let ir;
            if (Lt && xt.current && Ut) {
                const Cr = Ut.createElement("style");
                Cr.appendChild(Ut.createTextNode(DISABLE_CSS_TRANSITION)),
                Ut.head.appendChild(Cr),
                window.getComputedStyle(Ut.body),
                ir = setTimeout( () => {
                    Ut.head.removeChild(Cr)
                }
                , 1)
            }
            return () => {
                clearTimeout(ir)
            }
        }
        , [Zn, Lt, Ut]),
        reactExports.useEffect( () => (xt.current = !0,
        () => {
            xt.current = !1
        }
        ), []);
        const xr = reactExports.useMemo( () => ({
            allColorSchemes: hn,
            colorScheme: Zn,
            darkColorScheme: cr,
            lightColorScheme: Hn,
            mode: rr,
            setColorScheme: Mn,
            setMode: Bn,
            systemMode: Un
        }), [hn, Zn, cr, Hn, rr, Mn, Bn, Un, pr.colorSchemeSelector]);
        let wr = !0;
        (Xt || qt.cssVariables === !1 || jt && ($t == null ? void 0 : $t.cssVarPrefix) === Yt) && (wr = !1);
        const Rn = jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [jsxRuntimeExports.jsx(ThemeProvider$1, {
                themeId: Ht ? $ : void 0,
                theme: pr,
                children: wt
            }), wr && jsxRuntimeExports.jsx(GlobalStyles$3, {
                styles: ((or = pr.generateStyleSheets) == null ? void 0 : or.call(pr)) || []
            })]
        });
        return jt ? Rn : jsxRuntimeExports.jsx(lt.Provider, {
            value: xr,
            children: Rn
        })
    }
    const mt = typeof it == "string" ? it : it.light
      , yt = typeof it == "string" ? it : it.dark;
    return {
        CssVarsProvider: ht,
        useColorScheme: ct,
        getInitColorSchemeScript: _t => InitColorSchemeScript({
            colorSchemeStorageKey: nt,
            defaultLightColorScheme: mt,
            defaultDarkColorScheme: yt,
            modeStorageKey: tt,
            ..._t
        })
    }
}
function createGetCssVar$1(_e="") {
    function $(...tt) {
        if (!tt.length)
            return "";
        const nt = tt[0];
        return typeof nt == "string" && !nt.match(/(#|\(|\)|(-?(\d*\.)?\d+)(px|em|%|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc))|^(-?(\d*\.)?\d+)$|(\d+ \d+ \d+)/) ? `, var(--${_e ? `${_e}-` : ""}${nt}${$(...tt.slice(1))})` : `, ${nt}`
    }
    return (tt, ...nt) => `var(--${_e ? `${_e}-` : ""}${tt}${$(...nt)})`
}
const assignNestedKeys = (_e, $, et, tt=[]) => {
    let nt = _e;
    $.forEach( (rt, it) => {
        it === $.length - 1 ? Array.isArray(nt) ? nt[Number(rt)] = et : nt && typeof nt == "object" && (nt[rt] = et) : nt && typeof nt == "object" && (nt[rt] || (nt[rt] = tt.includes(rt) ? [] : {}),
        nt = nt[rt])
    }
    )
}
  , walkObjectDeep = (_e, $, et) => {
    function tt(nt, rt=[], it=[]) {
        Object.entries(nt).forEach( ([ot,st]) => {
            (!et || et && !et([...rt, ot])) && st != null && (typeof st == "object" && Object.keys(st).length > 0 ? tt(st, [...rt, ot], Array.isArray(st) ? [...it, ot] : it) : $([...rt, ot], st, it))
        }
        )
    }
    tt(_e)
}
  , getCssValue = (_e, $) => typeof $ == "number" ? ["lineHeight", "fontWeight", "opacity", "zIndex"].some(tt => _e.includes(tt)) || _e[_e.length - 1].toLowerCase().includes("opacity") ? $ : `${$}px` : $;
function cssVarsParser(_e, $) {
    const {prefix: et, shouldSkipGeneratingVar: tt} = $ || {}
      , nt = {}
      , rt = {}
      , it = {};
    return walkObjectDeep(_e, (ot, st, lt) => {
        if ((typeof st == "string" || typeof st == "number") && (!tt || !tt(ot, st))) {
            const ct = `--${et ? `${et}-` : ""}${ot.join("-")}`
              , dt = getCssValue(ot, st);
            Object.assign(nt, {
                [ct]: dt
            }),
            assignNestedKeys(rt, ot, `var(${ct})`, lt),
            assignNestedKeys(it, ot, `var(${ct}, ${dt})`, lt)
        }
    }
    , ot => ot[0] === "vars"),
    {
        css: nt,
        vars: rt,
        varsWithDefaults: it
    }
}
function prepareCssVars(_e, $={}) {
    const {getSelector: et=Et, disableCssColorScheme: tt, colorSchemeSelector: nt} = $
      , {colorSchemes: rt={}, components: it, defaultColorScheme: ot="light", ...st} = _e
      , {vars: lt, css: ct, varsWithDefaults: dt} = cssVarsParser(st, $);
    let pt = dt;
    const ht = {}
      , {[ot]: mt, ...yt} = rt;
    if (Object.entries(yt || {}).forEach( ([St,Ct]) => {
        const {vars: Nt, css: Lt, varsWithDefaults: kt} = cssVarsParser(Ct, $);
        pt = deepmerge$1(pt, kt),
        ht[St] = {
            css: Lt,
            vars: Nt
        }
    }
    ),
    mt) {
        const {css: St, vars: Ct, varsWithDefaults: Nt} = cssVarsParser(mt, $);
        pt = deepmerge$1(pt, Nt),
        ht[ot] = {
            css: St,
            vars: Ct
        }
    }
    function Et(St, Ct) {
        var Lt, kt;
        let Nt = nt;
        if (nt === "class" && (Nt = ".%s"),
        nt === "data" && (Nt = "[data-%s]"),
        nt != null && nt.startsWith("data-") && !nt.includes("%s") && (Nt = `[${nt}="%s"]`),
        St) {
            if (Nt === "media")
                return _e.defaultColorScheme === St ? ":root" : {
                    [`@media (prefers-color-scheme: ${((kt = (Lt = rt[St]) == null ? void 0 : Lt.palette) == null ? void 0 : kt.mode) || St})`]: {
                        ":root": Ct
                    }
                };
            if (Nt)
                return _e.defaultColorScheme === St ? `:root, ${Nt.replace("%s", String(St))}` : Nt.replace("%s", String(St))
        }
        return ":root"
    }
    return {
        vars: pt,
        generateThemeVars: () => {
            let St = {
                ...lt
            };
            return Object.entries(ht).forEach( ([,{vars: Ct}]) => {
                St = deepmerge$1(St, Ct)
            }
            ),
            St
        }
        ,
        generateStyleSheets: () => {
            var Ut, Jt;
            const St = []
              , Ct = _e.defaultColorScheme || "light";
            function Nt(Pt, Xt) {
                Object.keys(Xt).length && St.push(typeof Pt == "string" ? {
                    [Pt]: {
                        ...Xt
                    }
                } : Pt)
            }
            Nt(et(void 0, {
                ...ct
            }), ct);
            const {[Ct]: Lt, ...kt} = ht;
            if (Lt) {
                const {css: Pt} = Lt
                  , Xt = (Jt = (Ut = rt[Ct]) == null ? void 0 : Ut.palette) == null ? void 0 : Jt.mode
                  , rn = !tt && Xt ? {
                    colorScheme: Xt,
                    ...Pt
                } : {
                    ...Pt
                };
                Nt(et(Ct, {
                    ...rn
                }), rn)
            }
            return Object.entries(kt).forEach( ([Pt,{css: Xt}]) => {
                var xt, $t;
                const rn = ($t = (xt = rt[Pt]) == null ? void 0 : xt.palette) == null ? void 0 : $t.mode
                  , zt = !tt && rn ? {
                    colorScheme: rn,
                    ...Xt
                } : {
                    ...Xt
                };
                Nt(et(Pt, {
                    ...zt
                }), zt)
            }
            ),
            St
        }
    }
}
function createGetColorSchemeSelector(_e) {
    return function(et) {
        return _e === "media" ? `@media (prefers-color-scheme: ${et})` : _e ? _e.startsWith("data-") && !_e.includes("%s") ? `[${_e}="${et}"] &` : _e === "class" ? `.${et} &` : _e === "data" ? `[data-${et}] &` : `${_e.replace("%s", et)} &` : "&"
    }
}
const defaultTheme$2 = createTheme$1()
  , defaultCreateStyledComponent = styled$1("div", {
    name: "MuiStack",
    slot: "Root",
    overridesResolver: (_e, $) => $.root
});
function useThemePropsDefault(_e) {
    return useThemeProps({
        props: _e,
        name: "MuiStack",
        defaultTheme: defaultTheme$2
    })
}
function joinChildren(_e, $) {
    const et = reactExports.Children.toArray(_e).filter(Boolean);
    return et.reduce( (tt, nt, rt) => (tt.push(nt),
    rt < et.length - 1 && tt.push(reactExports.cloneElement($, {
        key: `separator-${rt}`
    })),
    tt), [])
}
const getSideFromDirection = _e => ({
    row: "Left",
    "row-reverse": "Right",
    column: "Top",
    "column-reverse": "Bottom"
})[_e]
  , style = ({ownerState: _e, theme: $}) => {
    let et = {
        display: "flex",
        flexDirection: "column",
        ...handleBreakpoints({
            theme: $
        }, resolveBreakpointValues({
            values: _e.direction,
            breakpoints: $.breakpoints.values
        }), tt => ({
            flexDirection: tt
        }))
    };
    if (_e.spacing) {
        const tt = createUnarySpacing($)
          , nt = Object.keys($.breakpoints.values).reduce( (st, lt) => ((typeof _e.spacing == "object" && _e.spacing[lt] != null || typeof _e.direction == "object" && _e.direction[lt] != null) && (st[lt] = !0),
        st), {})
          , rt = resolveBreakpointValues({
            values: _e.direction,
            base: nt
        })
          , it = resolveBreakpointValues({
            values: _e.spacing,
            base: nt
        });
        typeof rt == "object" && Object.keys(rt).forEach( (st, lt, ct) => {
            if (!rt[st]) {
                const pt = lt > 0 ? rt[ct[lt - 1]] : "column";
                rt[st] = pt
            }
        }
        ),
        et = deepmerge$1(et, handleBreakpoints({
            theme: $
        }, it, (st, lt) => _e.useFlexGap ? {
            gap: getValue$4(tt, st)
        } : {
            "& > :not(style):not(style)": {
                margin: 0
            },
            "& > :not(style) ~ :not(style)": {
                [`margin${getSideFromDirection(lt ? rt[lt] : _e.direction)}`]: getValue$4(tt, st)
            }
        }))
    }
    return et = mergeBreakpointsInOrder($.breakpoints, et),
    et
}
;
function createStack(_e={}) {
    const {createStyledComponent: $=defaultCreateStyledComponent, useThemeProps: et=useThemePropsDefault, componentName: tt="MuiStack"} = _e
      , nt = () => composeClasses({
        root: ["root"]
    }, st => generateUtilityClass(tt, st), {})
      , rt = $(style);
    return reactExports.forwardRef(function(st, lt) {
        const ct = et(st)
          , dt = extendSxProp$1(ct)
          , {component: pt="div", direction: ht="column", spacing: mt=0, divider: yt, children: Et, className: _t, useFlexGap: wt=!1, ...St} = dt
          , Ct = {
            direction: ht,
            spacing: mt,
            useFlexGap: wt
        }
          , Nt = nt();
        return jsxRuntimeExports.jsx(rt, {
            as: pt,
            ownerState: Ct,
            ref: lt,
            className: clsx(Nt.root, _t),
            ...St,
            children: yt ? joinChildren(Et, yt) : Et
        })
    })
}
function getLight() {
    return {
        text: {
            primary: "rgba(0, 0, 0, 0.87)",
            secondary: "rgba(0, 0, 0, 0.6)",
            disabled: "rgba(0, 0, 0, 0.38)"
        },
        divider: "rgba(0, 0, 0, 0.12)",
        background: {
            paper: common.white,
            default: common.white
        },
        action: {
            active: "rgba(0, 0, 0, 0.54)",
            hover: "rgba(0, 0, 0, 0.04)",
            hoverOpacity: .04,
            selected: "rgba(0, 0, 0, 0.08)",
            selectedOpacity: .08,
            disabled: "rgba(0, 0, 0, 0.26)",
            disabledBackground: "rgba(0, 0, 0, 0.12)",
            disabledOpacity: .38,
            focus: "rgba(0, 0, 0, 0.12)",
            focusOpacity: .12,
            activatedOpacity: .12
        }
    }
}
const light = getLight();
function getDark() {
    return {
        text: {
            primary: common.white,
            secondary: "rgba(255, 255, 255, 0.7)",
            disabled: "rgba(255, 255, 255, 0.5)",
            icon: "rgba(255, 255, 255, 0.5)"
        },
        divider: "rgba(255, 255, 255, 0.12)",
        background: {
            paper: "#121212",
            default: "#121212"
        },
        action: {
            active: common.white,
            hover: "rgba(255, 255, 255, 0.08)",
            hoverOpacity: .08,
            selected: "rgba(255, 255, 255, 0.16)",
            selectedOpacity: .16,
            disabled: "rgba(255, 255, 255, 0.3)",
            disabledBackground: "rgba(255, 255, 255, 0.12)",
            disabledOpacity: .38,
            focus: "rgba(255, 255, 255, 0.12)",
            focusOpacity: .12,
            activatedOpacity: .24
        }
    }
}
const dark = getDark();
function addLightOrDark(_e, $, et, tt) {
    const nt = tt.light || tt
      , rt = tt.dark || tt * 1.5;
    _e[$] || (_e.hasOwnProperty(et) ? _e[$] = _e[et] : $ === "light" ? _e.light = lighten(_e.main, nt) : $ === "dark" && (_e.dark = darken(_e.main, rt)))
}
function getDefaultPrimary(_e="light") {
    return _e === "dark" ? {
        main: blue[200],
        light: blue[50],
        dark: blue[400]
    } : {
        main: blue[700],
        light: blue[400],
        dark: blue[800]
    }
}
function getDefaultSecondary(_e="light") {
    return _e === "dark" ? {
        main: purple[200],
        light: purple[50],
        dark: purple[400]
    } : {
        main: purple[500],
        light: purple[300],
        dark: purple[700]
    }
}
function getDefaultError(_e="light") {
    return _e === "dark" ? {
        main: red[500],
        light: red[300],
        dark: red[700]
    } : {
        main: red[700],
        light: red[400],
        dark: red[800]
    }
}
function getDefaultInfo(_e="light") {
    return _e === "dark" ? {
        main: lightBlue[400],
        light: lightBlue[300],
        dark: lightBlue[700]
    } : {
        main: lightBlue[700],
        light: lightBlue[500],
        dark: lightBlue[900]
    }
}
function getDefaultSuccess(_e="light") {
    return _e === "dark" ? {
        main: green[400],
        light: green[300],
        dark: green[700]
    } : {
        main: green[800],
        light: green[500],
        dark: green[900]
    }
}
function getDefaultWarning(_e="light") {
    return _e === "dark" ? {
        main: orange[400],
        light: orange[300],
        dark: orange[700]
    } : {
        main: "#ed6c02",
        light: orange[500],
        dark: orange[900]
    }
}
function createPalette(_e) {
    const {mode: $="light", contrastThreshold: et=3, tonalOffset: tt=.2, ...nt} = _e
      , rt = _e.primary || getDefaultPrimary($)
      , it = _e.secondary || getDefaultSecondary($)
      , ot = _e.error || getDefaultError($)
      , st = _e.info || getDefaultInfo($)
      , lt = _e.success || getDefaultSuccess($)
      , ct = _e.warning || getDefaultWarning($);
    function dt(yt) {
        return getContrastRatio(yt, dark.text.primary) >= et ? dark.text.primary : light.text.primary
    }
    const pt = ({color: yt, name: Et, mainShade: _t=500, lightShade: wt=300, darkShade: St=700}) => {
        if (yt = {
            ...yt
        },
        !yt.main && yt[_t] && (yt.main = yt[_t]),
        !yt.hasOwnProperty("main"))
            throw new Error(formatMuiErrorMessage(11, Et ? ` (${Et})` : "", _t));
        if (typeof yt.main != "string")
            throw new Error(formatMuiErrorMessage(12, Et ? ` (${Et})` : "", JSON.stringify(yt.main)));
        return addLightOrDark(yt, "light", wt, tt),
        addLightOrDark(yt, "dark", St, tt),
        yt.contrastText || (yt.contrastText = dt(yt.main)),
        yt
    }
    ;
    let ht;
    return $ === "light" ? ht = getLight() : $ === "dark" && (ht = getDark()),
    deepmerge$1({
        common: {
            ...common
        },
        mode: $,
        primary: pt({
            color: rt,
            name: "primary"
        }),
        secondary: pt({
            color: it,
            name: "secondary",
            mainShade: "A400",
            lightShade: "A200",
            darkShade: "A700"
        }),
        error: pt({
            color: ot,
            name: "error"
        }),
        warning: pt({
            color: ct,
            name: "warning"
        }),
        info: pt({
            color: st,
            name: "info"
        }),
        success: pt({
            color: lt,
            name: "success"
        }),
        grey,
        contrastThreshold: et,
        getContrastText: dt,
        augmentColor: pt,
        tonalOffset: tt,
        ...ht
    }, nt)
}
function prepareTypographyVars(_e) {
    const $ = {};
    return Object.entries(_e).forEach(tt => {
        const [nt,rt] = tt;
        typeof rt == "object" && ($[nt] = `${rt.fontStyle ? `${rt.fontStyle} ` : ""}${rt.fontVariant ? `${rt.fontVariant} ` : ""}${rt.fontWeight ? `${rt.fontWeight} ` : ""}${rt.fontStretch ? `${rt.fontStretch} ` : ""}${rt.fontSize || ""}${rt.lineHeight ? `/${rt.lineHeight} ` : ""}${rt.fontFamily || ""}`)
    }
    ),
    $
}
function createMixins(_e, $) {
    return {
        toolbar: {
            minHeight: 56,
            [_e.up("xs")]: {
                "@media (orientation: landscape)": {
                    minHeight: 48
                }
            },
            [_e.up("sm")]: {
                minHeight: 64
            }
        },
        ...$
    }
}
function round$1(_e) {
    return Math.round(_e * 1e5) / 1e5
}
const caseAllCaps = {
    textTransform: "uppercase"
}
  , defaultFontFamily = '"Roboto", "Helvetica", "Arial", sans-serif';
function createTypography(_e, $) {
    const {fontFamily: et=defaultFontFamily, fontSize: tt=14, fontWeightLight: nt=300, fontWeightRegular: rt=400, fontWeightMedium: it=500, fontWeightBold: ot=700, htmlFontSize: st=16, allVariants: lt, pxToRem: ct, ...dt} = typeof $ == "function" ? $(_e) : $
      , pt = tt / 14
      , ht = ct || (Et => `${Et / st * pt}rem`)
      , mt = (Et, _t, wt, St, Ct) => ({
        fontFamily: et,
        fontWeight: Et,
        fontSize: ht(_t),
        lineHeight: wt,
        ...et === defaultFontFamily ? {
            letterSpacing: `${round$1(St / _t)}em`
        } : {},
        ...Ct,
        ...lt
    })
      , yt = {
        h1: mt(nt, 96, 1.167, -1.5),
        h2: mt(nt, 60, 1.2, -.5),
        h3: mt(rt, 48, 1.167, 0),
        h4: mt(rt, 34, 1.235, .25),
        h5: mt(rt, 24, 1.334, 0),
        h6: mt(it, 20, 1.6, .15),
        subtitle1: mt(rt, 16, 1.75, .15),
        subtitle2: mt(it, 14, 1.57, .1),
        body1: mt(rt, 16, 1.5, .15),
        body2: mt(rt, 14, 1.43, .15),
        button: mt(it, 14, 1.75, .4, caseAllCaps),
        caption: mt(rt, 12, 1.66, .4),
        overline: mt(rt, 12, 2.66, 1, caseAllCaps),
        inherit: {
            fontFamily: "inherit",
            fontWeight: "inherit",
            fontSize: "inherit",
            lineHeight: "inherit",
            letterSpacing: "inherit"
        }
    };
    return deepmerge$1({
        htmlFontSize: st,
        pxToRem: ht,
        fontFamily: et,
        fontSize: tt,
        fontWeightLight: nt,
        fontWeightRegular: rt,
        fontWeightMedium: it,
        fontWeightBold: ot,
        ...yt
    }, dt, {
        clone: !1
    })
}
const shadowKeyUmbraOpacity = .2
  , shadowKeyPenumbraOpacity = .14
  , shadowAmbientShadowOpacity = .12;
function createShadow(..._e) {
    return [`${_e[0]}px ${_e[1]}px ${_e[2]}px ${_e[3]}px rgba(0,0,0,${shadowKeyUmbraOpacity})`, `${_e[4]}px ${_e[5]}px ${_e[6]}px ${_e[7]}px rgba(0,0,0,${shadowKeyPenumbraOpacity})`, `${_e[8]}px ${_e[9]}px ${_e[10]}px ${_e[11]}px rgba(0,0,0,${shadowAmbientShadowOpacity})`].join(",")
}
const shadows = ["none", createShadow(0, 2, 1, -1, 0, 1, 1, 0, 0, 1, 3, 0), createShadow(0, 3, 1, -2, 0, 2, 2, 0, 0, 1, 5, 0), createShadow(0, 3, 3, -2, 0, 3, 4, 0, 0, 1, 8, 0), createShadow(0, 2, 4, -1, 0, 4, 5, 0, 0, 1, 10, 0), createShadow(0, 3, 5, -1, 0, 5, 8, 0, 0, 1, 14, 0), createShadow(0, 3, 5, -1, 0, 6, 10, 0, 0, 1, 18, 0), createShadow(0, 4, 5, -2, 0, 7, 10, 1, 0, 2, 16, 1), createShadow(0, 5, 5, -3, 0, 8, 10, 1, 0, 3, 14, 2), createShadow(0, 5, 6, -3, 0, 9, 12, 1, 0, 3, 16, 2), createShadow(0, 6, 6, -3, 0, 10, 14, 1, 0, 4, 18, 3), createShadow(0, 6, 7, -4, 0, 11, 15, 1, 0, 4, 20, 3), createShadow(0, 7, 8, -4, 0, 12, 17, 2, 0, 5, 22, 4), createShadow(0, 7, 8, -4, 0, 13, 19, 2, 0, 5, 24, 4), createShadow(0, 7, 9, -4, 0, 14, 21, 2, 0, 5, 26, 4), createShadow(0, 8, 9, -5, 0, 15, 22, 2, 0, 6, 28, 5), createShadow(0, 8, 10, -5, 0, 16, 24, 2, 0, 6, 30, 5), createShadow(0, 8, 11, -5, 0, 17, 26, 2, 0, 6, 32, 5), createShadow(0, 9, 11, -5, 0, 18, 28, 2, 0, 7, 34, 6), createShadow(0, 9, 12, -6, 0, 19, 29, 2, 0, 7, 36, 6), createShadow(0, 10, 13, -6, 0, 20, 31, 3, 0, 8, 38, 7), createShadow(0, 10, 13, -6, 0, 21, 33, 3, 0, 8, 40, 7), createShadow(0, 10, 14, -6, 0, 22, 35, 3, 0, 8, 42, 7), createShadow(0, 11, 14, -7, 0, 23, 36, 3, 0, 9, 44, 8), createShadow(0, 11, 15, -7, 0, 24, 38, 3, 0, 9, 46, 8)]
  , easing = {
    easeInOut: "cubic-bezier(0.4, 0, 0.2, 1)",
    easeOut: "cubic-bezier(0.0, 0, 0.2, 1)",
    easeIn: "cubic-bezier(0.4, 0, 1, 1)",
    sharp: "cubic-bezier(0.4, 0, 0.6, 1)"
}
  , duration$2 = {
    shortest: 150,
    shorter: 200,
    short: 250,
    standard: 300,
    complex: 375,
    enteringScreen: 225,
    leavingScreen: 195
};
function formatMs(_e) {
    return `${Math.round(_e)}ms`
}
function getAutoHeightDuration(_e) {
    if (!_e)
        return 0;
    const $ = _e / 36;
    return Math.min(Math.round((4 + 15 * $ ** .25 + $ / 5) * 10), 3e3)
}
function createTransitions(_e) {
    const $ = {
        ...easing,
        ..._e.easing
    }
      , et = {
        ...duration$2,
        ..._e.duration
    };
    return {
        getAutoHeightDuration,
        create: (nt=["all"], rt={}) => {
            const {duration: it=et.standard, easing: ot=$.easeInOut, delay: st=0, ...lt} = rt;
            return (Array.isArray(nt) ? nt : [nt]).map(ct => `${ct} ${typeof it == "string" ? it : formatMs(it)} ${ot} ${typeof st == "string" ? st : formatMs(st)}`).join(",")
        }
        ,
        ..._e,
        easing: $,
        duration: et
    }
}
const zIndex = {
    mobileStepper: 1e3,
    fab: 1050,
    speedDial: 1050,
    appBar: 1100,
    drawer: 1200,
    modal: 1300,
    snackbar: 1400,
    tooltip: 1500
};
function isSerializable(_e) {
    return isPlainObject$3(_e) || typeof _e > "u" || typeof _e == "string" || typeof _e == "boolean" || typeof _e == "number" || Array.isArray(_e)
}
function stringifyTheme(_e={}) {
    const $ = {
        ..._e
    };
    function et(tt) {
        const nt = Object.entries(tt);
        for (let rt = 0; rt < nt.length; rt++) {
            const [it,ot] = nt[rt];
            !isSerializable(ot) || it.startsWith("unstable_") ? delete tt[it] : isPlainObject$3(ot) && (tt[it] = {
                ...ot
            },
            et(tt[it]))
        }
    }
    return et($),
    `import { unstable_createBreakpoints as createBreakpoints, createTransitions } from '@mui/material/styles';

const theme = ${JSON.stringify($, null, 2)};

theme.breakpoints = createBreakpoints(theme.breakpoints || {});
theme.transitions = createTransitions(theme.transitions || {});

export default theme;`
}
function createThemeNoVars(_e={}, ...$) {
    const {breakpoints: et, mixins: tt={}, spacing: nt, palette: rt={}, transitions: it={}, typography: ot={}, shape: st, ...lt} = _e;
    if (_e.vars)
        throw new Error(formatMuiErrorMessage(20));
    const ct = createPalette(rt)
      , dt = createTheme$1(_e);
    let pt = deepmerge$1(dt, {
        mixins: createMixins(dt.breakpoints, tt),
        palette: ct,
        shadows: shadows.slice(),
        typography: createTypography(ct, ot),
        transitions: createTransitions(it),
        zIndex: {
            ...zIndex
        }
    });
    return pt = deepmerge$1(pt, lt),
    pt = $.reduce( (ht, mt) => deepmerge$1(ht, mt), pt),
    pt.unstable_sxConfig = {
        ...defaultSxConfig,
        ...lt == null ? void 0 : lt.unstable_sxConfig
    },
    pt.unstable_sx = function(mt) {
        return styleFunctionSx({
            sx: mt,
            theme: this
        })
    }
    ,
    pt.toRuntimeSource = stringifyTheme,
    pt
}
function getOverlayAlpha(_e) {
    let $;
    return _e < 1 ? $ = 5.11916 * _e ** 2 : $ = 4.5 * Math.log(_e + 1) + 2,
    Math.round($ * 10) / 1e3
}
const defaultDarkOverlays = [...Array(25)].map( (_e, $) => {
    if ($ === 0)
        return "none";
    const et = getOverlayAlpha($);
    return `linear-gradient(rgba(255 255 255 / ${et}), rgba(255 255 255 / ${et}))`
}
);
function getOpacity(_e) {
    return {
        inputPlaceholder: _e === "dark" ? .5 : .42,
        inputUnderline: _e === "dark" ? .7 : .42,
        switchTrackDisabled: _e === "dark" ? .2 : .12,
        switchTrack: _e === "dark" ? .3 : .38
    }
}
function getOverlays(_e) {
    return _e === "dark" ? defaultDarkOverlays : []
}
function createColorScheme(_e) {
    const {palette: $={
        mode: "light"
    }, opacity: et, overlays: tt, ...nt} = _e
      , rt = createPalette($);
    return {
        palette: rt,
        opacity: {
            ...getOpacity(rt.mode),
            ...et
        },
        overlays: tt || getOverlays(rt.mode),
        ...nt
    }
}
function shouldSkipGeneratingVar(_e) {
    var $;
    return !!_e[0].match(/(cssVarPrefix|colorSchemeSelector|rootSelector|typography|mixins|breakpoints|direction|transitions)/) || !!_e[0].match(/sxConfig$/) || _e[0] === "palette" && !!(($ = _e[1]) != null && $.match(/(mode|contrastThreshold|tonalOffset)/))
}
const excludeVariablesFromRoot = _e => [...[...Array(25)].map( ($, et) => `--${_e ? `${_e}-` : ""}overlays-${et}`), `--${_e ? `${_e}-` : ""}palette-AppBar-darkBg`, `--${_e ? `${_e}-` : ""}palette-AppBar-darkColor`]
  , defaultGetSelector = _e => ($, et) => {
    const tt = _e.rootSelector || ":root"
      , nt = _e.colorSchemeSelector;
    let rt = nt;
    if (nt === "class" && (rt = ".%s"),
    nt === "data" && (rt = "[data-%s]"),
    nt != null && nt.startsWith("data-") && !nt.includes("%s") && (rt = `[${nt}="%s"]`),
    _e.defaultColorScheme === $) {
        if ($ === "dark") {
            const it = {};
            return excludeVariablesFromRoot(_e.cssVarPrefix).forEach(ot => {
                it[ot] = et[ot],
                delete et[ot]
            }
            ),
            rt === "media" ? {
                [tt]: et,
                "@media (prefers-color-scheme: dark)": {
                    [tt]: it
                }
            } : rt ? {
                [rt.replace("%s", $)]: it,
                [`${tt}, ${rt.replace("%s", $)}`]: et
            } : {
                [tt]: {
                    ...et,
                    ...it
                }
            }
        }
        if (rt && rt !== "media")
            return `${tt}, ${rt.replace("%s", String($))}`
    } else if ($) {
        if (rt === "media")
            return {
                [`@media (prefers-color-scheme: ${String($)})`]: {
                    [tt]: et
                }
            };
        if (rt)
            return rt.replace("%s", String($))
    }
    return tt
}
;
function assignNode(_e, $) {
    $.forEach(et => {
        _e[et] || (_e[et] = {})
    }
    )
}
function setColor(_e, $, et) {
    !_e[$] && et && (_e[$] = et)
}
function toRgb(_e) {
    return typeof _e != "string" || !_e.startsWith("hsl") ? _e : hslToRgb(_e)
}
function setColorChannel(_e, $) {
    `${$}Channel`in _e || (_e[`${$}Channel`] = private_safeColorChannel(toRgb(_e[$])))
}
function getSpacingVal(_e) {
    return typeof _e == "number" ? `${_e}px` : typeof _e == "string" || typeof _e == "function" || Array.isArray(_e) ? _e : "8px"
}
const silent = _e => {
    try {
        return _e()
    } catch {}
}
  , createGetCssVar = (_e="mui") => createGetCssVar$1(_e);
function attachColorScheme$1(_e, $, et, tt) {
    if (!$)
        return;
    $ = $ === !0 ? {} : $;
    const nt = tt === "dark" ? "dark" : "light";
    if (!et) {
        _e[tt] = createColorScheme({
            ...$,
            palette: {
                mode: nt,
                ...$ == null ? void 0 : $.palette
            }
        });
        return
    }
    const {palette: rt, ...it} = createThemeNoVars({
        ...et,
        palette: {
            mode: nt,
            ...$ == null ? void 0 : $.palette
        }
    });
    return _e[tt] = {
        ...$,
        palette: rt,
        opacity: {
            ...getOpacity(nt),
            ...$ == null ? void 0 : $.opacity
        },
        overlays: ($ == null ? void 0 : $.overlays) || getOverlays(nt)
    },
    it
}
function createThemeWithVars(_e={}, ...$) {
    const {colorSchemes: et={
        light: !0
    }, defaultColorScheme: tt, disableCssColorScheme: nt=!1, cssVarPrefix: rt="mui", shouldSkipGeneratingVar: it=shouldSkipGeneratingVar, colorSchemeSelector: ot=et.light && et.dark ? "media" : void 0, rootSelector: st=":root", ...lt} = _e
      , ct = Object.keys(et)[0]
      , dt = tt || (et.light && ct !== "light" ? "light" : ct)
      , pt = createGetCssVar(rt)
      , {[dt]: ht, light: mt, dark: yt, ...Et} = et
      , _t = {
        ...Et
    };
    let wt = ht;
    if ((dt === "dark" && !("dark"in et) || dt === "light" && !("light"in et)) && (wt = !0),
    !wt)
        throw new Error(formatMuiErrorMessage(21, dt));
    const St = attachColorScheme$1(_t, wt, lt, dt);
    mt && !_t.light && attachColorScheme$1(_t, mt, void 0, "light"),
    yt && !_t.dark && attachColorScheme$1(_t, yt, void 0, "dark");
    let Ct = {
        defaultColorScheme: dt,
        ...St,
        cssVarPrefix: rt,
        colorSchemeSelector: ot,
        rootSelector: st,
        getCssVar: pt,
        colorSchemes: _t,
        font: {
            ...prepareTypographyVars(St.typography),
            ...St.font
        },
        spacing: getSpacingVal(lt.spacing)
    };
    Object.keys(Ct.colorSchemes).forEach(Jt => {
        const Pt = Ct.colorSchemes[Jt].palette
          , Xt = rn => {
            const zt = rn.split("-")
              , xt = zt[1]
              , $t = zt[2];
            return pt(rn, Pt[xt][$t])
        }
        ;
        if (Pt.mode === "light" && (setColor(Pt.common, "background", "#fff"),
        setColor(Pt.common, "onBackground", "#000")),
        Pt.mode === "dark" && (setColor(Pt.common, "background", "#000"),
        setColor(Pt.common, "onBackground", "#fff")),
        assignNode(Pt, ["Alert", "AppBar", "Avatar", "Button", "Chip", "FilledInput", "LinearProgress", "Skeleton", "Slider", "SnackbarContent", "SpeedDialAction", "StepConnector", "StepContent", "Switch", "TableCell", "Tooltip"]),
        Pt.mode === "light") {
            setColor(Pt.Alert, "errorColor", private_safeDarken(Pt.error.light, .6)),
            setColor(Pt.Alert, "infoColor", private_safeDarken(Pt.info.light, .6)),
            setColor(Pt.Alert, "successColor", private_safeDarken(Pt.success.light, .6)),
            setColor(Pt.Alert, "warningColor", private_safeDarken(Pt.warning.light, .6)),
            setColor(Pt.Alert, "errorFilledBg", Xt("palette-error-main")),
            setColor(Pt.Alert, "infoFilledBg", Xt("palette-info-main")),
            setColor(Pt.Alert, "successFilledBg", Xt("palette-success-main")),
            setColor(Pt.Alert, "warningFilledBg", Xt("palette-warning-main")),
            setColor(Pt.Alert, "errorFilledColor", silent( () => Pt.getContrastText(Pt.error.main))),
            setColor(Pt.Alert, "infoFilledColor", silent( () => Pt.getContrastText(Pt.info.main))),
            setColor(Pt.Alert, "successFilledColor", silent( () => Pt.getContrastText(Pt.success.main))),
            setColor(Pt.Alert, "warningFilledColor", silent( () => Pt.getContrastText(Pt.warning.main))),
            setColor(Pt.Alert, "errorStandardBg", private_safeLighten(Pt.error.light, .9)),
            setColor(Pt.Alert, "infoStandardBg", private_safeLighten(Pt.info.light, .9)),
            setColor(Pt.Alert, "successStandardBg", private_safeLighten(Pt.success.light, .9)),
            setColor(Pt.Alert, "warningStandardBg", private_safeLighten(Pt.warning.light, .9)),
            setColor(Pt.Alert, "errorIconColor", Xt("palette-error-main")),
            setColor(Pt.Alert, "infoIconColor", Xt("palette-info-main")),
            setColor(Pt.Alert, "successIconColor", Xt("palette-success-main")),
            setColor(Pt.Alert, "warningIconColor", Xt("palette-warning-main")),
            setColor(Pt.AppBar, "defaultBg", Xt("palette-grey-100")),
            setColor(Pt.Avatar, "defaultBg", Xt("palette-grey-400")),
            setColor(Pt.Button, "inheritContainedBg", Xt("palette-grey-300")),
            setColor(Pt.Button, "inheritContainedHoverBg", Xt("palette-grey-A100")),
            setColor(Pt.Chip, "defaultBorder", Xt("palette-grey-400")),
            setColor(Pt.Chip, "defaultAvatarColor", Xt("palette-grey-700")),
            setColor(Pt.Chip, "defaultIconColor", Xt("palette-grey-700")),
            setColor(Pt.FilledInput, "bg", "rgba(0, 0, 0, 0.06)"),
            setColor(Pt.FilledInput, "hoverBg", "rgba(0, 0, 0, 0.09)"),
            setColor(Pt.FilledInput, "disabledBg", "rgba(0, 0, 0, 0.12)"),
            setColor(Pt.LinearProgress, "primaryBg", private_safeLighten(Pt.primary.main, .62)),
            setColor(Pt.LinearProgress, "secondaryBg", private_safeLighten(Pt.secondary.main, .62)),
            setColor(Pt.LinearProgress, "errorBg", private_safeLighten(Pt.error.main, .62)),
            setColor(Pt.LinearProgress, "infoBg", private_safeLighten(Pt.info.main, .62)),
            setColor(Pt.LinearProgress, "successBg", private_safeLighten(Pt.success.main, .62)),
            setColor(Pt.LinearProgress, "warningBg", private_safeLighten(Pt.warning.main, .62)),
            setColor(Pt.Skeleton, "bg", `rgba(${Xt("palette-text-primaryChannel")} / 0.11)`),
            setColor(Pt.Slider, "primaryTrack", private_safeLighten(Pt.primary.main, .62)),
            setColor(Pt.Slider, "secondaryTrack", private_safeLighten(Pt.secondary.main, .62)),
            setColor(Pt.Slider, "errorTrack", private_safeLighten(Pt.error.main, .62)),
            setColor(Pt.Slider, "infoTrack", private_safeLighten(Pt.info.main, .62)),
            setColor(Pt.Slider, "successTrack", private_safeLighten(Pt.success.main, .62)),
            setColor(Pt.Slider, "warningTrack", private_safeLighten(Pt.warning.main, .62));
            const rn = private_safeEmphasize(Pt.background.default, .8);
            setColor(Pt.SnackbarContent, "bg", rn),
            setColor(Pt.SnackbarContent, "color", silent( () => Pt.getContrastText(rn))),
            setColor(Pt.SpeedDialAction, "fabHoverBg", private_safeEmphasize(Pt.background.paper, .15)),
            setColor(Pt.StepConnector, "border", Xt("palette-grey-400")),
            setColor(Pt.StepContent, "border", Xt("palette-grey-400")),
            setColor(Pt.Switch, "defaultColor", Xt("palette-common-white")),
            setColor(Pt.Switch, "defaultDisabledColor", Xt("palette-grey-100")),
            setColor(Pt.Switch, "primaryDisabledColor", private_safeLighten(Pt.primary.main, .62)),
            setColor(Pt.Switch, "secondaryDisabledColor", private_safeLighten(Pt.secondary.main, .62)),
            setColor(Pt.Switch, "errorDisabledColor", private_safeLighten(Pt.error.main, .62)),
            setColor(Pt.Switch, "infoDisabledColor", private_safeLighten(Pt.info.main, .62)),
            setColor(Pt.Switch, "successDisabledColor", private_safeLighten(Pt.success.main, .62)),
            setColor(Pt.Switch, "warningDisabledColor", private_safeLighten(Pt.warning.main, .62)),
            setColor(Pt.TableCell, "border", private_safeLighten(private_safeAlpha(Pt.divider, 1), .88)),
            setColor(Pt.Tooltip, "bg", private_safeAlpha(Pt.grey[700], .92))
        }
        if (Pt.mode === "dark") {
            setColor(Pt.Alert, "errorColor", private_safeLighten(Pt.error.light, .6)),
            setColor(Pt.Alert, "infoColor", private_safeLighten(Pt.info.light, .6)),
            setColor(Pt.Alert, "successColor", private_safeLighten(Pt.success.light, .6)),
            setColor(Pt.Alert, "warningColor", private_safeLighten(Pt.warning.light, .6)),
            setColor(Pt.Alert, "errorFilledBg", Xt("palette-error-dark")),
            setColor(Pt.Alert, "infoFilledBg", Xt("palette-info-dark")),
            setColor(Pt.Alert, "successFilledBg", Xt("palette-success-dark")),
            setColor(Pt.Alert, "warningFilledBg", Xt("palette-warning-dark")),
            setColor(Pt.Alert, "errorFilledColor", silent( () => Pt.getContrastText(Pt.error.dark))),
            setColor(Pt.Alert, "infoFilledColor", silent( () => Pt.getContrastText(Pt.info.dark))),
            setColor(Pt.Alert, "successFilledColor", silent( () => Pt.getContrastText(Pt.success.dark))),
            setColor(Pt.Alert, "warningFilledColor", silent( () => Pt.getContrastText(Pt.warning.dark))),
            setColor(Pt.Alert, "errorStandardBg", private_safeDarken(Pt.error.light, .9)),
            setColor(Pt.Alert, "infoStandardBg", private_safeDarken(Pt.info.light, .9)),
            setColor(Pt.Alert, "successStandardBg", private_safeDarken(Pt.success.light, .9)),
            setColor(Pt.Alert, "warningStandardBg", private_safeDarken(Pt.warning.light, .9)),
            setColor(Pt.Alert, "errorIconColor", Xt("palette-error-main")),
            setColor(Pt.Alert, "infoIconColor", Xt("palette-info-main")),
            setColor(Pt.Alert, "successIconColor", Xt("palette-success-main")),
            setColor(Pt.Alert, "warningIconColor", Xt("palette-warning-main")),
            setColor(Pt.AppBar, "defaultBg", Xt("palette-grey-900")),
            setColor(Pt.AppBar, "darkBg", Xt("palette-background-paper")),
            setColor(Pt.AppBar, "darkColor", Xt("palette-text-primary")),
            setColor(Pt.Avatar, "defaultBg", Xt("palette-grey-600")),
            setColor(Pt.Button, "inheritContainedBg", Xt("palette-grey-800")),
            setColor(Pt.Button, "inheritContainedHoverBg", Xt("palette-grey-700")),
            setColor(Pt.Chip, "defaultBorder", Xt("palette-grey-700")),
            setColor(Pt.Chip, "defaultAvatarColor", Xt("palette-grey-300")),
            setColor(Pt.Chip, "defaultIconColor", Xt("palette-grey-300")),
            setColor(Pt.FilledInput, "bg", "rgba(255, 255, 255, 0.09)"),
            setColor(Pt.FilledInput, "hoverBg", "rgba(255, 255, 255, 0.13)"),
            setColor(Pt.FilledInput, "disabledBg", "rgba(255, 255, 255, 0.12)"),
            setColor(Pt.LinearProgress, "primaryBg", private_safeDarken(Pt.primary.main, .5)),
            setColor(Pt.LinearProgress, "secondaryBg", private_safeDarken(Pt.secondary.main, .5)),
            setColor(Pt.LinearProgress, "errorBg", private_safeDarken(Pt.error.main, .5)),
            setColor(Pt.LinearProgress, "infoBg", private_safeDarken(Pt.info.main, .5)),
            setColor(Pt.LinearProgress, "successBg", private_safeDarken(Pt.success.main, .5)),
            setColor(Pt.LinearProgress, "warningBg", private_safeDarken(Pt.warning.main, .5)),
            setColor(Pt.Skeleton, "bg", `rgba(${Xt("palette-text-primaryChannel")} / 0.13)`),
            setColor(Pt.Slider, "primaryTrack", private_safeDarken(Pt.primary.main, .5)),
            setColor(Pt.Slider, "secondaryTrack", private_safeDarken(Pt.secondary.main, .5)),
            setColor(Pt.Slider, "errorTrack", private_safeDarken(Pt.error.main, .5)),
            setColor(Pt.Slider, "infoTrack", private_safeDarken(Pt.info.main, .5)),
            setColor(Pt.Slider, "successTrack", private_safeDarken(Pt.success.main, .5)),
            setColor(Pt.Slider, "warningTrack", private_safeDarken(Pt.warning.main, .5));
            const rn = private_safeEmphasize(Pt.background.default, .98);
            setColor(Pt.SnackbarContent, "bg", rn),
            setColor(Pt.SnackbarContent, "color", silent( () => Pt.getContrastText(rn))),
            setColor(Pt.SpeedDialAction, "fabHoverBg", private_safeEmphasize(Pt.background.paper, .15)),
            setColor(Pt.StepConnector, "border", Xt("palette-grey-600")),
            setColor(Pt.StepContent, "border", Xt("palette-grey-600")),
            setColor(Pt.Switch, "defaultColor", Xt("palette-grey-300")),
            setColor(Pt.Switch, "defaultDisabledColor", Xt("palette-grey-600")),
            setColor(Pt.Switch, "primaryDisabledColor", private_safeDarken(Pt.primary.main, .55)),
            setColor(Pt.Switch, "secondaryDisabledColor", private_safeDarken(Pt.secondary.main, .55)),
            setColor(Pt.Switch, "errorDisabledColor", private_safeDarken(Pt.error.main, .55)),
            setColor(Pt.Switch, "infoDisabledColor", private_safeDarken(Pt.info.main, .55)),
            setColor(Pt.Switch, "successDisabledColor", private_safeDarken(Pt.success.main, .55)),
            setColor(Pt.Switch, "warningDisabledColor", private_safeDarken(Pt.warning.main, .55)),
            setColor(Pt.TableCell, "border", private_safeDarken(private_safeAlpha(Pt.divider, 1), .68)),
            setColor(Pt.Tooltip, "bg", private_safeAlpha(Pt.grey[700], .92))
        }
        setColorChannel(Pt.background, "default"),
        setColorChannel(Pt.background, "paper"),
        setColorChannel(Pt.common, "background"),
        setColorChannel(Pt.common, "onBackground"),
        setColorChannel(Pt, "divider"),
        Object.keys(Pt).forEach(rn => {
            const zt = Pt[rn];
            rn !== "tonalOffset" && zt && typeof zt == "object" && (zt.main && setColor(Pt[rn], "mainChannel", private_safeColorChannel(toRgb(zt.main))),
            zt.light && setColor(Pt[rn], "lightChannel", private_safeColorChannel(toRgb(zt.light))),
            zt.dark && setColor(Pt[rn], "darkChannel", private_safeColorChannel(toRgb(zt.dark))),
            zt.contrastText && setColor(Pt[rn], "contrastTextChannel", private_safeColorChannel(toRgb(zt.contrastText))),
            rn === "text" && (setColorChannel(Pt[rn], "primary"),
            setColorChannel(Pt[rn], "secondary")),
            rn === "action" && (zt.active && setColorChannel(Pt[rn], "active"),
            zt.selected && setColorChannel(Pt[rn], "selected")))
        }
        )
    }
    ),
    Ct = $.reduce( (Jt, Pt) => deepmerge$1(Jt, Pt), Ct);
    const Nt = {
        prefix: rt,
        disableCssColorScheme: nt,
        shouldSkipGeneratingVar: it,
        getSelector: defaultGetSelector(Ct)
    }
      , {vars: Lt, generateThemeVars: kt, generateStyleSheets: Ut} = prepareCssVars(Ct, Nt);
    return Ct.vars = Lt,
    Object.entries(Ct.colorSchemes[Ct.defaultColorScheme]).forEach( ([Jt,Pt]) => {
        Ct[Jt] = Pt
    }
    ),
    Ct.generateThemeVars = kt,
    Ct.generateStyleSheets = Ut,
    Ct.generateSpacing = function() {
        return createSpacing(lt.spacing, createUnarySpacing(this))
    }
    ,
    Ct.getColorSchemeSelector = createGetColorSchemeSelector(ot),
    Ct.spacing = Ct.generateSpacing(),
    Ct.shouldSkipGeneratingVar = it,
    Ct.unstable_sxConfig = {
        ...defaultSxConfig,
        ...lt == null ? void 0 : lt.unstable_sxConfig
    },
    Ct.unstable_sx = function(Pt) {
        return styleFunctionSx({
            sx: Pt,
            theme: this
        })
    }
    ,
    Ct.toRuntimeSource = stringifyTheme,
    Ct
}
function attachColorScheme(_e, $, et) {
    _e.colorSchemes && et && (_e.colorSchemes[$] = {
        ...et !== !0 && et,
        palette: createPalette({
            ...et === !0 ? {} : et.palette,
            mode: $
        })
    })
}
function createTheme(_e={}, ...$) {
    const {palette: et, cssVariables: tt=!1, colorSchemes: nt=et ? void 0 : {
        light: !0
    }, defaultColorScheme: rt=et == null ? void 0 : et.mode, ...it} = _e
      , ot = rt || "light"
      , st = nt == null ? void 0 : nt[ot]
      , lt = {
        ...nt,
        ...et ? {
            [ot]: {
                ...typeof st != "boolean" && st,
                palette: et
            }
        } : void 0
    };
    if (tt === !1) {
        if (!("colorSchemes"in _e))
            return createThemeNoVars(_e, ...$);
        let ct = et;
        "palette"in _e || lt[ot] && (lt[ot] !== !0 ? ct = lt[ot].palette : ot === "dark" && (ct = {
            mode: "dark"
        }));
        const dt = createThemeNoVars({
            ..._e,
            palette: ct
        }, ...$);
        return dt.defaultColorScheme = ot,
        dt.colorSchemes = lt,
        dt.palette.mode === "light" && (dt.colorSchemes.light = {
            ...lt.light !== !0 && lt.light,
            palette: dt.palette
        },
        attachColorScheme(dt, "dark", lt.dark)),
        dt.palette.mode === "dark" && (dt.colorSchemes.dark = {
            ...lt.dark !== !0 && lt.dark,
            palette: dt.palette
        },
        attachColorScheme(dt, "light", lt.light)),
        dt
    }
    return !et && !("light"in lt) && ot === "light" && (lt.light = !0),
    createThemeWithVars({
        ...it,
        colorSchemes: lt,
        defaultColorScheme: ot,
        ...typeof tt != "boolean" && tt
    }, ...$)
}
const defaultTheme$1 = createTheme();
function useTheme() {
    const _e = useTheme$2(defaultTheme$1);
    return _e[THEME_ID] || _e
}
function slotShouldForwardProp(_e) {
    return _e !== "ownerState" && _e !== "theme" && _e !== "sx" && _e !== "as"
}
const rootShouldForwardProp = _e => slotShouldForwardProp(_e) && _e !== "classes"
  , styled = createStyled({
    themeId: THEME_ID,
    defaultTheme: defaultTheme$1,
    rootShouldForwardProp
});
function ThemeProviderNoVars({theme: _e, ...$}) {
    const et = THEME_ID in _e ? _e[THEME_ID] : void 0;
    return jsxRuntimeExports.jsx(ThemeProvider$1, {
        ...$,
        themeId: et ? THEME_ID : void 0,
        theme: et || _e
    })
}
const defaultConfig = {
    colorSchemeStorageKey: "mui-color-scheme",
    defaultLightColorScheme: "light",
    defaultDarkColorScheme: "dark",
    modeStorageKey: "mui-mode"
}
  , {CssVarsProvider: InternalCssVarsProvider} = createCssVarsProvider({
    themeId: THEME_ID,
    theme: () => createTheme({
        cssVariables: !0
    }),
    colorSchemeStorageKey: defaultConfig.colorSchemeStorageKey,
    modeStorageKey: defaultConfig.modeStorageKey,
    defaultColorScheme: {
        light: defaultConfig.defaultLightColorScheme,
        dark: defaultConfig.defaultDarkColorScheme
    },
    resolveTheme: _e => {
        const $ = {
            ..._e,
            typography: createTypography(_e.palette, _e.typography)
        };
        return $.unstable_sx = function(tt) {
            return styleFunctionSx({
                sx: tt,
                theme: this
            })
        }
        ,
        $
    }
})
  , CssVarsProvider = InternalCssVarsProvider;
function ThemeProvider({theme: _e, ...$}) {
    return typeof _e == "function" ? jsxRuntimeExports.jsx(ThemeProviderNoVars, {
        theme: _e,
        ...$
    }) : "colorSchemes"in (THEME_ID in _e ? _e[THEME_ID] : _e) ? jsxRuntimeExports.jsx(CssVarsProvider, {
        theme: _e,
        ...$
    }) : jsxRuntimeExports.jsx(ThemeProviderNoVars, {
        theme: _e,
        ...$
    })
}
function GlobalStyles$1(_e) {
    return jsxRuntimeExports.jsx(GlobalStyles$2, {
        ..._e,
        defaultTheme: defaultTheme$1,
        themeId: THEME_ID
    })
}
function globalCss(_e) {
    return function(et) {
        return jsxRuntimeExports.jsx(GlobalStyles$1, {
            styles: typeof _e == "function" ? tt => _e({
                theme: tt,
                ...et
            }) : _e
        })
    }
}
function internal_createExtendSxProp() {
    return extendSxProp$1
}
const memoTheme = unstable_memoTheme;
function useDefaultProps(_e) {
    return useDefaultProps$1(_e)
}
function getSvgIconUtilityClass(_e) {
    return generateUtilityClass("MuiSvgIcon", _e)
}
generateUtilityClasses("MuiSvgIcon", ["root", "colorPrimary", "colorSecondary", "colorAction", "colorError", "colorDisabled", "fontSizeInherit", "fontSizeSmall", "fontSizeMedium", "fontSizeLarge"]);
const useUtilityClasses$z = _e => {
    const {color: $, fontSize: et, classes: tt} = _e
      , nt = {
        root: ["root", $ !== "inherit" && `color${capitalize($)}`, `fontSize${capitalize(et)}`]
    };
    return composeClasses(nt, getSvgIconUtilityClass, tt)
}
  , SvgIconRoot = styled("svg", {
    name: "MuiSvgIcon",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, et.color !== "inherit" && $[`color${capitalize(et.color)}`], $[`fontSize${capitalize(et.fontSize)}`]]
    }
})(memoTheme( ({theme: _e}) => {
    var $, et, tt, nt, rt, it, ot, st, lt, ct, dt, pt, ht, mt;
    return {
        userSelect: "none",
        width: "1em",
        height: "1em",
        display: "inline-block",
        flexShrink: 0,
        transition: (nt = ($ = _e.transitions) == null ? void 0 : $.create) == null ? void 0 : nt.call($, "fill", {
            duration: (tt = (et = (_e.vars ?? _e).transitions) == null ? void 0 : et.duration) == null ? void 0 : tt.shorter
        }),
        variants: [{
            props: yt => !yt.hasSvgAsChild,
            style: {
                fill: "currentColor"
            }
        }, {
            props: {
                fontSize: "inherit"
            },
            style: {
                fontSize: "inherit"
            }
        }, {
            props: {
                fontSize: "small"
            },
            style: {
                fontSize: ((it = (rt = _e.typography) == null ? void 0 : rt.pxToRem) == null ? void 0 : it.call(rt, 20)) || "1.25rem"
            }
        }, {
            props: {
                fontSize: "medium"
            },
            style: {
                fontSize: ((st = (ot = _e.typography) == null ? void 0 : ot.pxToRem) == null ? void 0 : st.call(ot, 24)) || "1.5rem"
            }
        }, {
            props: {
                fontSize: "large"
            },
            style: {
                fontSize: ((ct = (lt = _e.typography) == null ? void 0 : lt.pxToRem) == null ? void 0 : ct.call(lt, 35)) || "2.1875rem"
            }
        }, ...Object.entries((_e.vars ?? _e).palette).filter( ([,yt]) => yt && yt.main).map( ([yt]) => {
            var Et, _t;
            return {
                props: {
                    color: yt
                },
                style: {
                    color: (_t = (Et = (_e.vars ?? _e).palette) == null ? void 0 : Et[yt]) == null ? void 0 : _t.main
                }
            }
        }
        ), {
            props: {
                color: "action"
            },
            style: {
                color: (pt = (dt = (_e.vars ?? _e).palette) == null ? void 0 : dt.action) == null ? void 0 : pt.active
            }
        }, {
            props: {
                color: "disabled"
            },
            style: {
                color: (mt = (ht = (_e.vars ?? _e).palette) == null ? void 0 : ht.action) == null ? void 0 : mt.disabled
            }
        }, {
            props: {
                color: "inherit"
            },
            style: {
                color: void 0
            }
        }]
    }
}
))
  , SvgIcon = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiSvgIcon"
    })
      , {children: nt, className: rt, color: it="inherit", component: ot="svg", fontSize: st="medium", htmlColor: lt, inheritViewBox: ct=!1, titleAccess: dt, viewBox: pt="0 0 24 24", ...ht} = tt
      , mt = reactExports.isValidElement(nt) && nt.type === "svg"
      , yt = {
        ...tt,
        color: it,
        component: ot,
        fontSize: st,
        instanceFontSize: $.fontSize,
        inheritViewBox: ct,
        viewBox: pt,
        hasSvgAsChild: mt
    }
      , Et = {};
    ct || (Et.viewBox = pt);
    const _t = useUtilityClasses$z(yt);
    return jsxRuntimeExports.jsxs(SvgIconRoot, {
        as: ot,
        className: clsx(_t.root, rt),
        focusable: "false",
        color: lt,
        "aria-hidden": dt ? void 0 : !0,
        role: dt ? "img" : void 0,
        ref: et,
        ...Et,
        ...ht,
        ...mt && nt.props,
        ownerState: yt,
        children: [mt ? nt.props.children : nt, dt ? jsxRuntimeExports.jsx("title", {
            children: dt
        }) : null]
    })
});
SvgIcon.muiName = "SvgIcon";
function createSvgIcon(_e, $) {
    function et(tt, nt) {
        return jsxRuntimeExports.jsx(SvgIcon, {
            "data-testid": `${$}Icon`,
            ref: nt,
            ...tt,
            children: _e
        })
    }
    return et.muiName = SvgIcon.muiName,
    reactExports.memo(reactExports.forwardRef(et))
}
function _objectWithoutPropertiesLoose$1(_e, $) {
    if (_e == null)
        return {};
    var et = {};
    for (var tt in _e)
        if ({}.hasOwnProperty.call(_e, tt)) {
            if ($.indexOf(tt) !== -1)
                continue;
            et[tt] = _e[tt]
        }
    return et
}
function _setPrototypeOf(_e, $) {
    return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(et, tt) {
        return et.__proto__ = tt,
        et
    }
    ,
    _setPrototypeOf(_e, $)
}
function _inheritsLoose(_e, $) {
    _e.prototype = Object.create($.prototype),
    _e.prototype.constructor = _e,
    _setPrototypeOf(_e, $)
}
const config$1 = {
    disabled: !1
}
  , TransitionGroupContext = React.createContext(null);
var forceReflow = function($) {
    return $.scrollTop
}
  , UNMOUNTED = "unmounted"
  , EXITED = "exited"
  , ENTERING = "entering"
  , ENTERED = "entered"
  , EXITING = "exiting"
  , Transition = function(_e) {
    _inheritsLoose($, _e);
    function $(tt, nt) {
        var rt;
        rt = _e.call(this, tt, nt) || this;
        var it = nt, ot = it && !it.isMounting ? tt.enter : tt.appear, st;
        return rt.appearStatus = null,
        tt.in ? ot ? (st = EXITED,
        rt.appearStatus = ENTERING) : st = ENTERED : tt.unmountOnExit || tt.mountOnEnter ? st = UNMOUNTED : st = EXITED,
        rt.state = {
            status: st
        },
        rt.nextCallback = null,
        rt
    }
    $.getDerivedStateFromProps = function(nt, rt) {
        var it = nt.in;
        return it && rt.status === UNMOUNTED ? {
            status: EXITED
        } : null
    }
    ;
    var et = $.prototype;
    return et.componentDidMount = function() {
        this.updateStatus(!0, this.appearStatus)
    }
    ,
    et.componentDidUpdate = function(nt) {
        var rt = null;
        if (nt !== this.props) {
            var it = this.state.status;
            this.props.in ? it !== ENTERING && it !== ENTERED && (rt = ENTERING) : (it === ENTERING || it === ENTERED) && (rt = EXITING)
        }
        this.updateStatus(!1, rt)
    }
    ,
    et.componentWillUnmount = function() {
        this.cancelNextCallback()
    }
    ,
    et.getTimeouts = function() {
        var nt = this.props.timeout, rt, it, ot;
        return rt = it = ot = nt,
        nt != null && typeof nt != "number" && (rt = nt.exit,
        it = nt.enter,
        ot = nt.appear !== void 0 ? nt.appear : it),
        {
            exit: rt,
            enter: it,
            appear: ot
        }
    }
    ,
    et.updateStatus = function(nt, rt) {
        if (nt === void 0 && (nt = !1),
        rt !== null)
            if (this.cancelNextCallback(),
            rt === ENTERING) {
                if (this.props.unmountOnExit || this.props.mountOnEnter) {
                    var it = this.props.nodeRef ? this.props.nodeRef.current : io.findDOMNode(this);
                    it && forceReflow(it)
                }
                this.performEnter(nt)
            } else
                this.performExit();
        else
            this.props.unmountOnExit && this.state.status === EXITED && this.setState({
                status: UNMOUNTED
            })
    }
    ,
    et.performEnter = function(nt) {
        var rt = this
          , it = this.props.enter
          , ot = this.context ? this.context.isMounting : nt
          , st = this.props.nodeRef ? [ot] : [io.findDOMNode(this), ot]
          , lt = st[0]
          , ct = st[1]
          , dt = this.getTimeouts()
          , pt = ot ? dt.appear : dt.enter;
        if (!nt && !it || config$1.disabled) {
            this.safeSetState({
                status: ENTERED
            }, function() {
                rt.props.onEntered(lt)
            });
            return
        }
        this.props.onEnter(lt, ct),
        this.safeSetState({
            status: ENTERING
        }, function() {
            rt.props.onEntering(lt, ct),
            rt.onTransitionEnd(pt, function() {
                rt.safeSetState({
                    status: ENTERED
                }, function() {
                    rt.props.onEntered(lt, ct)
                })
            })
        })
    }
    ,
    et.performExit = function() {
        var nt = this
          , rt = this.props.exit
          , it = this.getTimeouts()
          , ot = this.props.nodeRef ? void 0 : io.findDOMNode(this);
        if (!rt || config$1.disabled) {
            this.safeSetState({
                status: EXITED
            }, function() {
                nt.props.onExited(ot)
            });
            return
        }
        this.props.onExit(ot),
        this.safeSetState({
            status: EXITING
        }, function() {
            nt.props.onExiting(ot),
            nt.onTransitionEnd(it.exit, function() {
                nt.safeSetState({
                    status: EXITED
                }, function() {
                    nt.props.onExited(ot)
                })
            })
        })
    }
    ,
    et.cancelNextCallback = function() {
        this.nextCallback !== null && (this.nextCallback.cancel(),
        this.nextCallback = null)
    }
    ,
    et.safeSetState = function(nt, rt) {
        rt = this.setNextCallback(rt),
        this.setState(nt, rt)
    }
    ,
    et.setNextCallback = function(nt) {
        var rt = this
          , it = !0;
        return this.nextCallback = function(ot) {
            it && (it = !1,
            rt.nextCallback = null,
            nt(ot))
        }
        ,
        this.nextCallback.cancel = function() {
            it = !1
        }
        ,
        this.nextCallback
    }
    ,
    et.onTransitionEnd = function(nt, rt) {
        this.setNextCallback(rt);
        var it = this.props.nodeRef ? this.props.nodeRef.current : io.findDOMNode(this)
          , ot = nt == null && !this.props.addEndListener;
        if (!it || ot) {
            setTimeout(this.nextCallback, 0);
            return
        }
        if (this.props.addEndListener) {
            var st = this.props.nodeRef ? [this.nextCallback] : [it, this.nextCallback]
              , lt = st[0]
              , ct = st[1];
            this.props.addEndListener(lt, ct)
        }
        nt != null && setTimeout(this.nextCallback, nt)
    }
    ,
    et.render = function() {
        var nt = this.state.status;
        if (nt === UNMOUNTED)
            return null;
        var rt = this.props
          , it = rt.children;
        rt.in,
        rt.mountOnEnter,
        rt.unmountOnExit,
        rt.appear,
        rt.enter,
        rt.exit,
        rt.timeout,
        rt.addEndListener,
        rt.onEnter,
        rt.onEntering,
        rt.onEntered,
        rt.onExit,
        rt.onExiting,
        rt.onExited,
        rt.nodeRef;
        var ot = _objectWithoutPropertiesLoose$1(rt, ["children", "in", "mountOnEnter", "unmountOnExit", "appear", "enter", "exit", "timeout", "addEndListener", "onEnter", "onEntering", "onEntered", "onExit", "onExiting", "onExited", "nodeRef"]);
        return React.createElement(TransitionGroupContext.Provider, {
            value: null
        }, typeof it == "function" ? it(nt, ot) : React.cloneElement(React.Children.only(it), ot))
    }
    ,
    $
}(React.Component);
Transition.contextType = TransitionGroupContext;
Transition.propTypes = {};
function noop$4() {}
Transition.defaultProps = {
    in: !1,
    mountOnEnter: !1,
    unmountOnExit: !1,
    appear: !1,
    enter: !0,
    exit: !0,
    onEnter: noop$4,
    onEntering: noop$4,
    onEntered: noop$4,
    onExit: noop$4,
    onExiting: noop$4,
    onExited: noop$4
};
Transition.UNMOUNTED = UNMOUNTED;
Transition.EXITED = EXITED;
Transition.ENTERING = ENTERING;
Transition.ENTERED = ENTERED;
Transition.EXITING = EXITING;
function _assertThisInitialized(_e) {
    if (_e === void 0)
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return _e
}
function getChildMapping(_e, $) {
    var et = function(rt) {
        return $ && reactExports.isValidElement(rt) ? $(rt) : rt
    }
      , tt = Object.create(null);
    return _e && reactExports.Children.map(_e, function(nt) {
        return nt
    }).forEach(function(nt) {
        tt[nt.key] = et(nt)
    }),
    tt
}
function mergeChildMappings(_e, $) {
    _e = _e || {},
    $ = $ || {};
    function et(ct) {
        return ct in $ ? $[ct] : _e[ct]
    }
    var tt = Object.create(null)
      , nt = [];
    for (var rt in _e)
        rt in $ ? nt.length && (tt[rt] = nt,
        nt = []) : nt.push(rt);
    var it, ot = {};
    for (var st in $) {
        if (tt[st])
            for (it = 0; it < tt[st].length; it++) {
                var lt = tt[st][it];
                ot[tt[st][it]] = et(lt)
            }
        ot[st] = et(st)
    }
    for (it = 0; it < nt.length; it++)
        ot[nt[it]] = et(nt[it]);
    return ot
}
function getProp(_e, $, et) {
    return et[$] != null ? et[$] : _e.props[$]
}
function getInitialChildMapping(_e, $) {
    return getChildMapping(_e.children, function(et) {
        return reactExports.cloneElement(et, {
            onExited: $.bind(null, et),
            in: !0,
            appear: getProp(et, "appear", _e),
            enter: getProp(et, "enter", _e),
            exit: getProp(et, "exit", _e)
        })
    })
}
function getNextChildMapping(_e, $, et) {
    var tt = getChildMapping(_e.children)
      , nt = mergeChildMappings($, tt);
    return Object.keys(nt).forEach(function(rt) {
        var it = nt[rt];
        if (reactExports.isValidElement(it)) {
            var ot = rt in $
              , st = rt in tt
              , lt = $[rt]
              , ct = reactExports.isValidElement(lt) && !lt.props.in;
            st && (!ot || ct) ? nt[rt] = reactExports.cloneElement(it, {
                onExited: et.bind(null, it),
                in: !0,
                exit: getProp(it, "exit", _e),
                enter: getProp(it, "enter", _e)
            }) : !st && ot && !ct ? nt[rt] = reactExports.cloneElement(it, {
                in: !1
            }) : st && ot && reactExports.isValidElement(lt) && (nt[rt] = reactExports.cloneElement(it, {
                onExited: et.bind(null, it),
                in: lt.props.in,
                exit: getProp(it, "exit", _e),
                enter: getProp(it, "enter", _e)
            }))
        }
    }),
    nt
}
var values = Object.values || function(_e) {
    return Object.keys(_e).map(function($) {
        return _e[$]
    })
}
  , defaultProps = {
    component: "div",
    childFactory: function($) {
        return $
    }
}
  , TransitionGroup = function(_e) {
    _inheritsLoose($, _e);
    function $(tt, nt) {
        var rt;
        rt = _e.call(this, tt, nt) || this;
        var it = rt.handleExited.bind(_assertThisInitialized(rt));
        return rt.state = {
            contextValue: {
                isMounting: !0
            },
            handleExited: it,
            firstRender: !0
        },
        rt
    }
    var et = $.prototype;
    return et.componentDidMount = function() {
        this.mounted = !0,
        this.setState({
            contextValue: {
                isMounting: !1
            }
        })
    }
    ,
    et.componentWillUnmount = function() {
        this.mounted = !1
    }
    ,
    $.getDerivedStateFromProps = function(nt, rt) {
        var it = rt.children
          , ot = rt.handleExited
          , st = rt.firstRender;
        return {
            children: st ? getInitialChildMapping(nt, ot) : getNextChildMapping(nt, it, ot),
            firstRender: !1
        }
    }
    ,
    et.handleExited = function(nt, rt) {
        var it = getChildMapping(this.props.children);
        nt.key in it || (nt.props.onExited && nt.props.onExited(rt),
        this.mounted && this.setState(function(ot) {
            var st = _extends$3({}, ot.children);
            return delete st[nt.key],
            {
                children: st
            }
        }))
    }
    ,
    et.render = function() {
        var nt = this.props
          , rt = nt.component
          , it = nt.childFactory
          , ot = _objectWithoutPropertiesLoose$1(nt, ["component", "childFactory"])
          , st = this.state.contextValue
          , lt = values(this.state.children).map(it);
        return delete ot.appear,
        delete ot.enter,
        delete ot.exit,
        rt === null ? React.createElement(TransitionGroupContext.Provider, {
            value: st
        }, lt) : React.createElement(TransitionGroupContext.Provider, {
            value: st
        }, React.createElement(rt, ot, lt))
    }
    ,
    $
}(React.Component);
TransitionGroup.propTypes = {};
TransitionGroup.defaultProps = defaultProps;
const reflow = _e => _e.scrollTop;
function getTransitionProps(_e, $) {
    const {timeout: et, easing: tt, style: nt={}} = _e;
    return {
        duration: nt.transitionDuration ?? (typeof et == "number" ? et : et[$.mode] || 0),
        easing: nt.transitionTimingFunction ?? (typeof tt == "object" ? tt[$.mode] : tt),
        delay: nt.transitionDelay
    }
}
function getCollapseUtilityClass(_e) {
    return generateUtilityClass("MuiCollapse", _e)
}
generateUtilityClasses("MuiCollapse", ["root", "horizontal", "vertical", "entered", "hidden", "wrapper", "wrapperInner"]);
const useUtilityClasses$y = _e => {
    const {orientation: $, classes: et} = _e
      , tt = {
        root: ["root", `${$}`],
        entered: ["entered"],
        hidden: ["hidden"],
        wrapper: ["wrapper", `${$}`],
        wrapperInner: ["wrapperInner", `${$}`]
    };
    return composeClasses(tt, getCollapseUtilityClass, et)
}
  , CollapseRoot = styled("div", {
    name: "MuiCollapse",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, $[et.orientation], et.state === "entered" && $.entered, et.state === "exited" && !et.in && et.collapsedSize === "0px" && $.hidden]
    }
})(memoTheme( ({theme: _e}) => ({
    height: 0,
    overflow: "hidden",
    transition: _e.transitions.create("height"),
    variants: [{
        props: {
            orientation: "horizontal"
        },
        style: {
            height: "auto",
            width: 0,
            transition: _e.transitions.create("width")
        }
    }, {
        props: {
            state: "entered"
        },
        style: {
            height: "auto",
            overflow: "visible"
        }
    }, {
        props: {
            state: "entered",
            orientation: "horizontal"
        },
        style: {
            width: "auto"
        }
    }, {
        props: ({ownerState: $}) => $.state === "exited" && !$.in && $.collapsedSize === "0px",
        style: {
            visibility: "hidden"
        }
    }]
})))
  , CollapseWrapper = styled("div", {
    name: "MuiCollapse",
    slot: "Wrapper",
    overridesResolver: (_e, $) => $.wrapper
})({
    display: "flex",
    width: "100%",
    variants: [{
        props: {
            orientation: "horizontal"
        },
        style: {
            width: "auto",
            height: "100%"
        }
    }]
})
  , CollapseWrapperInner = styled("div", {
    name: "MuiCollapse",
    slot: "WrapperInner",
    overridesResolver: (_e, $) => $.wrapperInner
})({
    width: "100%",
    variants: [{
        props: {
            orientation: "horizontal"
        },
        style: {
            width: "auto",
            height: "100%"
        }
    }]
})
  , Collapse = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiCollapse"
    })
      , {addEndListener: nt, children: rt, className: it, collapsedSize: ot="0px", component: st, easing: lt, in: ct, onEnter: dt, onEntered: pt, onEntering: ht, onExit: mt, onExited: yt, onExiting: Et, orientation: _t="vertical", style: wt, timeout: St=duration$2.standard, TransitionComponent: Ct=Transition, ...Nt} = tt
      , Lt = {
        ...tt,
        orientation: _t,
        collapsedSize: ot
    }
      , kt = useUtilityClasses$y(Lt)
      , Ut = useTheme()
      , Jt = useTimeout()
      , Pt = reactExports.useRef(null)
      , Xt = reactExports.useRef()
      , rn = typeof ot == "number" ? `${ot}px` : ot
      , zt = _t === "horizontal"
      , xt = zt ? "width" : "height"
      , $t = reactExports.useRef(null)
      , Dt = useForkRef(et, $t)
      , jt = _n => kn => {
        if (_n) {
            const Dn = $t.current;
            kn === void 0 ? _n(Dn) : _n(Dn, kn)
        }
    }
      , Ft = () => Pt.current ? Pt.current[zt ? "clientWidth" : "clientHeight"] : 0
      , Ht = jt( (_n, kn) => {
        Pt.current && zt && (Pt.current.style.position = "absolute"),
        _n.style[xt] = rn,
        dt && dt(_n, kn)
    }
    )
      , qt = jt( (_n, kn) => {
        const Dn = Ft();
        Pt.current && zt && (Pt.current.style.position = "");
        const {duration: jn, easing: Bn} = getTransitionProps({
            style: wt,
            timeout: St,
            easing: lt
        }, {
            mode: "enter"
        });
        if (St === "auto") {
            const Un = Ut.transitions.getAutoHeightDuration(Dn);
            _n.style.transitionDuration = `${Un}ms`,
            Xt.current = Un
        } else
            _n.style.transitionDuration = typeof jn == "string" ? jn : `${jn}ms`;
        _n.style[xt] = `${Dn}px`,
        _n.style.transitionTimingFunction = Bn,
        ht && ht(_n, kn)
    }
    )
      , Wt = jt( (_n, kn) => {
        _n.style[xt] = "auto",
        pt && pt(_n, kn)
    }
    )
      , Mt = jt(_n => {
        _n.style[xt] = `${Ft()}px`,
        mt && mt(_n)
    }
    )
      , Yt = jt(yt)
      , un = jt(_n => {
        const kn = Ft()
          , {duration: Dn, easing: jn} = getTransitionProps({
            style: wt,
            timeout: St,
            easing: lt
        }, {
            mode: "exit"
        });
        if (St === "auto") {
            const Bn = Ut.transitions.getAutoHeightDuration(kn);
            _n.style.transitionDuration = `${Bn}ms`,
            Xt.current = Bn
        } else
            _n.style.transitionDuration = typeof Dn == "string" ? Dn : `${Dn}ms`;
        _n.style[xt] = rn,
        _n.style.transitionTimingFunction = jn,
        Et && Et(_n)
    }
    )
      , hn = _n => {
        St === "auto" && Jt.start(Xt.current || 0, _n),
        nt && nt($t.current, _n)
    }
    ;
    return jsxRuntimeExports.jsx(Ct, {
        in: ct,
        onEnter: Ht,
        onEntered: Wt,
        onEntering: qt,
        onExit: Mt,
        onExited: Yt,
        onExiting: un,
        addEndListener: hn,
        nodeRef: $t,
        timeout: St === "auto" ? null : St,
        ...Nt,
        children: (_n, {ownerState: kn, ...Dn}) => jsxRuntimeExports.jsx(CollapseRoot, {
            as: st,
            className: clsx(kt.root, it, {
                entered: kt.entered,
                exited: !ct && rn === "0px" && kt.hidden
            }[_n]),
            style: {
                [zt ? "minWidth" : "minHeight"]: rn,
                ...wt
            },
            ref: Dt,
            ownerState: {
                ...Lt,
                state: _n
            },
            ...Dn,
            children: jsxRuntimeExports.jsx(CollapseWrapper, {
                ownerState: {
                    ...Lt,
                    state: _n
                },
                className: kt.wrapper,
                ref: Pt,
                children: jsxRuntimeExports.jsx(CollapseWrapperInner, {
                    ownerState: {
                        ...Lt,
                        state: _n
                    },
                    className: kt.wrapperInner,
                    children: rt
                })
            })
        })
    })
});
Collapse && (Collapse.muiSupportAuto = !0);
function getPaperUtilityClass(_e) {
    return generateUtilityClass("MuiPaper", _e)
}
generateUtilityClasses("MuiPaper", ["root", "rounded", "outlined", "elevation", "elevation0", "elevation1", "elevation2", "elevation3", "elevation4", "elevation5", "elevation6", "elevation7", "elevation8", "elevation9", "elevation10", "elevation11", "elevation12", "elevation13", "elevation14", "elevation15", "elevation16", "elevation17", "elevation18", "elevation19", "elevation20", "elevation21", "elevation22", "elevation23", "elevation24"]);
const useUtilityClasses$x = _e => {
    const {square: $, elevation: et, variant: tt, classes: nt} = _e
      , rt = {
        root: ["root", tt, !$ && "rounded", tt === "elevation" && `elevation${et}`]
    };
    return composeClasses(rt, getPaperUtilityClass, nt)
}
  , PaperRoot = styled("div", {
    name: "MuiPaper",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, $[et.variant], !et.square && $.rounded, et.variant === "elevation" && $[`elevation${et.elevation}`]]
    }
})(memoTheme( ({theme: _e}) => ({
    backgroundColor: (_e.vars || _e).palette.background.paper,
    color: (_e.vars || _e).palette.text.primary,
    transition: _e.transitions.create("box-shadow"),
    variants: [{
        props: ({ownerState: $}) => !$.square,
        style: {
            borderRadius: _e.shape.borderRadius
        }
    }, {
        props: {
            variant: "outlined"
        },
        style: {
            border: `1px solid ${(_e.vars || _e).palette.divider}`
        }
    }, {
        props: {
            variant: "elevation"
        },
        style: {
            boxShadow: "var(--Paper-shadow)",
            backgroundImage: "var(--Paper-overlay)"
        }
    }]
})))
  , Paper = reactExports.forwardRef(function($, et) {
    var ht;
    const tt = useDefaultProps({
        props: $,
        name: "MuiPaper"
    })
      , nt = useTheme()
      , {className: rt, component: it="div", elevation: ot=1, square: st=!1, variant: lt="elevation", ...ct} = tt
      , dt = {
        ...tt,
        component: it,
        elevation: ot,
        square: st,
        variant: lt
    }
      , pt = useUtilityClasses$x(dt);
    return jsxRuntimeExports.jsx(PaperRoot, {
        as: it,
        ownerState: dt,
        className: clsx(pt.root, rt),
        ref: et,
        ...ct,
        style: {
            ...lt === "elevation" && {
                "--Paper-shadow": (nt.vars || nt).shadows[ot],
                ...nt.vars && {
                    "--Paper-overlay": (ht = nt.vars.overlays) == null ? void 0 : ht[ot]
                },
                ...!nt.vars && nt.palette.mode === "dark" && {
                    "--Paper-overlay": `linear-gradient(${alpha("#fff", getOverlayAlpha(ot))}, ${alpha("#fff", getOverlayAlpha(ot))})`
                }
            },
            ...ct.style
        }
    })
});
function useSlot(_e, $) {
    const {className: et, elementType: tt, ownerState: nt, externalForwardedProps: rt, internalForwardedProps: it, shouldForwardComponentProp: ot=!1, ...st} = $
      , {component: lt, slots: ct={
        [_e]: void 0
    }, slotProps: dt={
        [_e]: void 0
    }, ...pt} = rt
      , ht = ct[_e] || tt
      , mt = resolveComponentProps(dt[_e], nt)
      , {props: {component: yt, ...Et}, internalRef: _t} = mergeSlotProps({
        className: et,
        ...st,
        externalForwardedProps: _e === "root" ? pt : void 0,
        externalSlotProps: mt
    })
      , wt = useForkRef(_t, mt == null ? void 0 : mt.ref, $.ref)
      , St = _e === "root" ? yt || lt : yt
      , Ct = appendOwnerState(ht, {
        ..._e === "root" && !lt && !ct[_e] && it,
        ..._e !== "root" && !ct[_e] && it,
        ...Et,
        ...St && !ot && {
            as: St
        },
        ...St && ot && {
            component: St
        },
        ref: wt
    }, nt);
    return [ht, Ct]
}
class LazyRipple {
    constructor() {
        Br(this, "mountEffect", () => {
            this.shouldMount && !this.didMount && this.ref.current !== null && (this.didMount = !0,
            this.mounted.resolve())
        }
        );
        this.ref = {
            current: null
        },
        this.mounted = null,
        this.didMount = !1,
        this.shouldMount = !1,
        this.setShouldMount = null
    }
    static create() {
        return new LazyRipple
    }
    static use() {
        const $ = useLazyRef(LazyRipple.create).current
          , [et,tt] = reactExports.useState(!1);
        return $.shouldMount = et,
        $.setShouldMount = tt,
        reactExports.useEffect($.mountEffect, [et]),
        $
    }
    mount() {
        return this.mounted || (this.mounted = createControlledPromise(),
        this.shouldMount = !0,
        this.setShouldMount(this.shouldMount)),
        this.mounted
    }
    start(...$) {
        this.mount().then( () => {
            var et;
            return (et = this.ref.current) == null ? void 0 : et.start(...$)
        }
        )
    }
    stop(...$) {
        this.mount().then( () => {
            var et;
            return (et = this.ref.current) == null ? void 0 : et.stop(...$)
        }
        )
    }
    pulsate(...$) {
        this.mount().then( () => {
            var et;
            return (et = this.ref.current) == null ? void 0 : et.pulsate(...$)
        }
        )
    }
}
function useLazyRipple() {
    return LazyRipple.use()
}
function createControlledPromise() {
    let _e, $;
    const et = new Promise( (tt, nt) => {
        _e = tt,
        $ = nt
    }
    );
    return et.resolve = _e,
    et.reject = $,
    et
}
function Ripple(_e) {
    const {className: $, classes: et, pulsate: tt=!1, rippleX: nt, rippleY: rt, rippleSize: it, in: ot, onExited: st, timeout: lt} = _e
      , [ct,dt] = reactExports.useState(!1)
      , pt = clsx($, et.ripple, et.rippleVisible, tt && et.ripplePulsate)
      , ht = {
        width: it,
        height: it,
        top: -(it / 2) + rt,
        left: -(it / 2) + nt
    }
      , mt = clsx(et.child, ct && et.childLeaving, tt && et.childPulsate);
    return !ot && !ct && dt(!0),
    reactExports.useEffect( () => {
        if (!ot && st != null) {
            const yt = setTimeout(st, lt);
            return () => {
                clearTimeout(yt)
            }
        }
    }
    , [st, ot, lt]),
    jsxRuntimeExports.jsx("span", {
        className: pt,
        style: ht,
        children: jsxRuntimeExports.jsx("span", {
            className: mt
        })
    })
}
const touchRippleClasses = generateUtilityClasses("MuiTouchRipple", ["root", "ripple", "rippleVisible", "ripplePulsate", "child", "childLeaving", "childPulsate"])
  , DURATION = 550
  , DELAY_RIPPLE = 80
  , enterKeyframe = keyframes`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`
  , exitKeyframe = keyframes`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`
  , pulsateKeyframe = keyframes`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`
  , TouchRippleRoot = styled("span", {
    name: "MuiTouchRipple",
    slot: "Root"
})({
    overflow: "hidden",
    pointerEvents: "none",
    position: "absolute",
    zIndex: 0,
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    borderRadius: "inherit"
})
  , TouchRippleRipple = styled(Ripple, {
    name: "MuiTouchRipple",
    slot: "Ripple"
})`
  opacity: 0;
  position: absolute;

  &.${touchRippleClasses.rippleVisible} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${enterKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${ ({theme: _e}) => _e.transitions.easing.easeInOut};
  }

  &.${touchRippleClasses.ripplePulsate} {
    animation-duration: ${ ({theme: _e}) => _e.transitions.duration.shorter}ms;
  }

  & .${touchRippleClasses.child} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${touchRippleClasses.childLeaving} {
    opacity: 0;
    animation-name: ${exitKeyframe};
    animation-duration: ${DURATION}ms;
    animation-timing-function: ${ ({theme: _e}) => _e.transitions.easing.easeInOut};
  }

  & .${touchRippleClasses.childPulsate} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${pulsateKeyframe};
    animation-duration: 2500ms;
    animation-timing-function: ${ ({theme: _e}) => _e.transitions.easing.easeInOut};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`
  , TouchRipple = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiTouchRipple"
    })
      , {center: nt=!1, classes: rt={}, className: it, ...ot} = tt
      , [st,lt] = reactExports.useState([])
      , ct = reactExports.useRef(0)
      , dt = reactExports.useRef(null);
    reactExports.useEffect( () => {
        dt.current && (dt.current(),
        dt.current = null)
    }
    , [st]);
    const pt = reactExports.useRef(!1)
      , ht = useTimeout()
      , mt = reactExports.useRef(null)
      , yt = reactExports.useRef(null)
      , Et = reactExports.useCallback(Ct => {
        const {pulsate: Nt, rippleX: Lt, rippleY: kt, rippleSize: Ut, cb: Jt} = Ct;
        lt(Pt => [...Pt, jsxRuntimeExports.jsx(TouchRippleRipple, {
            classes: {
                ripple: clsx(rt.ripple, touchRippleClasses.ripple),
                rippleVisible: clsx(rt.rippleVisible, touchRippleClasses.rippleVisible),
                ripplePulsate: clsx(rt.ripplePulsate, touchRippleClasses.ripplePulsate),
                child: clsx(rt.child, touchRippleClasses.child),
                childLeaving: clsx(rt.childLeaving, touchRippleClasses.childLeaving),
                childPulsate: clsx(rt.childPulsate, touchRippleClasses.childPulsate)
            },
            timeout: DURATION,
            pulsate: Nt,
            rippleX: Lt,
            rippleY: kt,
            rippleSize: Ut
        }, ct.current)]),
        ct.current += 1,
        dt.current = Jt
    }
    , [rt])
      , _t = reactExports.useCallback( (Ct={}, Nt={}, Lt= () => {}
    ) => {
        const {pulsate: kt=!1, center: Ut=nt || Nt.pulsate, fakeElement: Jt=!1} = Nt;
        if ((Ct == null ? void 0 : Ct.type) === "mousedown" && pt.current) {
            pt.current = !1;
            return
        }
        (Ct == null ? void 0 : Ct.type) === "touchstart" && (pt.current = !0);
        const Pt = Jt ? null : yt.current
          , Xt = Pt ? Pt.getBoundingClientRect() : {
            width: 0,
            height: 0,
            left: 0,
            top: 0
        };
        let rn, zt, xt;
        if (Ut || Ct === void 0 || Ct.clientX === 0 && Ct.clientY === 0 || !Ct.clientX && !Ct.touches)
            rn = Math.round(Xt.width / 2),
            zt = Math.round(Xt.height / 2);
        else {
            const {clientX: $t, clientY: Dt} = Ct.touches && Ct.touches.length > 0 ? Ct.touches[0] : Ct;
            rn = Math.round($t - Xt.left),
            zt = Math.round(Dt - Xt.top)
        }
        if (Ut)
            xt = Math.sqrt((2 * Xt.width ** 2 + Xt.height ** 2) / 3),
            xt % 2 === 0 && (xt += 1);
        else {
            const $t = Math.max(Math.abs((Pt ? Pt.clientWidth : 0) - rn), rn) * 2 + 2
              , Dt = Math.max(Math.abs((Pt ? Pt.clientHeight : 0) - zt), zt) * 2 + 2;
            xt = Math.sqrt($t ** 2 + Dt ** 2)
        }
        Ct != null && Ct.touches ? mt.current === null && (mt.current = () => {
            Et({
                pulsate: kt,
                rippleX: rn,
                rippleY: zt,
                rippleSize: xt,
                cb: Lt
            })
        }
        ,
        ht.start(DELAY_RIPPLE, () => {
            mt.current && (mt.current(),
            mt.current = null)
        }
        )) : Et({
            pulsate: kt,
            rippleX: rn,
            rippleY: zt,
            rippleSize: xt,
            cb: Lt
        })
    }
    , [nt, Et, ht])
      , wt = reactExports.useCallback( () => {
        _t({}, {
            pulsate: !0
        })
    }
    , [_t])
      , St = reactExports.useCallback( (Ct, Nt) => {
        if (ht.clear(),
        (Ct == null ? void 0 : Ct.type) === "touchend" && mt.current) {
            mt.current(),
            mt.current = null,
            ht.start(0, () => {
                St(Ct, Nt)
            }
            );
            return
        }
        mt.current = null,
        lt(Lt => Lt.length > 0 ? Lt.slice(1) : Lt),
        dt.current = Nt
    }
    , [ht]);
    return reactExports.useImperativeHandle(et, () => ({
        pulsate: wt,
        start: _t,
        stop: St
    }), [wt, _t, St]),
    jsxRuntimeExports.jsx(TouchRippleRoot, {
        className: clsx(touchRippleClasses.root, rt.root, it),
        ref: yt,
        ...ot,
        children: jsxRuntimeExports.jsx(TransitionGroup, {
            component: null,
            exit: !0,
            children: st
        })
    })
});
function getButtonBaseUtilityClass(_e) {
    return generateUtilityClass("MuiButtonBase", _e)
}
const buttonBaseClasses = generateUtilityClasses("MuiButtonBase", ["root", "disabled", "focusVisible"])
  , useUtilityClasses$w = _e => {
    const {disabled: $, focusVisible: et, focusVisibleClassName: tt, classes: nt} = _e
      , it = composeClasses({
        root: ["root", $ && "disabled", et && "focusVisible"]
    }, getButtonBaseUtilityClass, nt);
    return et && tt && (it.root += ` ${tt}`),
    it
}
  , ButtonBaseRoot = styled("button", {
    name: "MuiButtonBase",
    slot: "Root",
    overridesResolver: (_e, $) => $.root
})({
    display: "inline-flex",
    alignItems: "center",
    justifyContent: "center",
    position: "relative",
    boxSizing: "border-box",
    WebkitTapHighlightColor: "transparent",
    backgroundColor: "transparent",
    outline: 0,
    border: 0,
    margin: 0,
    borderRadius: 0,
    padding: 0,
    cursor: "pointer",
    userSelect: "none",
    verticalAlign: "middle",
    MozAppearance: "none",
    WebkitAppearance: "none",
    textDecoration: "none",
    color: "inherit",
    "&::-moz-focus-inner": {
        borderStyle: "none"
    },
    [`&.${buttonBaseClasses.disabled}`]: {
        pointerEvents: "none",
        cursor: "default"
    },
    "@media print": {
        colorAdjust: "exact"
    }
})
  , ButtonBase = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiButtonBase"
    })
      , {action: nt, centerRipple: rt=!1, children: it, className: ot, component: st="button", disabled: lt=!1, disableRipple: ct=!1, disableTouchRipple: dt=!1, focusRipple: pt=!1, focusVisibleClassName: ht, LinkComponent: mt="a", onBlur: yt, onClick: Et, onContextMenu: _t, onDragLeave: wt, onFocus: St, onFocusVisible: Ct, onKeyDown: Nt, onKeyUp: Lt, onMouseDown: kt, onMouseLeave: Ut, onMouseUp: Jt, onTouchEnd: Pt, onTouchMove: Xt, onTouchStart: rn, tabIndex: zt=0, TouchRippleProps: xt, touchRippleRef: $t, type: Dt, ...jt} = tt
      , Ft = reactExports.useRef(null)
      , Ht = useLazyRipple()
      , qt = useForkRef(Ht.ref, $t)
      , [Wt,Mt] = reactExports.useState(!1);
    lt && Wt && Mt(!1),
    reactExports.useImperativeHandle(nt, () => ({
        focusVisible: () => {
            Mt(!0),
            Ft.current.focus()
        }
    }), []);
    const Yt = Ht.shouldMount && !ct && !lt;
    reactExports.useEffect( () => {
        Wt && pt && !ct && Ht.pulsate()
    }
    , [ct, pt, Wt, Ht]);
    const un = useRippleHandler(Ht, "start", kt, dt)
      , hn = useRippleHandler(Ht, "stop", _t, dt)
      , _n = useRippleHandler(Ht, "stop", wt, dt)
      , kn = useRippleHandler(Ht, "stop", Jt, dt)
      , Dn = useRippleHandler(Ht, "stop", Rn => {
        Wt && Rn.preventDefault(),
        Ut && Ut(Rn)
    }
    , dt)
      , jn = useRippleHandler(Ht, "start", rn, dt)
      , Bn = useRippleHandler(Ht, "stop", Pt, dt)
      , Un = useRippleHandler(Ht, "stop", Xt, dt)
      , Hn = useRippleHandler(Ht, "stop", Rn => {
        isFocusVisible(Rn.target) || Mt(!1),
        yt && yt(Rn)
    }
    , !1)
      , cr = useEventCallback$1(Rn => {
        Ft.current || (Ft.current = Rn.currentTarget),
        isFocusVisible(Rn.target) && (Mt(!0),
        Ct && Ct(Rn)),
        St && St(Rn)
    }
    )
      , Gn = () => {
        const Rn = Ft.current;
        return st && st !== "button" && !(Rn.tagName === "A" && Rn.href)
    }
      , Mn = useEventCallback$1(Rn => {
        pt && !Rn.repeat && Wt && Rn.key === " " && Ht.stop(Rn, () => {
            Ht.start(Rn)
        }
        ),
        Rn.target === Rn.currentTarget && Gn() && Rn.key === " " && Rn.preventDefault(),
        Nt && Nt(Rn),
        Rn.target === Rn.currentTarget && Gn() && Rn.key === "Enter" && !lt && (Rn.preventDefault(),
        Et && Et(Rn))
    }
    )
      , rr = useEventCallback$1(Rn => {
        pt && Rn.key === " " && Wt && !Rn.defaultPrevented && Ht.stop(Rn, () => {
            Ht.pulsate(Rn)
        }
        ),
        Lt && Lt(Rn),
        Et && Rn.target === Rn.currentTarget && Gn() && Rn.key === " " && !Rn.defaultPrevented && Et(Rn)
    }
    );
    let Zn = st;
    Zn === "button" && (jt.href || jt.to) && (Zn = mt);
    const pr = {};
    Zn === "button" ? (pr.type = Dt === void 0 ? "button" : Dt,
    pr.disabled = lt) : (!jt.href && !jt.to && (pr.role = "button"),
    lt && (pr["aria-disabled"] = lt));
    const Ur = useForkRef(et, Ft)
      , xr = {
        ...tt,
        centerRipple: rt,
        component: st,
        disabled: lt,
        disableRipple: ct,
        disableTouchRipple: dt,
        focusRipple: pt,
        tabIndex: zt,
        focusVisible: Wt
    }
      , wr = useUtilityClasses$w(xr);
    return jsxRuntimeExports.jsxs(ButtonBaseRoot, {
        as: Zn,
        className: clsx(wr.root, ot),
        ownerState: xr,
        onBlur: Hn,
        onClick: Et,
        onContextMenu: hn,
        onFocus: cr,
        onKeyDown: Mn,
        onKeyUp: rr,
        onMouseDown: un,
        onMouseLeave: Dn,
        onMouseUp: kn,
        onDragLeave: _n,
        onTouchEnd: Bn,
        onTouchMove: Un,
        onTouchStart: jn,
        ref: Ur,
        tabIndex: lt ? -1 : zt,
        type: Dt,
        ...pr,
        ...jt,
        children: [it, Yt ? jsxRuntimeExports.jsx(TouchRipple, {
            ref: qt,
            center: rt,
            ...xt
        }) : null]
    })
});
function useRippleHandler(_e, $, et, tt=!1) {
    return useEventCallback$1(nt => (et && et(nt),
    tt || _e[$](nt),
    !0))
}
function hasCorrectMainProperty(_e) {
    return typeof _e.main == "string"
}
function checkSimplePaletteColorValues(_e, $=[]) {
    if (!hasCorrectMainProperty(_e))
        return !1;
    for (const et of $)
        if (!_e.hasOwnProperty(et) || typeof _e[et] != "string")
            return !1;
    return !0
}
function createSimplePaletteValueFilter(_e=[]) {
    return ([,$]) => $ && checkSimplePaletteColorValues($, _e)
}
function getCircularProgressUtilityClass(_e) {
    return generateUtilityClass("MuiCircularProgress", _e)
}
generateUtilityClasses("MuiCircularProgress", ["root", "determinate", "indeterminate", "colorPrimary", "colorSecondary", "svg", "circle", "circleDeterminate", "circleIndeterminate", "circleDisableShrink"]);
const SIZE = 44
  , circularRotateKeyframe = keyframes`
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
`
  , circularDashKeyframe = keyframes`
  0% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: 0;
  }

  50% {
    stroke-dasharray: 100px, 200px;
    stroke-dashoffset: -15px;
  }

  100% {
    stroke-dasharray: 1px, 200px;
    stroke-dashoffset: -126px;
  }
`
  , rotateAnimation = typeof circularRotateKeyframe != "string" ? css`
        animation: ${circularRotateKeyframe} 1.4s linear infinite;
      ` : null
  , dashAnimation = typeof circularDashKeyframe != "string" ? css`
        animation: ${circularDashKeyframe} 1.4s ease-in-out infinite;
      ` : null
  , useUtilityClasses$v = _e => {
    const {classes: $, variant: et, color: tt, disableShrink: nt} = _e
      , rt = {
        root: ["root", et, `color${capitalize(tt)}`],
        svg: ["svg"],
        circle: ["circle", `circle${capitalize(et)}`, nt && "circleDisableShrink"]
    };
    return composeClasses(rt, getCircularProgressUtilityClass, $)
}
  , CircularProgressRoot = styled("span", {
    name: "MuiCircularProgress",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, $[et.variant], $[`color${capitalize(et.color)}`]]
    }
})(memoTheme( ({theme: _e}) => ({
    display: "inline-block",
    variants: [{
        props: {
            variant: "determinate"
        },
        style: {
            transition: _e.transitions.create("transform")
        }
    }, {
        props: {
            variant: "indeterminate"
        },
        style: rotateAnimation || {
            animation: `${circularRotateKeyframe} 1.4s linear infinite`
        }
    }, ...Object.entries(_e.palette).filter(createSimplePaletteValueFilter()).map( ([$]) => ({
        props: {
            color: $
        },
        style: {
            color: (_e.vars || _e).palette[$].main
        }
    }))]
})))
  , CircularProgressSVG = styled("svg", {
    name: "MuiCircularProgress",
    slot: "Svg",
    overridesResolver: (_e, $) => $.svg
})({
    display: "block"
})
  , CircularProgressCircle = styled("circle", {
    name: "MuiCircularProgress",
    slot: "Circle",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.circle, $[`circle${capitalize(et.variant)}`], et.disableShrink && $.circleDisableShrink]
    }
})(memoTheme( ({theme: _e}) => ({
    stroke: "currentColor",
    variants: [{
        props: {
            variant: "determinate"
        },
        style: {
            transition: _e.transitions.create("stroke-dashoffset")
        }
    }, {
        props: {
            variant: "indeterminate"
        },
        style: {
            strokeDasharray: "80px, 200px",
            strokeDashoffset: 0
        }
    }, {
        props: ({ownerState: $}) => $.variant === "indeterminate" && !$.disableShrink,
        style: dashAnimation || {
            animation: `${circularDashKeyframe} 1.4s ease-in-out infinite`
        }
    }]
})))
  , CircularProgress = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiCircularProgress"
    })
      , {className: nt, color: rt="primary", disableShrink: it=!1, size: ot=40, style: st, thickness: lt=3.6, value: ct=0, variant: dt="indeterminate", ...pt} = tt
      , ht = {
        ...tt,
        color: rt,
        disableShrink: it,
        size: ot,
        thickness: lt,
        value: ct,
        variant: dt
    }
      , mt = useUtilityClasses$v(ht)
      , yt = {}
      , Et = {}
      , _t = {};
    if (dt === "determinate") {
        const wt = 2 * Math.PI * ((SIZE - lt) / 2);
        yt.strokeDasharray = wt.toFixed(3),
        _t["aria-valuenow"] = Math.round(ct),
        yt.strokeDashoffset = `${((100 - ct) / 100 * wt).toFixed(3)}px`,
        Et.transform = "rotate(-90deg)"
    }
    return jsxRuntimeExports.jsx(CircularProgressRoot, {
        className: clsx(mt.root, nt),
        style: {
            width: ot,
            height: ot,
            ...Et,
            ...st
        },
        ownerState: ht,
        ref: et,
        role: "progressbar",
        ..._t,
        ...pt,
        children: jsxRuntimeExports.jsx(CircularProgressSVG, {
            className: mt.svg,
            ownerState: ht,
            viewBox: `${SIZE / 2} ${SIZE / 2} ${SIZE} ${SIZE}`,
            children: jsxRuntimeExports.jsx(CircularProgressCircle, {
                className: mt.circle,
                style: yt,
                ownerState: ht,
                cx: SIZE,
                cy: SIZE,
                r: (SIZE - lt) / 2,
                fill: "none",
                strokeWidth: lt
            })
        })
    })
});
function getIconButtonUtilityClass(_e) {
    return generateUtilityClass("MuiIconButton", _e)
}
const iconButtonClasses = generateUtilityClasses("MuiIconButton", ["root", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorError", "colorInfo", "colorSuccess", "colorWarning", "edgeStart", "edgeEnd", "sizeSmall", "sizeMedium", "sizeLarge", "loading", "loadingIndicator", "loadingWrapper"])
  , useUtilityClasses$u = _e => {
    const {classes: $, disabled: et, color: tt, edge: nt, size: rt, loading: it} = _e
      , ot = {
        root: ["root", it && "loading", et && "disabled", tt !== "default" && `color${capitalize(tt)}`, nt && `edge${capitalize(nt)}`, `size${capitalize(rt)}`],
        loadingIndicator: ["loadingIndicator"],
        loadingWrapper: ["loadingWrapper"]
    };
    return composeClasses(ot, getIconButtonUtilityClass, $)
}
  , IconButtonRoot = styled(ButtonBase, {
    name: "MuiIconButton",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, et.loading && $.loading, et.color !== "default" && $[`color${capitalize(et.color)}`], et.edge && $[`edge${capitalize(et.edge)}`], $[`size${capitalize(et.size)}`]]
    }
})(memoTheme( ({theme: _e}) => ({
    textAlign: "center",
    flex: "0 0 auto",
    fontSize: _e.typography.pxToRem(24),
    padding: 8,
    borderRadius: "50%",
    color: (_e.vars || _e).palette.action.active,
    transition: _e.transitions.create("background-color", {
        duration: _e.transitions.duration.shortest
    }),
    variants: [{
        props: $ => !$.disableRipple,
        style: {
            "--IconButton-hoverBg": _e.vars ? `rgba(${_e.vars.palette.action.activeChannel} / ${_e.vars.palette.action.hoverOpacity})` : alpha(_e.palette.action.active, _e.palette.action.hoverOpacity),
            "&:hover": {
                backgroundColor: "var(--IconButton-hoverBg)",
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }
        }
    }, {
        props: {
            edge: "start"
        },
        style: {
            marginLeft: -12
        }
    }, {
        props: {
            edge: "start",
            size: "small"
        },
        style: {
            marginLeft: -3
        }
    }, {
        props: {
            edge: "end"
        },
        style: {
            marginRight: -12
        }
    }, {
        props: {
            edge: "end",
            size: "small"
        },
        style: {
            marginRight: -3
        }
    }]
})), memoTheme( ({theme: _e}) => ({
    variants: [{
        props: {
            color: "inherit"
        },
        style: {
            color: "inherit"
        }
    }, ...Object.entries(_e.palette).filter(createSimplePaletteValueFilter()).map( ([$]) => ({
        props: {
            color: $
        },
        style: {
            color: (_e.vars || _e).palette[$].main
        }
    })), ...Object.entries(_e.palette).filter(createSimplePaletteValueFilter()).map( ([$]) => ({
        props: {
            color: $
        },
        style: {
            "--IconButton-hoverBg": _e.vars ? `rgba(${(_e.vars || _e).palette[$].mainChannel} / ${_e.vars.palette.action.hoverOpacity})` : alpha((_e.vars || _e).palette[$].main, _e.palette.action.hoverOpacity)
        }
    })), {
        props: {
            size: "small"
        },
        style: {
            padding: 5,
            fontSize: _e.typography.pxToRem(18)
        }
    }, {
        props: {
            size: "large"
        },
        style: {
            padding: 12,
            fontSize: _e.typography.pxToRem(28)
        }
    }],
    [`&.${iconButtonClasses.disabled}`]: {
        backgroundColor: "transparent",
        color: (_e.vars || _e).palette.action.disabled
    },
    [`&.${iconButtonClasses.loading}`]: {
        color: "transparent"
    }
})))
  , IconButtonLoadingIndicator = styled("span", {
    name: "MuiIconButton",
    slot: "LoadingIndicator",
    overridesResolver: (_e, $) => $.loadingIndicator
})( ({theme: _e}) => ({
    display: "none",
    position: "absolute",
    visibility: "visible",
    top: "50%",
    left: "50%",
    transform: "translate(-50%, -50%)",
    color: (_e.vars || _e).palette.action.disabled,
    variants: [{
        props: {
            loading: !0
        },
        style: {
            display: "flex"
        }
    }]
}))
  , IconButton = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiIconButton"
    })
      , {edge: nt=!1, children: rt, className: it, color: ot="default", disabled: st=!1, disableFocusRipple: lt=!1, size: ct="medium", id: dt, loading: pt=null, loadingIndicator: ht, ...mt} = tt
      , yt = useId(dt)
      , Et = ht ?? jsxRuntimeExports.jsx(CircularProgress, {
        "aria-labelledby": yt,
        color: "inherit",
        size: 16
    })
      , _t = {
        ...tt,
        edge: nt,
        color: ot,
        disabled: st,
        disableFocusRipple: lt,
        loading: pt,
        loadingIndicator: Et,
        size: ct
    }
      , wt = useUtilityClasses$u(_t);
    return jsxRuntimeExports.jsxs(IconButtonRoot, {
        id: pt ? yt : dt,
        className: clsx(wt.root, it),
        centerRipple: !0,
        focusRipple: !lt,
        disabled: st || pt,
        ref: et,
        ...mt,
        ownerState: _t,
        children: [typeof pt == "boolean" && jsxRuntimeExports.jsx("span", {
            className: wt.loadingWrapper,
            style: {
                display: "contents"
            },
            children: jsxRuntimeExports.jsx(IconButtonLoadingIndicator, {
                className: wt.loadingIndicator,
                ownerState: _t,
                children: pt && Et
            })
        }), rt]
    })
});
function getTypographyUtilityClass(_e) {
    return generateUtilityClass("MuiTypography", _e)
}
generateUtilityClasses("MuiTypography", ["root", "h1", "h2", "h3", "h4", "h5", "h6", "subtitle1", "subtitle2", "body1", "body2", "inherit", "button", "caption", "overline", "alignLeft", "alignRight", "alignCenter", "alignJustify", "noWrap", "gutterBottom", "paragraph"]);
const v6Colors = {
    primary: !0,
    secondary: !0,
    error: !0,
    info: !0,
    success: !0,
    warning: !0,
    textPrimary: !0,
    textSecondary: !0,
    textDisabled: !0
}
  , extendSxProp = internal_createExtendSxProp()
  , useUtilityClasses$t = _e => {
    const {align: $, gutterBottom: et, noWrap: tt, paragraph: nt, variant: rt, classes: it} = _e
      , ot = {
        root: ["root", rt, _e.align !== "inherit" && `align${capitalize($)}`, et && "gutterBottom", tt && "noWrap", nt && "paragraph"]
    };
    return composeClasses(ot, getTypographyUtilityClass, it)
}
  , TypographyRoot = styled("span", {
    name: "MuiTypography",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, et.variant && $[et.variant], et.align !== "inherit" && $[`align${capitalize(et.align)}`], et.noWrap && $.noWrap, et.gutterBottom && $.gutterBottom, et.paragraph && $.paragraph]
    }
})(memoTheme( ({theme: _e}) => {
    var $;
    return {
        margin: 0,
        variants: [{
            props: {
                variant: "inherit"
            },
            style: {
                font: "inherit",
                lineHeight: "inherit",
                letterSpacing: "inherit"
            }
        }, ...Object.entries(_e.typography).filter( ([et,tt]) => et !== "inherit" && tt && typeof tt == "object").map( ([et,tt]) => ({
            props: {
                variant: et
            },
            style: tt
        })), ...Object.entries(_e.palette).filter(createSimplePaletteValueFilter()).map( ([et]) => ({
            props: {
                color: et
            },
            style: {
                color: (_e.vars || _e).palette[et].main
            }
        })), ...Object.entries((($ = _e.palette) == null ? void 0 : $.text) || {}).filter( ([,et]) => typeof et == "string").map( ([et]) => ({
            props: {
                color: `text${capitalize(et)}`
            },
            style: {
                color: (_e.vars || _e).palette.text[et]
            }
        })), {
            props: ({ownerState: et}) => et.align !== "inherit",
            style: {
                textAlign: "var(--Typography-textAlign)"
            }
        }, {
            props: ({ownerState: et}) => et.noWrap,
            style: {
                overflow: "hidden",
                textOverflow: "ellipsis",
                whiteSpace: "nowrap"
            }
        }, {
            props: ({ownerState: et}) => et.gutterBottom,
            style: {
                marginBottom: "0.35em"
            }
        }, {
            props: ({ownerState: et}) => et.paragraph,
            style: {
                marginBottom: 16
            }
        }]
    }
}
))
  , defaultVariantMapping = {
    h1: "h1",
    h2: "h2",
    h3: "h3",
    h4: "h4",
    h5: "h5",
    h6: "h6",
    subtitle1: "h6",
    subtitle2: "h6",
    body1: "p",
    body2: "p",
    inherit: "p"
}
  , Typography = reactExports.forwardRef(function($, et) {
    const {color: tt, ...nt} = useDefaultProps({
        props: $,
        name: "MuiTypography"
    })
      , rt = !v6Colors[tt]
      , it = extendSxProp({
        ...nt,
        ...rt && {
            color: tt
        }
    })
      , {align: ot="inherit", className: st, component: lt, gutterBottom: ct=!1, noWrap: dt=!1, paragraph: pt=!1, variant: ht="body1", variantMapping: mt=defaultVariantMapping, ...yt} = it
      , Et = {
        ...it,
        align: ot,
        color: tt,
        className: st,
        component: lt,
        gutterBottom: ct,
        noWrap: dt,
        paragraph: pt,
        variant: ht,
        variantMapping: mt
    }
      , _t = lt || (pt ? "p" : mt[ht] || defaultVariantMapping[ht]) || "span"
      , wt = useUtilityClasses$t(Et);
    return jsxRuntimeExports.jsx(TypographyRoot, {
        as: _t,
        ref: et,
        className: clsx(wt.root, st),
        ...yt,
        ownerState: Et,
        style: {
            ...ot !== "inherit" && {
                "--Typography-textAlign": ot
            },
            ...yt.style
        }
    })
});
function getContainer$1(_e) {
    return typeof _e == "function" ? _e() : _e
}
const Portal = reactExports.forwardRef(function($, et) {
    const {children: tt, container: nt, disablePortal: rt=!1} = $
      , [it,ot] = reactExports.useState(null)
      , st = useForkRef(reactExports.isValidElement(tt) ? getReactElementRef(tt) : null, et);
    if (useEnhancedEffect( () => {
        rt || ot(getContainer$1(nt) || document.body)
    }
    , [nt, rt]),
    useEnhancedEffect( () => {
        if (it && !rt)
            return setRef(et, it),
            () => {
                setRef(et, null)
            }
    }
    , [et, it, rt]),
    rt) {
        if (reactExports.isValidElement(tt)) {
            const lt = {
                ref: st
            };
            return reactExports.cloneElement(tt, lt)
        }
        return tt
    }
    return it && reactDomExports.createPortal(tt, it)
});
function getStyleValue(_e) {
    return parseInt(_e, 10) || 0
}
const styles$4 = {
    shadow: {
        visibility: "hidden",
        position: "absolute",
        overflow: "hidden",
        height: 0,
        top: 0,
        left: 0,
        transform: "translateZ(0)"
    }
};
function isObjectEmpty(_e) {
    for (const $ in _e)
        return !1;
    return !0
}
function isEmpty(_e) {
    return isObjectEmpty(_e) || _e.outerHeightStyle === 0 && !_e.overflowing
}
const TextareaAutosize = reactExports.forwardRef(function($, et) {
    const {onChange: tt, maxRows: nt, minRows: rt=1, style: it, value: ot, ...st} = $
      , {current: lt} = reactExports.useRef(ot != null)
      , ct = reactExports.useRef(null)
      , dt = useForkRef(et, ct)
      , pt = reactExports.useRef(null)
      , ht = reactExports.useRef(null)
      , mt = reactExports.useCallback( () => {
        const wt = ct.current
          , St = ht.current;
        if (!wt || !St)
            return;
        const Nt = ownerWindow(wt).getComputedStyle(wt);
        if (Nt.width === "0px")
            return {
                outerHeightStyle: 0,
                overflowing: !1
            };
        St.style.width = Nt.width,
        St.value = wt.value || $.placeholder || "x",
        St.value.slice(-1) === `
` && (St.value += " ");
        const Lt = Nt.boxSizing
          , kt = getStyleValue(Nt.paddingBottom) + getStyleValue(Nt.paddingTop)
          , Ut = getStyleValue(Nt.borderBottomWidth) + getStyleValue(Nt.borderTopWidth)
          , Jt = St.scrollHeight;
        St.value = "x";
        const Pt = St.scrollHeight;
        let Xt = Jt;
        rt && (Xt = Math.max(Number(rt) * Pt, Xt)),
        nt && (Xt = Math.min(Number(nt) * Pt, Xt)),
        Xt = Math.max(Xt, Pt);
        const rn = Xt + (Lt === "border-box" ? kt + Ut : 0)
          , zt = Math.abs(Xt - Jt) <= 1;
        return {
            outerHeightStyle: rn,
            overflowing: zt
        }
    }
    , [nt, rt, $.placeholder])
      , yt = reactExports.useCallback( () => {
        const wt = ct.current
          , St = mt();
        if (!wt || !St || isEmpty(St))
            return;
        const Ct = St.outerHeightStyle;
        pt.current !== Ct && (pt.current = Ct,
        wt.style.height = `${Ct}px`),
        wt.style.overflow = St.overflowing ? "hidden" : ""
    }
    , [mt])
      , Et = reactExports.useRef(-1);
    useEnhancedEffect( () => {
        const wt = debounce( () => yt())
          , St = ct == null ? void 0 : ct.current;
        if (!St)
            return;
        const Ct = ownerWindow(St);
        Ct.addEventListener("resize", wt);
        let Nt;
        return typeof ResizeObserver < "u" && (Nt = new ResizeObserver( () => {
            Nt.unobserve(St),
            cancelAnimationFrame(Et.current),
            yt(),
            Et.current = requestAnimationFrame( () => {
                Nt.observe(St)
            }
            )
        }
        ),
        Nt.observe(St)),
        () => {
            wt.clear(),
            cancelAnimationFrame(Et.current),
            Ct.removeEventListener("resize", wt),
            Nt && Nt.disconnect()
        }
    }
    , [mt, yt]),
    useEnhancedEffect( () => {
        yt()
    }
    );
    const _t = wt => {
        lt || yt(),
        tt && tt(wt)
    }
    ;
    return jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [jsxRuntimeExports.jsx("textarea", {
            value: ot,
            onChange: _t,
            ref: dt,
            rows: rt,
            style: it,
            ...st
        }), jsxRuntimeExports.jsx("textarea", {
            "aria-hidden": !0,
            className: $.className,
            readOnly: !0,
            ref: ht,
            tabIndex: -1,
            style: {
                ...styles$4.shadow,
                ...it,
                paddingTop: 0,
                paddingBottom: 0
            }
        })]
    })
});
function isHostComponent(_e) {
    return typeof _e == "string"
}
function formControlState({props: _e, states: $, muiFormControl: et}) {
    return $.reduce( (tt, nt) => (tt[nt] = _e[nt],
    et && typeof _e[nt] > "u" && (tt[nt] = et[nt]),
    tt), {})
}
const FormControlContext = reactExports.createContext(void 0);
function useFormControl() {
    return reactExports.useContext(FormControlContext)
}
function hasValue(_e) {
    return _e != null && !(Array.isArray(_e) && _e.length === 0)
}
function isFilled(_e, $=!1) {
    return _e && (hasValue(_e.value) && _e.value !== "" || $ && hasValue(_e.defaultValue) && _e.defaultValue !== "")
}
function isAdornedStart(_e) {
    return _e.startAdornment
}
function getInputBaseUtilityClass(_e) {
    return generateUtilityClass("MuiInputBase", _e)
}
const inputBaseClasses = generateUtilityClasses("MuiInputBase", ["root", "formControl", "focused", "disabled", "adornedStart", "adornedEnd", "error", "sizeSmall", "multiline", "colorSecondary", "fullWidth", "hiddenLabel", "readOnly", "input", "inputSizeSmall", "inputMultiline", "inputTypeSearch", "inputAdornedStart", "inputAdornedEnd", "inputHiddenLabel"]);
var _InputGlobalStyles;
const rootOverridesResolver = (_e, $) => {
    const {ownerState: et} = _e;
    return [$.root, et.formControl && $.formControl, et.startAdornment && $.adornedStart, et.endAdornment && $.adornedEnd, et.error && $.error, et.size === "small" && $.sizeSmall, et.multiline && $.multiline, et.color && $[`color${capitalize(et.color)}`], et.fullWidth && $.fullWidth, et.hiddenLabel && $.hiddenLabel]
}
  , inputOverridesResolver = (_e, $) => {
    const {ownerState: et} = _e;
    return [$.input, et.size === "small" && $.inputSizeSmall, et.multiline && $.inputMultiline, et.type === "search" && $.inputTypeSearch, et.startAdornment && $.inputAdornedStart, et.endAdornment && $.inputAdornedEnd, et.hiddenLabel && $.inputHiddenLabel]
}
  , useUtilityClasses$s = _e => {
    const {classes: $, color: et, disabled: tt, error: nt, endAdornment: rt, focused: it, formControl: ot, fullWidth: st, hiddenLabel: lt, multiline: ct, readOnly: dt, size: pt, startAdornment: ht, type: mt} = _e
      , yt = {
        root: ["root", `color${capitalize(et)}`, tt && "disabled", nt && "error", st && "fullWidth", it && "focused", ot && "formControl", pt && pt !== "medium" && `size${capitalize(pt)}`, ct && "multiline", ht && "adornedStart", rt && "adornedEnd", lt && "hiddenLabel", dt && "readOnly"],
        input: ["input", tt && "disabled", mt === "search" && "inputTypeSearch", ct && "inputMultiline", pt === "small" && "inputSizeSmall", lt && "inputHiddenLabel", ht && "inputAdornedStart", rt && "inputAdornedEnd", dt && "readOnly"]
    };
    return composeClasses(yt, getInputBaseUtilityClass, $)
}
  , InputBaseRoot = styled("div", {
    name: "MuiInputBase",
    slot: "Root",
    overridesResolver: rootOverridesResolver
})(memoTheme( ({theme: _e}) => ({
    ..._e.typography.body1,
    color: (_e.vars || _e).palette.text.primary,
    lineHeight: "1.4375em",
    boxSizing: "border-box",
    position: "relative",
    cursor: "text",
    display: "inline-flex",
    alignItems: "center",
    [`&.${inputBaseClasses.disabled}`]: {
        color: (_e.vars || _e).palette.text.disabled,
        cursor: "default"
    },
    variants: [{
        props: ({ownerState: $}) => $.multiline,
        style: {
            padding: "4px 0 5px"
        }
    }, {
        props: ({ownerState: $, size: et}) => $.multiline && et === "small",
        style: {
            paddingTop: 1
        }
    }, {
        props: ({ownerState: $}) => $.fullWidth,
        style: {
            width: "100%"
        }
    }]
})))
  , InputBaseInput = styled("input", {
    name: "MuiInputBase",
    slot: "Input",
    overridesResolver: inputOverridesResolver
})(memoTheme( ({theme: _e}) => {
    const $ = _e.palette.mode === "light"
      , et = {
        color: "currentColor",
        ..._e.vars ? {
            opacity: _e.vars.opacity.inputPlaceholder
        } : {
            opacity: $ ? .42 : .5
        },
        transition: _e.transitions.create("opacity", {
            duration: _e.transitions.duration.shorter
        })
    }
      , tt = {
        opacity: "0 !important"
    }
      , nt = _e.vars ? {
        opacity: _e.vars.opacity.inputPlaceholder
    } : {
        opacity: $ ? .42 : .5
    };
    return {
        font: "inherit",
        letterSpacing: "inherit",
        color: "currentColor",
        padding: "4px 0 5px",
        border: 0,
        boxSizing: "content-box",
        background: "none",
        height: "1.4375em",
        margin: 0,
        WebkitTapHighlightColor: "transparent",
        display: "block",
        minWidth: 0,
        width: "100%",
        "&::-webkit-input-placeholder": et,
        "&::-moz-placeholder": et,
        "&::-ms-input-placeholder": et,
        "&:focus": {
            outline: 0
        },
        "&:invalid": {
            boxShadow: "none"
        },
        "&::-webkit-search-decoration": {
            WebkitAppearance: "none"
        },
        [`label[data-shrink=false] + .${inputBaseClasses.formControl} &`]: {
            "&::-webkit-input-placeholder": tt,
            "&::-moz-placeholder": tt,
            "&::-ms-input-placeholder": tt,
            "&:focus::-webkit-input-placeholder": nt,
            "&:focus::-moz-placeholder": nt,
            "&:focus::-ms-input-placeholder": nt
        },
        [`&.${inputBaseClasses.disabled}`]: {
            opacity: 1,
            WebkitTextFillColor: (_e.vars || _e).palette.text.disabled
        },
        variants: [{
            props: ({ownerState: rt}) => !rt.disableInjectingGlobalStyles,
            style: {
                animationName: "mui-auto-fill-cancel",
                animationDuration: "10ms",
                "&:-webkit-autofill": {
                    animationDuration: "5000s",
                    animationName: "mui-auto-fill"
                }
            }
        }, {
            props: {
                size: "small"
            },
            style: {
                paddingTop: 1
            }
        }, {
            props: ({ownerState: rt}) => rt.multiline,
            style: {
                height: "auto",
                resize: "none",
                padding: 0,
                paddingTop: 0
            }
        }, {
            props: {
                type: "search"
            },
            style: {
                MozAppearance: "textfield"
            }
        }]
    }
}
))
  , InputGlobalStyles = globalCss({
    "@keyframes mui-auto-fill": {
        from: {
            display: "block"
        }
    },
    "@keyframes mui-auto-fill-cancel": {
        from: {
            display: "block"
        }
    }
})
  , InputBase = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiInputBase"
    })
      , {"aria-describedby": nt, autoComplete: rt, autoFocus: it, className: ot, color: st, components: lt={}, componentsProps: ct={}, defaultValue: dt, disabled: pt, disableInjectingGlobalStyles: ht, endAdornment: mt, error: yt, fullWidth: Et=!1, id: _t, inputComponent: wt="input", inputProps: St={}, inputRef: Ct, margin: Nt, maxRows: Lt, minRows: kt, multiline: Ut=!1, name: Jt, onBlur: Pt, onChange: Xt, onClick: rn, onFocus: zt, onKeyDown: xt, onKeyUp: $t, placeholder: Dt, readOnly: jt, renderSuffix: Ft, rows: Ht, size: qt, slotProps: Wt={}, slots: Mt={}, startAdornment: Yt, type: un="text", value: hn, ..._n} = tt
      , kn = St.value != null ? St.value : hn
      , {current: Dn} = reactExports.useRef(kn != null)
      , jn = reactExports.useRef()
      , Bn = reactExports.useCallback(Kt => {}
    , [])
      , Un = useForkRef(jn, Ct, St.ref, Bn)
      , [Hn,cr] = reactExports.useState(!1)
      , Gn = useFormControl()
      , Mn = formControlState({
        props: tt,
        muiFormControl: Gn,
        states: ["color", "disabled", "error", "hiddenLabel", "size", "required", "filled"]
    });
    Mn.focused = Gn ? Gn.focused : Hn,
    reactExports.useEffect( () => {
        !Gn && pt && Hn && (cr(!1),
        Pt && Pt())
    }
    , [Gn, pt, Hn, Pt]);
    const rr = Gn && Gn.onFilled
      , Zn = Gn && Gn.onEmpty
      , pr = reactExports.useCallback(Kt => {
        isFilled(Kt) ? rr && rr() : Zn && Zn()
    }
    , [rr, Zn]);
    useEnhancedEffect( () => {
        Dn && pr({
            value: kn
        })
    }
    , [kn, pr, Dn]);
    const Ur = Kt => {
        zt && zt(Kt),
        St.onFocus && St.onFocus(Kt),
        Gn && Gn.onFocus ? Gn.onFocus(Kt) : cr(!0)
    }
      , xr = Kt => {
        Pt && Pt(Kt),
        St.onBlur && St.onBlur(Kt),
        Gn && Gn.onBlur ? Gn.onBlur(Kt) : cr(!1)
    }
      , wr = (Kt, ...Gt) => {
        if (!Dn) {
            const fn = Kt.target || jn.current;
            if (fn == null)
                throw new Error(formatMuiErrorMessage(1));
            pr({
                value: fn.value
            })
        }
        St.onChange && St.onChange(Kt, ...Gt),
        Xt && Xt(Kt, ...Gt)
    }
    ;
    reactExports.useEffect( () => {
        pr(jn.current)
    }
    , []);
    const Rn = Kt => {
        jn.current && Kt.currentTarget === Kt.target && jn.current.focus(),
        rn && rn(Kt)
    }
    ;
    let Vn = wt
      , qn = St;
    Ut && Vn === "input" && (Ht ? qn = {
        type: void 0,
        minRows: Ht,
        maxRows: Ht,
        ...qn
    } : qn = {
        type: void 0,
        maxRows: Lt,
        minRows: kt,
        ...qn
    },
    Vn = TextareaAutosize);
    const dr = Kt => {
        pr(Kt.animationName === "mui-auto-fill-cancel" ? jn.current : {
            value: "x"
        })
    }
    ;
    reactExports.useEffect( () => {
        Gn && Gn.setAdornedStart(!!Yt)
    }
    , [Gn, Yt]);
    const or = {
        ...tt,
        color: Mn.color || "primary",
        disabled: Mn.disabled,
        endAdornment: mt,
        error: Mn.error,
        focused: Mn.focused,
        formControl: Gn,
        fullWidth: Et,
        hiddenLabel: Mn.hiddenLabel,
        multiline: Ut,
        size: Mn.size,
        startAdornment: Yt,
        type: un
    }
      , ir = useUtilityClasses$s(or)
      , Cr = Mt.root || lt.Root || InputBaseRoot
      , br = Wt.root || ct.root || {}
      , an = Mt.input || lt.Input || InputBaseInput;
    return qn = {
        ...qn,
        ...Wt.input ?? ct.input
    },
    jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [!ht && typeof InputGlobalStyles == "function" && (_InputGlobalStyles || (_InputGlobalStyles = jsxRuntimeExports.jsx(InputGlobalStyles, {}))), jsxRuntimeExports.jsxs(Cr, {
            ...br,
            ref: et,
            onClick: Rn,
            ..._n,
            ...!isHostComponent(Cr) && {
                ownerState: {
                    ...or,
                    ...br.ownerState
                }
            },
            className: clsx(ir.root, br.className, ot, jt && "MuiInputBase-readOnly"),
            children: [Yt, jsxRuntimeExports.jsx(FormControlContext.Provider, {
                value: null,
                children: jsxRuntimeExports.jsx(an, {
                    "aria-invalid": Mn.error,
                    "aria-describedby": nt,
                    autoComplete: rt,
                    autoFocus: it,
                    defaultValue: dt,
                    disabled: Mn.disabled,
                    id: _t,
                    onAnimationStart: dr,
                    name: Jt,
                    placeholder: Dt,
                    readOnly: jt,
                    required: Mn.required,
                    rows: Ht,
                    value: kn,
                    onKeyDown: xt,
                    onKeyUp: $t,
                    type: un,
                    ...qn,
                    ...!isHostComponent(an) && {
                        as: Vn,
                        ownerState: {
                            ...or,
                            ...qn.ownerState
                        }
                    },
                    ref: Un,
                    className: clsx(ir.input, qn.className, jt && "MuiInputBase-readOnly"),
                    onBlur: xr,
                    onChange: wr,
                    onFocus: Ur
                })
            }), mt, Ft ? Ft({
                ...Mn,
                startAdornment: Yt
            }) : null]
        })]
    })
});
function getOutlinedInputUtilityClass(_e) {
    return generateUtilityClass("MuiOutlinedInput", _e)
}
const outlinedInputClasses = {
    ...inputBaseClasses,
    ...generateUtilityClasses("MuiOutlinedInput", ["root", "notchedOutline", "input"])
}
  , Person = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z"
}), "Person");
function getAvatarUtilityClass(_e) {
    return generateUtilityClass("MuiAvatar", _e)
}
generateUtilityClasses("MuiAvatar", ["root", "colorDefault", "circular", "rounded", "square", "img", "fallback"]);
const useUtilityClasses$r = _e => {
    const {classes: $, variant: et, colorDefault: tt} = _e;
    return composeClasses({
        root: ["root", et, tt && "colorDefault"],
        img: ["img"],
        fallback: ["fallback"]
    }, getAvatarUtilityClass, $)
}
  , AvatarRoot = styled("div", {
    name: "MuiAvatar",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, $[et.variant], et.colorDefault && $.colorDefault]
    }
})(memoTheme( ({theme: _e}) => ({
    position: "relative",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexShrink: 0,
    width: 40,
    height: 40,
    fontFamily: _e.typography.fontFamily,
    fontSize: _e.typography.pxToRem(20),
    lineHeight: 1,
    borderRadius: "50%",
    overflow: "hidden",
    userSelect: "none",
    variants: [{
        props: {
            variant: "rounded"
        },
        style: {
            borderRadius: (_e.vars || _e).shape.borderRadius
        }
    }, {
        props: {
            variant: "square"
        },
        style: {
            borderRadius: 0
        }
    }, {
        props: {
            colorDefault: !0
        },
        style: {
            color: (_e.vars || _e).palette.background.default,
            ..._e.vars ? {
                backgroundColor: _e.vars.palette.Avatar.defaultBg
            } : {
                backgroundColor: _e.palette.grey[400],
                ..._e.applyStyles("dark", {
                    backgroundColor: _e.palette.grey[600]
                })
            }
        }
    }]
})))
  , AvatarImg = styled("img", {
    name: "MuiAvatar",
    slot: "Img",
    overridesResolver: (_e, $) => $.img
})({
    width: "100%",
    height: "100%",
    textAlign: "center",
    objectFit: "cover",
    color: "transparent",
    textIndent: 1e4
})
  , AvatarFallback = styled(Person, {
    name: "MuiAvatar",
    slot: "Fallback",
    overridesResolver: (_e, $) => $.fallback
})({
    width: "75%",
    height: "75%"
});
function useLoaded({crossOrigin: _e, referrerPolicy: $, src: et, srcSet: tt}) {
    const [nt,rt] = reactExports.useState(!1);
    return reactExports.useEffect( () => {
        if (!et && !tt)
            return;
        rt(!1);
        let it = !0;
        const ot = new Image;
        return ot.onload = () => {
            it && rt("loaded")
        }
        ,
        ot.onerror = () => {
            it && rt("error")
        }
        ,
        ot.crossOrigin = _e,
        ot.referrerPolicy = $,
        ot.src = et,
        tt && (ot.srcset = tt),
        () => {
            it = !1
        }
    }
    , [_e, $, et, tt]),
    nt
}
const Avatar$1 = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiAvatar"
    })
      , {alt: nt, children: rt, className: it, component: ot="div", slots: st={}, slotProps: lt={}, imgProps: ct, sizes: dt, src: pt, srcSet: ht, variant: mt="circular", ...yt} = tt;
    let Et = null;
    const _t = {
        ...tt,
        component: ot,
        variant: mt
    }
      , wt = useLoaded({
        ...ct,
        ...typeof lt.img == "function" ? lt.img(_t) : lt.img,
        src: pt,
        srcSet: ht
    })
      , St = pt || ht
      , Ct = St && wt !== "error";
    _t.colorDefault = !Ct,
    delete _t.ownerState;
    const Nt = useUtilityClasses$r(_t)
      , [Lt,kt] = useSlot("img", {
        className: Nt.img,
        elementType: AvatarImg,
        externalForwardedProps: {
            slots: st,
            slotProps: {
                img: {
                    ...ct,
                    ...lt.img
                }
            }
        },
        additionalProps: {
            alt: nt,
            src: pt,
            srcSet: ht,
            sizes: dt
        },
        ownerState: _t
    });
    return Ct ? Et = jsxRuntimeExports.jsx(Lt, {
        ...kt
    }) : rt || rt === 0 ? Et = rt : St && nt ? Et = nt[0] : Et = jsxRuntimeExports.jsx(AvatarFallback, {
        ownerState: _t,
        className: Nt.fallback
    }),
    jsxRuntimeExports.jsx(AvatarRoot, {
        as: ot,
        className: clsx(Nt.root, it),
        ref: et,
        ...yt,
        ownerState: _t,
        children: Et
    })
})
  , styles$3 = {
    entering: {
        opacity: 1
    },
    entered: {
        opacity: 1
    }
}
  , Fade = reactExports.forwardRef(function($, et) {
    const tt = useTheme()
      , nt = {
        enter: tt.transitions.duration.enteringScreen,
        exit: tt.transitions.duration.leavingScreen
    }
      , {addEndListener: rt, appear: it=!0, children: ot, easing: st, in: lt, onEnter: ct, onEntered: dt, onEntering: pt, onExit: ht, onExited: mt, onExiting: yt, style: Et, timeout: _t=nt, TransitionComponent: wt=Transition, ...St} = $
      , Ct = reactExports.useRef(null)
      , Nt = useForkRef(Ct, getReactElementRef(ot), et)
      , Lt = xt => $t => {
        if (xt) {
            const Dt = Ct.current;
            $t === void 0 ? xt(Dt) : xt(Dt, $t)
        }
    }
      , kt = Lt(pt)
      , Ut = Lt( (xt, $t) => {
        reflow(xt);
        const Dt = getTransitionProps({
            style: Et,
            timeout: _t,
            easing: st
        }, {
            mode: "enter"
        });
        xt.style.webkitTransition = tt.transitions.create("opacity", Dt),
        xt.style.transition = tt.transitions.create("opacity", Dt),
        ct && ct(xt, $t)
    }
    )
      , Jt = Lt(dt)
      , Pt = Lt(yt)
      , Xt = Lt(xt => {
        const $t = getTransitionProps({
            style: Et,
            timeout: _t,
            easing: st
        }, {
            mode: "exit"
        });
        xt.style.webkitTransition = tt.transitions.create("opacity", $t),
        xt.style.transition = tt.transitions.create("opacity", $t),
        ht && ht(xt)
    }
    )
      , rn = Lt(mt)
      , zt = xt => {
        rt && rt(Ct.current, xt)
    }
    ;
    return jsxRuntimeExports.jsx(wt, {
        appear: it,
        in: lt,
        nodeRef: Ct,
        onEnter: Ut,
        onEntered: Jt,
        onEntering: kt,
        onExit: Xt,
        onExited: rn,
        onExiting: Pt,
        addEndListener: zt,
        timeout: _t,
        ...St,
        children: (xt, {ownerState: $t, ...Dt}) => reactExports.cloneElement(ot, {
            style: {
                opacity: 0,
                visibility: xt === "exited" && !lt ? "hidden" : void 0,
                ...styles$3[xt],
                ...Et,
                ...ot.props.style
            },
            ref: Nt,
            ...Dt
        })
    })
});
function getBackdropUtilityClass(_e) {
    return generateUtilityClass("MuiBackdrop", _e)
}
generateUtilityClasses("MuiBackdrop", ["root", "invisible"]);
const useUtilityClasses$q = _e => {
    const {classes: $, invisible: et} = _e;
    return composeClasses({
        root: ["root", et && "invisible"]
    }, getBackdropUtilityClass, $)
}
  , BackdropRoot = styled("div", {
    name: "MuiBackdrop",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, et.invisible && $.invisible]
    }
})({
    position: "fixed",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    backgroundColor: "rgba(0, 0, 0, 0.5)",
    WebkitTapHighlightColor: "transparent",
    variants: [{
        props: {
            invisible: !0
        },
        style: {
            backgroundColor: "transparent"
        }
    }]
})
  , Backdrop = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiBackdrop"
    })
      , {children: nt, className: rt, component: it="div", invisible: ot=!1, open: st, components: lt={}, componentsProps: ct={}, slotProps: dt={}, slots: pt={}, TransitionComponent: ht, transitionDuration: mt, ...yt} = tt
      , Et = {
        ...tt,
        component: it,
        invisible: ot
    }
      , _t = useUtilityClasses$q(Et)
      , wt = {
        transition: ht,
        root: lt.Root,
        ...pt
    }
      , St = {
        ...ct,
        ...dt
    }
      , Ct = {
        slots: wt,
        slotProps: St
    }
      , [Nt,Lt] = useSlot("root", {
        elementType: BackdropRoot,
        externalForwardedProps: Ct,
        className: clsx(_t.root, rt),
        ownerState: Et
    })
      , [kt,Ut] = useSlot("transition", {
        elementType: Fade,
        externalForwardedProps: Ct,
        ownerState: Et
    });
    return jsxRuntimeExports.jsx(kt, {
        in: st,
        timeout: mt,
        ...yt,
        ...Ut,
        children: jsxRuntimeExports.jsx(Nt, {
            "aria-hidden": !0,
            ...Lt,
            classes: _t,
            ref: et,
            children: nt
        })
    })
})
  , boxClasses = generateUtilityClasses("MuiBox", ["root"])
  , defaultTheme = createTheme()
  , Box = createBox({
    themeId: THEME_ID,
    defaultTheme,
    defaultClassName: boxClasses.root,
    generateClassName: ClassNameGenerator.generate
});
function getButtonUtilityClass(_e) {
    return generateUtilityClass("MuiButton", _e)
}
const buttonClasses = generateUtilityClasses("MuiButton", ["root", "text", "textInherit", "textPrimary", "textSecondary", "textSuccess", "textError", "textInfo", "textWarning", "outlined", "outlinedInherit", "outlinedPrimary", "outlinedSecondary", "outlinedSuccess", "outlinedError", "outlinedInfo", "outlinedWarning", "contained", "containedInherit", "containedPrimary", "containedSecondary", "containedSuccess", "containedError", "containedInfo", "containedWarning", "disableElevation", "focusVisible", "disabled", "colorInherit", "colorPrimary", "colorSecondary", "colorSuccess", "colorError", "colorInfo", "colorWarning", "textSizeSmall", "textSizeMedium", "textSizeLarge", "outlinedSizeSmall", "outlinedSizeMedium", "outlinedSizeLarge", "containedSizeSmall", "containedSizeMedium", "containedSizeLarge", "sizeMedium", "sizeSmall", "sizeLarge", "fullWidth", "startIcon", "endIcon", "icon", "iconSizeSmall", "iconSizeMedium", "iconSizeLarge", "loading", "loadingWrapper", "loadingIconPlaceholder", "loadingIndicator", "loadingPositionCenter", "loadingPositionStart", "loadingPositionEnd"])
  , ButtonGroupContext = reactExports.createContext({})
  , ButtonGroupButtonContext = reactExports.createContext(void 0)
  , useUtilityClasses$p = _e => {
    const {color: $, disableElevation: et, fullWidth: tt, size: nt, variant: rt, loading: it, loadingPosition: ot, classes: st} = _e
      , lt = {
        root: ["root", it && "loading", rt, `${rt}${capitalize($)}`, `size${capitalize(nt)}`, `${rt}Size${capitalize(nt)}`, `color${capitalize($)}`, et && "disableElevation", tt && "fullWidth", it && `loadingPosition${capitalize(ot)}`],
        startIcon: ["icon", "startIcon", `iconSize${capitalize(nt)}`],
        endIcon: ["icon", "endIcon", `iconSize${capitalize(nt)}`],
        loadingIndicator: ["loadingIndicator"],
        loadingWrapper: ["loadingWrapper"]
    }
      , ct = composeClasses(lt, getButtonUtilityClass, st);
    return {
        ...st,
        ...ct
    }
}
  , commonIconStyles = [{
    props: {
        size: "small"
    },
    style: {
        "& > *:nth-of-type(1)": {
            fontSize: 18
        }
    }
}, {
    props: {
        size: "medium"
    },
    style: {
        "& > *:nth-of-type(1)": {
            fontSize: 20
        }
    }
}, {
    props: {
        size: "large"
    },
    style: {
        "& > *:nth-of-type(1)": {
            fontSize: 22
        }
    }
}]
  , ButtonRoot = styled(ButtonBase, {
    shouldForwardProp: _e => rootShouldForwardProp(_e) || _e === "classes",
    name: "MuiButton",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, $[et.variant], $[`${et.variant}${capitalize(et.color)}`], $[`size${capitalize(et.size)}`], $[`${et.variant}Size${capitalize(et.size)}`], et.color === "inherit" && $.colorInherit, et.disableElevation && $.disableElevation, et.fullWidth && $.fullWidth, et.loading && $.loading]
    }
})(memoTheme( ({theme: _e}) => {
    const $ = _e.palette.mode === "light" ? _e.palette.grey[300] : _e.palette.grey[800]
      , et = _e.palette.mode === "light" ? _e.palette.grey.A100 : _e.palette.grey[700];
    return {
        ..._e.typography.button,
        minWidth: 64,
        padding: "6px 16px",
        border: 0,
        borderRadius: (_e.vars || _e).shape.borderRadius,
        transition: _e.transitions.create(["background-color", "box-shadow", "border-color", "color"], {
            duration: _e.transitions.duration.short
        }),
        "&:hover": {
            textDecoration: "none"
        },
        [`&.${buttonClasses.disabled}`]: {
            color: (_e.vars || _e).palette.action.disabled
        },
        variants: [{
            props: {
                variant: "contained"
            },
            style: {
                color: "var(--variant-containedColor)",
                backgroundColor: "var(--variant-containedBg)",
                boxShadow: (_e.vars || _e).shadows[2],
                "&:hover": {
                    boxShadow: (_e.vars || _e).shadows[4],
                    "@media (hover: none)": {
                        boxShadow: (_e.vars || _e).shadows[2]
                    }
                },
                "&:active": {
                    boxShadow: (_e.vars || _e).shadows[8]
                },
                [`&.${buttonClasses.focusVisible}`]: {
                    boxShadow: (_e.vars || _e).shadows[6]
                },
                [`&.${buttonClasses.disabled}`]: {
                    color: (_e.vars || _e).palette.action.disabled,
                    boxShadow: (_e.vars || _e).shadows[0],
                    backgroundColor: (_e.vars || _e).palette.action.disabledBackground
                }
            }
        }, {
            props: {
                variant: "outlined"
            },
            style: {
                padding: "5px 15px",
                border: "1px solid currentColor",
                borderColor: "var(--variant-outlinedBorder, currentColor)",
                backgroundColor: "var(--variant-outlinedBg)",
                color: "var(--variant-outlinedColor)",
                [`&.${buttonClasses.disabled}`]: {
                    border: `1px solid ${(_e.vars || _e).palette.action.disabledBackground}`
                }
            }
        }, {
            props: {
                variant: "text"
            },
            style: {
                padding: "6px 8px",
                color: "var(--variant-textColor)",
                backgroundColor: "var(--variant-textBg)"
            }
        }, ...Object.entries(_e.palette).filter(createSimplePaletteValueFilter()).map( ([tt]) => ({
            props: {
                color: tt
            },
            style: {
                "--variant-textColor": (_e.vars || _e).palette[tt].main,
                "--variant-outlinedColor": (_e.vars || _e).palette[tt].main,
                "--variant-outlinedBorder": _e.vars ? `rgba(${_e.vars.palette[tt].mainChannel} / 0.5)` : alpha(_e.palette[tt].main, .5),
                "--variant-containedColor": (_e.vars || _e).palette[tt].contrastText,
                "--variant-containedBg": (_e.vars || _e).palette[tt].main,
                "@media (hover: hover)": {
                    "&:hover": {
                        "--variant-containedBg": (_e.vars || _e).palette[tt].dark,
                        "--variant-textBg": _e.vars ? `rgba(${_e.vars.palette[tt].mainChannel} / ${_e.vars.palette.action.hoverOpacity})` : alpha(_e.palette[tt].main, _e.palette.action.hoverOpacity),
                        "--variant-outlinedBorder": (_e.vars || _e).palette[tt].main,
                        "--variant-outlinedBg": _e.vars ? `rgba(${_e.vars.palette[tt].mainChannel} / ${_e.vars.palette.action.hoverOpacity})` : alpha(_e.palette[tt].main, _e.palette.action.hoverOpacity)
                    }
                }
            }
        })), {
            props: {
                color: "inherit"
            },
            style: {
                color: "inherit",
                borderColor: "currentColor",
                "--variant-containedBg": _e.vars ? _e.vars.palette.Button.inheritContainedBg : $,
                "@media (hover: hover)": {
                    "&:hover": {
                        "--variant-containedBg": _e.vars ? _e.vars.palette.Button.inheritContainedHoverBg : et,
                        "--variant-textBg": _e.vars ? `rgba(${_e.vars.palette.text.primaryChannel} / ${_e.vars.palette.action.hoverOpacity})` : alpha(_e.palette.text.primary, _e.palette.action.hoverOpacity),
                        "--variant-outlinedBg": _e.vars ? `rgba(${_e.vars.palette.text.primaryChannel} / ${_e.vars.palette.action.hoverOpacity})` : alpha(_e.palette.text.primary, _e.palette.action.hoverOpacity)
                    }
                }
            }
        }, {
            props: {
                size: "small",
                variant: "text"
            },
            style: {
                padding: "4px 5px",
                fontSize: _e.typography.pxToRem(13)
            }
        }, {
            props: {
                size: "large",
                variant: "text"
            },
            style: {
                padding: "8px 11px",
                fontSize: _e.typography.pxToRem(15)
            }
        }, {
            props: {
                size: "small",
                variant: "outlined"
            },
            style: {
                padding: "3px 9px",
                fontSize: _e.typography.pxToRem(13)
            }
        }, {
            props: {
                size: "large",
                variant: "outlined"
            },
            style: {
                padding: "7px 21px",
                fontSize: _e.typography.pxToRem(15)
            }
        }, {
            props: {
                size: "small",
                variant: "contained"
            },
            style: {
                padding: "4px 10px",
                fontSize: _e.typography.pxToRem(13)
            }
        }, {
            props: {
                size: "large",
                variant: "contained"
            },
            style: {
                padding: "8px 22px",
                fontSize: _e.typography.pxToRem(15)
            }
        }, {
            props: {
                disableElevation: !0
            },
            style: {
                boxShadow: "none",
                "&:hover": {
                    boxShadow: "none"
                },
                [`&.${buttonClasses.focusVisible}`]: {
                    boxShadow: "none"
                },
                "&:active": {
                    boxShadow: "none"
                },
                [`&.${buttonClasses.disabled}`]: {
                    boxShadow: "none"
                }
            }
        }, {
            props: {
                fullWidth: !0
            },
            style: {
                width: "100%"
            }
        }, {
            props: {
                loadingPosition: "center"
            },
            style: {
                transition: _e.transitions.create(["background-color", "box-shadow", "border-color"], {
                    duration: _e.transitions.duration.short
                }),
                [`&.${buttonClasses.loading}`]: {
                    color: "transparent"
                }
            }
        }]
    }
}
))
  , ButtonStartIcon = styled("span", {
    name: "MuiButton",
    slot: "StartIcon",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.startIcon, et.loading && $.startIconLoadingStart, $[`iconSize${capitalize(et.size)}`]]
    }
})( ({theme: _e}) => ({
    display: "inherit",
    marginRight: 8,
    marginLeft: -4,
    variants: [{
        props: {
            size: "small"
        },
        style: {
            marginLeft: -2
        }
    }, {
        props: {
            loadingPosition: "start",
            loading: !0
        },
        style: {
            transition: _e.transitions.create(["opacity"], {
                duration: _e.transitions.duration.short
            }),
            opacity: 0
        }
    }, {
        props: {
            loadingPosition: "start",
            loading: !0,
            fullWidth: !0
        },
        style: {
            marginRight: -8
        }
    }, ...commonIconStyles]
}))
  , ButtonEndIcon = styled("span", {
    name: "MuiButton",
    slot: "EndIcon",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.endIcon, et.loading && $.endIconLoadingEnd, $[`iconSize${capitalize(et.size)}`]]
    }
})( ({theme: _e}) => ({
    display: "inherit",
    marginRight: -4,
    marginLeft: 8,
    variants: [{
        props: {
            size: "small"
        },
        style: {
            marginRight: -2
        }
    }, {
        props: {
            loadingPosition: "end",
            loading: !0
        },
        style: {
            transition: _e.transitions.create(["opacity"], {
                duration: _e.transitions.duration.short
            }),
            opacity: 0
        }
    }, {
        props: {
            loadingPosition: "end",
            loading: !0,
            fullWidth: !0
        },
        style: {
            marginLeft: -8
        }
    }, ...commonIconStyles]
}))
  , ButtonLoadingIndicator = styled("span", {
    name: "MuiButton",
    slot: "LoadingIndicator",
    overridesResolver: (_e, $) => $.loadingIndicator
})( ({theme: _e}) => ({
    display: "none",
    position: "absolute",
    visibility: "visible",
    variants: [{
        props: {
            loading: !0
        },
        style: {
            display: "flex"
        }
    }, {
        props: {
            loadingPosition: "start"
        },
        style: {
            left: 14
        }
    }, {
        props: {
            loadingPosition: "start",
            size: "small"
        },
        style: {
            left: 10
        }
    }, {
        props: {
            variant: "text",
            loadingPosition: "start"
        },
        style: {
            left: 6
        }
    }, {
        props: {
            loadingPosition: "center"
        },
        style: {
            left: "50%",
            transform: "translate(-50%)",
            color: (_e.vars || _e).palette.action.disabled
        }
    }, {
        props: {
            loadingPosition: "end"
        },
        style: {
            right: 14
        }
    }, {
        props: {
            loadingPosition: "end",
            size: "small"
        },
        style: {
            right: 10
        }
    }, {
        props: {
            variant: "text",
            loadingPosition: "end"
        },
        style: {
            right: 6
        }
    }, {
        props: {
            loadingPosition: "start",
            fullWidth: !0
        },
        style: {
            position: "relative",
            left: -10
        }
    }, {
        props: {
            loadingPosition: "end",
            fullWidth: !0
        },
        style: {
            position: "relative",
            right: -10
        }
    }]
}))
  , ButtonLoadingIconPlaceholder = styled("span", {
    name: "MuiButton",
    slot: "LoadingIconPlaceholder",
    overridesResolver: (_e, $) => $.loadingIconPlaceholder
})({
    display: "inline-block",
    width: "1em",
    height: "1em"
})
  , Button = reactExports.forwardRef(function($, et) {
    const tt = reactExports.useContext(ButtonGroupContext)
      , nt = reactExports.useContext(ButtonGroupButtonContext)
      , rt = resolveProps(tt, $)
      , it = useDefaultProps({
        props: rt,
        name: "MuiButton"
    })
      , {children: ot, color: st="primary", component: lt="button", className: ct, disabled: dt=!1, disableElevation: pt=!1, disableFocusRipple: ht=!1, endIcon: mt, focusVisibleClassName: yt, fullWidth: Et=!1, id: _t, loading: wt=null, loadingIndicator: St, loadingPosition: Ct="center", size: Nt="medium", startIcon: Lt, type: kt, variant: Ut="text", ...Jt} = it
      , Pt = useId(_t)
      , Xt = St ?? jsxRuntimeExports.jsx(CircularProgress, {
        "aria-labelledby": Pt,
        color: "inherit",
        size: 16
    })
      , rn = {
        ...it,
        color: st,
        component: lt,
        disabled: dt,
        disableElevation: pt,
        disableFocusRipple: ht,
        fullWidth: Et,
        loading: wt,
        loadingIndicator: Xt,
        loadingPosition: Ct,
        size: Nt,
        type: kt,
        variant: Ut
    }
      , zt = useUtilityClasses$p(rn)
      , xt = (Lt || wt && Ct === "start") && jsxRuntimeExports.jsx(ButtonStartIcon, {
        className: zt.startIcon,
        ownerState: rn,
        children: Lt || jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
            className: zt.loadingIconPlaceholder,
            ownerState: rn
        })
    })
      , $t = (mt || wt && Ct === "end") && jsxRuntimeExports.jsx(ButtonEndIcon, {
        className: zt.endIcon,
        ownerState: rn,
        children: mt || jsxRuntimeExports.jsx(ButtonLoadingIconPlaceholder, {
            className: zt.loadingIconPlaceholder,
            ownerState: rn
        })
    })
      , Dt = nt || ""
      , jt = typeof wt == "boolean" ? jsxRuntimeExports.jsx("span", {
        className: zt.loadingWrapper,
        style: {
            display: "contents"
        },
        children: wt && jsxRuntimeExports.jsx(ButtonLoadingIndicator, {
            className: zt.loadingIndicator,
            ownerState: rn,
            children: Xt
        })
    }) : null;
    return jsxRuntimeExports.jsxs(ButtonRoot, {
        ownerState: rn,
        className: clsx(tt.className, zt.root, ct, Dt),
        component: lt,
        disabled: dt || wt,
        focusRipple: !ht,
        focusVisibleClassName: clsx(zt.focusVisible, yt),
        ref: et,
        type: kt,
        id: wt ? Pt : _t,
        ...Jt,
        classes: zt,
        children: [xt, Ct !== "end" && jt, ot, Ct === "end" && jt, $t]
    })
});
function getSwitchBaseUtilityClass(_e) {
    return generateUtilityClass("PrivateSwitchBase", _e)
}
generateUtilityClasses("PrivateSwitchBase", ["root", "checked", "disabled", "input", "edgeStart", "edgeEnd"]);
const useUtilityClasses$o = _e => {
    const {classes: $, checked: et, disabled: tt, edge: nt} = _e
      , rt = {
        root: ["root", et && "checked", tt && "disabled", nt && `edge${capitalize(nt)}`],
        input: ["input"]
    };
    return composeClasses(rt, getSwitchBaseUtilityClass, $)
}
  , SwitchBaseRoot = styled(ButtonBase)({
    padding: 9,
    borderRadius: "50%",
    variants: [{
        props: {
            edge: "start",
            size: "small"
        },
        style: {
            marginLeft: -3
        }
    }, {
        props: ({edge: _e, ownerState: $}) => _e === "start" && $.size !== "small",
        style: {
            marginLeft: -12
        }
    }, {
        props: {
            edge: "end",
            size: "small"
        },
        style: {
            marginRight: -3
        }
    }, {
        props: ({edge: _e, ownerState: $}) => _e === "end" && $.size !== "small",
        style: {
            marginRight: -12
        }
    }]
})
  , SwitchBaseInput = styled("input", {
    shouldForwardProp: rootShouldForwardProp
})({
    cursor: "inherit",
    position: "absolute",
    opacity: 0,
    width: "100%",
    height: "100%",
    top: 0,
    left: 0,
    margin: 0,
    padding: 0,
    zIndex: 1
})
  , SwitchBase = reactExports.forwardRef(function($, et) {
    const {autoFocus: tt, checked: nt, checkedIcon: rt, className: it, defaultChecked: ot, disabled: st, disableFocusRipple: lt=!1, edge: ct=!1, icon: dt, id: pt, inputProps: ht, inputRef: mt, name: yt, onBlur: Et, onChange: _t, onFocus: wt, readOnly: St, required: Ct=!1, tabIndex: Nt, type: Lt, value: kt, ...Ut} = $
      , [Jt,Pt] = useControlled({
        controlled: nt,
        default: !!ot,
        name: "SwitchBase",
        state: "checked"
    })
      , Xt = useFormControl()
      , rn = Ht => {
        wt && wt(Ht),
        Xt && Xt.onFocus && Xt.onFocus(Ht)
    }
      , zt = Ht => {
        Et && Et(Ht),
        Xt && Xt.onBlur && Xt.onBlur(Ht)
    }
      , xt = Ht => {
        if (Ht.nativeEvent.defaultPrevented)
            return;
        const qt = Ht.target.checked;
        Pt(qt),
        _t && _t(Ht, qt)
    }
    ;
    let $t = st;
    Xt && typeof $t > "u" && ($t = Xt.disabled);
    const Dt = Lt === "checkbox" || Lt === "radio"
      , jt = {
        ...$,
        checked: Jt,
        disabled: $t,
        disableFocusRipple: lt,
        edge: ct
    }
      , Ft = useUtilityClasses$o(jt);
    return jsxRuntimeExports.jsxs(SwitchBaseRoot, {
        component: "span",
        className: clsx(Ft.root, it),
        centerRipple: !0,
        focusRipple: !lt,
        disabled: $t,
        tabIndex: null,
        role: void 0,
        onFocus: rn,
        onBlur: zt,
        ownerState: jt,
        ref: et,
        ...Ut,
        children: [jsxRuntimeExports.jsx(SwitchBaseInput, {
            autoFocus: tt,
            checked: nt,
            defaultChecked: ot,
            className: Ft.input,
            disabled: $t,
            id: Dt ? pt : void 0,
            name: yt,
            onChange: xt,
            readOnly: St,
            ref: mt,
            required: Ct,
            ownerState: jt,
            tabIndex: Nt,
            type: Lt,
            ...Lt === "checkbox" && kt === void 0 ? {} : {
                value: kt
            },
            ...ht
        }), Jt ? rt : dt]
    })
})
  , CheckBoxOutlineBlankIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z"
}), "CheckBoxOutlineBlank")
  , CheckBoxIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"
}), "CheckBox")
  , IndeterminateCheckBoxIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z"
}), "IndeterminateCheckBox");
function getCheckboxUtilityClass(_e) {
    return generateUtilityClass("MuiCheckbox", _e)
}
const checkboxClasses = generateUtilityClasses("MuiCheckbox", ["root", "checked", "disabled", "indeterminate", "colorPrimary", "colorSecondary", "sizeSmall", "sizeMedium"])
  , useUtilityClasses$n = _e => {
    const {classes: $, indeterminate: et, color: tt, size: nt} = _e
      , rt = {
        root: ["root", et && "indeterminate", `color${capitalize(tt)}`, `size${capitalize(nt)}`]
    }
      , it = composeClasses(rt, getCheckboxUtilityClass, $);
    return {
        ...$,
        ...it
    }
}
  , CheckboxRoot = styled(SwitchBase, {
    shouldForwardProp: _e => rootShouldForwardProp(_e) || _e === "classes",
    name: "MuiCheckbox",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, et.indeterminate && $.indeterminate, $[`size${capitalize(et.size)}`], et.color !== "default" && $[`color${capitalize(et.color)}`]]
    }
})(memoTheme( ({theme: _e}) => ({
    color: (_e.vars || _e).palette.text.secondary,
    variants: [{
        props: {
            color: "default",
            disableRipple: !1
        },
        style: {
            "&:hover": {
                backgroundColor: _e.vars ? `rgba(${_e.vars.palette.action.activeChannel} / ${_e.vars.palette.action.hoverOpacity})` : alpha(_e.palette.action.active, _e.palette.action.hoverOpacity)
            }
        }
    }, ...Object.entries(_e.palette).filter(createSimplePaletteValueFilter()).map( ([$]) => ({
        props: {
            color: $,
            disableRipple: !1
        },
        style: {
            "&:hover": {
                backgroundColor: _e.vars ? `rgba(${_e.vars.palette[$].mainChannel} / ${_e.vars.palette.action.hoverOpacity})` : alpha(_e.palette[$].main, _e.palette.action.hoverOpacity)
            }
        }
    })), ...Object.entries(_e.palette).filter(createSimplePaletteValueFilter()).map( ([$]) => ({
        props: {
            color: $
        },
        style: {
            [`&.${checkboxClasses.checked}, &.${checkboxClasses.indeterminate}`]: {
                color: (_e.vars || _e).palette[$].main
            },
            [`&.${checkboxClasses.disabled}`]: {
                color: (_e.vars || _e).palette.action.disabled
            }
        }
    })), {
        props: {
            disableRipple: !1
        },
        style: {
            "&:hover": {
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }
        }
    }]
})))
  , defaultCheckedIcon = jsxRuntimeExports.jsx(CheckBoxIcon, {})
  , defaultIcon = jsxRuntimeExports.jsx(CheckBoxOutlineBlankIcon, {})
  , defaultIndeterminateIcon = jsxRuntimeExports.jsx(IndeterminateCheckBoxIcon, {})
  , Checkbox = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiCheckbox"
    })
      , {checkedIcon: nt=defaultCheckedIcon, color: rt="primary", icon: it=defaultIcon, indeterminate: ot=!1, indeterminateIcon: st=defaultIndeterminateIcon, inputProps: lt, size: ct="medium", disableRipple: dt=!1, className: pt, ...ht} = tt
      , mt = ot ? st : it
      , yt = ot ? st : nt
      , Et = {
        ...tt,
        disableRipple: dt,
        color: rt,
        indeterminate: ot,
        size: ct
    }
      , _t = useUtilityClasses$n(Et);
    return jsxRuntimeExports.jsx(CheckboxRoot, {
        type: "checkbox",
        inputProps: {
            "data-indeterminate": ot,
            ...lt
        },
        icon: reactExports.cloneElement(mt, {
            fontSize: mt.props.fontSize ?? ct
        }),
        checkedIcon: reactExports.cloneElement(yt, {
            fontSize: yt.props.fontSize ?? ct
        }),
        ownerState: Et,
        ref: et,
        className: clsx(_t.root, pt),
        disableRipple: dt,
        ...ht,
        classes: _t
    })
});
function mapEventPropToEvent(_e) {
    return _e.substring(2).toLowerCase()
}
function clickedRootScrollbar(_e, $) {
    return $.documentElement.clientWidth < _e.clientX || $.documentElement.clientHeight < _e.clientY
}
function ClickAwayListener(_e) {
    const {children: $, disableReactTree: et=!1, mouseEvent: tt="onClick", onClickAway: nt, touchEvent: rt="onTouchEnd"} = _e
      , it = reactExports.useRef(!1)
      , ot = reactExports.useRef(null)
      , st = reactExports.useRef(!1)
      , lt = reactExports.useRef(!1);
    reactExports.useEffect( () => (setTimeout( () => {
        st.current = !0
    }
    , 0),
    () => {
        st.current = !1
    }
    ), []);
    const ct = useForkRef(getReactElementRef($), ot)
      , dt = useEventCallback$1(mt => {
        const yt = lt.current;
        lt.current = !1;
        const Et = ownerDocument(ot.current);
        if (!st.current || !ot.current || "clientX"in mt && clickedRootScrollbar(mt, Et))
            return;
        if (it.current) {
            it.current = !1;
            return
        }
        let _t;
        mt.composedPath ? _t = mt.composedPath().includes(ot.current) : _t = !Et.documentElement.contains(mt.target) || ot.current.contains(mt.target),
        !_t && (et || !yt) && nt(mt)
    }
    )
      , pt = mt => yt => {
        lt.current = !0;
        const Et = $.props[mt];
        Et && Et(yt)
    }
      , ht = {
        ref: ct
    };
    return rt !== !1 && (ht[rt] = pt(rt)),
    reactExports.useEffect( () => {
        if (rt !== !1) {
            const mt = mapEventPropToEvent(rt)
              , yt = ownerDocument(ot.current)
              , Et = () => {
                it.current = !0
            }
            ;
            return yt.addEventListener(mt, dt),
            yt.addEventListener("touchmove", Et),
            () => {
                yt.removeEventListener(mt, dt),
                yt.removeEventListener("touchmove", Et)
            }
        }
    }
    , [dt, rt]),
    tt !== !1 && (ht[tt] = pt(tt)),
    reactExports.useEffect( () => {
        if (tt !== !1) {
            const mt = mapEventPropToEvent(tt)
              , yt = ownerDocument(ot.current);
            return yt.addEventListener(mt, dt),
            () => {
                yt.removeEventListener(mt, dt)
            }
        }
    }
    , [dt, tt]),
    reactExports.cloneElement($, ht)
}
const isDynamicSupport = typeof globalCss({}) == "function"
  , html = (_e, $) => ({
    WebkitFontSmoothing: "antialiased",
    MozOsxFontSmoothing: "grayscale",
    boxSizing: "border-box",
    WebkitTextSizeAdjust: "100%",
    ...$ && !_e.vars && {
        colorScheme: _e.palette.mode
    }
})
  , body = _e => ({
    color: (_e.vars || _e).palette.text.primary,
    ..._e.typography.body1,
    backgroundColor: (_e.vars || _e).palette.background.default,
    "@media print": {
        backgroundColor: (_e.vars || _e).palette.common.white
    }
})
  , styles$2 = (_e, $=!1) => {
    var rt, it;
    const et = {};
    $ && _e.colorSchemes && typeof _e.getColorSchemeSelector == "function" && Object.entries(_e.colorSchemes).forEach( ([ot,st]) => {
        var ct, dt;
        const lt = _e.getColorSchemeSelector(ot);
        lt.startsWith("@") ? et[lt] = {
            ":root": {
                colorScheme: (ct = st.palette) == null ? void 0 : ct.mode
            }
        } : et[lt.replace(/\s*&/, "")] = {
            colorScheme: (dt = st.palette) == null ? void 0 : dt.mode
        }
    }
    );
    let tt = {
        html: html(_e, $),
        "*, *::before, *::after": {
            boxSizing: "inherit"
        },
        "strong, b": {
            fontWeight: _e.typography.fontWeightBold
        },
        body: {
            margin: 0,
            ...body(_e),
            "&::backdrop": {
                backgroundColor: (_e.vars || _e).palette.background.default
            }
        },
        ...et
    };
    const nt = (it = (rt = _e.components) == null ? void 0 : rt.MuiCssBaseline) == null ? void 0 : it.styleOverrides;
    return nt && (tt = [tt, nt]),
    tt
}
  , SELECTOR = "mui-ecs"
  , staticStyles = _e => {
    const $ = styles$2(_e, !1)
      , et = Array.isArray($) ? $[0] : $;
    return !_e.vars && et && (et.html[`:root:has(${SELECTOR})`] = {
        colorScheme: _e.palette.mode
    }),
    _e.colorSchemes && Object.entries(_e.colorSchemes).forEach( ([tt,nt]) => {
        var it, ot;
        const rt = _e.getColorSchemeSelector(tt);
        rt.startsWith("@") ? et[rt] = {
            [`:root:not(:has(.${SELECTOR}))`]: {
                colorScheme: (it = nt.palette) == null ? void 0 : it.mode
            }
        } : et[rt.replace(/\s*&/, "")] = {
            [`&:not(:has(.${SELECTOR}))`]: {
                colorScheme: (ot = nt.palette) == null ? void 0 : ot.mode
            }
        }
    }
    ),
    $
}
  , GlobalStyles = globalCss(isDynamicSupport ? ({theme: _e, enableColorScheme: $}) => styles$2(_e, $) : ({theme: _e}) => staticStyles(_e));
function CssBaseline(_e) {
    const $ = useDefaultProps({
        props: _e,
        name: "MuiCssBaseline"
    })
      , {children: et, enableColorScheme: tt=!1} = $;
    return jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [isDynamicSupport && jsxRuntimeExports.jsx(GlobalStyles, {
            enableColorScheme: tt
        }), !isDynamicSupport && !tt && jsxRuntimeExports.jsx("span", {
            className: SELECTOR,
            style: {
                display: "none"
            }
        }), et]
    })
}
function isOverflowing(_e) {
    const $ = ownerDocument(_e);
    return $.body === _e ? ownerWindow(_e).innerWidth > $.documentElement.clientWidth : _e.scrollHeight > _e.clientHeight
}
function ariaHidden(_e, $) {
    $ ? _e.setAttribute("aria-hidden", "true") : _e.removeAttribute("aria-hidden")
}
function getPaddingRight(_e) {
    return parseInt(ownerWindow(_e).getComputedStyle(_e).paddingRight, 10) || 0
}
function isAriaHiddenForbiddenOnElement(_e) {
    const et = ["TEMPLATE", "SCRIPT", "STYLE", "LINK", "MAP", "META", "NOSCRIPT", "PICTURE", "COL", "COLGROUP", "PARAM", "SLOT", "SOURCE", "TRACK"].includes(_e.tagName)
      , tt = _e.tagName === "INPUT" && _e.getAttribute("type") === "hidden";
    return et || tt
}
function ariaHiddenSiblings(_e, $, et, tt, nt) {
    const rt = [$, et, ...tt];
    [].forEach.call(_e.children, it => {
        const ot = !rt.includes(it)
          , st = !isAriaHiddenForbiddenOnElement(it);
        ot && st && ariaHidden(it, nt)
    }
    )
}
function findIndexOf(_e, $) {
    let et = -1;
    return _e.some( (tt, nt) => $(tt) ? (et = nt,
    !0) : !1),
    et
}
function handleContainer(_e, $) {
    const et = []
      , tt = _e.container;
    if (!$.disableScrollLock) {
        if (isOverflowing(tt)) {
            const it = getScrollbarSize(ownerWindow(tt));
            et.push({
                value: tt.style.paddingRight,
                property: "padding-right",
                el: tt
            }),
            tt.style.paddingRight = `${getPaddingRight(tt) + it}px`;
            const ot = ownerDocument(tt).querySelectorAll(".mui-fixed");
            [].forEach.call(ot, st => {
                et.push({
                    value: st.style.paddingRight,
                    property: "padding-right",
                    el: st
                }),
                st.style.paddingRight = `${getPaddingRight(st) + it}px`
            }
            )
        }
        let rt;
        if (tt.parentNode instanceof DocumentFragment)
            rt = ownerDocument(tt).body;
        else {
            const it = tt.parentElement
              , ot = ownerWindow(tt);
            rt = (it == null ? void 0 : it.nodeName) === "HTML" && ot.getComputedStyle(it).overflowY === "scroll" ? it : tt
        }
        et.push({
            value: rt.style.overflow,
            property: "overflow",
            el: rt
        }, {
            value: rt.style.overflowX,
            property: "overflow-x",
            el: rt
        }, {
            value: rt.style.overflowY,
            property: "overflow-y",
            el: rt
        }),
        rt.style.overflow = "hidden"
    }
    return () => {
        et.forEach( ({value: rt, el: it, property: ot}) => {
            rt ? it.style.setProperty(ot, rt) : it.style.removeProperty(ot)
        }
        )
    }
}
function getHiddenSiblings(_e) {
    const $ = [];
    return [].forEach.call(_e.children, et => {
        et.getAttribute("aria-hidden") === "true" && $.push(et)
    }
    ),
    $
}
class ModalManager {
    constructor() {
        this.modals = [],
        this.containers = []
    }
    add($, et) {
        let tt = this.modals.indexOf($);
        if (tt !== -1)
            return tt;
        tt = this.modals.length,
        this.modals.push($),
        $.modalRef && ariaHidden($.modalRef, !1);
        const nt = getHiddenSiblings(et);
        ariaHiddenSiblings(et, $.mount, $.modalRef, nt, !0);
        const rt = findIndexOf(this.containers, it => it.container === et);
        return rt !== -1 ? (this.containers[rt].modals.push($),
        tt) : (this.containers.push({
            modals: [$],
            container: et,
            restore: null,
            hiddenSiblings: nt
        }),
        tt)
    }
    mount($, et) {
        const tt = findIndexOf(this.containers, rt => rt.modals.includes($))
          , nt = this.containers[tt];
        nt.restore || (nt.restore = handleContainer(nt, et))
    }
    remove($, et=!0) {
        const tt = this.modals.indexOf($);
        if (tt === -1)
            return tt;
        const nt = findIndexOf(this.containers, it => it.modals.includes($))
          , rt = this.containers[nt];
        if (rt.modals.splice(rt.modals.indexOf($), 1),
        this.modals.splice(tt, 1),
        rt.modals.length === 0)
            rt.restore && rt.restore(),
            $.modalRef && ariaHidden($.modalRef, et),
            ariaHiddenSiblings(rt.container, $.mount, $.modalRef, rt.hiddenSiblings, !1),
            this.containers.splice(nt, 1);
        else {
            const it = rt.modals[rt.modals.length - 1];
            it.modalRef && ariaHidden(it.modalRef, !1)
        }
        return tt
    }
    isTopModal($) {
        return this.modals.length > 0 && this.modals[this.modals.length - 1] === $
    }
}
const candidatesSelector = ["input", "select", "textarea", "a[href]", "button", "[tabindex]", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])'].join(",");
function getTabIndex(_e) {
    const $ = parseInt(_e.getAttribute("tabindex") || "", 10);
    return Number.isNaN($) ? _e.contentEditable === "true" || (_e.nodeName === "AUDIO" || _e.nodeName === "VIDEO" || _e.nodeName === "DETAILS") && _e.getAttribute("tabindex") === null ? 0 : _e.tabIndex : $
}
function isNonTabbableRadio(_e) {
    if (_e.tagName !== "INPUT" || _e.type !== "radio" || !_e.name)
        return !1;
    const $ = tt => _e.ownerDocument.querySelector(`input[type="radio"]${tt}`);
    let et = $(`[name="${_e.name}"]:checked`);
    return et || (et = $(`[name="${_e.name}"]`)),
    et !== _e
}
function isNodeMatchingSelectorFocusable(_e) {
    return !(_e.disabled || _e.tagName === "INPUT" && _e.type === "hidden" || isNonTabbableRadio(_e))
}
function defaultGetTabbable(_e) {
    const $ = []
      , et = [];
    return Array.from(_e.querySelectorAll(candidatesSelector)).forEach( (tt, nt) => {
        const rt = getTabIndex(tt);
        rt === -1 || !isNodeMatchingSelectorFocusable(tt) || (rt === 0 ? $.push(tt) : et.push({
            documentOrder: nt,
            tabIndex: rt,
            node: tt
        }))
    }
    ),
    et.sort( (tt, nt) => tt.tabIndex === nt.tabIndex ? tt.documentOrder - nt.documentOrder : tt.tabIndex - nt.tabIndex).map(tt => tt.node).concat($)
}
function defaultIsEnabled() {
    return !0
}
function FocusTrap(_e) {
    const {children: $, disableAutoFocus: et=!1, disableEnforceFocus: tt=!1, disableRestoreFocus: nt=!1, getTabbable: rt=defaultGetTabbable, isEnabled: it=defaultIsEnabled, open: ot} = _e
      , st = reactExports.useRef(!1)
      , lt = reactExports.useRef(null)
      , ct = reactExports.useRef(null)
      , dt = reactExports.useRef(null)
      , pt = reactExports.useRef(null)
      , ht = reactExports.useRef(!1)
      , mt = reactExports.useRef(null)
      , yt = useForkRef(getReactElementRef($), mt)
      , Et = reactExports.useRef(null);
    reactExports.useEffect( () => {
        !ot || !mt.current || (ht.current = !et)
    }
    , [et, ot]),
    reactExports.useEffect( () => {
        if (!ot || !mt.current)
            return;
        const St = ownerDocument(mt.current);
        return mt.current.contains(St.activeElement) || (mt.current.hasAttribute("tabIndex") || mt.current.setAttribute("tabIndex", "-1"),
        ht.current && mt.current.focus()),
        () => {
            nt || (dt.current && dt.current.focus && (st.current = !0,
            dt.current.focus()),
            dt.current = null)
        }
    }
    , [ot]),
    reactExports.useEffect( () => {
        if (!ot || !mt.current)
            return;
        const St = ownerDocument(mt.current)
          , Ct = kt => {
            Et.current = kt,
            !(tt || !it() || kt.key !== "Tab") && St.activeElement === mt.current && kt.shiftKey && (st.current = !0,
            ct.current && ct.current.focus())
        }
          , Nt = () => {
            var Jt, Pt;
            const kt = mt.current;
            if (kt === null)
                return;
            if (!St.hasFocus() || !it() || st.current) {
                st.current = !1;
                return
            }
            if (kt.contains(St.activeElement) || tt && St.activeElement !== lt.current && St.activeElement !== ct.current)
                return;
            if (St.activeElement !== pt.current)
                pt.current = null;
            else if (pt.current !== null)
                return;
            if (!ht.current)
                return;
            let Ut = [];
            if ((St.activeElement === lt.current || St.activeElement === ct.current) && (Ut = rt(mt.current)),
            Ut.length > 0) {
                const Xt = !!((Jt = Et.current) != null && Jt.shiftKey && ((Pt = Et.current) == null ? void 0 : Pt.key) === "Tab")
                  , rn = Ut[0]
                  , zt = Ut[Ut.length - 1];
                typeof rn != "string" && typeof zt != "string" && (Xt ? zt.focus() : rn.focus())
            } else
                kt.focus()
        }
        ;
        St.addEventListener("focusin", Nt),
        St.addEventListener("keydown", Ct, !0);
        const Lt = setInterval( () => {
            St.activeElement && St.activeElement.tagName === "BODY" && Nt()
        }
        , 50);
        return () => {
            clearInterval(Lt),
            St.removeEventListener("focusin", Nt),
            St.removeEventListener("keydown", Ct, !0)
        }
    }
    , [et, tt, nt, it, ot, rt]);
    const _t = St => {
        dt.current === null && (dt.current = St.relatedTarget),
        ht.current = !0,
        pt.current = St.target;
        const Ct = $.props.onFocus;
        Ct && Ct(St)
    }
      , wt = St => {
        dt.current === null && (dt.current = St.relatedTarget),
        ht.current = !0
    }
    ;
    return jsxRuntimeExports.jsxs(reactExports.Fragment, {
        children: [jsxRuntimeExports.jsx("div", {
            tabIndex: ot ? 0 : -1,
            onFocus: wt,
            ref: lt,
            "data-testid": "sentinelStart"
        }), reactExports.cloneElement($, {
            ref: yt,
            onFocus: _t
        }), jsxRuntimeExports.jsx("div", {
            tabIndex: ot ? 0 : -1,
            onFocus: wt,
            ref: ct,
            "data-testid": "sentinelEnd"
        })]
    })
}
function getContainer(_e) {
    return typeof _e == "function" ? _e() : _e
}
function getHasTransition(_e) {
    return _e ? _e.props.hasOwnProperty("in") : !1
}
const noop$3 = () => {}
  , manager = new ModalManager;
function useModal(_e) {
    const {container: $, disableEscapeKeyDown: et=!1, disableScrollLock: tt=!1, closeAfterTransition: nt=!1, onTransitionEnter: rt, onTransitionExited: it, children: ot, onClose: st, open: lt, rootRef: ct} = _e
      , dt = reactExports.useRef({})
      , pt = reactExports.useRef(null)
      , ht = reactExports.useRef(null)
      , mt = useForkRef(ht, ct)
      , [yt,Et] = reactExports.useState(!lt)
      , _t = getHasTransition(ot);
    let wt = !0;
    (_e["aria-hidden"] === "false" || _e["aria-hidden"] === !1) && (wt = !1);
    const St = () => ownerDocument(pt.current)
      , Ct = () => (dt.current.modalRef = ht.current,
    dt.current.mount = pt.current,
    dt.current)
      , Nt = () => {
        manager.mount(Ct(), {
            disableScrollLock: tt
        }),
        ht.current && (ht.current.scrollTop = 0)
    }
      , Lt = useEventCallback$1( () => {
        const $t = getContainer($) || St().body;
        manager.add(Ct(), $t),
        ht.current && Nt()
    }
    )
      , kt = () => manager.isTopModal(Ct())
      , Ut = useEventCallback$1($t => {
        pt.current = $t,
        $t && (lt && kt() ? Nt() : ht.current && ariaHidden(ht.current, wt))
    }
    )
      , Jt = reactExports.useCallback( () => {
        manager.remove(Ct(), wt)
    }
    , [wt]);
    reactExports.useEffect( () => () => {
        Jt()
    }
    , [Jt]),
    reactExports.useEffect( () => {
        lt ? Lt() : (!_t || !nt) && Jt()
    }
    , [lt, Jt, _t, nt, Lt]);
    const Pt = $t => Dt => {
        var jt;
        (jt = $t.onKeyDown) == null || jt.call($t, Dt),
        !(Dt.key !== "Escape" || Dt.which === 229 || !kt()) && (et || (Dt.stopPropagation(),
        st && st(Dt, "escapeKeyDown")))
    }
      , Xt = $t => Dt => {
        var jt;
        (jt = $t.onClick) == null || jt.call($t, Dt),
        Dt.target === Dt.currentTarget && st && st(Dt, "backdropClick")
    }
    ;
    return {
        getRootProps: ($t={}) => {
            const Dt = extractEventHandlers(_e);
            delete Dt.onTransitionEnter,
            delete Dt.onTransitionExited;
            const jt = {
                ...Dt,
                ...$t
            };
            return {
                role: "presentation",
                ...jt,
                onKeyDown: Pt(jt),
                ref: mt
            }
        }
        ,
        getBackdropProps: ($t={}) => {
            const Dt = $t;
            return {
                "aria-hidden": !0,
                ...Dt,
                onClick: Xt(Dt),
                open: lt
            }
        }
        ,
        getTransitionProps: () => {
            const $t = () => {
                Et(!1),
                rt && rt()
            }
              , Dt = () => {
                Et(!0),
                it && it(),
                nt && Jt()
            }
            ;
            return {
                onEnter: createChainedFunction($t, (ot == null ? void 0 : ot.props.onEnter) ?? noop$3),
                onExited: createChainedFunction(Dt, (ot == null ? void 0 : ot.props.onExited) ?? noop$3)
            }
        }
        ,
        rootRef: mt,
        portalRef: Ut,
        isTopModal: kt,
        exited: yt,
        hasTransition: _t
    }
}
function getModalUtilityClass(_e) {
    return generateUtilityClass("MuiModal", _e)
}
generateUtilityClasses("MuiModal", ["root", "hidden", "backdrop"]);
const useUtilityClasses$m = _e => {
    const {open: $, exited: et, classes: tt} = _e;
    return composeClasses({
        root: ["root", !$ && et && "hidden"],
        backdrop: ["backdrop"]
    }, getModalUtilityClass, tt)
}
  , ModalRoot = styled("div", {
    name: "MuiModal",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, !et.open && et.exited && $.hidden]
    }
})(memoTheme( ({theme: _e}) => ({
    position: "fixed",
    zIndex: (_e.vars || _e).zIndex.modal,
    right: 0,
    bottom: 0,
    top: 0,
    left: 0,
    variants: [{
        props: ({ownerState: $}) => !$.open && $.exited,
        style: {
            visibility: "hidden"
        }
    }]
})))
  , ModalBackdrop = styled(Backdrop, {
    name: "MuiModal",
    slot: "Backdrop",
    overridesResolver: (_e, $) => $.backdrop
})({
    zIndex: -1
})
  , Modal = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        name: "MuiModal",
        props: $
    })
      , {BackdropComponent: nt=ModalBackdrop, BackdropProps: rt, classes: it, className: ot, closeAfterTransition: st=!1, children: lt, container: ct, component: dt, components: pt={}, componentsProps: ht={}, disableAutoFocus: mt=!1, disableEnforceFocus: yt=!1, disableEscapeKeyDown: Et=!1, disablePortal: _t=!1, disableRestoreFocus: wt=!1, disableScrollLock: St=!1, hideBackdrop: Ct=!1, keepMounted: Nt=!1, onBackdropClick: Lt, onClose: kt, onTransitionEnter: Ut, onTransitionExited: Jt, open: Pt, slotProps: Xt={}, slots: rn={}, theme: zt, ...xt} = tt
      , $t = {
        ...tt,
        closeAfterTransition: st,
        disableAutoFocus: mt,
        disableEnforceFocus: yt,
        disableEscapeKeyDown: Et,
        disablePortal: _t,
        disableRestoreFocus: wt,
        disableScrollLock: St,
        hideBackdrop: Ct,
        keepMounted: Nt
    }
      , {getRootProps: Dt, getBackdropProps: jt, getTransitionProps: Ft, portalRef: Ht, isTopModal: qt, exited: Wt, hasTransition: Mt} = useModal({
        ...$t,
        rootRef: et
    })
      , Yt = {
        ...$t,
        exited: Wt
    }
      , un = useUtilityClasses$m(Yt)
      , hn = {};
    if (lt.props.tabIndex === void 0 && (hn.tabIndex = "-1"),
    Mt) {
        const {onEnter: Hn, onExited: cr} = Ft();
        hn.onEnter = Hn,
        hn.onExited = cr
    }
    const _n = {
        ...xt,
        slots: {
            root: pt.Root,
            backdrop: pt.Backdrop,
            ...rn
        },
        slotProps: {
            ...ht,
            ...Xt
        }
    }
      , [kn,Dn] = useSlot("root", {
        elementType: ModalRoot,
        externalForwardedProps: _n,
        getSlotProps: Dt,
        additionalProps: {
            ref: et,
            as: dt
        },
        ownerState: Yt,
        className: clsx(ot, un == null ? void 0 : un.root, !Yt.open && Yt.exited && (un == null ? void 0 : un.hidden))
    })
      , [jn,Bn] = useSlot("backdrop", {
        elementType: nt,
        externalForwardedProps: _n,
        additionalProps: rt,
        getSlotProps: Hn => jt({
            ...Hn,
            onClick: cr => {
                Lt && Lt(cr),
                Hn != null && Hn.onClick && Hn.onClick(cr)
            }
        }),
        className: clsx(rt == null ? void 0 : rt.className, un == null ? void 0 : un.backdrop),
        ownerState: Yt
    })
      , Un = useForkRef(rt == null ? void 0 : rt.ref, Bn.ref);
    return !Nt && !Pt && (!Mt || Wt) ? null : jsxRuntimeExports.jsx(Portal, {
        ref: Ht,
        container: ct,
        disablePortal: _t,
        children: jsxRuntimeExports.jsxs(kn, {
            ...Dn,
            children: [!Ct && nt ? jsxRuntimeExports.jsx(jn, {
                ...Bn,
                ref: Un
            }) : null, jsxRuntimeExports.jsx(FocusTrap, {
                disableEnforceFocus: yt,
                disableAutoFocus: mt,
                disableRestoreFocus: wt,
                isEnabled: qt,
                open: Pt,
                children: reactExports.cloneElement(lt, hn)
            })]
        })
    })
});
function getDialogUtilityClass(_e) {
    return generateUtilityClass("MuiDialog", _e)
}
const dialogClasses = generateUtilityClasses("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"])
  , DialogContext = reactExports.createContext({})
  , DialogBackdrop = styled(Backdrop, {
    name: "MuiDialog",
    slot: "Backdrop",
    overrides: (_e, $) => $.backdrop
})({
    zIndex: -1
})
  , useUtilityClasses$l = _e => {
    const {classes: $, scroll: et, maxWidth: tt, fullWidth: nt, fullScreen: rt} = _e
      , it = {
        root: ["root"],
        container: ["container", `scroll${capitalize(et)}`],
        paper: ["paper", `paperScroll${capitalize(et)}`, `paperWidth${capitalize(String(tt))}`, nt && "paperFullWidth", rt && "paperFullScreen"]
    };
    return composeClasses(it, getDialogUtilityClass, $)
}
  , DialogRoot = styled(Modal, {
    name: "MuiDialog",
    slot: "Root",
    overridesResolver: (_e, $) => $.root
})({
    "@media print": {
        position: "absolute !important"
    }
})
  , DialogContainer = styled("div", {
    name: "MuiDialog",
    slot: "Container",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.container, $[`scroll${capitalize(et.scroll)}`]]
    }
})({
    height: "100%",
    "@media print": {
        height: "auto"
    },
    outline: 0,
    variants: [{
        props: {
            scroll: "paper"
        },
        style: {
            display: "flex",
            justifyContent: "center",
            alignItems: "center"
        }
    }, {
        props: {
            scroll: "body"
        },
        style: {
            overflowY: "auto",
            overflowX: "hidden",
            textAlign: "center",
            "&::after": {
                content: '""',
                display: "inline-block",
                verticalAlign: "middle",
                height: "100%",
                width: "0"
            }
        }
    }]
})
  , DialogPaper = styled(Paper, {
    name: "MuiDialog",
    slot: "Paper",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.paper, $[`scrollPaper${capitalize(et.scroll)}`], $[`paperWidth${capitalize(String(et.maxWidth))}`], et.fullWidth && $.paperFullWidth, et.fullScreen && $.paperFullScreen]
    }
})(memoTheme( ({theme: _e}) => ({
    margin: 32,
    position: "relative",
    overflowY: "auto",
    "@media print": {
        overflowY: "visible",
        boxShadow: "none"
    },
    variants: [{
        props: {
            scroll: "paper"
        },
        style: {
            display: "flex",
            flexDirection: "column",
            maxHeight: "calc(100% - 64px)"
        }
    }, {
        props: {
            scroll: "body"
        },
        style: {
            display: "inline-block",
            verticalAlign: "middle",
            textAlign: "initial"
        }
    }, {
        props: ({ownerState: $}) => !$.maxWidth,
        style: {
            maxWidth: "calc(100% - 64px)"
        }
    }, {
        props: {
            maxWidth: "xs"
        },
        style: {
            maxWidth: _e.breakpoints.unit === "px" ? Math.max(_e.breakpoints.values.xs, 444) : `max(${_e.breakpoints.values.xs}${_e.breakpoints.unit}, 444px)`,
            [`&.${dialogClasses.paperScrollBody}`]: {
                [_e.breakpoints.down(Math.max(_e.breakpoints.values.xs, 444) + 32 * 2)]: {
                    maxWidth: "calc(100% - 64px)"
                }
            }
        }
    }, ...Object.keys(_e.breakpoints.values).filter($ => $ !== "xs").map($ => ({
        props: {
            maxWidth: $
        },
        style: {
            maxWidth: `${_e.breakpoints.values[$]}${_e.breakpoints.unit}`,
            [`&.${dialogClasses.paperScrollBody}`]: {
                [_e.breakpoints.down(_e.breakpoints.values[$] + 32 * 2)]: {
                    maxWidth: "calc(100% - 64px)"
                }
            }
        }
    })), {
        props: ({ownerState: $}) => $.fullWidth,
        style: {
            width: "calc(100% - 64px)"
        }
    }, {
        props: ({ownerState: $}) => $.fullScreen,
        style: {
            margin: 0,
            width: "100%",
            maxWidth: "100%",
            height: "100%",
            maxHeight: "none",
            borderRadius: 0,
            [`&.${dialogClasses.paperScrollBody}`]: {
                margin: 0,
                maxWidth: "100%"
            }
        }
    }]
})))
  , Dialog$1 = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiDialog"
    })
      , nt = useTheme()
      , rt = {
        enter: nt.transitions.duration.enteringScreen,
        exit: nt.transitions.duration.leavingScreen
    }
      , {"aria-describedby": it, "aria-labelledby": ot, "aria-modal": st=!0, BackdropComponent: lt, BackdropProps: ct, children: dt, className: pt, disableEscapeKeyDown: ht=!1, fullScreen: mt=!1, fullWidth: yt=!1, maxWidth: Et="sm", onBackdropClick: _t, onClick: wt, onClose: St, open: Ct, PaperComponent: Nt=Paper, PaperProps: Lt={}, scroll: kt="paper", slots: Ut={}, slotProps: Jt={}, TransitionComponent: Pt=Fade, transitionDuration: Xt=rt, TransitionProps: rn, ...zt} = tt
      , xt = {
        ...tt,
        disableEscapeKeyDown: ht,
        fullScreen: mt,
        fullWidth: yt,
        maxWidth: Et,
        scroll: kt
    }
      , $t = useUtilityClasses$l(xt)
      , Dt = reactExports.useRef()
      , jt = Gn => {
        Dt.current = Gn.target === Gn.currentTarget
    }
      , Ft = Gn => {
        wt && wt(Gn),
        Dt.current && (Dt.current = null,
        _t && _t(Gn),
        St && St(Gn, "backdropClick"))
    }
      , Ht = useId(ot)
      , qt = reactExports.useMemo( () => ({
        titleId: Ht
    }), [Ht])
      , Wt = {
        transition: Pt,
        ...Ut
    }
      , Mt = {
        transition: rn,
        paper: Lt,
        backdrop: ct,
        ...Jt
    }
      , Yt = {
        slots: Wt,
        slotProps: Mt
    }
      , [un,hn] = useSlot("root", {
        elementType: DialogRoot,
        shouldForwardComponentProp: !0,
        externalForwardedProps: Yt,
        ownerState: xt,
        className: clsx($t.root, pt),
        ref: et
    })
      , [_n,kn] = useSlot("backdrop", {
        elementType: DialogBackdrop,
        shouldForwardComponentProp: !0,
        externalForwardedProps: Yt,
        ownerState: xt
    })
      , [Dn,jn] = useSlot("paper", {
        elementType: DialogPaper,
        shouldForwardComponentProp: !0,
        externalForwardedProps: Yt,
        ownerState: xt,
        className: clsx($t.paper, Lt.className)
    })
      , [Bn,Un] = useSlot("container", {
        elementType: DialogContainer,
        externalForwardedProps: Yt,
        ownerState: xt,
        className: clsx($t.container)
    })
      , [Hn,cr] = useSlot("transition", {
        elementType: Fade,
        externalForwardedProps: Yt,
        ownerState: xt,
        additionalProps: {
            appear: !0,
            in: Ct,
            timeout: Xt,
            role: "presentation"
        }
    });
    return jsxRuntimeExports.jsx(un, {
        closeAfterTransition: !0,
        slots: {
            backdrop: _n
        },
        slotProps: {
            backdrop: {
                transitionDuration: Xt,
                as: lt,
                ...kn
            }
        },
        disableEscapeKeyDown: ht,
        onClose: St,
        open: Ct,
        onClick: Ft,
        ...hn,
        ...zt,
        children: jsxRuntimeExports.jsx(Hn, {
            ...cr,
            children: jsxRuntimeExports.jsx(Bn, {
                onMouseDown: jt,
                ...Un,
                children: jsxRuntimeExports.jsx(Dn, {
                    as: Nt,
                    elevation: 24,
                    role: "dialog",
                    "aria-describedby": it,
                    "aria-labelledby": Ht,
                    "aria-modal": st,
                    ...jn,
                    children: jsxRuntimeExports.jsx(DialogContext.Provider, {
                        value: qt,
                        children: dt
                    })
                })
            })
        })
    })
});
function getDialogActionsUtilityClass(_e) {
    return generateUtilityClass("MuiDialogActions", _e)
}
generateUtilityClasses("MuiDialogActions", ["root", "spacing"]);
const useUtilityClasses$k = _e => {
    const {classes: $, disableSpacing: et} = _e;
    return composeClasses({
        root: ["root", !et && "spacing"]
    }, getDialogActionsUtilityClass, $)
}
  , DialogActionsRoot = styled("div", {
    name: "MuiDialogActions",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, !et.disableSpacing && $.spacing]
    }
})({
    display: "flex",
    alignItems: "center",
    padding: 8,
    justifyContent: "flex-end",
    flex: "0 0 auto",
    variants: [{
        props: ({ownerState: _e}) => !_e.disableSpacing,
        style: {
            "& > :not(style) ~ :not(style)": {
                marginLeft: 8
            }
        }
    }]
})
  , DialogActions = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiDialogActions"
    })
      , {className: nt, disableSpacing: rt=!1, ...it} = tt
      , ot = {
        ...tt,
        disableSpacing: rt
    }
      , st = useUtilityClasses$k(ot);
    return jsxRuntimeExports.jsx(DialogActionsRoot, {
        className: clsx(st.root, nt),
        ownerState: ot,
        ref: et,
        ...it
    })
});
function getDialogContentUtilityClass(_e) {
    return generateUtilityClass("MuiDialogContent", _e)
}
generateUtilityClasses("MuiDialogContent", ["root", "dividers"]);
function getDialogTitleUtilityClass(_e) {
    return generateUtilityClass("MuiDialogTitle", _e)
}
const dialogTitleClasses = generateUtilityClasses("MuiDialogTitle", ["root"])
  , useUtilityClasses$j = _e => {
    const {classes: $, dividers: et} = _e;
    return composeClasses({
        root: ["root", et && "dividers"]
    }, getDialogContentUtilityClass, $)
}
  , DialogContentRoot = styled("div", {
    name: "MuiDialogContent",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, et.dividers && $.dividers]
    }
})(memoTheme( ({theme: _e}) => ({
    flex: "1 1 auto",
    WebkitOverflowScrolling: "touch",
    overflowY: "auto",
    padding: "20px 24px",
    variants: [{
        props: ({ownerState: $}) => $.dividers,
        style: {
            padding: "16px 24px",
            borderTop: `1px solid ${(_e.vars || _e).palette.divider}`,
            borderBottom: `1px solid ${(_e.vars || _e).palette.divider}`
        }
    }, {
        props: ({ownerState: $}) => !$.dividers,
        style: {
            [`.${dialogTitleClasses.root} + &`]: {
                paddingTop: 0
            }
        }
    }]
})))
  , DialogContent = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiDialogContent"
    })
      , {className: nt, dividers: rt=!1, ...it} = tt
      , ot = {
        ...tt,
        dividers: rt
    }
      , st = useUtilityClasses$j(ot);
    return jsxRuntimeExports.jsx(DialogContentRoot, {
        className: clsx(st.root, nt),
        ownerState: ot,
        ref: et,
        ...it
    })
})
  , useUtilityClasses$i = _e => {
    const {classes: $} = _e;
    return composeClasses({
        root: ["root"]
    }, getDialogTitleUtilityClass, $)
}
  , DialogTitleRoot = styled(Typography, {
    name: "MuiDialogTitle",
    slot: "Root",
    overridesResolver: (_e, $) => $.root
})({
    padding: "16px 24px",
    flex: "0 0 auto"
})
  , DialogTitle = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiDialogTitle"
    })
      , {className: nt, id: rt, ...it} = tt
      , ot = tt
      , st = useUtilityClasses$i(ot)
      , {titleId: lt=rt} = reactExports.useContext(DialogContext);
    return jsxRuntimeExports.jsx(DialogTitleRoot, {
        component: "h2",
        className: clsx(st.root, nt),
        ownerState: ot,
        ref: et,
        variant: "h6",
        id: rt ?? lt,
        ...it
    })
});
function getDividerUtilityClass(_e) {
    return generateUtilityClass("MuiDivider", _e)
}
const dividerClasses = generateUtilityClasses("MuiDivider", ["root", "absolute", "fullWidth", "inset", "middle", "flexItem", "light", "vertical", "withChildren", "withChildrenVertical", "textAlignRight", "textAlignLeft", "wrapper", "wrapperVertical"])
  , useUtilityClasses$h = _e => {
    const {absolute: $, children: et, classes: tt, flexItem: nt, light: rt, orientation: it, textAlign: ot, variant: st} = _e;
    return composeClasses({
        root: ["root", $ && "absolute", st, rt && "light", it === "vertical" && "vertical", nt && "flexItem", et && "withChildren", et && it === "vertical" && "withChildrenVertical", ot === "right" && it !== "vertical" && "textAlignRight", ot === "left" && it !== "vertical" && "textAlignLeft"],
        wrapper: ["wrapper", it === "vertical" && "wrapperVertical"]
    }, getDividerUtilityClass, tt)
}
  , DividerRoot = styled("div", {
    name: "MuiDivider",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, et.absolute && $.absolute, $[et.variant], et.light && $.light, et.orientation === "vertical" && $.vertical, et.flexItem && $.flexItem, et.children && $.withChildren, et.children && et.orientation === "vertical" && $.withChildrenVertical, et.textAlign === "right" && et.orientation !== "vertical" && $.textAlignRight, et.textAlign === "left" && et.orientation !== "vertical" && $.textAlignLeft]
    }
})(memoTheme( ({theme: _e}) => ({
    margin: 0,
    flexShrink: 0,
    borderWidth: 0,
    borderStyle: "solid",
    borderColor: (_e.vars || _e).palette.divider,
    borderBottomWidth: "thin",
    variants: [{
        props: {
            absolute: !0
        },
        style: {
            position: "absolute",
            bottom: 0,
            left: 0,
            width: "100%"
        }
    }, {
        props: {
            light: !0
        },
        style: {
            borderColor: _e.vars ? `rgba(${_e.vars.palette.dividerChannel} / 0.08)` : alpha(_e.palette.divider, .08)
        }
    }, {
        props: {
            variant: "inset"
        },
        style: {
            marginLeft: 72
        }
    }, {
        props: {
            variant: "middle",
            orientation: "horizontal"
        },
        style: {
            marginLeft: _e.spacing(2),
            marginRight: _e.spacing(2)
        }
    }, {
        props: {
            variant: "middle",
            orientation: "vertical"
        },
        style: {
            marginTop: _e.spacing(1),
            marginBottom: _e.spacing(1)
        }
    }, {
        props: {
            orientation: "vertical"
        },
        style: {
            height: "100%",
            borderBottomWidth: 0,
            borderRightWidth: "thin"
        }
    }, {
        props: {
            flexItem: !0
        },
        style: {
            alignSelf: "stretch",
            height: "auto"
        }
    }, {
        props: ({ownerState: $}) => !!$.children,
        style: {
            display: "flex",
            textAlign: "center",
            border: 0,
            borderTopStyle: "solid",
            borderLeftStyle: "solid",
            "&::before, &::after": {
                content: '""',
                alignSelf: "center"
            }
        }
    }, {
        props: ({ownerState: $}) => $.children && $.orientation !== "vertical",
        style: {
            "&::before, &::after": {
                width: "100%",
                borderTop: `thin solid ${(_e.vars || _e).palette.divider}`,
                borderTopStyle: "inherit"
            }
        }
    }, {
        props: ({ownerState: $}) => $.orientation === "vertical" && $.children,
        style: {
            flexDirection: "column",
            "&::before, &::after": {
                height: "100%",
                borderLeft: `thin solid ${(_e.vars || _e).palette.divider}`,
                borderLeftStyle: "inherit"
            }
        }
    }, {
        props: ({ownerState: $}) => $.textAlign === "right" && $.orientation !== "vertical",
        style: {
            "&::before": {
                width: "90%"
            },
            "&::after": {
                width: "10%"
            }
        }
    }, {
        props: ({ownerState: $}) => $.textAlign === "left" && $.orientation !== "vertical",
        style: {
            "&::before": {
                width: "10%"
            },
            "&::after": {
                width: "90%"
            }
        }
    }]
})))
  , DividerWrapper = styled("span", {
    name: "MuiDivider",
    slot: "Wrapper",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.wrapper, et.orientation === "vertical" && $.wrapperVertical]
    }
})(memoTheme( ({theme: _e}) => ({
    display: "inline-block",
    paddingLeft: `calc(${_e.spacing(1)} * 1.2)`,
    paddingRight: `calc(${_e.spacing(1)} * 1.2)`,
    whiteSpace: "nowrap",
    variants: [{
        props: {
            orientation: "vertical"
        },
        style: {
            paddingTop: `calc(${_e.spacing(1)} * 1.2)`,
            paddingBottom: `calc(${_e.spacing(1)} * 1.2)`
        }
    }]
})))
  , Divider = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiDivider"
    })
      , {absolute: nt=!1, children: rt, className: it, orientation: ot="horizontal", component: st=rt || ot === "vertical" ? "div" : "hr", flexItem: lt=!1, light: ct=!1, role: dt=st !== "hr" ? "separator" : void 0, textAlign: pt="center", variant: ht="fullWidth", ...mt} = tt
      , yt = {
        ...tt,
        absolute: nt,
        component: st,
        flexItem: lt,
        light: ct,
        orientation: ot,
        role: dt,
        textAlign: pt,
        variant: ht
    }
      , Et = useUtilityClasses$h(yt);
    return jsxRuntimeExports.jsx(DividerRoot, {
        as: st,
        className: clsx(Et.root, it),
        role: dt,
        ref: et,
        ownerState: yt,
        "aria-orientation": dt === "separator" && (st !== "hr" || ot === "vertical") ? ot : void 0,
        ...mt,
        children: rt ? jsxRuntimeExports.jsx(DividerWrapper, {
            className: Et.wrapper,
            ownerState: yt,
            children: rt
        }) : null
    })
});
Divider && (Divider.muiSkipListHighlight = !0);
function getTranslateValue(_e, $, et) {
    const tt = $.getBoundingClientRect()
      , nt = et && et.getBoundingClientRect()
      , rt = ownerWindow($);
    let it;
    if ($.fakeTransform)
        it = $.fakeTransform;
    else {
        const lt = rt.getComputedStyle($);
        it = lt.getPropertyValue("-webkit-transform") || lt.getPropertyValue("transform")
    }
    let ot = 0
      , st = 0;
    if (it && it !== "none" && typeof it == "string") {
        const lt = it.split("(")[1].split(")")[0].split(",");
        ot = parseInt(lt[4], 10),
        st = parseInt(lt[5], 10)
    }
    return _e === "left" ? nt ? `translateX(${nt.right + ot - tt.left}px)` : `translateX(${rt.innerWidth + ot - tt.left}px)` : _e === "right" ? nt ? `translateX(-${tt.right - nt.left - ot}px)` : `translateX(-${tt.left + tt.width - ot}px)` : _e === "up" ? nt ? `translateY(${nt.bottom + st - tt.top}px)` : `translateY(${rt.innerHeight + st - tt.top}px)` : nt ? `translateY(-${tt.top - nt.top + tt.height - st}px)` : `translateY(-${tt.top + tt.height - st}px)`
}
function resolveContainer(_e) {
    return typeof _e == "function" ? _e() : _e
}
function setTranslateValue(_e, $, et) {
    const tt = resolveContainer(et)
      , nt = getTranslateValue(_e, $, tt);
    nt && ($.style.webkitTransform = nt,
    $.style.transform = nt)
}
const Slide = reactExports.forwardRef(function($, et) {
    const tt = useTheme()
      , nt = {
        enter: tt.transitions.easing.easeOut,
        exit: tt.transitions.easing.sharp
    }
      , rt = {
        enter: tt.transitions.duration.enteringScreen,
        exit: tt.transitions.duration.leavingScreen
    }
      , {addEndListener: it, appear: ot=!0, children: st, container: lt, direction: ct="down", easing: dt=nt, in: pt, onEnter: ht, onEntered: mt, onEntering: yt, onExit: Et, onExited: _t, onExiting: wt, style: St, timeout: Ct=rt, TransitionComponent: Nt=Transition, ...Lt} = $
      , kt = reactExports.useRef(null)
      , Ut = useForkRef(getReactElementRef(st), kt, et)
      , Jt = Ft => Ht => {
        Ft && (Ht === void 0 ? Ft(kt.current) : Ft(kt.current, Ht))
    }
      , Pt = Jt( (Ft, Ht) => {
        setTranslateValue(ct, Ft, lt),
        reflow(Ft),
        ht && ht(Ft, Ht)
    }
    )
      , Xt = Jt( (Ft, Ht) => {
        const qt = getTransitionProps({
            timeout: Ct,
            style: St,
            easing: dt
        }, {
            mode: "enter"
        });
        Ft.style.webkitTransition = tt.transitions.create("-webkit-transform", {
            ...qt
        }),
        Ft.style.transition = tt.transitions.create("transform", {
            ...qt
        }),
        Ft.style.webkitTransform = "none",
        Ft.style.transform = "none",
        yt && yt(Ft, Ht)
    }
    )
      , rn = Jt(mt)
      , zt = Jt(wt)
      , xt = Jt(Ft => {
        const Ht = getTransitionProps({
            timeout: Ct,
            style: St,
            easing: dt
        }, {
            mode: "exit"
        });
        Ft.style.webkitTransition = tt.transitions.create("-webkit-transform", Ht),
        Ft.style.transition = tt.transitions.create("transform", Ht),
        setTranslateValue(ct, Ft, lt),
        Et && Et(Ft)
    }
    )
      , $t = Jt(Ft => {
        Ft.style.webkitTransition = "",
        Ft.style.transition = "",
        _t && _t(Ft)
    }
    )
      , Dt = Ft => {
        it && it(kt.current, Ft)
    }
      , jt = reactExports.useCallback( () => {
        kt.current && setTranslateValue(ct, kt.current, lt)
    }
    , [ct, lt]);
    return reactExports.useEffect( () => {
        if (pt || ct === "down" || ct === "right")
            return;
        const Ft = debounce( () => {
            kt.current && setTranslateValue(ct, kt.current, lt)
        }
        )
          , Ht = ownerWindow(kt.current);
        return Ht.addEventListener("resize", Ft),
        () => {
            Ft.clear(),
            Ht.removeEventListener("resize", Ft)
        }
    }
    , [ct, pt, lt]),
    reactExports.useEffect( () => {
        pt || jt()
    }
    , [pt, jt]),
    jsxRuntimeExports.jsx(Nt, {
        nodeRef: kt,
        onEnter: Pt,
        onEntered: rn,
        onEntering: Xt,
        onExit: xt,
        onExited: $t,
        onExiting: zt,
        addEndListener: Dt,
        appear: ot,
        in: pt,
        timeout: Ct,
        ...Lt,
        children: (Ft, {ownerState: Ht, ...qt}) => reactExports.cloneElement(st, {
            ref: Ut,
            style: {
                visibility: Ft === "exited" && !pt ? "hidden" : void 0,
                ...St,
                ...st.props.style
            },
            ...qt
        })
    })
});
function getDrawerUtilityClass(_e) {
    return generateUtilityClass("MuiDrawer", _e)
}
generateUtilityClasses("MuiDrawer", ["root", "docked", "paper", "anchorLeft", "anchorRight", "anchorTop", "anchorBottom", "paperAnchorLeft", "paperAnchorRight", "paperAnchorTop", "paperAnchorBottom", "paperAnchorDockedLeft", "paperAnchorDockedRight", "paperAnchorDockedTop", "paperAnchorDockedBottom", "modal"]);
const overridesResolver$2 = (_e, $) => {
    const {ownerState: et} = _e;
    return [$.root, (et.variant === "permanent" || et.variant === "persistent") && $.docked, $.modal]
}
  , useUtilityClasses$g = _e => {
    const {classes: $, anchor: et, variant: tt} = _e
      , nt = {
        root: ["root", `anchor${capitalize(et)}`],
        docked: [(tt === "permanent" || tt === "persistent") && "docked"],
        modal: ["modal"],
        paper: ["paper", `paperAnchor${capitalize(et)}`, tt !== "temporary" && `paperAnchorDocked${capitalize(et)}`]
    };
    return composeClasses(nt, getDrawerUtilityClass, $)
}
  , DrawerRoot = styled(Modal, {
    name: "MuiDrawer",
    slot: "Root",
    overridesResolver: overridesResolver$2
})(memoTheme( ({theme: _e}) => ({
    zIndex: (_e.vars || _e).zIndex.drawer
})))
  , DrawerDockedRoot = styled("div", {
    shouldForwardProp: rootShouldForwardProp,
    name: "MuiDrawer",
    slot: "Docked",
    skipVariantsResolver: !1,
    overridesResolver: overridesResolver$2
})({
    flex: "0 0 auto"
})
  , DrawerPaper = styled(Paper, {
    name: "MuiDrawer",
    slot: "Paper",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.paper, $[`paperAnchor${capitalize(et.anchor)}`], et.variant !== "temporary" && $[`paperAnchorDocked${capitalize(et.anchor)}`]]
    }
})(memoTheme( ({theme: _e}) => ({
    overflowY: "auto",
    display: "flex",
    flexDirection: "column",
    height: "100%",
    flex: "1 0 auto",
    zIndex: (_e.vars || _e).zIndex.drawer,
    WebkitOverflowScrolling: "touch",
    position: "fixed",
    top: 0,
    outline: 0,
    variants: [{
        props: {
            anchor: "left"
        },
        style: {
            left: 0
        }
    }, {
        props: {
            anchor: "top"
        },
        style: {
            top: 0,
            left: 0,
            right: 0,
            height: "auto",
            maxHeight: "100%"
        }
    }, {
        props: {
            anchor: "right"
        },
        style: {
            right: 0
        }
    }, {
        props: {
            anchor: "bottom"
        },
        style: {
            top: "auto",
            left: 0,
            bottom: 0,
            right: 0,
            height: "auto",
            maxHeight: "100%"
        }
    }, {
        props: ({ownerState: $}) => $.anchor === "left" && $.variant !== "temporary",
        style: {
            borderRight: `1px solid ${(_e.vars || _e).palette.divider}`
        }
    }, {
        props: ({ownerState: $}) => $.anchor === "top" && $.variant !== "temporary",
        style: {
            borderBottom: `1px solid ${(_e.vars || _e).palette.divider}`
        }
    }, {
        props: ({ownerState: $}) => $.anchor === "right" && $.variant !== "temporary",
        style: {
            borderLeft: `1px solid ${(_e.vars || _e).palette.divider}`
        }
    }, {
        props: ({ownerState: $}) => $.anchor === "bottom" && $.variant !== "temporary",
        style: {
            borderTop: `1px solid ${(_e.vars || _e).palette.divider}`
        }
    }]
})))
  , oppositeDirection = {
    left: "right",
    right: "left",
    top: "down",
    bottom: "up"
};
function isHorizontal(_e) {
    return ["left", "right"].includes(_e)
}
function getAnchor({direction: _e}, $) {
    return _e === "rtl" && isHorizontal($) ? oppositeDirection[$] : $
}
const Drawer = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiDrawer"
    })
      , nt = useTheme()
      , rt = useRtl()
      , it = {
        enter: nt.transitions.duration.enteringScreen,
        exit: nt.transitions.duration.leavingScreen
    }
      , {anchor: ot="left", BackdropProps: st, children: lt, className: ct, elevation: dt=16, hideBackdrop: pt=!1, ModalProps: {BackdropProps: ht, ...mt}={}, onClose: yt, open: Et=!1, PaperProps: _t={}, SlideProps: wt, TransitionComponent: St=Slide, transitionDuration: Ct=it, variant: Nt="temporary", ...Lt} = tt
      , kt = reactExports.useRef(!1);
    reactExports.useEffect( () => {
        kt.current = !0
    }
    , []);
    const Ut = getAnchor({
        direction: rt ? "rtl" : "ltr"
    }, ot)
      , Pt = {
        ...tt,
        anchor: ot,
        elevation: dt,
        open: Et,
        variant: Nt,
        ...Lt
    }
      , Xt = useUtilityClasses$g(Pt)
      , rn = jsxRuntimeExports.jsx(DrawerPaper, {
        elevation: Nt === "temporary" ? dt : 0,
        square: !0,
        ..._t,
        className: clsx(Xt.paper, _t.className),
        ownerState: Pt,
        children: lt
    });
    if (Nt === "permanent")
        return jsxRuntimeExports.jsx(DrawerDockedRoot, {
            className: clsx(Xt.root, Xt.docked, ct),
            ownerState: Pt,
            ref: et,
            ...Lt,
            children: rn
        });
    const zt = jsxRuntimeExports.jsx(St, {
        in: Et,
        direction: oppositeDirection[Ut],
        timeout: Ct,
        appear: kt.current,
        ...wt,
        children: rn
    });
    return Nt === "persistent" ? jsxRuntimeExports.jsx(DrawerDockedRoot, {
        className: clsx(Xt.root, Xt.docked, ct),
        ownerState: Pt,
        ref: et,
        ...Lt,
        children: zt
    }) : jsxRuntimeExports.jsx(DrawerRoot, {
        BackdropProps: {
            ...st,
            ...ht,
            transitionDuration: Ct
        },
        className: clsx(Xt.root, Xt.modal, ct),
        open: Et,
        ownerState: Pt,
        onClose: yt,
        hideBackdrop: pt,
        ref: et,
        ...Lt,
        ...mt,
        children: zt
    })
});
function getFormControlUtilityClasses(_e) {
    return generateUtilityClass("MuiFormControl", _e)
}
generateUtilityClasses("MuiFormControl", ["root", "marginNone", "marginNormal", "marginDense", "fullWidth", "disabled"]);
const useUtilityClasses$f = _e => {
    const {classes: $, margin: et, fullWidth: tt} = _e
      , nt = {
        root: ["root", et !== "none" && `margin${capitalize(et)}`, tt && "fullWidth"]
    };
    return composeClasses(nt, getFormControlUtilityClasses, $)
}
  , FormControlRoot = styled("div", {
    name: "MuiFormControl",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, $[`margin${capitalize(et.margin)}`], et.fullWidth && $.fullWidth]
    }
})({
    display: "inline-flex",
    flexDirection: "column",
    position: "relative",
    minWidth: 0,
    padding: 0,
    margin: 0,
    border: 0,
    verticalAlign: "top",
    variants: [{
        props: {
            margin: "normal"
        },
        style: {
            marginTop: 16,
            marginBottom: 8
        }
    }, {
        props: {
            margin: "dense"
        },
        style: {
            marginTop: 8,
            marginBottom: 4
        }
    }, {
        props: {
            fullWidth: !0
        },
        style: {
            width: "100%"
        }
    }]
})
  , FormControl = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiFormControl"
    })
      , {children: nt, className: rt, color: it="primary", component: ot="div", disabled: st=!1, error: lt=!1, focused: ct, fullWidth: dt=!1, hiddenLabel: pt=!1, margin: ht="none", required: mt=!1, size: yt="medium", variant: Et="outlined", ..._t} = tt
      , wt = {
        ...tt,
        color: it,
        component: ot,
        disabled: st,
        error: lt,
        fullWidth: dt,
        hiddenLabel: pt,
        margin: ht,
        required: mt,
        size: yt,
        variant: Et
    }
      , St = useUtilityClasses$f(wt)
      , [Ct,Nt] = reactExports.useState( () => {
        let $t = !1;
        return nt && reactExports.Children.forEach(nt, Dt => {
            if (!isMuiElement(Dt, ["Input", "Select"]))
                return;
            const jt = isMuiElement(Dt, ["Select"]) ? Dt.props.input : Dt;
            jt && isAdornedStart(jt.props) && ($t = !0)
        }
        ),
        $t
    }
    )
      , [Lt,kt] = reactExports.useState( () => {
        let $t = !1;
        return nt && reactExports.Children.forEach(nt, Dt => {
            isMuiElement(Dt, ["Input", "Select"]) && (isFilled(Dt.props, !0) || isFilled(Dt.props.inputProps, !0)) && ($t = !0)
        }
        ),
        $t
    }
    )
      , [Ut,Jt] = reactExports.useState(!1);
    st && Ut && Jt(!1);
    const Pt = ct !== void 0 && !st ? ct : Ut;
    let Xt;
    reactExports.useRef(!1);
    const rn = reactExports.useCallback( () => {
        kt(!0)
    }
    , [])
      , zt = reactExports.useCallback( () => {
        kt(!1)
    }
    , [])
      , xt = reactExports.useMemo( () => ({
        adornedStart: Ct,
        setAdornedStart: Nt,
        color: it,
        disabled: st,
        error: lt,
        filled: Lt,
        focused: Pt,
        fullWidth: dt,
        hiddenLabel: pt,
        size: yt,
        onBlur: () => {
            Jt(!1)
        }
        ,
        onFocus: () => {
            Jt(!0)
        }
        ,
        onEmpty: zt,
        onFilled: rn,
        registerEffect: Xt,
        required: mt,
        variant: Et
    }), [Ct, it, st, lt, Lt, Pt, dt, pt, Xt, zt, rn, mt, yt, Et]);
    return jsxRuntimeExports.jsx(FormControlContext.Provider, {
        value: xt,
        children: jsxRuntimeExports.jsx(FormControlRoot, {
            as: ot,
            ownerState: wt,
            className: clsx(St.root, rt),
            ref: et,
            ..._t,
            children: nt
        })
    })
});
function getFormControlLabelUtilityClasses(_e) {
    return generateUtilityClass("MuiFormControlLabel", _e)
}
const formControlLabelClasses = generateUtilityClasses("MuiFormControlLabel", ["root", "labelPlacementStart", "labelPlacementTop", "labelPlacementBottom", "disabled", "label", "error", "required", "asterisk"])
  , useUtilityClasses$e = _e => {
    const {classes: $, disabled: et, labelPlacement: tt, error: nt, required: rt} = _e
      , it = {
        root: ["root", et && "disabled", `labelPlacement${capitalize(tt)}`, nt && "error", rt && "required"],
        label: ["label", et && "disabled"],
        asterisk: ["asterisk", nt && "error"]
    };
    return composeClasses(it, getFormControlLabelUtilityClasses, $)
}
  , FormControlLabelRoot = styled("label", {
    name: "MuiFormControlLabel",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [{
            [`& .${formControlLabelClasses.label}`]: $.label
        }, $.root, $[`labelPlacement${capitalize(et.labelPlacement)}`]]
    }
})(memoTheme( ({theme: _e}) => ({
    display: "inline-flex",
    alignItems: "center",
    cursor: "pointer",
    verticalAlign: "middle",
    WebkitTapHighlightColor: "transparent",
    marginLeft: -11,
    marginRight: 16,
    [`&.${formControlLabelClasses.disabled}`]: {
        cursor: "default"
    },
    [`& .${formControlLabelClasses.label}`]: {
        [`&.${formControlLabelClasses.disabled}`]: {
            color: (_e.vars || _e).palette.text.disabled
        }
    },
    variants: [{
        props: {
            labelPlacement: "start"
        },
        style: {
            flexDirection: "row-reverse",
            marginRight: -11
        }
    }, {
        props: {
            labelPlacement: "top"
        },
        style: {
            flexDirection: "column-reverse"
        }
    }, {
        props: {
            labelPlacement: "bottom"
        },
        style: {
            flexDirection: "column"
        }
    }, {
        props: ({labelPlacement: $}) => $ === "start" || $ === "top" || $ === "bottom",
        style: {
            marginLeft: 16
        }
    }]
})))
  , AsteriskComponent = styled("span", {
    name: "MuiFormControlLabel",
    slot: "Asterisk",
    overridesResolver: (_e, $) => $.asterisk
})(memoTheme( ({theme: _e}) => ({
    [`&.${formControlLabelClasses.error}`]: {
        color: (_e.vars || _e).palette.error.main
    }
})))
  , FormControlLabel = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiFormControlLabel"
    })
      , {checked: nt, className: rt, componentsProps: it={}, control: ot, disabled: st, disableTypography: lt, inputRef: ct, label: dt, labelPlacement: pt="end", name: ht, onChange: mt, required: yt, slots: Et={}, slotProps: _t={}, value: wt, ...St} = tt
      , Ct = useFormControl()
      , Nt = st ?? ot.props.disabled ?? (Ct == null ? void 0 : Ct.disabled)
      , Lt = yt ?? ot.props.required
      , kt = {
        disabled: Nt,
        required: Lt
    };
    ["checked", "name", "onChange", "value", "inputRef"].forEach($t => {
        typeof ot.props[$t] > "u" && typeof tt[$t] < "u" && (kt[$t] = tt[$t])
    }
    );
    const Ut = formControlState({
        props: tt,
        muiFormControl: Ct,
        states: ["error"]
    })
      , Jt = {
        ...tt,
        disabled: Nt,
        labelPlacement: pt,
        required: Lt,
        error: Ut.error
    }
      , Pt = useUtilityClasses$e(Jt)
      , Xt = {
        slots: Et,
        slotProps: {
            ...it,
            ..._t
        }
    }
      , [rn,zt] = useSlot("typography", {
        elementType: Typography,
        externalForwardedProps: Xt,
        ownerState: Jt
    });
    let xt = dt;
    return xt != null && xt.type !== Typography && !lt && (xt = jsxRuntimeExports.jsx(rn, {
        component: "span",
        ...zt,
        className: clsx(Pt.label, zt == null ? void 0 : zt.className),
        children: xt
    })),
    jsxRuntimeExports.jsxs(FormControlLabelRoot, {
        className: clsx(Pt.root, rt),
        ownerState: Jt,
        ref: et,
        ...St,
        children: [reactExports.cloneElement(ot, kt), Lt ? jsxRuntimeExports.jsxs("div", {
            children: [xt, jsxRuntimeExports.jsxs(AsteriskComponent, {
                ownerState: Jt,
                "aria-hidden": !0,
                className: Pt.asterisk,
                children: ["", "*"]
            })]
        }) : xt]
    })
});
function getFormGroupUtilityClass(_e) {
    return generateUtilityClass("MuiFormGroup", _e)
}
generateUtilityClasses("MuiFormGroup", ["root", "row", "error"]);
const useUtilityClasses$d = _e => {
    const {classes: $, row: et, error: tt} = _e;
    return composeClasses({
        root: ["root", et && "row", tt && "error"]
    }, getFormGroupUtilityClass, $)
}
  , FormGroupRoot = styled("div", {
    name: "MuiFormGroup",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, et.row && $.row]
    }
})({
    display: "flex",
    flexDirection: "column",
    flexWrap: "wrap",
    variants: [{
        props: {
            row: !0
        },
        style: {
            flexDirection: "row"
        }
    }]
})
  , FormGroup = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiFormGroup"
    })
      , {className: nt, row: rt=!1, ...it} = tt
      , ot = useFormControl()
      , st = formControlState({
        props: tt,
        muiFormControl: ot,
        states: ["error"]
    })
      , lt = {
        ...tt,
        row: rt,
        error: st.error
    }
      , ct = useUtilityClasses$d(lt);
    return jsxRuntimeExports.jsx(FormGroupRoot, {
        className: clsx(ct.root, nt),
        ownerState: lt,
        ref: et,
        ...it
    })
});
function getScale(_e) {
    return `scale(${_e}, ${_e ** 2})`
}
const styles$1 = {
    entering: {
        opacity: 1,
        transform: getScale(1)
    },
    entered: {
        opacity: 1,
        transform: "none"
    }
}
  , isWebKit154 = typeof navigator < "u" && /^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent) && /(os |version\/)15(.|_)4/i.test(navigator.userAgent)
  , Grow = reactExports.forwardRef(function($, et) {
    const {addEndListener: tt, appear: nt=!0, children: rt, easing: it, in: ot, onEnter: st, onEntered: lt, onEntering: ct, onExit: dt, onExited: pt, onExiting: ht, style: mt, timeout: yt="auto", TransitionComponent: Et=Transition, ..._t} = $
      , wt = useTimeout()
      , St = reactExports.useRef()
      , Ct = useTheme()
      , Nt = reactExports.useRef(null)
      , Lt = useForkRef(Nt, getReactElementRef(rt), et)
      , kt = $t => Dt => {
        if ($t) {
            const jt = Nt.current;
            Dt === void 0 ? $t(jt) : $t(jt, Dt)
        }
    }
      , Ut = kt(ct)
      , Jt = kt( ($t, Dt) => {
        reflow($t);
        const {duration: jt, delay: Ft, easing: Ht} = getTransitionProps({
            style: mt,
            timeout: yt,
            easing: it
        }, {
            mode: "enter"
        });
        let qt;
        yt === "auto" ? (qt = Ct.transitions.getAutoHeightDuration($t.clientHeight),
        St.current = qt) : qt = jt,
        $t.style.transition = [Ct.transitions.create("opacity", {
            duration: qt,
            delay: Ft
        }), Ct.transitions.create("transform", {
            duration: isWebKit154 ? qt : qt * .666,
            delay: Ft,
            easing: Ht
        })].join(","),
        st && st($t, Dt)
    }
    )
      , Pt = kt(lt)
      , Xt = kt(ht)
      , rn = kt($t => {
        const {duration: Dt, delay: jt, easing: Ft} = getTransitionProps({
            style: mt,
            timeout: yt,
            easing: it
        }, {
            mode: "exit"
        });
        let Ht;
        yt === "auto" ? (Ht = Ct.transitions.getAutoHeightDuration($t.clientHeight),
        St.current = Ht) : Ht = Dt,
        $t.style.transition = [Ct.transitions.create("opacity", {
            duration: Ht,
            delay: jt
        }), Ct.transitions.create("transform", {
            duration: isWebKit154 ? Ht : Ht * .666,
            delay: isWebKit154 ? jt : jt || Ht * .333,
            easing: Ft
        })].join(","),
        $t.style.opacity = 0,
        $t.style.transform = getScale(.75),
        dt && dt($t)
    }
    )
      , zt = kt(pt)
      , xt = $t => {
        yt === "auto" && wt.start(St.current || 0, $t),
        tt && tt(Nt.current, $t)
    }
    ;
    return jsxRuntimeExports.jsx(Et, {
        appear: nt,
        in: ot,
        nodeRef: Nt,
        onEnter: Jt,
        onEntered: Pt,
        onEntering: Ut,
        onExit: rn,
        onExited: zt,
        onExiting: Xt,
        addEndListener: xt,
        timeout: yt === "auto" ? null : yt,
        ..._t,
        children: ($t, {ownerState: Dt, ...jt}) => reactExports.cloneElement(rt, {
            style: {
                opacity: 0,
                transform: getScale(.75),
                visibility: $t === "exited" && !ot ? "hidden" : void 0,
                ...styles$1[$t],
                ...mt,
                ...rt.props.style
            },
            ref: Lt,
            ...jt
        })
    })
});
Grow && (Grow.muiSupportAuto = !0);
const useMediaQuery = unstable_createUseMediaQuery({
    themeId: THEME_ID
})
  , ListContext = reactExports.createContext({});
function getListUtilityClass(_e) {
    return generateUtilityClass("MuiList", _e)
}
generateUtilityClasses("MuiList", ["root", "padding", "dense", "subheader"]);
const useUtilityClasses$c = _e => {
    const {classes: $, disablePadding: et, dense: tt, subheader: nt} = _e;
    return composeClasses({
        root: ["root", !et && "padding", tt && "dense", nt && "subheader"]
    }, getListUtilityClass, $)
}
  , ListRoot = styled("ul", {
    name: "MuiList",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, !et.disablePadding && $.padding, et.dense && $.dense, et.subheader && $.subheader]
    }
})({
    listStyle: "none",
    margin: 0,
    padding: 0,
    position: "relative",
    variants: [{
        props: ({ownerState: _e}) => !_e.disablePadding,
        style: {
            paddingTop: 8,
            paddingBottom: 8
        }
    }, {
        props: ({ownerState: _e}) => _e.subheader,
        style: {
            paddingTop: 0
        }
    }]
})
  , List = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiList"
    })
      , {children: nt, className: rt, component: it="ul", dense: ot=!1, disablePadding: st=!1, subheader: lt, ...ct} = tt
      , dt = reactExports.useMemo( () => ({
        dense: ot
    }), [ot])
      , pt = {
        ...tt,
        component: it,
        dense: ot,
        disablePadding: st
    }
      , ht = useUtilityClasses$c(pt);
    return jsxRuntimeExports.jsx(ListContext.Provider, {
        value: dt,
        children: jsxRuntimeExports.jsxs(ListRoot, {
            as: it,
            className: clsx(ht.root, rt),
            ref: et,
            ownerState: pt,
            ...ct,
            children: [lt, nt]
        })
    })
});
function getListItemUtilityClass(_e) {
    return generateUtilityClass("MuiListItem", _e)
}
generateUtilityClasses("MuiListItem", ["root", "container", "dense", "alignItemsFlexStart", "divider", "gutters", "padding", "secondaryAction"]);
const listItemButtonClasses = generateUtilityClasses("MuiListItemButton", ["root", "focusVisible", "dense", "alignItemsFlexStart", "disabled", "divider", "gutters", "selected"]);
function getListItemSecondaryActionClassesUtilityClass(_e) {
    return generateUtilityClass("MuiListItemSecondaryAction", _e)
}
generateUtilityClasses("MuiListItemSecondaryAction", ["root", "disableGutters"]);
const useUtilityClasses$b = _e => {
    const {disableGutters: $, classes: et} = _e;
    return composeClasses({
        root: ["root", $ && "disableGutters"]
    }, getListItemSecondaryActionClassesUtilityClass, et)
}
  , ListItemSecondaryActionRoot = styled("div", {
    name: "MuiListItemSecondaryAction",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, et.disableGutters && $.disableGutters]
    }
})({
    position: "absolute",
    right: 16,
    top: "50%",
    transform: "translateY(-50%)",
    variants: [{
        props: ({ownerState: _e}) => _e.disableGutters,
        style: {
            right: 0
        }
    }]
})
  , ListItemSecondaryAction = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiListItemSecondaryAction"
    })
      , {className: nt, ...rt} = tt
      , it = reactExports.useContext(ListContext)
      , ot = {
        ...tt,
        disableGutters: it.disableGutters
    }
      , st = useUtilityClasses$b(ot);
    return jsxRuntimeExports.jsx(ListItemSecondaryActionRoot, {
        className: clsx(st.root, nt),
        ownerState: ot,
        ref: et,
        ...rt
    })
});
ListItemSecondaryAction.muiName = "ListItemSecondaryAction";
const overridesResolver$1 = (_e, $) => {
    const {ownerState: et} = _e;
    return [$.root, et.dense && $.dense, et.alignItems === "flex-start" && $.alignItemsFlexStart, et.divider && $.divider, !et.disableGutters && $.gutters, !et.disablePadding && $.padding, et.hasSecondaryAction && $.secondaryAction]
}
  , useUtilityClasses$a = _e => {
    const {alignItems: $, classes: et, dense: tt, disableGutters: nt, disablePadding: rt, divider: it, hasSecondaryAction: ot} = _e;
    return composeClasses({
        root: ["root", tt && "dense", !nt && "gutters", !rt && "padding", it && "divider", $ === "flex-start" && "alignItemsFlexStart", ot && "secondaryAction"],
        container: ["container"]
    }, getListItemUtilityClass, et)
}
  , ListItemRoot = styled("div", {
    name: "MuiListItem",
    slot: "Root",
    overridesResolver: overridesResolver$1
})(memoTheme( ({theme: _e}) => ({
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    width: "100%",
    boxSizing: "border-box",
    textAlign: "left",
    variants: [{
        props: ({ownerState: $}) => !$.disablePadding,
        style: {
            paddingTop: 8,
            paddingBottom: 8
        }
    }, {
        props: ({ownerState: $}) => !$.disablePadding && $.dense,
        style: {
            paddingTop: 4,
            paddingBottom: 4
        }
    }, {
        props: ({ownerState: $}) => !$.disablePadding && !$.disableGutters,
        style: {
            paddingLeft: 16,
            paddingRight: 16
        }
    }, {
        props: ({ownerState: $}) => !$.disablePadding && !!$.secondaryAction,
        style: {
            paddingRight: 48
        }
    }, {
        props: ({ownerState: $}) => !!$.secondaryAction,
        style: {
            [`& > .${listItemButtonClasses.root}`]: {
                paddingRight: 48
            }
        }
    }, {
        props: {
            alignItems: "flex-start"
        },
        style: {
            alignItems: "flex-start"
        }
    }, {
        props: ({ownerState: $}) => $.divider,
        style: {
            borderBottom: `1px solid ${(_e.vars || _e).palette.divider}`,
            backgroundClip: "padding-box"
        }
    }, {
        props: ({ownerState: $}) => $.button,
        style: {
            transition: _e.transitions.create("background-color", {
                duration: _e.transitions.duration.shortest
            }),
            "&:hover": {
                textDecoration: "none",
                backgroundColor: (_e.vars || _e).palette.action.hover,
                "@media (hover: none)": {
                    backgroundColor: "transparent"
                }
            }
        }
    }, {
        props: ({ownerState: $}) => $.hasSecondaryAction,
        style: {
            paddingRight: 48
        }
    }]
})))
  , ListItemContainer = styled("li", {
    name: "MuiListItem",
    slot: "Container",
    overridesResolver: (_e, $) => $.container
})({
    position: "relative"
})
  , ListItem = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiListItem"
    })
      , {alignItems: nt="center", children: rt, className: it, component: ot, components: st={}, componentsProps: lt={}, ContainerComponent: ct="li", ContainerProps: {className: dt, ...pt}={}, dense: ht=!1, disableGutters: mt=!1, disablePadding: yt=!1, divider: Et=!1, secondaryAction: _t, slotProps: wt={}, slots: St={}, ...Ct} = tt
      , Nt = reactExports.useContext(ListContext)
      , Lt = reactExports.useMemo( () => ({
        dense: ht || Nt.dense || !1,
        alignItems: nt,
        disableGutters: mt
    }), [nt, Nt.dense, ht, mt])
      , kt = reactExports.useRef(null)
      , Ut = reactExports.Children.toArray(rt)
      , Jt = Ut.length && isMuiElement(Ut[Ut.length - 1], ["ListItemSecondaryAction"])
      , Pt = {
        ...tt,
        alignItems: nt,
        dense: Lt.dense,
        disableGutters: mt,
        disablePadding: yt,
        divider: Et,
        hasSecondaryAction: Jt
    }
      , Xt = useUtilityClasses$a(Pt)
      , rn = useForkRef(kt, et)
      , zt = St.root || st.Root || ListItemRoot
      , xt = wt.root || lt.root || {}
      , $t = {
        className: clsx(Xt.root, xt.className, it),
        ...Ct
    };
    let Dt = ot || "li";
    return Jt ? (Dt = !$t.component && !ot ? "div" : Dt,
    ct === "li" && (Dt === "li" ? Dt = "div" : $t.component === "li" && ($t.component = "div")),
    jsxRuntimeExports.jsx(ListContext.Provider, {
        value: Lt,
        children: jsxRuntimeExports.jsxs(ListItemContainer, {
            as: ct,
            className: clsx(Xt.container, dt),
            ref: rn,
            ownerState: Pt,
            ...pt,
            children: [jsxRuntimeExports.jsx(zt, {
                ...xt,
                ...!isHostComponent(zt) && {
                    as: Dt,
                    ownerState: {
                        ...Pt,
                        ...xt.ownerState
                    }
                },
                ...$t,
                children: Ut
            }), Ut.pop()]
        })
    })) : jsxRuntimeExports.jsx(ListContext.Provider, {
        value: Lt,
        children: jsxRuntimeExports.jsxs(zt, {
            ...xt,
            as: Dt,
            ref: rn,
            ...!isHostComponent(zt) && {
                ownerState: {
                    ...Pt,
                    ...xt.ownerState
                }
            },
            ...$t,
            children: [Ut, _t && jsxRuntimeExports.jsx(ListItemSecondaryAction, {
                children: _t
            })]
        })
    })
});
function getListItemIconUtilityClass(_e) {
    return generateUtilityClass("MuiListItemIcon", _e)
}
const listItemIconClasses = generateUtilityClasses("MuiListItemIcon", ["root", "alignItemsFlexStart"])
  , useUtilityClasses$9 = _e => {
    const {alignItems: $, classes: et} = _e;
    return composeClasses({
        root: ["root", $ === "flex-start" && "alignItemsFlexStart"]
    }, getListItemIconUtilityClass, et)
}
  , ListItemIconRoot = styled("div", {
    name: "MuiListItemIcon",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, et.alignItems === "flex-start" && $.alignItemsFlexStart]
    }
})(memoTheme( ({theme: _e}) => ({
    minWidth: 56,
    color: (_e.vars || _e).palette.action.active,
    flexShrink: 0,
    display: "inline-flex",
    variants: [{
        props: {
            alignItems: "flex-start"
        },
        style: {
            marginTop: 8
        }
    }]
})))
  , ListItemIcon = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiListItemIcon"
    })
      , {className: nt, ...rt} = tt
      , it = reactExports.useContext(ListContext)
      , ot = {
        ...tt,
        alignItems: it.alignItems
    }
      , st = useUtilityClasses$9(ot);
    return jsxRuntimeExports.jsx(ListItemIconRoot, {
        className: clsx(st.root, nt),
        ownerState: ot,
        ref: et,
        ...rt
    })
})
  , listItemTextClasses = generateUtilityClasses("MuiListItemText", ["root", "multiline", "dense", "inset", "primary", "secondary"]);
function nextItem$1(_e, $, et) {
    return _e === $ ? _e.firstChild : $ && $.nextElementSibling ? $.nextElementSibling : et ? null : _e.firstChild
}
function previousItem$1(_e, $, et) {
    return _e === $ ? et ? _e.firstChild : _e.lastChild : $ && $.previousElementSibling ? $.previousElementSibling : et ? null : _e.lastChild
}
function textCriteriaMatches(_e, $) {
    if ($ === void 0)
        return !0;
    let et = _e.innerText;
    return et === void 0 && (et = _e.textContent),
    et = et.trim().toLowerCase(),
    et.length === 0 ? !1 : $.repeating ? et[0] === $.keys[0] : et.startsWith($.keys.join(""))
}
function moveFocus$1(_e, $, et, tt, nt, rt) {
    let it = !1
      , ot = nt(_e, $, $ ? et : !1);
    for (; ot; ) {
        if (ot === _e.firstChild) {
            if (it)
                return !1;
            it = !0
        }
        const st = tt ? !1 : ot.disabled || ot.getAttribute("aria-disabled") === "true";
        if (!ot.hasAttribute("tabindex") || !textCriteriaMatches(ot, rt) || st)
            ot = nt(_e, ot, et);
        else
            return ot.focus(),
            !0
    }
    return !1
}
const MenuList = reactExports.forwardRef(function($, et) {
    const {actions: tt, autoFocus: nt=!1, autoFocusItem: rt=!1, children: it, className: ot, disabledItemsFocusable: st=!1, disableListWrap: lt=!1, onKeyDown: ct, variant: dt="selectedMenu", ...pt} = $
      , ht = reactExports.useRef(null)
      , mt = reactExports.useRef({
        keys: [],
        repeating: !0,
        previousKeyMatched: !0,
        lastTime: null
    });
    useEnhancedEffect( () => {
        nt && ht.current.focus()
    }
    , [nt]),
    reactExports.useImperativeHandle(tt, () => ({
        adjustStyleForScrollbar: (St, {direction: Ct}) => {
            const Nt = !ht.current.style.width;
            if (St.clientHeight < ht.current.clientHeight && Nt) {
                const Lt = `${getScrollbarSize(ownerWindow(St))}px`;
                ht.current.style[Ct === "rtl" ? "paddingLeft" : "paddingRight"] = Lt,
                ht.current.style.width = `calc(100% + ${Lt})`
            }
            return ht.current
        }
    }), []);
    const yt = St => {
        const Ct = ht.current
          , Nt = St.key;
        if (St.ctrlKey || St.metaKey || St.altKey) {
            ct && ct(St);
            return
        }
        const kt = ownerDocument(Ct).activeElement;
        if (Nt === "ArrowDown")
            St.preventDefault(),
            moveFocus$1(Ct, kt, lt, st, nextItem$1);
        else if (Nt === "ArrowUp")
            St.preventDefault(),
            moveFocus$1(Ct, kt, lt, st, previousItem$1);
        else if (Nt === "Home")
            St.preventDefault(),
            moveFocus$1(Ct, null, lt, st, nextItem$1);
        else if (Nt === "End")
            St.preventDefault(),
            moveFocus$1(Ct, null, lt, st, previousItem$1);
        else if (Nt.length === 1) {
            const Ut = mt.current
              , Jt = Nt.toLowerCase()
              , Pt = performance.now();
            Ut.keys.length > 0 && (Pt - Ut.lastTime > 500 ? (Ut.keys = [],
            Ut.repeating = !0,
            Ut.previousKeyMatched = !0) : Ut.repeating && Jt !== Ut.keys[0] && (Ut.repeating = !1)),
            Ut.lastTime = Pt,
            Ut.keys.push(Jt);
            const Xt = kt && !Ut.repeating && textCriteriaMatches(kt, Ut);
            Ut.previousKeyMatched && (Xt || moveFocus$1(Ct, kt, !1, st, nextItem$1, Ut)) ? St.preventDefault() : Ut.previousKeyMatched = !1
        }
        ct && ct(St)
    }
      , Et = useForkRef(ht, et);
    let _t = -1;
    reactExports.Children.forEach(it, (St, Ct) => {
        if (!reactExports.isValidElement(St)) {
            _t === Ct && (_t += 1,
            _t >= it.length && (_t = -1));
            return
        }
        St.props.disabled || (dt === "selectedMenu" && St.props.selected || _t === -1) && (_t = Ct),
        _t === Ct && (St.props.disabled || St.props.muiSkipListHighlight || St.type.muiSkipListHighlight) && (_t += 1,
        _t >= it.length && (_t = -1))
    }
    );
    const wt = reactExports.Children.map(it, (St, Ct) => {
        if (Ct === _t) {
            const Nt = {};
            return rt && (Nt.autoFocus = !0),
            St.props.tabIndex === void 0 && dt === "selectedMenu" && (Nt.tabIndex = 0),
            reactExports.cloneElement(St, Nt)
        }
        return St
    }
    );
    return jsxRuntimeExports.jsx(List, {
        role: "menu",
        ref: Et,
        className: ot,
        onKeyDown: yt,
        tabIndex: nt ? 0 : -1,
        ...pt,
        children: wt
    })
});
function getPopoverUtilityClass(_e) {
    return generateUtilityClass("MuiPopover", _e)
}
generateUtilityClasses("MuiPopover", ["root", "paper"]);
function getOffsetTop(_e, $) {
    let et = 0;
    return typeof $ == "number" ? et = $ : $ === "center" ? et = _e.height / 2 : $ === "bottom" && (et = _e.height),
    et
}
function getOffsetLeft(_e, $) {
    let et = 0;
    return typeof $ == "number" ? et = $ : $ === "center" ? et = _e.width / 2 : $ === "right" && (et = _e.width),
    et
}
function getTransformOriginValue(_e) {
    return [_e.horizontal, _e.vertical].map($ => typeof $ == "number" ? `${$}px` : $).join(" ")
}
function resolveAnchorEl(_e) {
    return typeof _e == "function" ? _e() : _e
}
const useUtilityClasses$8 = _e => {
    const {classes: $} = _e;
    return composeClasses({
        root: ["root"],
        paper: ["paper"]
    }, getPopoverUtilityClass, $)
}
  , PopoverRoot = styled(Modal, {
    name: "MuiPopover",
    slot: "Root",
    overridesResolver: (_e, $) => $.root
})({})
  , PopoverPaper = styled(Paper, {
    name: "MuiPopover",
    slot: "Paper",
    overridesResolver: (_e, $) => $.paper
})({
    position: "absolute",
    overflowY: "auto",
    overflowX: "hidden",
    minWidth: 16,
    minHeight: 16,
    maxWidth: "calc(100% - 32px)",
    maxHeight: "calc(100% - 32px)",
    outline: 0
})
  , Popover = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiPopover"
    })
      , {action: nt, anchorEl: rt, anchorOrigin: it={
        vertical: "top",
        horizontal: "left"
    }, anchorPosition: ot, anchorReference: st="anchorEl", children: lt, className: ct, container: dt, elevation: pt=8, marginThreshold: ht=16, open: mt, PaperProps: yt={}, slots: Et={}, slotProps: _t={}, transformOrigin: wt={
        vertical: "top",
        horizontal: "left"
    }, TransitionComponent: St=Grow, transitionDuration: Ct="auto", TransitionProps: {onEntering: Nt, ...Lt}={}, disableScrollLock: kt=!1, ...Ut} = tt
      , Jt = (_t == null ? void 0 : _t.paper) ?? yt
      , Pt = reactExports.useRef()
      , Xt = {
        ...tt,
        anchorOrigin: it,
        anchorReference: st,
        elevation: pt,
        marginThreshold: ht,
        externalPaperSlotProps: Jt,
        transformOrigin: wt,
        TransitionComponent: St,
        transitionDuration: Ct,
        TransitionProps: Lt
    }
      , rn = useUtilityClasses$8(Xt)
      , zt = reactExports.useCallback( () => {
        if (st === "anchorPosition")
            return ot;
        const Bn = resolveAnchorEl(rt)
          , Hn = (Bn && Bn.nodeType === 1 ? Bn : ownerDocument(Pt.current).body).getBoundingClientRect();
        return {
            top: Hn.top + getOffsetTop(Hn, it.vertical),
            left: Hn.left + getOffsetLeft(Hn, it.horizontal)
        }
    }
    , [rt, it.horizontal, it.vertical, ot, st])
      , xt = reactExports.useCallback(Bn => ({
        vertical: getOffsetTop(Bn, wt.vertical),
        horizontal: getOffsetLeft(Bn, wt.horizontal)
    }), [wt.horizontal, wt.vertical])
      , $t = reactExports.useCallback(Bn => {
        const Un = {
            width: Bn.offsetWidth,
            height: Bn.offsetHeight
        }
          , Hn = xt(Un);
        if (st === "none")
            return {
                top: null,
                left: null,
                transformOrigin: getTransformOriginValue(Hn)
            };
        const cr = zt();
        let Gn = cr.top - Hn.vertical
          , Mn = cr.left - Hn.horizontal;
        const rr = Gn + Un.height
          , Zn = Mn + Un.width
          , pr = ownerWindow(resolveAnchorEl(rt))
          , Ur = pr.innerHeight - ht
          , xr = pr.innerWidth - ht;
        if (ht !== null && Gn < ht) {
            const wr = Gn - ht;
            Gn -= wr,
            Hn.vertical += wr
        } else if (ht !== null && rr > Ur) {
            const wr = rr - Ur;
            Gn -= wr,
            Hn.vertical += wr
        }
        if (ht !== null && Mn < ht) {
            const wr = Mn - ht;
            Mn -= wr,
            Hn.horizontal += wr
        } else if (Zn > xr) {
            const wr = Zn - xr;
            Mn -= wr,
            Hn.horizontal += wr
        }
        return {
            top: `${Math.round(Gn)}px`,
            left: `${Math.round(Mn)}px`,
            transformOrigin: getTransformOriginValue(Hn)
        }
    }
    , [rt, st, zt, xt, ht])
      , [Dt,jt] = reactExports.useState(mt)
      , Ft = reactExports.useCallback( () => {
        const Bn = Pt.current;
        if (!Bn)
            return;
        const Un = $t(Bn);
        Un.top !== null && Bn.style.setProperty("top", Un.top),
        Un.left !== null && (Bn.style.left = Un.left),
        Bn.style.transformOrigin = Un.transformOrigin,
        jt(!0)
    }
    , [$t]);
    reactExports.useEffect( () => (kt && window.addEventListener("scroll", Ft),
    () => window.removeEventListener("scroll", Ft)), [rt, kt, Ft]);
    const Ht = (Bn, Un) => {
        Nt && Nt(Bn, Un),
        Ft()
    }
      , qt = () => {
        jt(!1)
    }
    ;
    reactExports.useEffect( () => {
        mt && Ft()
    }
    ),
    reactExports.useImperativeHandle(nt, () => mt ? {
        updatePosition: () => {
            Ft()
        }
    } : null, [mt, Ft]),
    reactExports.useEffect( () => {
        if (!mt)
            return;
        const Bn = debounce( () => {
            Ft()
        }
        )
          , Un = ownerWindow(rt);
        return Un.addEventListener("resize", Bn),
        () => {
            Bn.clear(),
            Un.removeEventListener("resize", Bn)
        }
    }
    , [rt, mt, Ft]);
    let Wt = Ct;
    Ct === "auto" && !St.muiSupportAuto && (Wt = void 0);
    const Mt = dt || (rt ? ownerDocument(resolveAnchorEl(rt)).body : void 0)
      , Yt = {
        slots: Et,
        slotProps: {
            ..._t,
            paper: Jt
        }
    }
      , [un,hn] = useSlot("paper", {
        elementType: PopoverPaper,
        externalForwardedProps: Yt,
        additionalProps: {
            elevation: pt,
            className: clsx(rn.paper, Jt == null ? void 0 : Jt.className),
            style: Dt ? Jt.style : {
                ...Jt.style,
                opacity: 0
            }
        },
        ownerState: Xt
    })
      , [_n,{slotProps: kn, ...Dn}] = useSlot("root", {
        elementType: PopoverRoot,
        externalForwardedProps: Yt,
        additionalProps: {
            slotProps: {
                backdrop: {
                    invisible: !0
                }
            },
            container: Mt,
            open: mt
        },
        ownerState: Xt,
        className: clsx(rn.root, ct)
    })
      , jn = useForkRef(Pt, hn.ref);
    return jsxRuntimeExports.jsx(_n, {
        ...Dn,
        ...!isHostComponent(_n) && {
            slotProps: kn,
            disableScrollLock: kt
        },
        ...Ut,
        ref: et,
        children: jsxRuntimeExports.jsx(St, {
            appear: !0,
            in: mt,
            onEntering: Ht,
            onExited: qt,
            timeout: Wt,
            ...Lt,
            children: jsxRuntimeExports.jsx(un, {
                ...hn,
                ref: jn,
                children: lt
            })
        })
    })
});
function getMenuUtilityClass(_e) {
    return generateUtilityClass("MuiMenu", _e)
}
generateUtilityClasses("MuiMenu", ["root", "paper", "list"]);
const RTL_ORIGIN = {
    vertical: "top",
    horizontal: "right"
}
  , LTR_ORIGIN = {
    vertical: "top",
    horizontal: "left"
}
  , useUtilityClasses$7 = _e => {
    const {classes: $} = _e;
    return composeClasses({
        root: ["root"],
        paper: ["paper"],
        list: ["list"]
    }, getMenuUtilityClass, $)
}
  , MenuRoot = styled(Popover, {
    shouldForwardProp: _e => rootShouldForwardProp(_e) || _e === "classes",
    name: "MuiMenu",
    slot: "Root",
    overridesResolver: (_e, $) => $.root
})({})
  , MenuPaper = styled(PopoverPaper, {
    name: "MuiMenu",
    slot: "Paper",
    overridesResolver: (_e, $) => $.paper
})({
    maxHeight: "calc(100% - 96px)",
    WebkitOverflowScrolling: "touch"
})
  , MenuMenuList = styled(MenuList, {
    name: "MuiMenu",
    slot: "List",
    overridesResolver: (_e, $) => $.list
})({
    outline: 0
})
  , Menu = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiMenu"
    })
      , {autoFocus: nt=!0, children: rt, className: it, disableAutoFocusItem: ot=!1, MenuListProps: st={}, onClose: lt, open: ct, PaperProps: dt={}, PopoverClasses: pt, transitionDuration: ht="auto", TransitionProps: {onEntering: mt, ...yt}={}, variant: Et="selectedMenu", slots: _t={}, slotProps: wt={}, ...St} = tt
      , Ct = useRtl()
      , Nt = {
        ...tt,
        autoFocus: nt,
        disableAutoFocusItem: ot,
        MenuListProps: st,
        onEntering: mt,
        PaperProps: dt,
        transitionDuration: ht,
        TransitionProps: yt,
        variant: Et
    }
      , Lt = useUtilityClasses$7(Nt)
      , kt = nt && !ot && ct
      , Ut = reactExports.useRef(null)
      , Jt = (Dt, jt) => {
        Ut.current && Ut.current.adjustStyleForScrollbar(Dt, {
            direction: Ct ? "rtl" : "ltr"
        }),
        mt && mt(Dt, jt)
    }
      , Pt = Dt => {
        Dt.key === "Tab" && (Dt.preventDefault(),
        lt && lt(Dt, "tabKeyDown"))
    }
    ;
    let Xt = -1;
    reactExports.Children.map(rt, (Dt, jt) => {
        reactExports.isValidElement(Dt) && (Dt.props.disabled || (Et === "selectedMenu" && Dt.props.selected || Xt === -1) && (Xt = jt))
    }
    );
    const rn = _t.paper ?? MenuPaper
      , zt = wt.paper ?? dt
      , xt = useSlotProps({
        elementType: _t.root,
        externalSlotProps: wt.root,
        ownerState: Nt,
        className: [Lt.root, it]
    })
      , $t = useSlotProps({
        elementType: rn,
        externalSlotProps: zt,
        ownerState: Nt,
        className: Lt.paper
    });
    return jsxRuntimeExports.jsx(MenuRoot, {
        onClose: lt,
        anchorOrigin: {
            vertical: "bottom",
            horizontal: Ct ? "right" : "left"
        },
        transformOrigin: Ct ? RTL_ORIGIN : LTR_ORIGIN,
        slots: {
            paper: rn,
            root: _t.root
        },
        slotProps: {
            root: xt,
            paper: $t
        },
        open: ct,
        ref: et,
        transitionDuration: ht,
        TransitionProps: {
            onEntering: Jt,
            ...yt
        },
        ownerState: Nt,
        ...St,
        classes: pt,
        children: jsxRuntimeExports.jsx(MenuMenuList, {
            onKeyDown: Pt,
            actions: Ut,
            autoFocus: nt && (Xt === -1 || ot),
            autoFocusItem: kt,
            variant: Et,
            ...st,
            className: clsx(Lt.list, st.className),
            children: rt
        })
    })
});
function getMenuItemUtilityClass(_e) {
    return generateUtilityClass("MuiMenuItem", _e)
}
const menuItemClasses = generateUtilityClasses("MuiMenuItem", ["root", "focusVisible", "dense", "disabled", "divider", "gutters", "selected"])
  , overridesResolver = (_e, $) => {
    const {ownerState: et} = _e;
    return [$.root, et.dense && $.dense, et.divider && $.divider, !et.disableGutters && $.gutters]
}
  , useUtilityClasses$6 = _e => {
    const {disabled: $, dense: et, divider: tt, disableGutters: nt, selected: rt, classes: it} = _e
      , st = composeClasses({
        root: ["root", et && "dense", $ && "disabled", !nt && "gutters", tt && "divider", rt && "selected"]
    }, getMenuItemUtilityClass, it);
    return {
        ...it,
        ...st
    }
}
  , MenuItemRoot = styled(ButtonBase, {
    shouldForwardProp: _e => rootShouldForwardProp(_e) || _e === "classes",
    name: "MuiMenuItem",
    slot: "Root",
    overridesResolver
})(memoTheme( ({theme: _e}) => ({
    ..._e.typography.body1,
    display: "flex",
    justifyContent: "flex-start",
    alignItems: "center",
    position: "relative",
    textDecoration: "none",
    minHeight: 48,
    paddingTop: 6,
    paddingBottom: 6,
    boxSizing: "border-box",
    whiteSpace: "nowrap",
    "&:hover": {
        textDecoration: "none",
        backgroundColor: (_e.vars || _e).palette.action.hover,
        "@media (hover: none)": {
            backgroundColor: "transparent"
        }
    },
    [`&.${menuItemClasses.selected}`]: {
        backgroundColor: _e.vars ? `rgba(${_e.vars.palette.primary.mainChannel} / ${_e.vars.palette.action.selectedOpacity})` : alpha(_e.palette.primary.main, _e.palette.action.selectedOpacity),
        [`&.${menuItemClasses.focusVisible}`]: {
            backgroundColor: _e.vars ? `rgba(${_e.vars.palette.primary.mainChannel} / calc(${_e.vars.palette.action.selectedOpacity} + ${_e.vars.palette.action.focusOpacity}))` : alpha(_e.palette.primary.main, _e.palette.action.selectedOpacity + _e.palette.action.focusOpacity)
        }
    },
    [`&.${menuItemClasses.selected}:hover`]: {
        backgroundColor: _e.vars ? `rgba(${_e.vars.palette.primary.mainChannel} / calc(${_e.vars.palette.action.selectedOpacity} + ${_e.vars.palette.action.hoverOpacity}))` : alpha(_e.palette.primary.main, _e.palette.action.selectedOpacity + _e.palette.action.hoverOpacity),
        "@media (hover: none)": {
            backgroundColor: _e.vars ? `rgba(${_e.vars.palette.primary.mainChannel} / ${_e.vars.palette.action.selectedOpacity})` : alpha(_e.palette.primary.main, _e.palette.action.selectedOpacity)
        }
    },
    [`&.${menuItemClasses.focusVisible}`]: {
        backgroundColor: (_e.vars || _e).palette.action.focus
    },
    [`&.${menuItemClasses.disabled}`]: {
        opacity: (_e.vars || _e).palette.action.disabledOpacity
    },
    [`& + .${dividerClasses.root}`]: {
        marginTop: _e.spacing(1),
        marginBottom: _e.spacing(1)
    },
    [`& + .${dividerClasses.inset}`]: {
        marginLeft: 52
    },
    [`& .${listItemTextClasses.root}`]: {
        marginTop: 0,
        marginBottom: 0
    },
    [`& .${listItemTextClasses.inset}`]: {
        paddingLeft: 36
    },
    [`& .${listItemIconClasses.root}`]: {
        minWidth: 36
    },
    variants: [{
        props: ({ownerState: $}) => !$.disableGutters,
        style: {
            paddingLeft: 16,
            paddingRight: 16
        }
    }, {
        props: ({ownerState: $}) => $.divider,
        style: {
            borderBottom: `1px solid ${(_e.vars || _e).palette.divider}`,
            backgroundClip: "padding-box"
        }
    }, {
        props: ({ownerState: $}) => !$.dense,
        style: {
            [_e.breakpoints.up("sm")]: {
                minHeight: "auto"
            }
        }
    }, {
        props: ({ownerState: $}) => $.dense,
        style: {
            minHeight: 32,
            paddingTop: 4,
            paddingBottom: 4,
            ..._e.typography.body2,
            [`& .${listItemIconClasses.root} svg`]: {
                fontSize: "1.25rem"
            }
        }
    }]
})))
  , MenuItem = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiMenuItem"
    })
      , {autoFocus: nt=!1, component: rt="li", dense: it=!1, divider: ot=!1, disableGutters: st=!1, focusVisibleClassName: lt, role: ct="menuitem", tabIndex: dt, className: pt, ...ht} = tt
      , mt = reactExports.useContext(ListContext)
      , yt = reactExports.useMemo( () => ({
        dense: it || mt.dense || !1,
        disableGutters: st
    }), [mt.dense, it, st])
      , Et = reactExports.useRef(null);
    useEnhancedEffect( () => {
        nt && Et.current && Et.current.focus()
    }
    , [nt]);
    const _t = {
        ...tt,
        dense: yt.dense,
        divider: ot,
        disableGutters: st
    }
      , wt = useUtilityClasses$6(tt)
      , St = useForkRef(Et, et);
    let Ct;
    return tt.disabled || (Ct = dt !== void 0 ? dt : -1),
    jsxRuntimeExports.jsx(ListContext.Provider, {
        value: yt,
        children: jsxRuntimeExports.jsx(MenuItemRoot, {
            ref: St,
            role: ct,
            tabIndex: Ct,
            component: rt,
            focusVisibleClassName: clsx(wt.focusVisible, lt),
            className: clsx(wt.root, pt),
            ...ht,
            ownerState: _t,
            classes: wt
        })
    })
});
var _span;
const NotchedOutlineRoot$1 = styled("fieldset", {
    shouldForwardProp: rootShouldForwardProp
})({
    textAlign: "left",
    position: "absolute",
    bottom: 0,
    right: 0,
    top: -5,
    left: 0,
    margin: 0,
    padding: "0 8px",
    pointerEvents: "none",
    borderRadius: "inherit",
    borderStyle: "solid",
    borderWidth: 1,
    overflow: "hidden",
    minWidth: "0%"
})
  , NotchedOutlineLegend = styled("legend", {
    shouldForwardProp: rootShouldForwardProp
})(memoTheme( ({theme: _e}) => ({
    float: "unset",
    width: "auto",
    overflow: "hidden",
    variants: [{
        props: ({ownerState: $}) => !$.withLabel,
        style: {
            padding: 0,
            lineHeight: "11px",
            transition: _e.transitions.create("width", {
                duration: 150,
                easing: _e.transitions.easing.easeOut
            })
        }
    }, {
        props: ({ownerState: $}) => $.withLabel,
        style: {
            display: "block",
            padding: 0,
            height: 11,
            fontSize: "0.75em",
            visibility: "hidden",
            maxWidth: .01,
            transition: _e.transitions.create("max-width", {
                duration: 50,
                easing: _e.transitions.easing.easeOut
            }),
            whiteSpace: "nowrap",
            "& > span": {
                paddingLeft: 5,
                paddingRight: 5,
                display: "inline-block",
                opacity: 0,
                visibility: "visible"
            }
        }
    }, {
        props: ({ownerState: $}) => $.withLabel && $.notched,
        style: {
            maxWidth: "100%",
            transition: _e.transitions.create("max-width", {
                duration: 100,
                easing: _e.transitions.easing.easeOut,
                delay: 50
            })
        }
    }]
})));
function NotchedOutline(_e) {
    const {children: $, classes: et, className: tt, label: nt, notched: rt, ...it} = _e
      , ot = nt != null && nt !== ""
      , st = {
        ..._e,
        notched: rt,
        withLabel: ot
    };
    return jsxRuntimeExports.jsx(NotchedOutlineRoot$1, {
        "aria-hidden": !0,
        className: tt,
        ownerState: st,
        ...it,
        children: jsxRuntimeExports.jsx(NotchedOutlineLegend, {
            ownerState: st,
            children: ot ? jsxRuntimeExports.jsx("span", {
                children: nt
            }) : _span || (_span = jsxRuntimeExports.jsx("span", {
                className: "notranslate",
                "aria-hidden": !0,
                children: ""
            }))
        })
    })
}
const useUtilityClasses$5 = _e => {
    const {classes: $} = _e
      , tt = composeClasses({
        root: ["root"],
        notchedOutline: ["notchedOutline"],
        input: ["input"]
    }, getOutlinedInputUtilityClass, $);
    return {
        ...$,
        ...tt
    }
}
  , OutlinedInputRoot = styled(InputBaseRoot, {
    shouldForwardProp: _e => rootShouldForwardProp(_e) || _e === "classes",
    name: "MuiOutlinedInput",
    slot: "Root",
    overridesResolver: rootOverridesResolver
})(memoTheme( ({theme: _e}) => {
    const $ = _e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
        position: "relative",
        borderRadius: (_e.vars || _e).shape.borderRadius,
        [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
            borderColor: (_e.vars || _e).palette.text.primary
        },
        "@media (hover: none)": {
            [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
                borderColor: _e.vars ? `rgba(${_e.vars.palette.common.onBackgroundChannel} / 0.23)` : $
            }
        },
        [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
            borderWidth: 2
        },
        variants: [...Object.entries(_e.palette).filter(createSimplePaletteValueFilter()).map( ([et]) => ({
            props: {
                color: et
            },
            style: {
                [`&.${outlinedInputClasses.focused} .${outlinedInputClasses.notchedOutline}`]: {
                    borderColor: (_e.vars || _e).palette[et].main
                }
            }
        })), {
            props: {},
            style: {
                [`&.${outlinedInputClasses.error} .${outlinedInputClasses.notchedOutline}`]: {
                    borderColor: (_e.vars || _e).palette.error.main
                },
                [`&.${outlinedInputClasses.disabled} .${outlinedInputClasses.notchedOutline}`]: {
                    borderColor: (_e.vars || _e).palette.action.disabled
                }
            }
        }, {
            props: ({ownerState: et}) => et.startAdornment,
            style: {
                paddingLeft: 14
            }
        }, {
            props: ({ownerState: et}) => et.endAdornment,
            style: {
                paddingRight: 14
            }
        }, {
            props: ({ownerState: et}) => et.multiline,
            style: {
                padding: "16.5px 14px"
            }
        }, {
            props: ({ownerState: et, size: tt}) => et.multiline && tt === "small",
            style: {
                padding: "8.5px 14px"
            }
        }]
    }
}
))
  , NotchedOutlineRoot = styled(NotchedOutline, {
    name: "MuiOutlinedInput",
    slot: "NotchedOutline",
    overridesResolver: (_e, $) => $.notchedOutline
})(memoTheme( ({theme: _e}) => {
    const $ = _e.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)";
    return {
        borderColor: _e.vars ? `rgba(${_e.vars.palette.common.onBackgroundChannel} / 0.23)` : $
    }
}
))
  , OutlinedInputInput = styled(InputBaseInput, {
    name: "MuiOutlinedInput",
    slot: "Input",
    overridesResolver: inputOverridesResolver
})(memoTheme( ({theme: _e}) => ({
    padding: "16.5px 14px",
    ...!_e.vars && {
        "&:-webkit-autofill": {
            WebkitBoxShadow: _e.palette.mode === "light" ? null : "0 0 0 100px #266798 inset",
            WebkitTextFillColor: _e.palette.mode === "light" ? null : "#fff",
            caretColor: _e.palette.mode === "light" ? null : "#fff",
            borderRadius: "inherit"
        }
    },
    ..._e.vars && {
        "&:-webkit-autofill": {
            borderRadius: "inherit"
        },
        [_e.getColorSchemeSelector("dark")]: {
            "&:-webkit-autofill": {
                WebkitBoxShadow: "0 0 0 100px #266798 inset",
                WebkitTextFillColor: "#fff",
                caretColor: "#fff"
            }
        }
    },
    variants: [{
        props: {
            size: "small"
        },
        style: {
            padding: "8.5px 14px"
        }
    }, {
        props: ({ownerState: $}) => $.multiline,
        style: {
            padding: 0
        }
    }, {
        props: ({ownerState: $}) => $.startAdornment,
        style: {
            paddingLeft: 0
        }
    }, {
        props: ({ownerState: $}) => $.endAdornment,
        style: {
            paddingRight: 0
        }
    }]
})))
  , OutlinedInput = reactExports.forwardRef(function($, et) {
    var tt;
    const nt = useDefaultProps({
        props: $,
        name: "MuiOutlinedInput"
    })
      , {components: rt={}, fullWidth: it=!1, inputComponent: ot="input", label: st, multiline: lt=!1, notched: ct, slots: dt={}, type: pt="text", ...ht} = nt
      , mt = useUtilityClasses$5(nt)
      , yt = useFormControl()
      , Et = formControlState({
        props: nt,
        muiFormControl: yt,
        states: ["color", "disabled", "error", "focused", "hiddenLabel", "size", "required"]
    })
      , _t = {
        ...nt,
        color: Et.color || "primary",
        disabled: Et.disabled,
        error: Et.error,
        focused: Et.focused,
        formControl: yt,
        fullWidth: it,
        hiddenLabel: Et.hiddenLabel,
        multiline: lt,
        size: Et.size,
        type: pt
    }
      , wt = dt.root ?? rt.Root ?? OutlinedInputRoot
      , St = dt.input ?? rt.Input ?? OutlinedInputInput;
    return jsxRuntimeExports.jsx(InputBase, {
        slots: {
            root: wt,
            input: St
        },
        renderSuffix: Ct => jsxRuntimeExports.jsx(NotchedOutlineRoot, {
            ownerState: _t,
            className: mt.notchedOutline,
            label: st != null && st !== "" && Et.required ? tt || (tt = jsxRuntimeExports.jsxs(reactExports.Fragment, {
                children: [st, "", "*"]
            })) : st,
            notched: typeof ct < "u" ? ct : !!(Ct.startAdornment || Ct.filled || Ct.focused)
        }),
        fullWidth: it,
        inputComponent: ot,
        multiline: lt,
        ref: et,
        type: pt,
        ...ht,
        classes: {
            ...mt,
            notchedOutline: null
        }
    })
});
OutlinedInput.muiName = "Input";
function useSnackbar(_e={}) {
    const {autoHideDuration: $=null, disableWindowBlurListener: et=!1, onClose: tt, open: nt, resumeHideDuration: rt} = _e
      , it = useTimeout();
    reactExports.useEffect( () => {
        if (!nt)
            return;
        function _t(wt) {
            wt.defaultPrevented || wt.key === "Escape" && (tt == null || tt(wt, "escapeKeyDown"))
        }
        return document.addEventListener("keydown", _t),
        () => {
            document.removeEventListener("keydown", _t)
        }
    }
    , [nt, tt]);
    const ot = useEventCallback$1( (_t, wt) => {
        tt == null || tt(_t, wt)
    }
    )
      , st = useEventCallback$1(_t => {
        !tt || _t == null || it.start(_t, () => {
            ot(null, "timeout")
        }
        )
    }
    );
    reactExports.useEffect( () => (nt && st($),
    it.clear), [nt, $, st, it]);
    const lt = _t => {
        tt == null || tt(_t, "clickaway")
    }
      , ct = it.clear
      , dt = reactExports.useCallback( () => {
        $ != null && st(rt ?? $ * .5)
    }
    , [$, rt, st])
      , pt = _t => wt => {
        const St = _t.onBlur;
        St == null || St(wt),
        dt()
    }
      , ht = _t => wt => {
        const St = _t.onFocus;
        St == null || St(wt),
        ct()
    }
      , mt = _t => wt => {
        const St = _t.onMouseEnter;
        St == null || St(wt),
        ct()
    }
      , yt = _t => wt => {
        const St = _t.onMouseLeave;
        St == null || St(wt),
        dt()
    }
    ;
    return reactExports.useEffect( () => {
        if (!et && nt)
            return window.addEventListener("focus", dt),
            window.addEventListener("blur", ct),
            () => {
                window.removeEventListener("focus", dt),
                window.removeEventListener("blur", ct)
            }
    }
    , [et, nt, dt, ct]),
    {
        getRootProps: (_t={}) => {
            const wt = {
                ...extractEventHandlers(_e),
                ...extractEventHandlers(_t)
            };
            return {
                role: "presentation",
                ..._t,
                ...wt,
                onBlur: pt(wt),
                onFocus: ht(wt),
                onMouseEnter: mt(wt),
                onMouseLeave: yt(wt)
            }
        }
        ,
        onClickAway: lt
    }
}
function getSnackbarContentUtilityClass(_e) {
    return generateUtilityClass("MuiSnackbarContent", _e)
}
generateUtilityClasses("MuiSnackbarContent", ["root", "message", "action"]);
const useUtilityClasses$4 = _e => {
    const {classes: $} = _e;
    return composeClasses({
        root: ["root"],
        action: ["action"],
        message: ["message"]
    }, getSnackbarContentUtilityClass, $)
}
  , SnackbarContentRoot = styled(Paper, {
    name: "MuiSnackbarContent",
    slot: "Root",
    overridesResolver: (_e, $) => $.root
})(memoTheme( ({theme: _e}) => {
    const $ = _e.palette.mode === "light" ? .8 : .98
      , et = emphasize(_e.palette.background.default, $);
    return {
        ..._e.typography.body2,
        color: _e.vars ? _e.vars.palette.SnackbarContent.color : _e.palette.getContrastText(et),
        backgroundColor: _e.vars ? _e.vars.palette.SnackbarContent.bg : et,
        display: "flex",
        alignItems: "center",
        flexWrap: "wrap",
        padding: "6px 16px",
        borderRadius: (_e.vars || _e).shape.borderRadius,
        flexGrow: 1,
        [_e.breakpoints.up("sm")]: {
            flexGrow: "initial",
            minWidth: 288
        }
    }
}
))
  , SnackbarContentMessage = styled("div", {
    name: "MuiSnackbarContent",
    slot: "Message",
    overridesResolver: (_e, $) => $.message
})({
    padding: "8px 0"
})
  , SnackbarContentAction = styled("div", {
    name: "MuiSnackbarContent",
    slot: "Action",
    overridesResolver: (_e, $) => $.action
})({
    display: "flex",
    alignItems: "center",
    marginLeft: "auto",
    paddingLeft: 16,
    marginRight: -8
})
  , SnackbarContent = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiSnackbarContent"
    })
      , {action: nt, className: rt, message: it, role: ot="alert", ...st} = tt
      , lt = tt
      , ct = useUtilityClasses$4(lt);
    return jsxRuntimeExports.jsxs(SnackbarContentRoot, {
        role: ot,
        square: !0,
        elevation: 6,
        className: clsx(ct.root, rt),
        ownerState: lt,
        ref: et,
        ...st,
        children: [jsxRuntimeExports.jsx(SnackbarContentMessage, {
            className: ct.message,
            ownerState: lt,
            children: it
        }), nt ? jsxRuntimeExports.jsx(SnackbarContentAction, {
            className: ct.action,
            ownerState: lt,
            children: nt
        }) : null]
    })
});
function getSnackbarUtilityClass(_e) {
    return generateUtilityClass("MuiSnackbar", _e)
}
generateUtilityClasses("MuiSnackbar", ["root", "anchorOriginTopCenter", "anchorOriginBottomCenter", "anchorOriginTopRight", "anchorOriginBottomRight", "anchorOriginTopLeft", "anchorOriginBottomLeft"]);
const useUtilityClasses$3 = _e => {
    const {classes: $, anchorOrigin: et} = _e
      , tt = {
        root: ["root", `anchorOrigin${capitalize(et.vertical)}${capitalize(et.horizontal)}`]
    };
    return composeClasses(tt, getSnackbarUtilityClass, $)
}
  , SnackbarRoot = styled("div", {
    name: "MuiSnackbar",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, $[`anchorOrigin${capitalize(et.anchorOrigin.vertical)}${capitalize(et.anchorOrigin.horizontal)}`]]
    }
})(memoTheme( ({theme: _e}) => ({
    zIndex: (_e.vars || _e).zIndex.snackbar,
    position: "fixed",
    display: "flex",
    left: 8,
    right: 8,
    justifyContent: "center",
    alignItems: "center",
    variants: [{
        props: ({ownerState: $}) => $.anchorOrigin.vertical === "top",
        style: {
            top: 8,
            [_e.breakpoints.up("sm")]: {
                top: 24
            }
        }
    }, {
        props: ({ownerState: $}) => $.anchorOrigin.vertical !== "top",
        style: {
            bottom: 8,
            [_e.breakpoints.up("sm")]: {
                bottom: 24
            }
        }
    }, {
        props: ({ownerState: $}) => $.anchorOrigin.horizontal === "left",
        style: {
            justifyContent: "flex-start",
            [_e.breakpoints.up("sm")]: {
                left: 24,
                right: "auto"
            }
        }
    }, {
        props: ({ownerState: $}) => $.anchorOrigin.horizontal === "right",
        style: {
            justifyContent: "flex-end",
            [_e.breakpoints.up("sm")]: {
                right: 24,
                left: "auto"
            }
        }
    }, {
        props: ({ownerState: $}) => $.anchorOrigin.horizontal === "center",
        style: {
            [_e.breakpoints.up("sm")]: {
                left: "50%",
                right: "auto",
                transform: "translateX(-50%)"
            }
        }
    }]
})))
  , Snackbar = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiSnackbar"
    })
      , nt = useTheme()
      , rt = {
        enter: nt.transitions.duration.enteringScreen,
        exit: nt.transitions.duration.leavingScreen
    }
      , {action: it, anchorOrigin: {vertical: ot, horizontal: st}={
        vertical: "bottom",
        horizontal: "left"
    }, autoHideDuration: lt=null, children: ct, className: dt, ClickAwayListenerProps: pt, ContentProps: ht, disableWindowBlurListener: mt=!1, message: yt, onBlur: Et, onClose: _t, onFocus: wt, onMouseEnter: St, onMouseLeave: Ct, open: Nt, resumeHideDuration: Lt, TransitionComponent: kt=Grow, transitionDuration: Ut=rt, TransitionProps: {onEnter: Jt, onExited: Pt, ...Xt}={}, ...rn} = tt
      , zt = {
        ...tt,
        anchorOrigin: {
            vertical: ot,
            horizontal: st
        },
        autoHideDuration: lt,
        disableWindowBlurListener: mt,
        TransitionComponent: kt,
        transitionDuration: Ut
    }
      , xt = useUtilityClasses$3(zt)
      , {getRootProps: $t, onClickAway: Dt} = useSnackbar({
        ...zt
    })
      , [jt,Ft] = reactExports.useState(!0)
      , Ht = useSlotProps({
        elementType: SnackbarRoot,
        getSlotProps: $t,
        externalForwardedProps: rn,
        ownerState: zt,
        additionalProps: {
            ref: et
        },
        className: [xt.root, dt]
    })
      , qt = Mt => {
        Ft(!0),
        Pt && Pt(Mt)
    }
      , Wt = (Mt, Yt) => {
        Ft(!1),
        Jt && Jt(Mt, Yt)
    }
    ;
    return !Nt && jt ? null : jsxRuntimeExports.jsx(ClickAwayListener, {
        onClickAway: Dt,
        ...pt,
        children: jsxRuntimeExports.jsx(SnackbarRoot, {
            ...Ht,
            children: jsxRuntimeExports.jsx(kt, {
                appear: !0,
                in: Nt,
                timeout: Ut,
                direction: ot === "top" ? "down" : "up",
                onEnter: Wt,
                onExited: qt,
                ...Xt,
                children: ct || jsxRuntimeExports.jsx(SnackbarContent, {
                    message: yt,
                    action: it,
                    ...ht
                })
            })
        })
    })
})
  , Stack$5 = createStack({
    createStyledComponent: styled("div", {
        name: "MuiStack",
        slot: "Root",
        overridesResolver: (_e, $) => $.root
    }),
    useThemeProps: _e => useDefaultProps({
        props: _e,
        name: "MuiStack"
    })
});
function getTabUtilityClass(_e) {
    return generateUtilityClass("MuiTab", _e)
}
const tabClasses = generateUtilityClasses("MuiTab", ["root", "labelIcon", "textColorInherit", "textColorPrimary", "textColorSecondary", "selected", "disabled", "fullWidth", "wrapped", "iconWrapper", "icon"])
  , useUtilityClasses$2 = _e => {
    const {classes: $, textColor: et, fullWidth: tt, wrapped: nt, icon: rt, label: it, selected: ot, disabled: st} = _e
      , lt = {
        root: ["root", rt && it && "labelIcon", `textColor${capitalize(et)}`, tt && "fullWidth", nt && "wrapped", ot && "selected", st && "disabled"],
        icon: ["iconWrapper", "icon"]
    };
    return composeClasses(lt, getTabUtilityClass, $)
}
  , TabRoot = styled(ButtonBase, {
    name: "MuiTab",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, et.label && et.icon && $.labelIcon, $[`textColor${capitalize(et.textColor)}`], et.fullWidth && $.fullWidth, et.wrapped && $.wrapped, {
            [`& .${tabClasses.iconWrapper}`]: $.iconWrapper
        }, {
            [`& .${tabClasses.icon}`]: $.icon
        }]
    }
})(memoTheme( ({theme: _e}) => ({
    ..._e.typography.button,
    maxWidth: 360,
    minWidth: 90,
    position: "relative",
    minHeight: 48,
    flexShrink: 0,
    padding: "12px 16px",
    overflow: "hidden",
    whiteSpace: "normal",
    textAlign: "center",
    lineHeight: 1.25,
    variants: [{
        props: ({ownerState: $}) => $.label && ($.iconPosition === "top" || $.iconPosition === "bottom"),
        style: {
            flexDirection: "column"
        }
    }, {
        props: ({ownerState: $}) => $.label && $.iconPosition !== "top" && $.iconPosition !== "bottom",
        style: {
            flexDirection: "row"
        }
    }, {
        props: ({ownerState: $}) => $.icon && $.label,
        style: {
            minHeight: 72,
            paddingTop: 9,
            paddingBottom: 9
        }
    }, {
        props: ({ownerState: $, iconPosition: et}) => $.icon && $.label && et === "top",
        style: {
            [`& > .${tabClasses.icon}`]: {
                marginBottom: 6
            }
        }
    }, {
        props: ({ownerState: $, iconPosition: et}) => $.icon && $.label && et === "bottom",
        style: {
            [`& > .${tabClasses.icon}`]: {
                marginTop: 6
            }
        }
    }, {
        props: ({ownerState: $, iconPosition: et}) => $.icon && $.label && et === "start",
        style: {
            [`& > .${tabClasses.icon}`]: {
                marginRight: _e.spacing(1)
            }
        }
    }, {
        props: ({ownerState: $, iconPosition: et}) => $.icon && $.label && et === "end",
        style: {
            [`& > .${tabClasses.icon}`]: {
                marginLeft: _e.spacing(1)
            }
        }
    }, {
        props: {
            textColor: "inherit"
        },
        style: {
            color: "inherit",
            opacity: .6,
            [`&.${tabClasses.selected}`]: {
                opacity: 1
            },
            [`&.${tabClasses.disabled}`]: {
                opacity: (_e.vars || _e).palette.action.disabledOpacity
            }
        }
    }, {
        props: {
            textColor: "primary"
        },
        style: {
            color: (_e.vars || _e).palette.text.secondary,
            [`&.${tabClasses.selected}`]: {
                color: (_e.vars || _e).palette.primary.main
            },
            [`&.${tabClasses.disabled}`]: {
                color: (_e.vars || _e).palette.text.disabled
            }
        }
    }, {
        props: {
            textColor: "secondary"
        },
        style: {
            color: (_e.vars || _e).palette.text.secondary,
            [`&.${tabClasses.selected}`]: {
                color: (_e.vars || _e).palette.secondary.main
            },
            [`&.${tabClasses.disabled}`]: {
                color: (_e.vars || _e).palette.text.disabled
            }
        }
    }, {
        props: ({ownerState: $}) => $.fullWidth,
        style: {
            flexShrink: 1,
            flexGrow: 1,
            flexBasis: 0,
            maxWidth: "none"
        }
    }, {
        props: ({ownerState: $}) => $.wrapped,
        style: {
            fontSize: _e.typography.pxToRem(12)
        }
    }]
})))
  , Tab = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiTab"
    })
      , {className: nt, disabled: rt=!1, disableFocusRipple: it=!1, fullWidth: ot, icon: st, iconPosition: lt="top", indicator: ct, label: dt, onChange: pt, onClick: ht, onFocus: mt, selected: yt, selectionFollowsFocus: Et, textColor: _t="inherit", value: wt, wrapped: St=!1, ...Ct} = tt
      , Nt = {
        ...tt,
        disabled: rt,
        disableFocusRipple: it,
        selected: yt,
        icon: !!st,
        iconPosition: lt,
        label: !!dt,
        fullWidth: ot,
        textColor: _t,
        wrapped: St
    }
      , Lt = useUtilityClasses$2(Nt)
      , kt = st && dt && reactExports.isValidElement(st) ? reactExports.cloneElement(st, {
        className: clsx(Lt.icon, st.props.className)
    }) : st
      , Ut = Pt => {
        !yt && pt && pt(Pt, wt),
        ht && ht(Pt)
    }
      , Jt = Pt => {
        Et && !yt && pt && pt(Pt, wt),
        mt && mt(Pt)
    }
    ;
    return jsxRuntimeExports.jsxs(TabRoot, {
        focusRipple: !it,
        className: clsx(Lt.root, nt),
        ref: et,
        role: "tab",
        "aria-selected": yt,
        disabled: rt,
        onClick: Ut,
        onFocus: Jt,
        ownerState: Nt,
        tabIndex: yt ? 0 : -1,
        ...Ct,
        children: [lt === "top" || lt === "start" ? jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [kt, dt]
        }) : jsxRuntimeExports.jsxs(reactExports.Fragment, {
            children: [dt, kt]
        }), ct]
    })
})
  , KeyboardArrowLeft = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M15.41 16.09l-4.58-4.59 4.58-4.59L14 5.5l-6 6 6 6z"
}), "KeyboardArrowLeft")
  , KeyboardArrowRight = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M8.59 16.34l4.58-4.59-4.58-4.59L10 5.75l6 6-6 6z"
}), "KeyboardArrowRight");
function easeInOutSin(_e) {
    return (1 + Math.sin(Math.PI * _e - Math.PI / 2)) / 2
}
function animate(_e, $, et, tt={}, nt= () => {}
) {
    const {ease: rt=easeInOutSin, duration: it=300} = tt;
    let ot = null;
    const st = $[_e];
    let lt = !1;
    const ct = () => {
        lt = !0
    }
      , dt = pt => {
        if (lt) {
            nt(new Error("Animation cancelled"));
            return
        }
        ot === null && (ot = pt);
        const ht = Math.min(1, (pt - ot) / it);
        if ($[_e] = rt(ht) * (et - st) + st,
        ht >= 1) {
            requestAnimationFrame( () => {
                nt(null)
            }
            );
            return
        }
        requestAnimationFrame(dt)
    }
    ;
    return st === et ? (nt(new Error("Element already at target position")),
    ct) : (requestAnimationFrame(dt),
    ct)
}
const styles = {
    width: 99,
    height: 99,
    position: "absolute",
    top: -9999,
    overflow: "scroll"
};
function ScrollbarSize(_e) {
    const {onChange: $, ...et} = _e
      , tt = reactExports.useRef()
      , nt = reactExports.useRef(null)
      , rt = () => {
        tt.current = nt.current.offsetHeight - nt.current.clientHeight
    }
    ;
    return useEnhancedEffect( () => {
        const it = debounce( () => {
            const st = tt.current;
            rt(),
            st !== tt.current && $(tt.current)
        }
        )
          , ot = ownerWindow(nt.current);
        return ot.addEventListener("resize", it),
        () => {
            it.clear(),
            ot.removeEventListener("resize", it)
        }
    }
    , [$]),
    reactExports.useEffect( () => {
        rt(),
        $(tt.current)
    }
    , [$]),
    jsxRuntimeExports.jsx("div", {
        style: styles,
        ...et,
        ref: nt
    })
}
function getTabScrollButtonUtilityClass(_e) {
    return generateUtilityClass("MuiTabScrollButton", _e)
}
const tabScrollButtonClasses = generateUtilityClasses("MuiTabScrollButton", ["root", "vertical", "horizontal", "disabled"])
  , useUtilityClasses$1 = _e => {
    const {classes: $, orientation: et, disabled: tt} = _e;
    return composeClasses({
        root: ["root", et, tt && "disabled"]
    }, getTabScrollButtonUtilityClass, $)
}
  , TabScrollButtonRoot = styled(ButtonBase, {
    name: "MuiTabScrollButton",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.root, et.orientation && $[et.orientation]]
    }
})({
    width: 40,
    flexShrink: 0,
    opacity: .8,
    [`&.${tabScrollButtonClasses.disabled}`]: {
        opacity: 0
    },
    variants: [{
        props: {
            orientation: "vertical"
        },
        style: {
            width: "100%",
            height: 40,
            "& svg": {
                transform: "var(--TabScrollButton-svgRotate)"
            }
        }
    }]
})
  , TabScrollButton = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiTabScrollButton"
    })
      , {className: nt, slots: rt={}, slotProps: it={}, direction: ot, orientation: st, disabled: lt, ...ct} = tt
      , dt = useRtl()
      , pt = {
        isRtl: dt,
        ...tt
    }
      , ht = useUtilityClasses$1(pt)
      , mt = rt.StartScrollButtonIcon ?? KeyboardArrowLeft
      , yt = rt.EndScrollButtonIcon ?? KeyboardArrowRight
      , Et = useSlotProps({
        elementType: mt,
        externalSlotProps: it.startScrollButtonIcon,
        additionalProps: {
            fontSize: "small"
        },
        ownerState: pt
    })
      , _t = useSlotProps({
        elementType: yt,
        externalSlotProps: it.endScrollButtonIcon,
        additionalProps: {
            fontSize: "small"
        },
        ownerState: pt
    });
    return jsxRuntimeExports.jsx(TabScrollButtonRoot, {
        component: "div",
        className: clsx(ht.root, nt),
        ref: et,
        role: null,
        ownerState: pt,
        tabIndex: null,
        ...ct,
        style: {
            ...ct.style,
            ...st === "vertical" && {
                "--TabScrollButton-svgRotate": `rotate(${dt ? -90 : 90}deg)`
            }
        },
        children: ot === "left" ? jsxRuntimeExports.jsx(mt, {
            ...Et
        }) : jsxRuntimeExports.jsx(yt, {
            ..._t
        })
    })
});
function getTabsUtilityClass(_e) {
    return generateUtilityClass("MuiTabs", _e)
}
const tabsClasses = generateUtilityClasses("MuiTabs", ["root", "vertical", "flexContainer", "flexContainerVertical", "centered", "scroller", "fixed", "scrollableX", "scrollableY", "hideScrollbar", "scrollButtons", "scrollButtonsHideMobile", "indicator"])
  , nextItem = (_e, $) => _e === $ ? _e.firstChild : $ && $.nextElementSibling ? $.nextElementSibling : _e.firstChild
  , previousItem = (_e, $) => _e === $ ? _e.lastChild : $ && $.previousElementSibling ? $.previousElementSibling : _e.lastChild
  , moveFocus = (_e, $, et) => {
    let tt = !1
      , nt = et(_e, $);
    for (; nt; ) {
        if (nt === _e.firstChild) {
            if (tt)
                return;
            tt = !0
        }
        const rt = nt.disabled || nt.getAttribute("aria-disabled") === "true";
        if (!nt.hasAttribute("tabindex") || rt)
            nt = et(_e, nt);
        else {
            nt.focus();
            return
        }
    }
}
  , useUtilityClasses = _e => {
    const {vertical: $, fixed: et, hideScrollbar: tt, scrollableX: nt, scrollableY: rt, centered: it, scrollButtonsHideMobile: ot, classes: st} = _e;
    return composeClasses({
        root: ["root", $ && "vertical"],
        scroller: ["scroller", et && "fixed", tt && "hideScrollbar", nt && "scrollableX", rt && "scrollableY"],
        flexContainer: ["flexContainer", $ && "flexContainerVertical", it && "centered"],
        indicator: ["indicator"],
        scrollButtons: ["scrollButtons", ot && "scrollButtonsHideMobile"],
        scrollableX: [nt && "scrollableX"],
        hideScrollbar: [tt && "hideScrollbar"]
    }, getTabsUtilityClass, st)
}
  , TabsRoot = styled("div", {
    name: "MuiTabs",
    slot: "Root",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [{
            [`& .${tabsClasses.scrollButtons}`]: $.scrollButtons
        }, {
            [`& .${tabsClasses.scrollButtons}`]: et.scrollButtonsHideMobile && $.scrollButtonsHideMobile
        }, $.root, et.vertical && $.vertical]
    }
})(memoTheme( ({theme: _e}) => ({
    overflow: "hidden",
    minHeight: 48,
    WebkitOverflowScrolling: "touch",
    display: "flex",
    variants: [{
        props: ({ownerState: $}) => $.vertical,
        style: {
            flexDirection: "column"
        }
    }, {
        props: ({ownerState: $}) => $.scrollButtonsHideMobile,
        style: {
            [`& .${tabsClasses.scrollButtons}`]: {
                [_e.breakpoints.down("sm")]: {
                    display: "none"
                }
            }
        }
    }]
})))
  , TabsScroller = styled("div", {
    name: "MuiTabs",
    slot: "Scroller",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.scroller, et.fixed && $.fixed, et.hideScrollbar && $.hideScrollbar, et.scrollableX && $.scrollableX, et.scrollableY && $.scrollableY]
    }
})({
    position: "relative",
    display: "inline-block",
    flex: "1 1 auto",
    whiteSpace: "nowrap",
    variants: [{
        props: ({ownerState: _e}) => _e.fixed,
        style: {
            overflowX: "hidden",
            width: "100%"
        }
    }, {
        props: ({ownerState: _e}) => _e.hideScrollbar,
        style: {
            scrollbarWidth: "none",
            "&::-webkit-scrollbar": {
                display: "none"
            }
        }
    }, {
        props: ({ownerState: _e}) => _e.scrollableX,
        style: {
            overflowX: "auto",
            overflowY: "hidden"
        }
    }, {
        props: ({ownerState: _e}) => _e.scrollableY,
        style: {
            overflowY: "auto",
            overflowX: "hidden"
        }
    }]
})
  , FlexContainer = styled("div", {
    name: "MuiTabs",
    slot: "FlexContainer",
    overridesResolver: (_e, $) => {
        const {ownerState: et} = _e;
        return [$.flexContainer, et.vertical && $.flexContainerVertical, et.centered && $.centered]
    }
})({
    display: "flex",
    variants: [{
        props: ({ownerState: _e}) => _e.vertical,
        style: {
            flexDirection: "column"
        }
    }, {
        props: ({ownerState: _e}) => _e.centered,
        style: {
            justifyContent: "center"
        }
    }]
})
  , TabsIndicator = styled("span", {
    name: "MuiTabs",
    slot: "Indicator",
    overridesResolver: (_e, $) => $.indicator
})(memoTheme( ({theme: _e}) => ({
    position: "absolute",
    height: 2,
    bottom: 0,
    width: "100%",
    transition: _e.transitions.create(),
    variants: [{
        props: {
            indicatorColor: "primary"
        },
        style: {
            backgroundColor: (_e.vars || _e).palette.primary.main
        }
    }, {
        props: {
            indicatorColor: "secondary"
        },
        style: {
            backgroundColor: (_e.vars || _e).palette.secondary.main
        }
    }, {
        props: ({ownerState: $}) => $.vertical,
        style: {
            height: "100%",
            width: 2,
            right: 0
        }
    }]
})))
  , TabsScrollbarSize = styled(ScrollbarSize)({
    overflowX: "auto",
    overflowY: "hidden",
    scrollbarWidth: "none",
    "&::-webkit-scrollbar": {
        display: "none"
    }
})
  , defaultIndicatorStyle = {}
  , Tabs = reactExports.forwardRef(function($, et) {
    const tt = useDefaultProps({
        props: $,
        name: "MuiTabs"
    })
      , nt = useTheme()
      , rt = useRtl()
      , {"aria-label": it, "aria-labelledby": ot, action: st, centered: lt=!1, children: ct, className: dt, component: pt="div", allowScrollButtonsMobile: ht=!1, indicatorColor: mt="primary", onChange: yt, orientation: Et="horizontal", ScrollButtonComponent: _t=TabScrollButton, scrollButtons: wt="auto", selectionFollowsFocus: St, slots: Ct={}, slotProps: Nt={}, TabIndicatorProps: Lt={}, TabScrollButtonProps: kt={}, textColor: Ut="primary", value: Jt, variant: Pt="standard", visibleScrollbar: Xt=!1, ...rn} = tt
      , zt = Pt === "scrollable"
      , xt = Et === "vertical"
      , $t = xt ? "scrollTop" : "scrollLeft"
      , Dt = xt ? "top" : "left"
      , jt = xt ? "bottom" : "right"
      , Ft = xt ? "clientHeight" : "clientWidth"
      , Ht = xt ? "height" : "width"
      , qt = {
        ...tt,
        component: pt,
        allowScrollButtonsMobile: ht,
        indicatorColor: mt,
        orientation: Et,
        vertical: xt,
        scrollButtons: wt,
        textColor: Ut,
        variant: Pt,
        visibleScrollbar: Xt,
        fixed: !zt,
        hideScrollbar: zt && !Xt,
        scrollableX: zt && !xt,
        scrollableY: zt && xt,
        centered: lt && !zt,
        scrollButtonsHideMobile: !ht
    }
      , Wt = useUtilityClasses(qt)
      , Mt = useSlotProps({
        elementType: Ct.StartScrollButtonIcon,
        externalSlotProps: Nt.startScrollButtonIcon,
        ownerState: qt
    })
      , Yt = useSlotProps({
        elementType: Ct.EndScrollButtonIcon,
        externalSlotProps: Nt.endScrollButtonIcon,
        ownerState: qt
    })
      , [un,hn] = reactExports.useState(!1)
      , [_n,kn] = reactExports.useState(defaultIndicatorStyle)
      , [Dn,jn] = reactExports.useState(!1)
      , [Bn,Un] = reactExports.useState(!1)
      , [Hn,cr] = reactExports.useState(!1)
      , [Gn,Mn] = reactExports.useState({
        overflow: "hidden",
        scrollbarWidth: 0
    })
      , rr = new Map
      , Zn = reactExports.useRef(null)
      , pr = reactExports.useRef(null)
      , Ur = () => {
        const vn = Zn.current;
        let Tn;
        if (vn) {
            const lr = vn.getBoundingClientRect();
            Tn = {
                clientWidth: vn.clientWidth,
                scrollLeft: vn.scrollLeft,
                scrollTop: vn.scrollTop,
                scrollWidth: vn.scrollWidth,
                top: lr.top,
                bottom: lr.bottom,
                left: lr.left,
                right: lr.right
            }
        }
        let sr;
        if (vn && Jt !== !1) {
            const lr = pr.current.children;
            if (lr.length > 0) {
                const wn = lr[rr.get(Jt)];
                sr = wn ? wn.getBoundingClientRect() : null
            }
        }
        return {
            tabsMeta: Tn,
            tabMeta: sr
        }
    }
      , xr = useEventCallback$1( () => {
        const {tabsMeta: vn, tabMeta: Tn} = Ur();
        let sr = 0, lr;
        xt ? (lr = "top",
        Tn && vn && (sr = Tn.top - vn.top + vn.scrollTop)) : (lr = rt ? "right" : "left",
        Tn && vn && (sr = (rt ? -1 : 1) * (Tn[lr] - vn[lr] + vn.scrollLeft)));
        const wn = {
            [lr]: sr,
            [Ht]: Tn ? Tn[Ht] : 0
        };
        if (typeof _n[lr] != "number" || typeof _n[Ht] != "number")
            kn(wn);
        else {
            const Pn = Math.abs(_n[lr] - wn[lr])
              , Cn = Math.abs(_n[Ht] - wn[Ht]);
            (Pn >= 1 || Cn >= 1) && kn(wn)
        }
    }
    )
      , wr = (vn, {animation: Tn=!0}={}) => {
        Tn ? animate($t, Zn.current, vn, {
            duration: nt.transitions.duration.standard
        }) : Zn.current[$t] = vn
    }
      , Rn = vn => {
        let Tn = Zn.current[$t];
        xt ? Tn += vn : Tn += vn * (rt ? -1 : 1),
        wr(Tn)
    }
      , Vn = () => {
        const vn = Zn.current[Ft];
        let Tn = 0;
        const sr = Array.from(pr.current.children);
        for (let lr = 0; lr < sr.length; lr += 1) {
            const wn = sr[lr];
            if (Tn + wn[Ft] > vn) {
                lr === 0 && (Tn = vn);
                break
            }
            Tn += wn[Ft]
        }
        return Tn
    }
      , qn = () => {
        Rn(-1 * Vn())
    }
      , dr = () => {
        Rn(Vn())
    }
      , or = reactExports.useCallback(vn => {
        Mn({
            overflow: null,
            scrollbarWidth: vn
        })
    }
    , [])
      , ir = () => {
        const vn = {};
        vn.scrollbarSizeListener = zt ? jsxRuntimeExports.jsx(TabsScrollbarSize, {
            onChange: or,
            className: clsx(Wt.scrollableX, Wt.hideScrollbar)
        }) : null;
        const sr = zt && (wt === "auto" && (Dn || Bn) || wt === !0);
        return vn.scrollButtonStart = sr ? jsxRuntimeExports.jsx(_t, {
            slots: {
                StartScrollButtonIcon: Ct.StartScrollButtonIcon
            },
            slotProps: {
                startScrollButtonIcon: Mt
            },
            orientation: Et,
            direction: rt ? "right" : "left",
            onClick: qn,
            disabled: !Dn,
            ...kt,
            className: clsx(Wt.scrollButtons, kt.className)
        }) : null,
        vn.scrollButtonEnd = sr ? jsxRuntimeExports.jsx(_t, {
            slots: {
                EndScrollButtonIcon: Ct.EndScrollButtonIcon
            },
            slotProps: {
                endScrollButtonIcon: Yt
            },
            orientation: Et,
            direction: rt ? "left" : "right",
            onClick: dr,
            disabled: !Bn,
            ...kt,
            className: clsx(Wt.scrollButtons, kt.className)
        }) : null,
        vn
    }
      , Cr = useEventCallback$1(vn => {
        const {tabsMeta: Tn, tabMeta: sr} = Ur();
        if (!(!sr || !Tn)) {
            if (sr[Dt] < Tn[Dt]) {
                const lr = Tn[$t] + (sr[Dt] - Tn[Dt]);
                wr(lr, {
                    animation: vn
                })
            } else if (sr[jt] > Tn[jt]) {
                const lr = Tn[$t] + (sr[jt] - Tn[jt]);
                wr(lr, {
                    animation: vn
                })
            }
        }
    }
    )
      , br = useEventCallback$1( () => {
        zt && wt !== !1 && cr(!Hn)
    }
    );
    reactExports.useEffect( () => {
        const vn = debounce( () => {
            Zn.current && xr()
        }
        );
        let Tn;
        const sr = Pn => {
            Pn.forEach(Cn => {
                Cn.removedNodes.forEach(zn => {
                    Tn == null || Tn.unobserve(zn)
                }
                ),
                Cn.addedNodes.forEach(zn => {
                    Tn == null || Tn.observe(zn)
                }
                )
            }
            ),
            vn(),
            br()
        }
          , lr = ownerWindow(Zn.current);
        lr.addEventListener("resize", vn);
        let wn;
        return typeof ResizeObserver < "u" && (Tn = new ResizeObserver(vn),
        Array.from(pr.current.children).forEach(Pn => {
            Tn.observe(Pn)
        }
        )),
        typeof MutationObserver < "u" && (wn = new MutationObserver(sr),
        wn.observe(pr.current, {
            childList: !0
        })),
        () => {
            vn.clear(),
            lr.removeEventListener("resize", vn),
            wn == null || wn.disconnect(),
            Tn == null || Tn.disconnect()
        }
    }
    , [xr, br]),
    reactExports.useEffect( () => {
        const vn = Array.from(pr.current.children)
          , Tn = vn.length;
        if (typeof IntersectionObserver < "u" && Tn > 0 && zt && wt !== !1) {
            const sr = vn[0]
              , lr = vn[Tn - 1]
              , wn = {
                root: Zn.current,
                threshold: .99
            }
              , Pn = hr => {
                jn(!hr[0].isIntersecting)
            }
              , Cn = new IntersectionObserver(Pn,wn);
            Cn.observe(sr);
            const zn = hr => {
                Un(!hr[0].isIntersecting)
            }
              , ur = new IntersectionObserver(zn,wn);
            return ur.observe(lr),
            () => {
                Cn.disconnect(),
                ur.disconnect()
            }
        }
    }
    , [zt, wt, Hn, ct == null ? void 0 : ct.length]),
    reactExports.useEffect( () => {
        hn(!0)
    }
    , []),
    reactExports.useEffect( () => {
        xr()
    }
    ),
    reactExports.useEffect( () => {
        Cr(defaultIndicatorStyle !== _n)
    }
    , [Cr, _n]),
    reactExports.useImperativeHandle(st, () => ({
        updateIndicator: xr,
        updateScrollButtons: br
    }), [xr, br]);
    const an = jsxRuntimeExports.jsx(TabsIndicator, {
        ...Lt,
        className: clsx(Wt.indicator, Lt.className),
        ownerState: qt,
        style: {
            ..._n,
            ...Lt.style
        }
    });
    let Kt = 0;
    const Gt = reactExports.Children.map(ct, vn => {
        if (!reactExports.isValidElement(vn))
            return null;
        const Tn = vn.props.value === void 0 ? Kt : vn.props.value;
        rr.set(Tn, Kt);
        const sr = Tn === Jt;
        return Kt += 1,
        reactExports.cloneElement(vn, {
            fullWidth: Pt === "fullWidth",
            indicator: sr && !un && an,
            selected: sr,
            selectionFollowsFocus: St,
            onChange: yt,
            textColor: Ut,
            value: Tn,
            ...Kt === 1 && Jt === !1 && !vn.props.tabIndex ? {
                tabIndex: 0
            } : {}
        })
    }
    )
      , fn = vn => {
        const Tn = pr.current
          , sr = ownerDocument(Tn).activeElement;
        if (sr.getAttribute("role") !== "tab")
            return;
        let wn = Et === "horizontal" ? "ArrowLeft" : "ArrowUp"
          , Pn = Et === "horizontal" ? "ArrowRight" : "ArrowDown";
        switch (Et === "horizontal" && rt && (wn = "ArrowRight",
        Pn = "ArrowLeft"),
        vn.key) {
        case wn:
            vn.preventDefault(),
            moveFocus(Tn, sr, previousItem);
            break;
        case Pn:
            vn.preventDefault(),
            moveFocus(Tn, sr, nextItem);
            break;
        case "Home":
            vn.preventDefault(),
            moveFocus(Tn, null, nextItem);
            break;
        case "End":
            vn.preventDefault(),
            moveFocus(Tn, null, previousItem);
            break
        }
    }
      , En = ir();
    return jsxRuntimeExports.jsxs(TabsRoot, {
        className: clsx(Wt.root, dt),
        ownerState: qt,
        ref: et,
        as: pt,
        ...rn,
        children: [En.scrollButtonStart, En.scrollbarSizeListener, jsxRuntimeExports.jsxs(TabsScroller, {
            className: Wt.scroller,
            ownerState: qt,
            style: {
                overflow: Gn.overflow,
                [xt ? `margin${rt ? "Left" : "Right"}` : "marginBottom"]: Xt ? void 0 : -Gn.scrollbarWidth
            },
            ref: Zn,
            children: [jsxRuntimeExports.jsx(FlexContainer, {
                "aria-label": it,
                "aria-labelledby": ot,
                "aria-orientation": Et === "vertical" ? "vertical" : null,
                className: Wt.flexContainer,
                ownerState: qt,
                onKeyDown: fn,
                ref: pr,
                role: "tablist",
                children: Gt
            }), un && an]
        }), En.scrollButtonEnd]
    })
})
  , Img = styled("img")( ({theme: _e}) => ({
    width: _e.spacing(3),
    height: _e.spacing(3)
}))
  , WalletIcon = ({wallet: _e, ...$}) => _e && React.createElement(Img, {
    src: _e.adapter.icon,
    alt: `${_e.adapter.name} icon`,
    ...$
})
  , BaseWalletConnectionButton = React.forwardRef(function({color: $="primary", type: et="button", walletIcon: tt, walletName: nt, variant: rt="contained", ...it}, ot) {
    return React.createElement(Button, {
        ...it,
        color: $,
        startIcon: tt && nt ? React.createElement(WalletIcon, {
            wallet: {
                adapter: {
                    icon: tt,
                    name: nt
                }
            }
        }) : void 0,
        ref: ot,
        type: et,
        variant: rt
    })
})
  , AddIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M19 13h-6v6h-2v-6H5v-2h6V5h2v6h6z"
}), "Add")
  , ExpandMoreIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "m7 10 5 5 5-5z"
}), "ArrowDropDown")
  , ArrowDropUpIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "m7 14 5-5 5 5z"
}), "ArrowDropUp")
  , CameraAltIcon = createSvgIcon([jsxRuntimeExports.jsx("circle", {
    cx: "12",
    cy: "12",
    r: "3.2"
}, "0"), jsxRuntimeExports.jsx("path", {
    d: "M9 2 7.17 4H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2h-3.17L15 2zm3 15c-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5-2.24 5-5 5"
}, "1")], "CameraAlt")
  , CloseIcon$1 = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close")
  , DoneRoundedIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "m9 16.2-3.5-3.5a.984.984 0 0 0-1.4 0c-.39.39-.39 1.01 0 1.4l4.19 4.19c.39.39 1.02.39 1.41 0L20.3 7.7c.39-.39.39-1.01 0-1.4a.984.984 0 0 0-1.4 0z"
}), "DoneRounded")
  , CollapseIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "m12 8-6 6 1.41 1.41L12 10.83l4.59 4.58L18 14z"
}), "ExpandLess")
  , ExpandMore = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"
}), "ExpandMore")
  , CopyIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm-1 4 6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2zm-1 7h5.5L14 6.5z"
}), "FileCopy")
  , KeyboardArrowDown = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M7.41 8.59 12 13.17l4.59-4.58L18 10l-6 6-6-6z"
}), "KeyboardArrowDown")
  , DisconnectIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M17 7h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.43-.98 2.63-2.31 2.98l1.46 1.46C20.88 15.61 22 13.95 22 12c0-2.76-2.24-5-5-5m-1 4h-2.19l2 2H16zM2 4.27l3.11 3.11C3.29 8.12 2 9.91 2 12c0 2.76 2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1 0-1.59 1.21-2.9 2.76-3.07L8.73 11H8v2h2.73L13 15.27V17h1.73l4.01 4L20 19.74 3.27 3z"
}), "LinkOff")
  , PanoramaIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M23 18V6c0-1.1-.9-2-2-2H3c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h18c1.1 0 2-.9 2-2M8.5 12.5l2.5 3.01L14.5 11l4.5 6H5z"
}), "Panorama")
  , SwitchIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M6.99 11 3 15l3.99 4v-3H14v-2H6.99zM21 9l-3.99-4v3H10v2h7.01v3z"
}), "SwapHoriz")
  , TelegramIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M9.78 18.65l.28-4.23 7.68-6.92c.34-.31-.07-.46-.52-.19L7.74 13.3 3.64 12c-.88-.25-.89-.86.2-1.3l15.97-6.16c.73-.33 1.43.18 1.15 1.3l-2.72 12.81c-.19.91-.74 1.13-1.5.71L12.6 16.3l-1.99 1.93c-.23.23-.42.42-.83.42z"
}), "Telegram")
  , WarningIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M1 21h22L12 2zm12-3h-2v-2h2zm0-4h-2v-4h2z"
}), "Warning")
  , XIcon = createSvgIcon(jsxRuntimeExports.jsx("path", {
    d: "M18.244 2.25h3.308l-7.227 8.26 8.502 11.24H16.17l-5.214-6.817L4.99 21.75H1.68l7.73-8.835L1.254 2.25H8.08l4.713 6.231zm-1.161 17.52h1.833L7.084 4.126H5.117z"
}), "X")
  , StyledMenu = styled(Menu)( ({theme: _e}) => ({
    "& .MuiList-root": {
        padding: 0
    },
    "& .MuiListItemIcon-root": {
        marginRight: _e.spacing(),
        minWidth: "unset",
        "& .MuiSvgIcon-root": {
            width: 20,
            height: 20
        }
    }
}))
  , WalletActionMenuItem = styled(MenuItem)( ({theme: _e}) => ({
    padding: _e.spacing(1, 2),
    boxShadow: "inset 0 1px 0 0 rgba(255, 255, 255, 0.1)",
    "&:hover": {
        boxShadow: "inset 0 1px 0 0 rgba(255, 255, 255, 0.1), 0 1px 0 0 rgba(255, 255, 255, 0.05)"
    }
}))
  , WalletMenuItem = styled(WalletActionMenuItem)( () => ({
    padding: 0,
    "& .MuiButton-root": {
        borderRadius: 0
    }
}));
function BaseWalletMultiButton({children: _e, labels: $, ...et}) {
    const {setOpen: tt} = useWalletDialog()
      , nt = React.createRef()
      , [rt,it] = reactExports.useState(!1)
      , {buttonState: ot, onConnect: st, onDisconnect: lt, publicKey: ct, walletIcon: dt, walletName: pt} = useWalletMultiButton({
        onSelectWallet() {
            tt(!0)
        }
    })
      , ht = reactExports.useMemo( () => {
        if (_e)
            return _e;
        if (ct) {
            const mt = ct.toBase58();
            return mt.slice(0, 4) + ".." + mt.slice(-4)
        } else
            return ot === "connecting" || ot === "has-wallet" ? $[ot] : $["no-wallet"]
    }
    , [ot, _e, $, ct]);
    return React.createElement(React.Fragment, null, React.createElement(BaseWalletConnectionButton, {
        ...et,
        "aria-controls": "wallet-menu",
        "aria-haspopup": "true",
        onClick: () => {
            switch (ot) {
            case "no-wallet":
                tt(!0);
                break;
            case "has-wallet":
                st && st();
                break;
            case "connected":
                it(!0);
                break
            }
        }
        ,
        ref: nt,
        walletIcon: dt,
        walletName: pt
    }, ht), React.createElement(StyledMenu, {
        id: "wallet-menu",
        anchorEl: () => nt.current,
        open: rt,
        onClose: () => it(!1),
        marginThreshold: 0,
        TransitionComponent: Fade,
        transitionDuration: 250,
        keepMounted: !0,
        anchorOrigin: {
            vertical: "top",
            horizontal: "left"
        }
    }, React.createElement(WalletMenuItem, {
        onClick: () => it(!1)
    }, React.createElement(BaseWalletConnectionButton, {
        ...et,
        fullWidth: !0,
        onClick: () => it(!1),
        walletIcon: dt,
        walletName: pt
    }, pt)), React.createElement(Collapse, {
        in: rt
    }, ct ? React.createElement(WalletActionMenuItem, {
        onClick: async () => {
            it(!1),
            await navigator.clipboard.writeText(ct.toBase58())
        }
    }, React.createElement(ListItemIcon, null, React.createElement(CopyIcon, null)), $["copy-address"]) : null, React.createElement(WalletActionMenuItem, {
        onClick: () => {
            it(!1),
            tt(!0)
        }
    }, React.createElement(ListItemIcon, null, React.createElement(SwitchIcon, null)), $["change-wallet"]), lt ? React.createElement(WalletActionMenuItem, {
        onClick: () => {
            it(!1),
            lt()
        }
    }, React.createElement(ListItemIcon, null, React.createElement(DisconnectIcon, null)), $.disconnect) : null)))
}
const WalletListItem = ({onClick: _e, wallet: $, ...et}) => React.createElement(ListItem, {
    ...et
}, React.createElement(Button, {
    onClick: _e,
    endIcon: React.createElement(WalletIcon, {
        wallet: $
    })
}, $.adapter.name))
  , RootDialog = styled(Dialog$1)( ({theme: _e}) => ({
    "& .MuiDialog-paper": {
        width: _e.spacing(40),
        margin: 0
    },
    "& .MuiDialogTitle-root": {
        backgroundColor: _e.palette.primary.main,
        display: "flex",
        justifyContent: "space-between",
        lineHeight: _e.spacing(5),
        "& .MuiIconButton-root": {
            flexShrink: 1,
            padding: _e.spacing(),
            marginRight: _e.spacing(-1),
            color: _e.palette.grey[500]
        }
    },
    "& .MuiDialogContent-root": {
        padding: 0,
        "& .MuiCollapse-root": {
            "& .MuiList-root": {
                background: _e.palette.grey[900]
            }
        },
        "& .MuiList-root": {
            background: _e.palette.grey[900],
            padding: 0
        },
        "& .MuiListItem-root": {
            boxShadow: "inset 0 1px 0 0 rgba(255, 255, 255, 0.1)",
            "&:hover": {
                boxShadow: "inset 0 1px 0 0 rgba(255, 255, 255, 0.1), 0 1px 0 0 rgba(255, 255, 255, 0.05)"
            },
            padding: 0,
            "& .MuiButton-endIcon": {
                margin: 0
            },
            "& .MuiButton-root": {
                color: _e.palette.text.primary,
                flexGrow: 1,
                justifyContent: "space-between",
                padding: _e.spacing(1, 3),
                borderRadius: void 0,
                fontSize: "1rem",
                fontWeight: 400
            },
            "& .MuiSvgIcon-root": {
                color: _e.palette.grey[500]
            }
        }
    }
}))
  , WalletDialog = ({title: _e="Select your wallet", featuredWallets: $=3, onClose: et, ...tt}) => {
    const {wallets: nt, select: rt} = useWallet()
      , {open: it, setOpen: ot} = useWalletDialog()
      , [st,lt] = reactExports.useState(!1)
      , [ct,dt] = reactExports.useMemo( () => {
        const yt = []
          , Et = [];
        for (const wt of nt)
            wt.readyState === WalletReadyState.Installed ? yt.push(wt) : Et.push(wt);
        const _t = [...yt, ...Et];
        return [_t.slice(0, $), _t.slice($)]
    }
    , [nt, $])
      , pt = reactExports.useCallback( (yt, Et) => {
        et && et(yt, Et),
        yt.defaultPrevented || ot(!1)
    }
    , [ot, et])
      , ht = reactExports.useCallback( (yt, Et) => {
        rt(Et),
        pt(yt)
    }
    , [rt, pt])
      , mt = reactExports.useCallback( () => lt(!st), [lt, st]);
    return React.createElement(RootDialog, {
        open: it,
        onClose: pt,
        ...tt
    }, React.createElement(DialogTitle, null, _e, React.createElement(IconButton, {
        onClick: pt,
        size: "large"
    }, React.createElement(CloseIcon$1, null))), React.createElement(DialogContent, null, React.createElement(List, null, ct.map(yt => React.createElement(WalletListItem, {
        key: yt.adapter.name,
        onClick: Et => ht(Et, yt.adapter.name),
        wallet: yt
    })), dt.length ? React.createElement(React.Fragment, null, React.createElement(Collapse, {
        in: st,
        timeout: "auto",
        unmountOnExit: !0
    }, React.createElement(List, null, dt.map(yt => React.createElement(WalletListItem, {
        key: yt.adapter.name,
        onClick: Et => ht(Et, yt.adapter.name),
        wallet: yt
    })))), React.createElement(ListItem, null, React.createElement(Button, {
        onClick: mt
    }, st ? "Less" : "More", " options", st ? React.createElement(CollapseIcon, null) : React.createElement(ExpandMore, null)))) : null)))
}
  , WalletDialogProvider = ({children: _e, ...$}) => {
    const [et,tt] = reactExports.useState(!1);
    return React.createElement(WalletDialogContext.Provider, {
        value: {
            open: et,
            setOpen: tt
        }
    }, _e, React.createElement(WalletDialog, {
        ...$
    }))
}
  , createStoreImpl = _e => {
    let $;
    const et = new Set
      , tt = (lt, ct) => {
        const dt = typeof lt == "function" ? lt($) : lt;
        if (!Object.is(dt, $)) {
            const pt = $;
            $ = ct ?? (typeof dt != "object" || dt === null) ? dt : Object.assign({}, $, dt),
            et.forEach(ht => ht($, pt))
        }
    }
      , nt = () => $
      , ot = {
        setState: tt,
        getState: nt,
        getInitialState: () => st,
        subscribe: lt => (et.add(lt),
        () => et.delete(lt))
    }
      , st = $ = _e(tt, nt, ot);
    return ot
}
  , createStore = _e => _e ? createStoreImpl(_e) : createStoreImpl
  , identity$2 = _e => _e;
function useStore$2(_e, $=identity$2) {
    const et = React.useSyncExternalStore(_e.subscribe, () => $(_e.getState()), () => $(_e.getInitialState()));
    return React.useDebugValue(et),
    et
}
const createImpl = _e => {
    const $ = createStore(_e)
      , et = tt => useStore$2($, tt);
    return Object.assign(et, $),
    et
}
  , create$1 = _e => _e ? createImpl(_e) : createImpl;
function createJSONStorage(_e, $) {
    let et;
    try {
        et = _e()
    } catch {
        return
    }
    return {
        getItem: nt => {
            var rt;
            const it = st => st === null ? null : JSON.parse(st, void 0)
              , ot = (rt = et.getItem(nt)) != null ? rt : null;
            return ot instanceof Promise ? ot.then(it) : it(ot)
        }
        ,
        setItem: (nt, rt) => et.setItem(nt, JSON.stringify(rt, void 0)),
        removeItem: nt => et.removeItem(nt)
    }
}
const toThenable = _e => $ => {
    try {
        const et = _e($);
        return et instanceof Promise ? et : {
            then(tt) {
                return toThenable(tt)(et)
            },
            catch(tt) {
                return this
            }
        }
    } catch (et) {
        return {
            then(tt) {
                return this
            },
            catch(tt) {
                return toThenable(tt)(et)
            }
        }
    }
}
  , persistImpl = (_e, $) => (et, tt, nt) => {
    let rt = {
        storage: createJSONStorage( () => localStorage),
        partialize: yt => yt,
        version: 0,
        merge: (yt, Et) => ({
            ...Et,
            ...yt
        }),
        ...$
    }
      , it = !1;
    const ot = new Set
      , st = new Set;
    let lt = rt.storage;
    if (!lt)
        return _e( (...yt) => {
            et(...yt)
        }
        , tt, nt);
    const ct = () => {
        const yt = rt.partialize({
            ...tt()
        });
        return lt.setItem(rt.name, {
            state: yt,
            version: rt.version
        })
    }
      , dt = nt.setState;
    nt.setState = (yt, Et) => {
        dt(yt, Et),
        ct()
    }
    ;
    const pt = _e( (...yt) => {
        et(...yt),
        ct()
    }
    , tt, nt);
    nt.getInitialState = () => pt;
    let ht;
    const mt = () => {
        var yt, Et;
        if (!lt)
            return;
        it = !1,
        ot.forEach(wt => {
            var St;
            return wt((St = tt()) != null ? St : pt)
        }
        );
        const _t = ((Et = rt.onRehydrateStorage) == null ? void 0 : Et.call(rt, (yt = tt()) != null ? yt : pt)) || void 0;
        return toThenable(lt.getItem.bind(lt))(rt.name).then(wt => {
            if (wt)
                if (typeof wt.version == "number" && wt.version !== rt.version) {
                    if (rt.migrate) {
                        const St = rt.migrate(wt.state, wt.version);
                        return St instanceof Promise ? St.then(Ct => [!0, Ct]) : [!0, St]
                    }
                } else
                    return [!1, wt.state];
            return [!1, void 0]
        }
        ).then(wt => {
            var St;
            const [Ct,Nt] = wt;
            if (ht = rt.merge(Nt, (St = tt()) != null ? St : pt),
            et(ht, !0),
            Ct)
                return ct()
        }
        ).then( () => {
            _t == null || _t(ht, void 0),
            ht = tt(),
            it = !0,
            st.forEach(wt => wt(ht))
        }
        ).catch(wt => {
            _t == null || _t(void 0, wt)
        }
        )
    }
    ;
    return nt.persist = {
        setOptions: yt => {
            rt = {
                ...rt,
                ...yt
            },
            yt.storage && (lt = yt.storage)
        }
        ,
        clearStorage: () => {
            lt == null || lt.removeItem(rt.name)
        }
        ,
        getOptions: () => rt,
        rehydrate: () => mt(),
        hasHydrated: () => it,
        onHydrate: yt => (ot.add(yt),
        () => {
            ot.delete(yt)
        }
        ),
        onFinishHydration: yt => (st.add(yt),
        () => {
            st.delete(yt)
        }
        )
    },
    rt.skipHydration || mt(),
    ht || pt
}
  , persist = persistImpl;
function arrayMap$3(_e, $) {
    for (var et = -1, tt = _e == null ? 0 : _e.length, nt = Array(tt); ++et < tt; )
        nt[et] = $(_e[et], et, _e);
    return nt
}
var _arrayMap = arrayMap$3;
function listCacheClear$2() {
    this.__data__ = [],
    this.size = 0
}
var _listCacheClear = listCacheClear$2;
function eq$3(_e, $) {
    return _e === $ || _e !== _e && $ !== $
}
var eq_1 = eq$3
  , eq$2 = eq_1;
function assocIndexOf$5(_e, $) {
    for (var et = _e.length; et--; )
        if (eq$2(_e[et][0], $))
            return et;
    return -1
}
var _assocIndexOf = assocIndexOf$5
  , assocIndexOf$4 = _assocIndexOf
  , arrayProto$1 = Array.prototype
  , splice$1 = arrayProto$1.splice;
function listCacheDelete$2(_e) {
    var $ = this.__data__
      , et = assocIndexOf$4($, _e);
    if (et < 0)
        return !1;
    var tt = $.length - 1;
    return et == tt ? $.pop() : splice$1.call($, et, 1),
    --this.size,
    !0
}
var _listCacheDelete = listCacheDelete$2
  , assocIndexOf$3 = _assocIndexOf;
function listCacheGet$2(_e) {
    var $ = this.__data__
      , et = assocIndexOf$3($, _e);
    return et < 0 ? void 0 : $[et][1]
}
var _listCacheGet = listCacheGet$2
  , assocIndexOf$2 = _assocIndexOf;
function listCacheHas$2(_e) {
    return assocIndexOf$2(this.__data__, _e) > -1
}
var _listCacheHas = listCacheHas$2
  , assocIndexOf$1 = _assocIndexOf;
function listCacheSet$2(_e, $) {
    var et = this.__data__
      , tt = assocIndexOf$1(et, _e);
    return tt < 0 ? (++this.size,
    et.push([_e, $])) : et[tt][1] = $,
    this
}
var _listCacheSet = listCacheSet$2
  , listCacheClear$1 = _listCacheClear
  , listCacheDelete$1 = _listCacheDelete
  , listCacheGet$1 = _listCacheGet
  , listCacheHas$1 = _listCacheHas
  , listCacheSet$1 = _listCacheSet;
function ListCache$5(_e) {
    var $ = -1
      , et = _e == null ? 0 : _e.length;
    for (this.clear(); ++$ < et; ) {
        var tt = _e[$];
        this.set(tt[0], tt[1])
    }
}
ListCache$5.prototype.clear = listCacheClear$1;
ListCache$5.prototype.delete = listCacheDelete$1;
ListCache$5.prototype.get = listCacheGet$1;
ListCache$5.prototype.has = listCacheHas$1;
ListCache$5.prototype.set = listCacheSet$1;
var _ListCache = ListCache$5
  , ListCache$4 = _ListCache;
function stackClear$2() {
    this.__data__ = new ListCache$4,
    this.size = 0
}
var _stackClear = stackClear$2;
function stackDelete$2(_e) {
    var $ = this.__data__
      , et = $.delete(_e);
    return this.size = $.size,
    et
}
var _stackDelete = stackDelete$2;
function stackGet$2(_e) {
    return this.__data__.get(_e)
}
var _stackGet = stackGet$2;
function stackHas$2(_e) {
    return this.__data__.has(_e)
}
var _stackHas = stackHas$2
  , freeGlobal$2 = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis
  , _freeGlobal = freeGlobal$2
  , freeGlobal$1 = _freeGlobal
  , freeSelf$1 = typeof self == "object" && self && self.Object === Object && self
  , root$9 = freeGlobal$1 || freeSelf$1 || Function("return this")()
  , _root = root$9
  , root$8 = _root
  , Symbol$7 = root$8.Symbol
  , _Symbol = Symbol$7
  , Symbol$6 = _Symbol
  , objectProto$p = Object.prototype
  , hasOwnProperty$l = objectProto$p.hasOwnProperty
  , nativeObjectToString$3 = objectProto$p.toString
  , symToStringTag$3 = Symbol$6 ? Symbol$6.toStringTag : void 0;
function getRawTag$2(_e) {
    var $ = hasOwnProperty$l.call(_e, symToStringTag$3)
      , et = _e[symToStringTag$3];
    try {
        _e[symToStringTag$3] = void 0;
        var tt = !0
    } catch {}
    var nt = nativeObjectToString$3.call(_e);
    return tt && ($ ? _e[symToStringTag$3] = et : delete _e[symToStringTag$3]),
    nt
}
var _getRawTag = getRawTag$2
  , objectProto$o = Object.prototype
  , nativeObjectToString$2 = objectProto$o.toString;
function objectToString$3(_e) {
    return nativeObjectToString$2.call(_e)
}
var _objectToString = objectToString$3
  , Symbol$5 = _Symbol
  , getRawTag$1 = _getRawTag
  , objectToString$2 = _objectToString
  , nullTag$1 = "[object Null]"
  , undefinedTag$1 = "[object Undefined]"
  , symToStringTag$2 = Symbol$5 ? Symbol$5.toStringTag : void 0;
function baseGetTag$6(_e) {
    return _e == null ? _e === void 0 ? undefinedTag$1 : nullTag$1 : symToStringTag$2 && symToStringTag$2 in Object(_e) ? getRawTag$1(_e) : objectToString$2(_e)
}
var _baseGetTag = baseGetTag$6;
function isObject$i(_e) {
    var $ = typeof _e;
    return _e != null && ($ == "object" || $ == "function")
}
var isObject_1 = isObject$i;
const isObject$j = getDefaultExportFromCjs$2(isObject_1);
var baseGetTag$5 = _baseGetTag
  , isObject$h = isObject_1
  , asyncTag$1 = "[object AsyncFunction]"
  , funcTag$4 = "[object Function]"
  , genTag$2 = "[object GeneratorFunction]"
  , proxyTag$1 = "[object Proxy]";
function isFunction$5(_e) {
    if (!isObject$h(_e))
        return !1;
    var $ = baseGetTag$5(_e);
    return $ == funcTag$4 || $ == genTag$2 || $ == asyncTag$1 || $ == proxyTag$1
}
var isFunction_1 = isFunction$5;
const isFunction$6 = getDefaultExportFromCjs$2(isFunction_1);
var root$7 = _root
  , coreJsData$2 = root$7["__core-js_shared__"]
  , _coreJsData = coreJsData$2
  , coreJsData$1 = _coreJsData
  , maskSrcKey$1 = function() {
    var _e = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || "");
    return _e ? "Symbol(src)_1." + _e : ""
}();
function isMasked$2(_e) {
    return !!maskSrcKey$1 && maskSrcKey$1 in _e
}
var _isMasked = isMasked$2
  , funcProto$4 = Function.prototype
  , funcToString$4 = funcProto$4.toString;
function toSource$3(_e) {
    if (_e != null) {
        try {
            return funcToString$4.call(_e)
        } catch {}
        try {
            return _e + ""
        } catch {}
    }
    return ""
}
var _toSource = toSource$3
  , isFunction$4 = isFunction_1
  , isMasked$1 = _isMasked
  , isObject$g = isObject_1
  , toSource$2 = _toSource
  , reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g
  , reIsHostCtor$1 = /^\[object .+?Constructor\]$/
  , funcProto$3 = Function.prototype
  , objectProto$n = Object.prototype
  , funcToString$3 = funcProto$3.toString
  , hasOwnProperty$k = objectProto$n.hasOwnProperty
  , reIsNative$1 = RegExp("^" + funcToString$3.call(hasOwnProperty$k).replace(reRegExpChar$1, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative$2(_e) {
    if (!isObject$g(_e) || isMasked$1(_e))
        return !1;
    var $ = isFunction$4(_e) ? reIsNative$1 : reIsHostCtor$1;
    return $.test(toSource$2(_e))
}
var _baseIsNative = baseIsNative$2;
function getValue$3(_e, $) {
    return _e == null ? void 0 : _e[$]
}
var _getValue = getValue$3
  , baseIsNative$1 = _baseIsNative
  , getValue$2 = _getValue;
function getNative$7(_e, $) {
    var et = getValue$2(_e, $);
    return baseIsNative$1(et) ? et : void 0
}
var _getNative = getNative$7
  , getNative$6 = _getNative
  , root$6 = _root
  , Map$5 = getNative$6(root$6, "Map")
  , _Map = Map$5
  , getNative$5 = _getNative
  , nativeCreate$5 = getNative$5(Object, "create")
  , _nativeCreate = nativeCreate$5
  , nativeCreate$4 = _nativeCreate;
function hashClear$2() {
    this.__data__ = nativeCreate$4 ? nativeCreate$4(null) : {},
    this.size = 0
}
var _hashClear = hashClear$2;
function hashDelete$2(_e) {
    var $ = this.has(_e) && delete this.__data__[_e];
    return this.size -= $ ? 1 : 0,
    $
}
var _hashDelete = hashDelete$2
  , nativeCreate$3 = _nativeCreate
  , HASH_UNDEFINED$4 = "__lodash_hash_undefined__"
  , objectProto$m = Object.prototype
  , hasOwnProperty$j = objectProto$m.hasOwnProperty;
function hashGet$2(_e) {
    var $ = this.__data__;
    if (nativeCreate$3) {
        var et = $[_e];
        return et === HASH_UNDEFINED$4 ? void 0 : et
    }
    return hasOwnProperty$j.call($, _e) ? $[_e] : void 0
}
var _hashGet = hashGet$2
  , nativeCreate$2 = _nativeCreate
  , objectProto$l = Object.prototype
  , hasOwnProperty$i = objectProto$l.hasOwnProperty;
function hashHas$2(_e) {
    var $ = this.__data__;
    return nativeCreate$2 ? $[_e] !== void 0 : hasOwnProperty$i.call($, _e)
}
var _hashHas = hashHas$2
  , nativeCreate$1 = _nativeCreate
  , HASH_UNDEFINED$3 = "__lodash_hash_undefined__";
function hashSet$2(_e, $) {
    var et = this.__data__;
    return this.size += this.has(_e) ? 0 : 1,
    et[_e] = nativeCreate$1 && $ === void 0 ? HASH_UNDEFINED$3 : $,
    this
}
var _hashSet = hashSet$2
  , hashClear$1 = _hashClear
  , hashDelete$1 = _hashDelete
  , hashGet$1 = _hashGet
  , hashHas$1 = _hashHas
  , hashSet$1 = _hashSet;
function Hash$2(_e) {
    var $ = -1
      , et = _e == null ? 0 : _e.length;
    for (this.clear(); ++$ < et; ) {
        var tt = _e[$];
        this.set(tt[0], tt[1])
    }
}
Hash$2.prototype.clear = hashClear$1;
Hash$2.prototype.delete = hashDelete$1;
Hash$2.prototype.get = hashGet$1;
Hash$2.prototype.has = hashHas$1;
Hash$2.prototype.set = hashSet$1;
var _Hash = Hash$2
  , Hash$1 = _Hash
  , ListCache$3 = _ListCache
  , Map$4 = _Map;
function mapCacheClear$2() {
    this.size = 0,
    this.__data__ = {
        hash: new Hash$1,
        map: new (Map$4 || ListCache$3),
        string: new Hash$1
    }
}
var _mapCacheClear = mapCacheClear$2;
function isKeyable$2(_e) {
    var $ = typeof _e;
    return $ == "string" || $ == "number" || $ == "symbol" || $ == "boolean" ? _e !== "__proto__" : _e === null
}
var _isKeyable = isKeyable$2
  , isKeyable$1 = _isKeyable;
function getMapData$5(_e, $) {
    var et = _e.__data__;
    return isKeyable$1($) ? et[typeof $ == "string" ? "string" : "hash"] : et.map
}
var _getMapData = getMapData$5
  , getMapData$4 = _getMapData;
function mapCacheDelete$2(_e) {
    var $ = getMapData$4(this, _e).delete(_e);
    return this.size -= $ ? 1 : 0,
    $
}
var _mapCacheDelete = mapCacheDelete$2
  , getMapData$3 = _getMapData;
function mapCacheGet$2(_e) {
    return getMapData$3(this, _e).get(_e)
}
var _mapCacheGet = mapCacheGet$2
  , getMapData$2 = _getMapData;
function mapCacheHas$2(_e) {
    return getMapData$2(this, _e).has(_e)
}
var _mapCacheHas = mapCacheHas$2
  , getMapData$1 = _getMapData;
function mapCacheSet$2(_e, $) {
    var et = getMapData$1(this, _e)
      , tt = et.size;
    return et.set(_e, $),
    this.size += et.size == tt ? 0 : 1,
    this
}
var _mapCacheSet = mapCacheSet$2
  , mapCacheClear$1 = _mapCacheClear
  , mapCacheDelete$1 = _mapCacheDelete
  , mapCacheGet$1 = _mapCacheGet
  , mapCacheHas$1 = _mapCacheHas
  , mapCacheSet$1 = _mapCacheSet;
function MapCache$4(_e) {
    var $ = -1
      , et = _e == null ? 0 : _e.length;
    for (this.clear(); ++$ < et; ) {
        var tt = _e[$];
        this.set(tt[0], tt[1])
    }
}
MapCache$4.prototype.clear = mapCacheClear$1;
MapCache$4.prototype.delete = mapCacheDelete$1;
MapCache$4.prototype.get = mapCacheGet$1;
MapCache$4.prototype.has = mapCacheHas$1;
MapCache$4.prototype.set = mapCacheSet$1;
var _MapCache = MapCache$4
  , ListCache$2 = _ListCache
  , Map$3 = _Map
  , MapCache$3 = _MapCache
  , LARGE_ARRAY_SIZE$1 = 200;
function stackSet$2(_e, $) {
    var et = this.__data__;
    if (et instanceof ListCache$2) {
        var tt = et.__data__;
        if (!Map$3 || tt.length < LARGE_ARRAY_SIZE$1 - 1)
            return tt.push([_e, $]),
            this.size = ++et.size,
            this;
        et = this.__data__ = new MapCache$3(tt)
    }
    return et.set(_e, $),
    this.size = et.size,
    this
}
var _stackSet = stackSet$2
  , ListCache$1 = _ListCache
  , stackClear$1 = _stackClear
  , stackDelete$1 = _stackDelete
  , stackGet$1 = _stackGet
  , stackHas$1 = _stackHas
  , stackSet$1 = _stackSet;
function Stack$4(_e) {
    var $ = this.__data__ = new ListCache$1(_e);
    this.size = $.size
}
Stack$4.prototype.clear = stackClear$1;
Stack$4.prototype.delete = stackDelete$1;
Stack$4.prototype.get = stackGet$1;
Stack$4.prototype.has = stackHas$1;
Stack$4.prototype.set = stackSet$1;
var _Stack = Stack$4
  , HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
function setCacheAdd$1(_e) {
    return this.__data__.set(_e, HASH_UNDEFINED$2),
    this
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(_e) {
    return this.__data__.has(_e)
}
var _setCacheHas = setCacheHas$1
  , MapCache$2 = _MapCache
  , setCacheAdd = _setCacheAdd
  , setCacheHas = _setCacheHas;
function SetCache$1(_e) {
    var $ = -1
      , et = _e == null ? 0 : _e.length;
    for (this.__data__ = new MapCache$2; ++$ < et; )
        this.add(_e[$])
}
SetCache$1.prototype.add = SetCache$1.prototype.push = setCacheAdd;
SetCache$1.prototype.has = setCacheHas;
var _SetCache = SetCache$1;
function arraySome$1(_e, $) {
    for (var et = -1, tt = _e == null ? 0 : _e.length; ++et < tt; )
        if ($(_e[et], et, _e))
            return !0;
    return !1
}
var _arraySome = arraySome$1;
function cacheHas$1(_e, $) {
    return _e.has($)
}
var _cacheHas = cacheHas$1
  , SetCache = _SetCache
  , arraySome = _arraySome
  , cacheHas = _cacheHas
  , COMPARE_PARTIAL_FLAG$5 = 1
  , COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(_e, $, et, tt, nt, rt) {
    var it = et & COMPARE_PARTIAL_FLAG$5
      , ot = _e.length
      , st = $.length;
    if (ot != st && !(it && st > ot))
        return !1;
    var lt = rt.get(_e)
      , ct = rt.get($);
    if (lt && ct)
        return lt == $ && ct == _e;
    var dt = -1
      , pt = !0
      , ht = et & COMPARE_UNORDERED_FLAG$3 ? new SetCache : void 0;
    for (rt.set(_e, $),
    rt.set($, _e); ++dt < ot; ) {
        var mt = _e[dt]
          , yt = $[dt];
        if (tt)
            var Et = it ? tt(yt, mt, dt, $, _e, rt) : tt(mt, yt, dt, _e, $, rt);
        if (Et !== void 0) {
            if (Et)
                continue;
            pt = !1;
            break
        }
        if (ht) {
            if (!arraySome($, function(_t, wt) {
                if (!cacheHas(ht, wt) && (mt === _t || nt(mt, _t, et, tt, rt)))
                    return ht.push(wt)
            })) {
                pt = !1;
                break
            }
        } else if (!(mt === yt || nt(mt, yt, et, tt, rt))) {
            pt = !1;
            break
        }
    }
    return rt.delete(_e),
    rt.delete($),
    pt
}
var _equalArrays = equalArrays$2
  , root$5 = _root
  , Uint8Array$3 = root$5.Uint8Array
  , _Uint8Array = Uint8Array$3;
function mapToArray$1(_e) {
    var $ = -1
      , et = Array(_e.size);
    return _e.forEach(function(tt, nt) {
        et[++$] = [nt, tt]
    }),
    et
}
var _mapToArray = mapToArray$1;
function setToArray$1(_e) {
    var $ = -1
      , et = Array(_e.size);
    return _e.forEach(function(tt) {
        et[++$] = tt
    }),
    et
}
var _setToArray = setToArray$1
  , Symbol$4 = _Symbol
  , Uint8Array$2 = _Uint8Array
  , eq$1 = eq_1
  , equalArrays$1 = _equalArrays
  , mapToArray = _mapToArray
  , setToArray = _setToArray
  , COMPARE_PARTIAL_FLAG$4 = 1
  , COMPARE_UNORDERED_FLAG$2 = 2
  , boolTag$4 = "[object Boolean]"
  , dateTag$4 = "[object Date]"
  , errorTag$3 = "[object Error]"
  , mapTag$7 = "[object Map]"
  , numberTag$4 = "[object Number]"
  , regexpTag$4 = "[object RegExp]"
  , setTag$7 = "[object Set]"
  , stringTag$4 = "[object String]"
  , symbolTag$4 = "[object Symbol]"
  , arrayBufferTag$4 = "[object ArrayBuffer]"
  , dataViewTag$6 = "[object DataView]"
  , symbolProto$3 = Symbol$4 ? Symbol$4.prototype : void 0
  , symbolValueOf$1 = symbolProto$3 ? symbolProto$3.valueOf : void 0;
function equalByTag$1(_e, $, et, tt, nt, rt, it) {
    switch (et) {
    case dataViewTag$6:
        if (_e.byteLength != $.byteLength || _e.byteOffset != $.byteOffset)
            return !1;
        _e = _e.buffer,
        $ = $.buffer;
    case arrayBufferTag$4:
        return !(_e.byteLength != $.byteLength || !rt(new Uint8Array$2(_e), new Uint8Array$2($)));
    case boolTag$4:
    case dateTag$4:
    case numberTag$4:
        return eq$1(+_e, +$);
    case errorTag$3:
        return _e.name == $.name && _e.message == $.message;
    case regexpTag$4:
    case stringTag$4:
        return _e == $ + "";
    case mapTag$7:
        var ot = mapToArray;
    case setTag$7:
        var st = tt & COMPARE_PARTIAL_FLAG$4;
        if (ot || (ot = setToArray),
        _e.size != $.size && !st)
            return !1;
        var lt = it.get(_e);
        if (lt)
            return lt == $;
        tt |= COMPARE_UNORDERED_FLAG$2,
        it.set(_e, $);
        var ct = equalArrays$1(ot(_e), ot($), tt, nt, rt, it);
        return it.delete(_e),
        ct;
    case symbolTag$4:
        if (symbolValueOf$1)
            return symbolValueOf$1.call(_e) == symbolValueOf$1.call($)
    }
    return !1
}
var _equalByTag = equalByTag$1;
function arrayPush$2(_e, $) {
    for (var et = -1, tt = $.length, nt = _e.length; ++et < tt; )
        _e[nt + et] = $[et];
    return _e
}
var _arrayPush = arrayPush$2
  , isArray$e = Array.isArray
  , isArray_1 = isArray$e
  , arrayPush$1 = _arrayPush
  , isArray$d = isArray_1;
function baseGetAllKeys$2(_e, $, et) {
    var tt = $(_e);
    return isArray$d(_e) ? tt : arrayPush$1(tt, et(_e))
}
var _baseGetAllKeys = baseGetAllKeys$2;
function arrayFilter$2(_e, $) {
    for (var et = -1, tt = _e == null ? 0 : _e.length, nt = 0, rt = []; ++et < tt; ) {
        var it = _e[et];
        $(it, et, _e) && (rt[nt++] = it)
    }
    return rt
}
var _arrayFilter = arrayFilter$2;
function stubArray$2() {
    return []
}
var stubArray_1 = stubArray$2
  , arrayFilter$1 = _arrayFilter
  , stubArray$1 = stubArray_1
  , objectProto$k = Object.prototype
  , propertyIsEnumerable$3 = objectProto$k.propertyIsEnumerable
  , nativeGetSymbols$2 = Object.getOwnPropertySymbols
  , getSymbols$2 = nativeGetSymbols$2 ? function(_e) {
    return _e == null ? [] : (_e = Object(_e),
    arrayFilter$1(nativeGetSymbols$2(_e), function($) {
        return propertyIsEnumerable$3.call(_e, $)
    }))
}
: stubArray$1
  , _getSymbols = getSymbols$2;
function baseTimes$2(_e, $) {
    for (var et = -1, tt = Array(_e); ++et < _e; )
        tt[et] = $(et);
    return tt
}
var _baseTimes = baseTimes$2;
function isObjectLike$6(_e) {
    return _e != null && typeof _e == "object"
}
var isObjectLike_1 = isObjectLike$6
  , baseGetTag$4 = _baseGetTag
  , isObjectLike$5 = isObjectLike_1
  , argsTag$5 = "[object Arguments]";
function baseIsArguments$2(_e) {
    return isObjectLike$5(_e) && baseGetTag$4(_e) == argsTag$5
}
var _baseIsArguments = baseIsArguments$2
  , baseIsArguments$1 = _baseIsArguments
  , isObjectLike$4 = isObjectLike_1
  , objectProto$j = Object.prototype
  , hasOwnProperty$h = objectProto$j.hasOwnProperty
  , propertyIsEnumerable$2 = objectProto$j.propertyIsEnumerable
  , isArguments$3 = baseIsArguments$1(function() {
    return arguments
}()) ? baseIsArguments$1 : function(_e) {
    return isObjectLike$4(_e) && hasOwnProperty$h.call(_e, "callee") && !propertyIsEnumerable$2.call(_e, "callee")
}
  , isArguments_1 = isArguments$3
  , isBuffer$4 = {
    exports: {}
};
function stubFalse$1() {
    return !1
}
var stubFalse_1 = stubFalse$1;
isBuffer$4.exports;
(function(_e, $) {
    var et = _root
      , tt = stubFalse_1
      , nt = $ && !$.nodeType && $
      , rt = nt && !0 && _e && !_e.nodeType && _e
      , it = rt && rt.exports === nt
      , ot = it ? et.Buffer : void 0
      , st = ot ? ot.isBuffer : void 0
      , lt = st || tt;
    _e.exports = lt
}
)(isBuffer$4, isBuffer$4.exports);
var isBufferExports = isBuffer$4.exports
  , MAX_SAFE_INTEGER$4 = 9007199254740991
  , reIsUint$1 = /^(?:0|[1-9]\d*)$/;
function isIndex$3(_e, $) {
    var et = typeof _e;
    return $ = $ ?? MAX_SAFE_INTEGER$4,
    !!$ && (et == "number" || et != "symbol" && reIsUint$1.test(_e)) && _e > -1 && _e % 1 == 0 && _e < $
}
var _isIndex = isIndex$3
  , MAX_SAFE_INTEGER$3 = 9007199254740991;
function isLength$4(_e) {
    return typeof _e == "number" && _e > -1 && _e % 1 == 0 && _e <= MAX_SAFE_INTEGER$3
}
var isLength_1 = isLength$4
  , baseGetTag$3 = _baseGetTag
  , isLength$3 = isLength_1
  , isObjectLike$3 = isObjectLike_1
  , argsTag$4 = "[object Arguments]"
  , arrayTag$3 = "[object Array]"
  , boolTag$3 = "[object Boolean]"
  , dateTag$3 = "[object Date]"
  , errorTag$2 = "[object Error]"
  , funcTag$3 = "[object Function]"
  , mapTag$6 = "[object Map]"
  , numberTag$3 = "[object Number]"
  , objectTag$6 = "[object Object]"
  , regexpTag$3 = "[object RegExp]"
  , setTag$6 = "[object Set]"
  , stringTag$3 = "[object String]"
  , weakMapTag$4 = "[object WeakMap]"
  , arrayBufferTag$3 = "[object ArrayBuffer]"
  , dataViewTag$5 = "[object DataView]"
  , float32Tag$3 = "[object Float32Array]"
  , float64Tag$3 = "[object Float64Array]"
  , int8Tag$3 = "[object Int8Array]"
  , int16Tag$3 = "[object Int16Array]"
  , int32Tag$3 = "[object Int32Array]"
  , uint8Tag$3 = "[object Uint8Array]"
  , uint8ClampedTag$3 = "[object Uint8ClampedArray]"
  , uint16Tag$3 = "[object Uint16Array]"
  , uint32Tag$3 = "[object Uint32Array]"
  , typedArrayTags$1 = {};
typedArrayTags$1[float32Tag$3] = typedArrayTags$1[float64Tag$3] = typedArrayTags$1[int8Tag$3] = typedArrayTags$1[int16Tag$3] = typedArrayTags$1[int32Tag$3] = typedArrayTags$1[uint8Tag$3] = typedArrayTags$1[uint8ClampedTag$3] = typedArrayTags$1[uint16Tag$3] = typedArrayTags$1[uint32Tag$3] = !0;
typedArrayTags$1[argsTag$4] = typedArrayTags$1[arrayTag$3] = typedArrayTags$1[arrayBufferTag$3] = typedArrayTags$1[boolTag$3] = typedArrayTags$1[dataViewTag$5] = typedArrayTags$1[dateTag$3] = typedArrayTags$1[errorTag$2] = typedArrayTags$1[funcTag$3] = typedArrayTags$1[mapTag$6] = typedArrayTags$1[numberTag$3] = typedArrayTags$1[objectTag$6] = typedArrayTags$1[regexpTag$3] = typedArrayTags$1[setTag$6] = typedArrayTags$1[stringTag$3] = typedArrayTags$1[weakMapTag$4] = !1;
function baseIsTypedArray$2(_e) {
    return isObjectLike$3(_e) && isLength$3(_e.length) && !!typedArrayTags$1[baseGetTag$3(_e)]
}
var _baseIsTypedArray = baseIsTypedArray$2;
function baseUnary$2(_e) {
    return function($) {
        return _e($)
    }
}
var _baseUnary = baseUnary$2
  , _nodeUtil = {
    exports: {}
};
_nodeUtil.exports;
(function(_e, $) {
    var et = _freeGlobal
      , tt = $ && !$.nodeType && $
      , nt = tt && !0 && _e && !_e.nodeType && _e
      , rt = nt && nt.exports === tt
      , it = rt && et.process
      , ot = function() {
        try {
            var st = nt && nt.require && nt.require("util").types;
            return st || it && it.binding && it.binding("util")
        } catch {}
    }();
    _e.exports = ot
}
)(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports
  , baseIsTypedArray$1 = _baseIsTypedArray
  , baseUnary$1 = _baseUnary
  , nodeUtil$1 = _nodeUtilExports
  , nodeIsTypedArray$1 = nodeUtil$1 && nodeUtil$1.isTypedArray
  , isTypedArray$4 = nodeIsTypedArray$1 ? baseUnary$1(nodeIsTypedArray$1) : baseIsTypedArray$1
  , isTypedArray_1 = isTypedArray$4
  , baseTimes$1 = _baseTimes
  , isArguments$2 = isArguments_1
  , isArray$c = isArray_1
  , isBuffer$3 = isBufferExports
  , isIndex$2 = _isIndex
  , isTypedArray$3 = isTypedArray_1
  , objectProto$i = Object.prototype
  , hasOwnProperty$g = objectProto$i.hasOwnProperty;
function arrayLikeKeys$2(_e, $) {
    var et = isArray$c(_e)
      , tt = !et && isArguments$2(_e)
      , nt = !et && !tt && isBuffer$3(_e)
      , rt = !et && !tt && !nt && isTypedArray$3(_e)
      , it = et || tt || nt || rt
      , ot = it ? baseTimes$1(_e.length, String) : []
      , st = ot.length;
    for (var lt in _e)
        ($ || hasOwnProperty$g.call(_e, lt)) && !(it && (lt == "length" || nt && (lt == "offset" || lt == "parent") || rt && (lt == "buffer" || lt == "byteLength" || lt == "byteOffset") || isIndex$2(lt, st))) && ot.push(lt);
    return ot
}
var _arrayLikeKeys = arrayLikeKeys$2
  , objectProto$h = Object.prototype;
function isPrototype$2(_e) {
    var $ = _e && _e.constructor
      , et = typeof $ == "function" && $.prototype || objectProto$h;
    return _e === et
}
var _isPrototype = isPrototype$2;
function overArg$2(_e, $) {
    return function(et) {
        return _e($(et))
    }
}
var _overArg = overArg$2
  , overArg$1 = _overArg
  , nativeKeys$2 = overArg$1(Object.keys, Object)
  , _nativeKeys = nativeKeys$2
  , isPrototype$1 = _isPrototype
  , nativeKeys$1 = _nativeKeys
  , objectProto$g = Object.prototype
  , hasOwnProperty$f = objectProto$g.hasOwnProperty;
function baseKeys$2(_e) {
    if (!isPrototype$1(_e))
        return nativeKeys$1(_e);
    var $ = [];
    for (var et in Object(_e))
        hasOwnProperty$f.call(_e, et) && et != "constructor" && $.push(et);
    return $
}
var _baseKeys = baseKeys$2
  , isFunction$3 = isFunction_1
  , isLength$2 = isLength_1;
function isArrayLike$4(_e) {
    return _e != null && isLength$2(_e.length) && !isFunction$3(_e)
}
var isArrayLike_1 = isArrayLike$4
  , arrayLikeKeys$1 = _arrayLikeKeys
  , baseKeys$1 = _baseKeys
  , isArrayLike$3 = isArrayLike_1;
function keys$5(_e) {
    return isArrayLike$3(_e) ? arrayLikeKeys$1(_e) : baseKeys$1(_e)
}
var keys_1 = keys$5
  , baseGetAllKeys$1 = _baseGetAllKeys
  , getSymbols$1 = _getSymbols
  , keys$4 = keys_1;
function getAllKeys$2(_e) {
    return baseGetAllKeys$1(_e, keys$4, getSymbols$1)
}
var _getAllKeys = getAllKeys$2
  , getAllKeys$1 = _getAllKeys
  , COMPARE_PARTIAL_FLAG$3 = 1
  , objectProto$f = Object.prototype
  , hasOwnProperty$e = objectProto$f.hasOwnProperty;
function equalObjects$1(_e, $, et, tt, nt, rt) {
    var it = et & COMPARE_PARTIAL_FLAG$3
      , ot = getAllKeys$1(_e)
      , st = ot.length
      , lt = getAllKeys$1($)
      , ct = lt.length;
    if (st != ct && !it)
        return !1;
    for (var dt = st; dt--; ) {
        var pt = ot[dt];
        if (!(it ? pt in $ : hasOwnProperty$e.call($, pt)))
            return !1
    }
    var ht = rt.get(_e)
      , mt = rt.get($);
    if (ht && mt)
        return ht == $ && mt == _e;
    var yt = !0;
    rt.set(_e, $),
    rt.set($, _e);
    for (var Et = it; ++dt < st; ) {
        pt = ot[dt];
        var _t = _e[pt]
          , wt = $[pt];
        if (tt)
            var St = it ? tt(wt, _t, pt, $, _e, rt) : tt(_t, wt, pt, _e, $, rt);
        if (!(St === void 0 ? _t === wt || nt(_t, wt, et, tt, rt) : St)) {
            yt = !1;
            break
        }
        Et || (Et = pt == "constructor")
    }
    if (yt && !Et) {
        var Ct = _e.constructor
          , Nt = $.constructor;
        Ct != Nt && "constructor"in _e && "constructor"in $ && !(typeof Ct == "function" && Ct instanceof Ct && typeof Nt == "function" && Nt instanceof Nt) && (yt = !1)
    }
    return rt.delete(_e),
    rt.delete($),
    yt
}
var _equalObjects = equalObjects$1
  , getNative$4 = _getNative
  , root$4 = _root
  , DataView$3 = getNative$4(root$4, "DataView")
  , _DataView = DataView$3
  , getNative$3 = _getNative
  , root$3 = _root
  , Promise$3 = getNative$3(root$3, "Promise")
  , _Promise = Promise$3
  , getNative$2 = _getNative
  , root$2 = _root
  , Set$3 = getNative$2(root$2, "Set")
  , _Set = Set$3
  , getNative$1 = _getNative
  , root$1 = _root
  , WeakMap$3 = getNative$1(root$1, "WeakMap")
  , _WeakMap = WeakMap$3
  , DataView$2 = _DataView
  , Map$2 = _Map
  , Promise$2 = _Promise
  , Set$2 = _Set
  , WeakMap$2 = _WeakMap
  , baseGetTag$2 = _baseGetTag
  , toSource$1 = _toSource
  , mapTag$5 = "[object Map]"
  , objectTag$5 = "[object Object]"
  , promiseTag$1 = "[object Promise]"
  , setTag$5 = "[object Set]"
  , weakMapTag$3 = "[object WeakMap]"
  , dataViewTag$4 = "[object DataView]"
  , dataViewCtorString$1 = toSource$1(DataView$2)
  , mapCtorString$1 = toSource$1(Map$2)
  , promiseCtorString$1 = toSource$1(Promise$2)
  , setCtorString$1 = toSource$1(Set$2)
  , weakMapCtorString$1 = toSource$1(WeakMap$2)
  , getTag$2 = baseGetTag$2;
(DataView$2 && getTag$2(new DataView$2(new ArrayBuffer(1))) != dataViewTag$4 || Map$2 && getTag$2(new Map$2) != mapTag$5 || Promise$2 && getTag$2(Promise$2.resolve()) != promiseTag$1 || Set$2 && getTag$2(new Set$2) != setTag$5 || WeakMap$2 && getTag$2(new WeakMap$2) != weakMapTag$3) && (getTag$2 = function(_e) {
    var $ = baseGetTag$2(_e)
      , et = $ == objectTag$5 ? _e.constructor : void 0
      , tt = et ? toSource$1(et) : "";
    if (tt)
        switch (tt) {
        case dataViewCtorString$1:
            return dataViewTag$4;
        case mapCtorString$1:
            return mapTag$5;
        case promiseCtorString$1:
            return promiseTag$1;
        case setCtorString$1:
            return setTag$5;
        case weakMapCtorString$1:
            return weakMapTag$3
        }
    return $
}
);
var _getTag = getTag$2
  , Stack$3 = _Stack
  , equalArrays = _equalArrays
  , equalByTag = _equalByTag
  , equalObjects = _equalObjects
  , getTag$1 = _getTag
  , isArray$b = isArray_1
  , isBuffer$2 = isBufferExports
  , isTypedArray$2 = isTypedArray_1
  , COMPARE_PARTIAL_FLAG$2 = 1
  , argsTag$3 = "[object Arguments]"
  , arrayTag$2 = "[object Array]"
  , objectTag$4 = "[object Object]"
  , objectProto$e = Object.prototype
  , hasOwnProperty$d = objectProto$e.hasOwnProperty;
function baseIsEqualDeep$1(_e, $, et, tt, nt, rt) {
    var it = isArray$b(_e)
      , ot = isArray$b($)
      , st = it ? arrayTag$2 : getTag$1(_e)
      , lt = ot ? arrayTag$2 : getTag$1($);
    st = st == argsTag$3 ? objectTag$4 : st,
    lt = lt == argsTag$3 ? objectTag$4 : lt;
    var ct = st == objectTag$4
      , dt = lt == objectTag$4
      , pt = st == lt;
    if (pt && isBuffer$2(_e)) {
        if (!isBuffer$2($))
            return !1;
        it = !0,
        ct = !1
    }
    if (pt && !ct)
        return rt || (rt = new Stack$3),
        it || isTypedArray$2(_e) ? equalArrays(_e, $, et, tt, nt, rt) : equalByTag(_e, $, st, et, tt, nt, rt);
    if (!(et & COMPARE_PARTIAL_FLAG$2)) {
        var ht = ct && hasOwnProperty$d.call(_e, "__wrapped__")
          , mt = dt && hasOwnProperty$d.call($, "__wrapped__");
        if (ht || mt) {
            var yt = ht ? _e.value() : _e
              , Et = mt ? $.value() : $;
            return rt || (rt = new Stack$3),
            nt(yt, Et, et, tt, rt)
        }
    }
    return pt ? (rt || (rt = new Stack$3),
    equalObjects(_e, $, et, tt, nt, rt)) : !1
}
var _baseIsEqualDeep = baseIsEqualDeep$1
  , baseIsEqualDeep = _baseIsEqualDeep
  , isObjectLike$2 = isObjectLike_1;
function baseIsEqual$2(_e, $, et, tt, nt) {
    return _e === $ ? !0 : _e == null || $ == null || !isObjectLike$2(_e) && !isObjectLike$2($) ? _e !== _e && $ !== $ : baseIsEqualDeep(_e, $, et, tt, baseIsEqual$2, nt)
}
var _baseIsEqual = baseIsEqual$2
  , Stack$2 = _Stack
  , baseIsEqual$1 = _baseIsEqual
  , COMPARE_PARTIAL_FLAG$1 = 1
  , COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(_e, $, et, tt) {
    var nt = et.length
      , rt = nt
      , it = !tt;
    if (_e == null)
        return !rt;
    for (_e = Object(_e); nt--; ) {
        var ot = et[nt];
        if (it && ot[2] ? ot[1] !== _e[ot[0]] : !(ot[0]in _e))
            return !1
    }
    for (; ++nt < rt; ) {
        ot = et[nt];
        var st = ot[0]
          , lt = _e[st]
          , ct = ot[1];
        if (it && ot[2]) {
            if (lt === void 0 && !(st in _e))
                return !1
        } else {
            var dt = new Stack$2;
            if (tt)
                var pt = tt(lt, ct, st, _e, $, dt);
            if (!(pt === void 0 ? baseIsEqual$1(ct, lt, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, tt, dt) : pt))
                return !1
        }
    }
    return !0
}
var _baseIsMatch = baseIsMatch$1
  , isObject$f = isObject_1;
function isStrictComparable$2(_e) {
    return _e === _e && !isObject$f(_e)
}
var _isStrictComparable = isStrictComparable$2
  , isStrictComparable$1 = _isStrictComparable
  , keys$3 = keys_1;
function getMatchData$1(_e) {
    for (var $ = keys$3(_e), et = $.length; et--; ) {
        var tt = $[et]
          , nt = _e[tt];
        $[et] = [tt, nt, isStrictComparable$1(nt)]
    }
    return $
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(_e, $) {
    return function(et) {
        return et == null ? !1 : et[_e] === $ && ($ !== void 0 || _e in Object(et))
    }
}
var _matchesStrictComparable = matchesStrictComparable$2
  , baseIsMatch = _baseIsMatch
  , getMatchData = _getMatchData
  , matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(_e) {
    var $ = getMatchData(_e);
    return $.length == 1 && $[0][2] ? matchesStrictComparable$1($[0][0], $[0][1]) : function(et) {
        return et === _e || baseIsMatch(et, _e, $)
    }
}
var _baseMatches = baseMatches$1
  , baseGetTag$1 = _baseGetTag
  , isObjectLike$1 = isObjectLike_1
  , symbolTag$3 = "[object Symbol]";
function isSymbol$5(_e) {
    return typeof _e == "symbol" || isObjectLike$1(_e) && baseGetTag$1(_e) == symbolTag$3
}
var isSymbol_1 = isSymbol$5
  , isArray$a = isArray_1
  , isSymbol$4 = isSymbol_1
  , reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/
  , reIsPlainProp = /^\w*$/;
function isKey$3(_e, $) {
    if (isArray$a(_e))
        return !1;
    var et = typeof _e;
    return et == "number" || et == "symbol" || et == "boolean" || _e == null || isSymbol$4(_e) ? !0 : reIsPlainProp.test(_e) || !reIsDeepProp.test(_e) || $ != null && _e in Object($)
}
var _isKey = isKey$3
  , MapCache$1 = _MapCache
  , FUNC_ERROR_TEXT$1 = "Expected a function";
function memoize$2(_e, $) {
    if (typeof _e != "function" || $ != null && typeof $ != "function")
        throw new TypeError(FUNC_ERROR_TEXT$1);
    var et = function() {
        var tt = arguments
          , nt = $ ? $.apply(this, tt) : tt[0]
          , rt = et.cache;
        if (rt.has(nt))
            return rt.get(nt);
        var it = _e.apply(this, tt);
        return et.cache = rt.set(nt, it) || rt,
        it
    };
    return et.cache = new (memoize$2.Cache || MapCache$1),
    et
}
memoize$2.Cache = MapCache$1;
var memoize_1 = memoize$2;
const memoize$3 = getDefaultExportFromCjs$2(memoize_1);
var memoize$1 = memoize_1
  , MAX_MEMOIZE_SIZE$1 = 500;
function memoizeCapped$2(_e) {
    var $ = memoize$1(_e, function(tt) {
        return et.size === MAX_MEMOIZE_SIZE$1 && et.clear(),
        tt
    })
      , et = $.cache;
    return $
}
var _memoizeCapped = memoizeCapped$2
  , memoizeCapped$1 = _memoizeCapped
  , rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
  , reEscapeChar$1 = /\\(\\)?/g
  , stringToPath$2 = memoizeCapped$1(function(_e) {
    var $ = [];
    return _e.charCodeAt(0) === 46 && $.push(""),
    _e.replace(rePropName$1, function(et, tt, nt, rt) {
        $.push(nt ? rt.replace(reEscapeChar$1, "$1") : tt || et)
    }),
    $
})
  , _stringToPath = stringToPath$2
  , Symbol$3 = _Symbol
  , arrayMap$2 = _arrayMap
  , isArray$9 = isArray_1
  , isSymbol$3 = isSymbol_1
  , symbolProto$2 = Symbol$3 ? Symbol$3.prototype : void 0
  , symbolToString$2 = symbolProto$2 ? symbolProto$2.toString : void 0;
function baseToString$2(_e) {
    if (typeof _e == "string")
        return _e;
    if (isArray$9(_e))
        return arrayMap$2(_e, baseToString$2) + "";
    if (isSymbol$3(_e))
        return symbolToString$2 ? symbolToString$2.call(_e) : "";
    var $ = _e + "";
    return $ == "0" && 1 / _e == -1 / 0 ? "-0" : $
}
var _baseToString = baseToString$2
  , baseToString$1 = _baseToString;
function toString$6(_e) {
    return _e == null ? "" : baseToString$1(_e)
}
var toString_1 = toString$6
  , isArray$8 = isArray_1
  , isKey$2 = _isKey
  , stringToPath$1 = _stringToPath
  , toString$5 = toString_1;
function castPath$2(_e, $) {
    return isArray$8(_e) ? _e : isKey$2(_e, $) ? [_e] : stringToPath$1(toString$5(_e))
}
var _castPath = castPath$2
  , isSymbol$2 = isSymbol_1;
function toKey$5(_e) {
    if (typeof _e == "string" || isSymbol$2(_e))
        return _e;
    var $ = _e + "";
    return $ == "0" && 1 / _e == -1 / 0 ? "-0" : $
}
var _toKey = toKey$5
  , castPath$1 = _castPath
  , toKey$4 = _toKey;
function baseGet$2(_e, $) {
    $ = castPath$1($, _e);
    for (var et = 0, tt = $.length; _e != null && et < tt; )
        _e = _e[toKey$4($[et++])];
    return et && et == tt ? _e : void 0
}
var _baseGet = baseGet$2
  , baseGet$1 = _baseGet;
function get$1(_e, $, et) {
    var tt = _e == null ? void 0 : baseGet$1(_e, $);
    return tt === void 0 ? et : tt
}
var get_1 = get$1;
const get$2 = getDefaultExportFromCjs$2(get_1);
function baseHasIn$1(_e, $) {
    return _e != null && $ in Object(_e)
}
var _baseHasIn = baseHasIn$1
  , castPath = _castPath
  , isArguments$1 = isArguments_1
  , isArray$7 = isArray_1
  , isIndex$1 = _isIndex
  , isLength$1 = isLength_1
  , toKey$3 = _toKey;
function hasPath$1(_e, $, et) {
    $ = castPath($, _e);
    for (var tt = -1, nt = $.length, rt = !1; ++tt < nt; ) {
        var it = toKey$3($[tt]);
        if (!(rt = _e != null && et(_e, it)))
            break;
        _e = _e[it]
    }
    return rt || ++tt != nt ? rt : (nt = _e == null ? 0 : _e.length,
    !!nt && isLength$1(nt) && isIndex$1(it, nt) && (isArray$7(_e) || isArguments$1(_e)))
}
var _hasPath = hasPath$1
  , baseHasIn = _baseHasIn
  , hasPath = _hasPath;
function hasIn$1(_e, $) {
    return _e != null && hasPath(_e, $, baseHasIn)
}
var hasIn_1 = hasIn$1
  , baseIsEqual = _baseIsEqual
  , get = get_1
  , hasIn = hasIn_1
  , isKey$1 = _isKey
  , isStrictComparable = _isStrictComparable
  , matchesStrictComparable = _matchesStrictComparable
  , toKey$2 = _toKey
  , COMPARE_PARTIAL_FLAG = 1
  , COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(_e, $) {
    return isKey$1(_e) && isStrictComparable($) ? matchesStrictComparable(toKey$2(_e), $) : function(et) {
        var tt = get(et, _e);
        return tt === void 0 && tt === $ ? hasIn(et, _e) : baseIsEqual($, tt, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)
    }
}
var _baseMatchesProperty = baseMatchesProperty$1;
function identity$1(_e) {
    return _e
}
var identity_1 = identity$1;
function baseProperty$1(_e) {
    return function($) {
        return $ == null ? void 0 : $[_e]
    }
}
var _baseProperty = baseProperty$1
  , baseGet = _baseGet;
function basePropertyDeep$1(_e) {
    return function($) {
        return baseGet($, _e)
    }
}
var _basePropertyDeep = basePropertyDeep$1
  , baseProperty = _baseProperty
  , basePropertyDeep = _basePropertyDeep
  , isKey = _isKey
  , toKey$1 = _toKey;
function property$1(_e) {
    return isKey(_e) ? baseProperty(toKey$1(_e)) : basePropertyDeep(_e)
}
var property_1 = property$1
  , baseMatches = _baseMatches
  , baseMatchesProperty = _baseMatchesProperty
  , identity = identity_1
  , isArray$6 = isArray_1
  , property = property_1;
function baseIteratee$1(_e) {
    return typeof _e == "function" ? _e : _e == null ? identity : typeof _e == "object" ? isArray$6(_e) ? baseMatchesProperty(_e[0], _e[1]) : baseMatches(_e) : property(_e)
}
var _baseIteratee = baseIteratee$1;
function createBaseFor$1(_e) {
    return function($, et, tt) {
        for (var nt = -1, rt = Object($), it = tt($), ot = it.length; ot--; ) {
            var st = it[_e ? ot : ++nt];
            if (et(rt[st], st, rt) === !1)
                break
        }
        return $
    }
}
var _createBaseFor = createBaseFor$1
  , createBaseFor = _createBaseFor
  , baseFor$1 = createBaseFor()
  , _baseFor = baseFor$1
  , baseFor = _baseFor
  , keys$2 = keys_1;
function baseForOwn$1(_e, $) {
    return _e && baseFor(_e, $, keys$2)
}
var _baseForOwn = baseForOwn$1
  , isArrayLike$2 = isArrayLike_1;
function createBaseEach$1(_e, $) {
    return function(et, tt) {
        if (et == null)
            return et;
        if (!isArrayLike$2(et))
            return _e(et, tt);
        for (var nt = et.length, rt = $ ? nt : -1, it = Object(et); ($ ? rt-- : ++rt < nt) && tt(it[rt], rt, it) !== !1; )
            ;
        return et
    }
}
var _createBaseEach = createBaseEach$1
  , baseForOwn = _baseForOwn
  , createBaseEach = _createBaseEach
  , baseEach$1 = createBaseEach(baseForOwn)
  , _baseEach = baseEach$1
  , baseEach = _baseEach
  , isArrayLike$1 = isArrayLike_1;
function baseMap$1(_e, $) {
    var et = -1
      , tt = isArrayLike$1(_e) ? Array(_e.length) : [];
    return baseEach(_e, function(nt, rt, it) {
        tt[++et] = $(nt, rt, it)
    }),
    tt
}
var _baseMap = baseMap$1
  , arrayMap$1 = _arrayMap
  , baseIteratee = _baseIteratee
  , baseMap = _baseMap
  , isArray$5 = isArray_1;
function map(_e, $) {
    var et = isArray$5(_e) ? arrayMap$1 : baseMap;
    return et(_e, baseIteratee($))
}
var map_1 = map;
const map$1 = getDefaultExportFromCjs$2(map_1)
  , enIcon = "/assets/en-BiE4VHSb.svg"
  , jaIcon = "/assets/ja-BH0vhjMg.svg"
  , koIcon = "/assets/ko-Di3uOSp-.svg"
  , zhIcon = "/assets/zh-BLbrB8FE.svg"
  , LOCALES = [{
    key: "en",
    name: "English",
    icon: enIcon
}, {
    key: "zh-CN",
    name: "",
    icon: zhIcon
}, {
    key: "zh-HK",
    name: "",
    icon: zhIcon
}, {
    key: "ja",
    name: "",
    icon: jaIcon
}, {
    key: "ko",
    name: "",
    icon: koIcon
}];
map$1(LOCALES, "key");
const DEFAULT_LOCALE = "en"
  , useStore$1 = create$1()(persist(_e => ({
    signAddress: "",
    invite_code: "",
    token: "",
    theme: App_Theme.dark,
    userInfo: null,
    toggleTheme: () => _e($ => ({
        theme: $.theme === App_Theme.dark ? App_Theme.light : App_Theme.dark
    })),
    setTheme: $ => _e({
        theme: $
    }),
    setSignAddress: $ => _e({
        signAddress: $
    }),
    setUserInfo: $ => _e({
        userInfo: $
    }),
    setToken: $ => _e({
        token: $
    }),
    setInviteCode: $ => _e({
        invite_code: $
    }),
    clearUserInfo: () => _e( () => ({
        signAddress: "",
        token: "",
        userInfo: null,
        isModerator: !1,
        hasBound: !1
    })),
    tokenHoldings: {},
    setTokenHoldings: $ => _e({
        tokenHoldings: $
    }),
    isModerator: !1,
    setIsModerator: $ => _e({
        isModerator: $
    }),
    viewChart: !1,
    setViewChart: $ => _e({
        viewChart: $
    }),
    totalRewards: null,
    setTotalRewards: $ => _e({
        totalRewards: $
    }),
    nativeBalance: "0",
    setNativeBalance: $ => _e({
        nativeBalance: $
    }),
    hasBound: !1,
    setHasBound: $ => _e({
        hasBound: $
    }),
    activeLocale: DEFAULT_LOCALE,
    setActiveLocale: $ => _e({
        activeLocale: $
    })
}), {
    name: "global"
}));
function SolanaProvider({children: _e}) {
    const {clearUserInfo: $} = useStore$1()
      , {cluster: et} = useCluster()
      , {disconnect: tt} = useWallet()
      , nt = reactExports.useMemo( () => et.endpoint, [et])
      , rt = reactExports.useCallback(st => {}
    , [])
      , it = reactExports.useMemo( () => [new PhantomWalletAdapter, new SolflareWalletAdapter, new TorusWalletAdapter], [nt])
      , ot = useTheme();
    return jsxRuntimeExports.jsx(ConnectionProvider, {
        endpoint: nt,
        children: jsxRuntimeExports.jsx(WalletProvider, {
            wallets: it,
            onError: rt,
            autoConnect: !0,
            children: jsxRuntimeExports.jsx(WalletDialogProvider, {
                title: jsxRuntimeExports.jsx(Trans, {
                    id: "ytJ2WG"
                }),
                sx: {
                    "& .MuiDialogTitle-root": {
                        "& .MuiIconButton-root": {
                            color: ot.palette.text.primary
                        }
                    },
                    "& .MuiDialogContent-root": {
                        padding: 0,
                        "& .MuiCollapse-root": {
                            "& .MuiList-root": {
                                background: ot.palette.background.paper
                            }
                        },
                        "& .MuiList-root": {
                            background: ot.palette.background.paper,
                            padding: 0
                        },
                        "& .MuiListItem-root": {
                            "& .MuiButton-root": {
                                "&:hover": {
                                    background: ot.palette.action.hover
                                }
                            }
                        }
                    }
                },
                children: _e
            })
        })
    })
}
function useAnchorProvider() {
    const {connection: _e} = useConnection()
      , $ = useWallet();
    return new AnchorProvider(_e,$,{
        commitment: "confirmed"
    })
}
function WalletButton(_e) {
    const [$,et] = reactExports.useState(null)
      , {setOpen: tt} = useWalletDialog()
      , nt = {
        "change-wallet": i18n._({
            id: "3A/mG4"
        }),
        connecting: i18n._({
            id: "lNg25t"
        }),
        "copy-address": i18n._({
            id: "zXagFp"
        }),
        disconnect: i18n._({
            id: "+K0AvT"
        }),
        "has-wallet": i18n._({
            id: "iSLIjg"
        }),
        "no-wallet": i18n._({
            id: "CtByM7"
        })
    }
      , {wallet: rt, disconnect: it} = useWallet();
    return reactExports.useEffect( () => {
        rt && et(rt.readyState)
    }
    , [rt]),
    reactExports.useEffect( () => {
        $ === WalletReadyState.NotDetected && (it(),
        store$2.remove("walletName"),
        Vt.error(i18n._({
            id: "Cg2X6Z"
        })),
        et(null))
    }
    , [$]),
    jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: $ === WalletReadyState.NotDetected ? jsxRuntimeExports.jsx(Button, {
            ..._e,
            variant: "contained",
            sx: {
                height: "44px"
            },
            onClick: () => {
                tt(!0)
            }
            ,
            children: nt["no-wallet"]
        }) : jsxRuntimeExports.jsx(BaseWalletMultiButton, {
            labels: nt,
            ..._e,
            sx: {
                height: "44px"
            }
        })
    })
}
const TOKEN_PROGRAM_ID = new PublicKey("TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA");
new PublicKey("TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb");
const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey("ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL");
new PublicKey("So11111111111111111111111111111111111111112");
new PublicKey("9pan9bMn5HatX4EJdBwg9VgCa7Uz5HL8N1m5D3NdXejP");
const encodeDecode = _e => {
    const $ = _e.decode.bind(_e)
      , et = _e.encode.bind(_e);
    return {
        decode: $,
        encode: et
    }
}
  , bigInt = _e => $ => {
    const et = blob$1(_e, $)
      , {encode: tt, decode: nt} = encodeDecode(et)
      , rt = et;
    return rt.decode = (it, ot) => {
        const st = nt(it, ot);
        return toBigIntLE_1(Buffer$2.from(st))
    }
    ,
    rt.encode = (it, ot, st) => {
        const lt = toBufferLE_1(it, _e);
        return tt(lt, ot, st)
    }
    ,
    rt
}
  , u64 = bigInt(8)
  , bool = _e => {
    const $ = u8$1(_e)
      , {encode: et, decode: tt} = encodeDecode($)
      , nt = $;
    return nt.decode = (rt, it) => !!tt(rt, it),
    nt.encode = (rt, it, ot) => {
        const st = Number(rt);
        return et(st, it, ot)
    }
    ,
    nt
}
  , publicKey = _e => {
    const $ = blob$1(32, _e)
      , {encode: et, decode: tt} = encodeDecode($)
      , nt = $;
    return nt.decode = (rt, it) => {
        const ot = tt(rt, it);
        return new PublicKey(ot)
    }
    ,
    nt.encode = (rt, it, ot) => {
        const st = rt.toBuffer();
        return et(st, it, ot)
    }
    ,
    nt
}
;
class TokenError extends Error {
    constructor($) {
        super($)
    }
}
class TokenOwnerOffCurveError extends TokenError {
    constructor() {
        super(...arguments),
        this.name = "TokenOwnerOffCurveError"
    }
}
var AccountType;
(function(_e) {
    _e[_e.Uninitialized = 0] = "Uninitialized",
    _e[_e.Mint = 1] = "Mint",
    _e[_e.Account = 2] = "Account"
}
)(AccountType || (AccountType = {}));
const ACCOUNT_TYPE_SIZE = 1
  , MultisigLayout = struct$1([u8$1("m"), u8$1("n"), bool("isInitialized"), publicKey("signer1"), publicKey("signer2"), publicKey("signer3"), publicKey("signer4"), publicKey("signer5"), publicKey("signer6"), publicKey("signer7"), publicKey("signer8"), publicKey("signer9"), publicKey("signer10"), publicKey("signer11")])
  , MULTISIG_SIZE = MultisigLayout.span;
var AccountState;
(function(_e) {
    _e[_e.Uninitialized = 0] = "Uninitialized",
    _e[_e.Initialized = 1] = "Initialized",
    _e[_e.Frozen = 2] = "Frozen"
}
)(AccountState || (AccountState = {}));
const AccountLayout = struct$1([publicKey("mint"), publicKey("owner"), u64("amount"), u32$1("delegateOption"), publicKey("delegate"), u8$1("state"), u32$1("isNativeOption"), u64("isNative"), u64("delegatedAmount"), u32$1("closeAuthorityOption"), publicKey("closeAuthority")])
  , ACCOUNT_SIZE = AccountLayout.span
  , CpiGuardLayout = struct$1([bool("lockCpi")])
  , CPI_GUARD_SIZE = CpiGuardLayout.span
  , DefaultAccountStateLayout = struct$1([u8$1("state")])
  , DEFAULT_ACCOUNT_STATE_SIZE = DefaultAccountStateLayout.span;
var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3
  , SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001
  , SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004
  , SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005
  , SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006
  , SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;
function encodeValue(_e) {
    return Array.isArray(_e) ? "%5B" + _e.map(encodeValue).join("%2C%20") + "%5D" : typeof _e == "bigint" ? `${_e}n` : encodeURIComponent(String(_e != null && Object.getPrototypeOf(_e) === null ? {
        ..._e
    } : _e))
}
function encodeObjectContextEntry([_e,$]) {
    return `${_e}=${encodeValue($)}`
}
function encodeContextObject(_e) {
    const $ = Object.entries(_e).map(encodeObjectContextEntry).join("&");
    return btoa($)
}
function getErrorMessage(_e, $={}) {
    {
        let et = `Solana error #${_e}; Decode this error by running \`npx @solana/errors decode -- ${_e}`;
        return Object.keys($).length && (et += ` '${encodeContextObject($)}'`),
        `${et}\``
    }
}
var SolanaError = class extends Error {
    constructor(...[$,et]) {
        let tt, nt;
        if (et) {
            const {cause: it, ...ot} = et;
            it && (nt = {
                cause: it
            }),
            Object.keys(ot).length > 0 && (tt = ot)
        }
        const rt = getErrorMessage($, tt);
        super(rt, nt);
        Br(this, "cause", this.cause);
        Br(this, "context");
        this.context = {
            __code: $,
            ...tt
        },
        this.name = "SolanaError"
    }
}
  , padBytes = (_e, $) => {
    if (_e.length >= $)
        return _e;
    const et = new Uint8Array($).fill(0);
    return et.set(_e),
    et
}
  , fixBytes = (_e, $) => padBytes(_e.length <= $ ? _e : _e.slice(0, $), $);
function getEncodedSize(_e, $) {
    return "fixedSize"in $ ? $.fixedSize : $.getSizeFromValue(_e)
}
function createEncoder(_e) {
    return Object.freeze({
        ..._e,
        encode: $ => {
            const et = new Uint8Array(getEncodedSize($, _e));
            return _e.write($, et, 0),
            et
        }
    })
}
function createDecoder(_e) {
    return Object.freeze({
        ..._e,
        decode: ($, et=0) => _e.read($, et)[0]
    })
}
function isFixedSize(_e) {
    return "fixedSize"in _e && typeof _e.fixedSize == "number"
}
function combineCodec(_e, $) {
    if (isFixedSize(_e) !== isFixedSize($))
        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);
    if (isFixedSize(_e) && isFixedSize($) && _e.fixedSize !== $.fixedSize)
        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH,{
            decoderFixedSize: $.fixedSize,
            encoderFixedSize: _e.fixedSize
        });
    if (!isFixedSize(_e) && !isFixedSize($) && _e.maxSize !== $.maxSize)
        throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH,{
            decoderMaxSize: $.maxSize,
            encoderMaxSize: _e.maxSize
        });
    return {
        ...$,
        ..._e,
        decode: $.decode,
        encode: _e.encode,
        read: $.read,
        write: _e.write
    }
}
function assertByteArrayIsNotEmptyForCodec(_e, $, et=0) {
    if ($.length - et <= 0)
        throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY,{
            codecDescription: _e
        })
}
function assertByteArrayHasEnoughBytesForCodec(_e, $, et, tt=0) {
    const nt = et.length - tt;
    if (nt < $)
        throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH,{
            bytesLength: nt,
            codecDescription: _e,
            expected: $
        })
}
function fixEncoderSize(_e, $) {
    return createEncoder({
        fixedSize: $,
        write: (et, tt, nt) => {
            const rt = _e.encode(et)
              , it = rt.length > $ ? rt.slice(0, $) : rt;
            return tt.set(it, nt),
            nt + $
        }
    })
}
function fixDecoderSize(_e, $) {
    return createDecoder({
        fixedSize: $,
        read: (et, tt) => {
            assertByteArrayHasEnoughBytesForCodec("fixCodecSize", $, et, tt),
            (tt > 0 || et.length > $) && (et = et.slice(tt, tt + $)),
            isFixedSize(_e) && (et = fixBytes(et, _e.fixedSize));
            const [nt] = _e.read(et, 0);
            return [nt, tt + $]
        }
    })
}
function fixCodecSize(_e, $) {
    return combineCodec(fixEncoderSize(_e, $), fixDecoderSize(_e, $))
}
function assertNumberIsBetweenForCodec(_e, $, et, tt) {
    if (tt < $ || tt > et)
        throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE,{
            codecDescription: _e,
            max: et,
            min: $,
            value: tt
        })
}
function isLittleEndian(_e) {
    return (_e == null ? void 0 : _e.endian) !== 1
}
function numberEncoderFactory(_e) {
    return createEncoder({
        fixedSize: _e.size,
        write($, et, tt) {
            _e.range && assertNumberIsBetweenForCodec(_e.name, _e.range[0], _e.range[1], $);
            const nt = new ArrayBuffer(_e.size);
            return _e.set(new DataView(nt), $, isLittleEndian(_e.config)),
            et.set(new Uint8Array(nt), tt),
            tt + _e.size
        }
    })
}
function numberDecoderFactory(_e) {
    return createDecoder({
        fixedSize: _e.size,
        read($, et=0) {
            assertByteArrayIsNotEmptyForCodec(_e.name, $, et),
            assertByteArrayHasEnoughBytesForCodec(_e.name, _e.size, $, et);
            const tt = new DataView(toArrayBuffer($, et, _e.size));
            return [_e.get(tt, isLittleEndian(_e.config)), et + _e.size]
        }
    })
}
function toArrayBuffer(_e, $, et) {
    const tt = _e.byteOffset + ($ ?? 0)
      , nt = et ?? _e.byteLength;
    return _e.buffer.slice(tt, tt + nt)
}
var getU64Encoder = (_e={}) => numberEncoderFactory({
    config: _e,
    name: "u64",
    range: [0n, BigInt("0xffffffffffffffff")],
    set: ($, et, tt) => $.setBigUint64(0, BigInt(et), tt),
    size: 8
})
  , getU64Decoder = (_e={}) => numberDecoderFactory({
    config: _e,
    get: ($, et) => $.getBigUint64(0, et),
    name: "u64",
    size: 8
})
  , getU64Codec = (_e={}) => combineCodec(getU64Encoder(_e), getU64Decoder(_e));
function sumCodecSizes(_e) {
    return _e.reduce( ($, et) => $ === null || et === null ? null : $ + et, 0)
}
function getFixedSize(_e) {
    return isFixedSize(_e) ? _e.fixedSize : null
}
function getMaxSize(_e) {
    return isFixedSize(_e) ? _e.fixedSize : _e.maxSize ?? null
}
function getBytesEncoder() {
    return createEncoder({
        getSizeFromValue: _e => _e.length,
        write: (_e, $, et) => ($.set(_e, et),
        et + _e.length)
    })
}
function getBytesDecoder() {
    return createDecoder({
        read: (_e, $) => {
            const et = _e.slice($);
            return [et, $ + et.length]
        }
    })
}
function getBytesCodec() {
    return combineCodec(getBytesEncoder(), getBytesDecoder())
}
function getStructEncoder(_e) {
    const $ = _e.map( ([,nt]) => nt)
      , et = sumCodecSizes($.map(getFixedSize))
      , tt = sumCodecSizes($.map(getMaxSize)) ?? void 0;
    return createEncoder({
        ...et === null ? {
            getSizeFromValue: nt => _e.map( ([rt,it]) => getEncodedSize(nt[rt], it)).reduce( (rt, it) => rt + it, 0),
            maxSize: tt
        } : {
            fixedSize: et
        },
        write: (nt, rt, it) => (_e.forEach( ([ot,st]) => {
            it = st.write(nt[ot], rt, it)
        }
        ),
        it)
    })
}
function getStructDecoder(_e) {
    const $ = _e.map( ([,nt]) => nt)
      , et = sumCodecSizes($.map(getFixedSize))
      , tt = sumCodecSizes($.map(getMaxSize)) ?? void 0;
    return createDecoder({
        ...et === null ? {
            maxSize: tt
        } : {
            fixedSize: et
        },
        read: (nt, rt) => {
            const it = {};
            return _e.forEach( ([ot,st]) => {
                const [lt,ct] = st.read(nt, rt);
                rt = ct,
                it[ot] = lt
            }
            ),
            [it, rt]
        }
    })
}
function getStructCodec(_e) {
    return combineCodec(getStructEncoder(_e), getStructDecoder(_e))
}
const tokenGroupCodec = getStructCodec([["updateAuthority", fixCodecSize(getBytesCodec(), 32)], ["mint", fixCodecSize(getBytesCodec(), 32)], ["size", getU64Codec()], ["maxSize", getU64Codec()]])
  , TOKEN_GROUP_SIZE = tokenGroupCodec.fixedSize
  , tokenGroupMemberCodec = getStructCodec([["mint", fixCodecSize(getBytesCodec(), 32)], ["group", fixCodecSize(getBytesCodec(), 32)], ["memberNumber", getU64Codec()]])
  , TOKEN_GROUP_MEMBER_SIZE = tokenGroupMemberCodec.fixedSize
  , GroupMemberPointerLayout = struct$1([publicKey("authority"), publicKey("memberAddress")])
  , GROUP_MEMBER_POINTER_SIZE = GroupMemberPointerLayout.span
  , GroupPointerLayout = struct$1([publicKey("authority"), publicKey("groupAddress")])
  , GROUP_POINTER_SIZE = GroupPointerLayout.span
  , ImmutableOwnerLayout = struct$1([])
  , IMMUTABLE_OWNER_SIZE = ImmutableOwnerLayout.span
  , InterestBearingMintConfigStateLayout = struct$1([publicKey("rateAuthority"), ns64$1("initializationTimestamp"), s16("preUpdateAverageRate"), ns64$1("lastUpdateTimestamp"), s16("currentRate")])
  , INTEREST_BEARING_MINT_CONFIG_STATE_SIZE = InterestBearingMintConfigStateLayout.span
  , MemoTransferLayout = struct$1([bool("requireIncomingTransferMemos")])
  , MEMO_TRANSFER_SIZE = MemoTransferLayout.span
  , MetadataPointerLayout = struct$1([publicKey("authority"), publicKey("metadataAddress")])
  , METADATA_POINTER_SIZE = MetadataPointerLayout.span
  , MintCloseAuthorityLayout = struct$1([publicKey("closeAuthority")])
  , MINT_CLOSE_AUTHORITY_SIZE = MintCloseAuthorityLayout.span
  , NonTransferableLayout = struct$1([])
  , NON_TRANSFERABLE_SIZE = NonTransferableLayout.span
  , NON_TRANSFERABLE_ACCOUNT_SIZE = NonTransferableLayout.span
  , PausableConfigLayout = struct$1([publicKey("authority"), bool("paused")])
  , PAUSABLE_CONFIG_SIZE = PausableConfigLayout.span
  , PausableAccountLayout = struct$1([])
  , PAUSABLE_ACCOUNT_SIZE = PausableAccountLayout.span
  , PermanentDelegateLayout = struct$1([publicKey("delegate")])
  , PERMANENT_DELEGATE_SIZE = PermanentDelegateLayout.span
  , ScaledUiAmountConfigLayout = struct$1([publicKey("authority"), f64("multiplier"), u64("newMultiplierEffectiveTimestamp"), f64("newMultiplier")])
  , SCALED_UI_AMOUNT_CONFIG_SIZE = ScaledUiAmountConfigLayout.span
  , MAX_FEE_BASIS_POINTS = 1e4;
BigInt(MAX_FEE_BASIS_POINTS);
function transferFeeLayout(_e) {
    return struct$1([u64("epoch"), u64("maximumFee"), u16("transferFeeBasisPoints")], _e)
}
const TransferFeeConfigLayout = struct$1([publicKey("transferFeeConfigAuthority"), publicKey("withdrawWithheldAuthority"), u64("withheldAmount"), transferFeeLayout("olderTransferFee"), transferFeeLayout("newerTransferFee")])
  , TRANSFER_FEE_CONFIG_SIZE = TransferFeeConfigLayout.span
  , TransferFeeAmountLayout = struct$1([u64("withheldAmount")])
  , TRANSFER_FEE_AMOUNT_SIZE = TransferFeeAmountLayout.span
  , TransferHookLayout = struct$1([publicKey("authority"), publicKey("programId")])
  , TRANSFER_HOOK_SIZE = TransferHookLayout.span
  , TransferHookAccountLayout = struct$1([bool("transferring")])
  , TRANSFER_HOOK_ACCOUNT_SIZE = TransferHookAccountLayout.span
  , ExtraAccountMetaLayout = struct$1([u8$1("discriminator"), blob$1(32, "addressConfig"), bool("isSigner"), bool("isWritable")])
  , ExtraAccountMetaListLayout = struct$1([u32$1("count"), seq(ExtraAccountMetaLayout, greedy(ExtraAccountMetaLayout.span), "extraAccounts")]);
struct$1([u64("instructionDiscriminator"), u32$1("length"), ExtraAccountMetaListLayout.replicate("extraAccountsList")]);
var ExtensionType;
(function(_e) {
    _e[_e.Uninitialized = 0] = "Uninitialized",
    _e[_e.TransferFeeConfig = 1] = "TransferFeeConfig",
    _e[_e.TransferFeeAmount = 2] = "TransferFeeAmount",
    _e[_e.MintCloseAuthority = 3] = "MintCloseAuthority",
    _e[_e.ConfidentialTransferMint = 4] = "ConfidentialTransferMint",
    _e[_e.ConfidentialTransferAccount = 5] = "ConfidentialTransferAccount",
    _e[_e.DefaultAccountState = 6] = "DefaultAccountState",
    _e[_e.ImmutableOwner = 7] = "ImmutableOwner",
    _e[_e.MemoTransfer = 8] = "MemoTransfer",
    _e[_e.NonTransferable = 9] = "NonTransferable",
    _e[_e.InterestBearingConfig = 10] = "InterestBearingConfig",
    _e[_e.CpiGuard = 11] = "CpiGuard",
    _e[_e.PermanentDelegate = 12] = "PermanentDelegate",
    _e[_e.NonTransferableAccount = 13] = "NonTransferableAccount",
    _e[_e.TransferHook = 14] = "TransferHook",
    _e[_e.TransferHookAccount = 15] = "TransferHookAccount",
    _e[_e.MetadataPointer = 18] = "MetadataPointer",
    _e[_e.TokenMetadata = 19] = "TokenMetadata",
    _e[_e.GroupPointer = 20] = "GroupPointer",
    _e[_e.TokenGroup = 21] = "TokenGroup",
    _e[_e.GroupMemberPointer = 22] = "GroupMemberPointer",
    _e[_e.TokenGroupMember = 23] = "TokenGroupMember",
    _e[_e.ScaledUiAmountConfig = 25] = "ScaledUiAmountConfig",
    _e[_e.PausableConfig = 26] = "PausableConfig",
    _e[_e.PausableAccount = 27] = "PausableAccount"
}
)(ExtensionType || (ExtensionType = {}));
const TYPE_SIZE = 2
  , LENGTH_SIZE = 2;
function addTypeAndLengthToLen(_e) {
    return _e + TYPE_SIZE + LENGTH_SIZE
}
function isVariableLengthExtension(_e) {
    switch (_e) {
    case ExtensionType.TokenMetadata:
        return !0;
    default:
        return !1
    }
}
function getTypeLen(_e) {
    switch (_e) {
    case ExtensionType.Uninitialized:
        return 0;
    case ExtensionType.TransferFeeConfig:
        return TRANSFER_FEE_CONFIG_SIZE;
    case ExtensionType.TransferFeeAmount:
        return TRANSFER_FEE_AMOUNT_SIZE;
    case ExtensionType.MintCloseAuthority:
        return MINT_CLOSE_AUTHORITY_SIZE;
    case ExtensionType.ConfidentialTransferMint:
        return 65;
    case ExtensionType.ConfidentialTransferAccount:
        return 295;
    case ExtensionType.CpiGuard:
        return CPI_GUARD_SIZE;
    case ExtensionType.DefaultAccountState:
        return DEFAULT_ACCOUNT_STATE_SIZE;
    case ExtensionType.ImmutableOwner:
        return IMMUTABLE_OWNER_SIZE;
    case ExtensionType.MemoTransfer:
        return MEMO_TRANSFER_SIZE;
    case ExtensionType.MetadataPointer:
        return METADATA_POINTER_SIZE;
    case ExtensionType.NonTransferable:
        return NON_TRANSFERABLE_SIZE;
    case ExtensionType.InterestBearingConfig:
        return INTEREST_BEARING_MINT_CONFIG_STATE_SIZE;
    case ExtensionType.PermanentDelegate:
        return PERMANENT_DELEGATE_SIZE;
    case ExtensionType.NonTransferableAccount:
        return NON_TRANSFERABLE_ACCOUNT_SIZE;
    case ExtensionType.TransferHook:
        return TRANSFER_HOOK_SIZE;
    case ExtensionType.TransferHookAccount:
        return TRANSFER_HOOK_ACCOUNT_SIZE;
    case ExtensionType.GroupPointer:
        return GROUP_POINTER_SIZE;
    case ExtensionType.GroupMemberPointer:
        return GROUP_MEMBER_POINTER_SIZE;
    case ExtensionType.TokenGroup:
        return TOKEN_GROUP_SIZE;
    case ExtensionType.TokenGroupMember:
        return TOKEN_GROUP_MEMBER_SIZE;
    case ExtensionType.ScaledUiAmountConfig:
        return SCALED_UI_AMOUNT_CONFIG_SIZE;
    case ExtensionType.PausableConfig:
        return PAUSABLE_CONFIG_SIZE;
    case ExtensionType.PausableAccount:
        return PAUSABLE_ACCOUNT_SIZE;
    case ExtensionType.TokenMetadata:
        throw Error(`Cannot get type length for variable extension type: ${_e}`);
    default:
        throw Error(`Unknown extension type: ${_e}`)
    }
}
function getLen(_e, $, et={}) {
    if (_e.length === 0 && Object.keys(et).length === 0)
        return $;
    {
        const tt = ACCOUNT_SIZE + ACCOUNT_TYPE_SIZE + _e.filter( (nt, rt) => rt === _e.indexOf(nt)).map(nt => addTypeAndLengthToLen(getTypeLen(nt))).reduce( (nt, rt) => nt + rt, 0) + Object.entries(et).map( ([nt,rt]) => {
            if (!isVariableLengthExtension(Number(nt)))
                throw Error(`Extension ${nt} is not variable length`);
            return addTypeAndLengthToLen(rt)
        }
        ).reduce( (nt, rt) => nt + rt, 0);
        return tt === MULTISIG_SIZE ? tt + TYPE_SIZE : tt
    }
}
function getAccountLen(_e) {
    return getLen(_e, ACCOUNT_SIZE)
}
const MintLayout = struct$1([u32$1("mintAuthorityOption"), publicKey("mintAuthority"), u64("supply"), u8$1("decimals"), bool("isInitialized"), u32$1("freezeAuthorityOption"), publicKey("freezeAuthority")]);
MintLayout.span;
function getAssociatedTokenAddressSync(_e, $, et=!1, tt=TOKEN_PROGRAM_ID, nt=ASSOCIATED_TOKEN_PROGRAM_ID) {
    if (!et && !PublicKey.isOnCurve($.toBuffer()))
        throw new TokenOwnerOffCurveError;
    const [rt] = PublicKey.findProgramAddressSync([$.toBuffer(), tt.toBuffer(), _e.toBuffer()], nt);
    return rt
}
function createAssociatedTokenAccountInstruction(_e, $, et, tt, nt=TOKEN_PROGRAM_ID, rt=ASSOCIATED_TOKEN_PROGRAM_ID) {
    return buildAssociatedTokenAccountInstruction(_e, $, et, tt, Buffer$2.alloc(0), nt, rt)
}
function buildAssociatedTokenAccountInstruction(_e, $, et, tt, nt, rt=TOKEN_PROGRAM_ID, it=ASSOCIATED_TOKEN_PROGRAM_ID) {
    const ot = [{
        pubkey: _e,
        isSigner: !0,
        isWritable: !0
    }, {
        pubkey: $,
        isSigner: !1,
        isWritable: !0
    }, {
        pubkey: et,
        isSigner: !1,
        isWritable: !1
    }, {
        pubkey: tt,
        isSigner: !1,
        isWritable: !1
    }, {
        pubkey: SystemProgram.programId,
        isSigner: !1,
        isWritable: !1
    }, {
        pubkey: rt,
        isSigner: !1,
        isWritable: !1
    }];
    return new TransactionInstruction({
        keys: ot,
        programId: it,
        data: nt
    })
}
function useFirstMountState() {
    var _e = reactExports.useRef(!0);
    return _e.current ? (_e.current = !1,
    !0) : _e.current
}
var useUpdateEffect = function(_e, $) {
    var et = useFirstMountState();
    reactExports.useEffect(function() {
        if (!et)
            return _e()
    }, $)
}
  , noop$2 = function() {};
function on(_e) {
    for (var $ = [], et = 1; et < arguments.length; et++)
        $[et - 1] = arguments[et];
    _e && _e.addEventListener && _e.addEventListener.apply(_e, $)
}
function off(_e) {
    for (var $ = [], et = 1; et < arguments.length; et++)
        $[et - 1] = arguments[et];
    _e && _e.removeEventListener && _e.removeEventListener.apply(_e, $)
}
var isBrowser = typeof window < "u"
  , toggleSelection = function() {
    var _e = document.getSelection();
    if (!_e.rangeCount)
        return function() {}
        ;
    for (var $ = document.activeElement, et = [], tt = 0; tt < _e.rangeCount; tt++)
        et.push(_e.getRangeAt(tt));
    switch ($.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
        $.blur();
        break;
    default:
        $ = null;
        break
    }
    return _e.removeAllRanges(),
    function() {
        _e.type === "Caret" && _e.removeAllRanges(),
        _e.rangeCount || et.forEach(function(nt) {
            _e.addRange(nt)
        }),
        $ && $.focus()
    }
}
  , deselectCurrent = toggleSelection
  , clipboardToIE11Formatting = {
    "text/plain": "Text",
    "text/html": "Url",
    default: "Text"
}
  , defaultMessage = "Copy to clipboard: #{key}, Enter";
function format(_e) {
    var $ = (/mac os x/i.test(navigator.userAgent) ? "" : "Ctrl") + "+C";
    return _e.replace(/#{\s*key\s*}/g, $)
}
function copy(_e, $) {
    var et, tt, nt, rt, it, ot, st = !1;
    $ || ($ = {}),
    et = $.debug || !1;
    try {
        nt = deselectCurrent(),
        rt = document.createRange(),
        it = document.getSelection(),
        ot = document.createElement("span"),
        ot.textContent = _e,
        ot.ariaHidden = "true",
        ot.style.all = "unset",
        ot.style.position = "fixed",
        ot.style.top = 0,
        ot.style.clip = "rect(0, 0, 0, 0)",
        ot.style.whiteSpace = "pre",
        ot.style.webkitUserSelect = "text",
        ot.style.MozUserSelect = "text",
        ot.style.msUserSelect = "text",
        ot.style.userSelect = "text",
        ot.addEventListener("copy", function(ct) {
            if (ct.stopPropagation(),
            $.format)
                if (ct.preventDefault(),
                typeof ct.clipboardData > "u") {
                    window.clipboardData.clearData();
                    var dt = clipboardToIE11Formatting[$.format] || clipboardToIE11Formatting.default;
                    window.clipboardData.setData(dt, _e)
                } else
                    ct.clipboardData.clearData(),
                    ct.clipboardData.setData($.format, _e);
            $.onCopy && (ct.preventDefault(),
            $.onCopy(ct.clipboardData))
        }),
        document.body.appendChild(ot),
        rt.selectNodeContents(ot),
        it.addRange(rt);
        var lt = document.execCommand("copy");
        if (!lt)
            throw new Error("copy command was unsuccessful");
        st = !0
    } catch {
        try {
            window.clipboardData.setData($.format || "text", _e),
            $.onCopy && $.onCopy(window.clipboardData),
            st = !0
        } catch {
            tt = format("message"in $ ? $.message : defaultMessage),
            window.prompt(tt, _e)
        }
    } finally {
        it && (typeof it.removeRange == "function" ? it.removeRange(rt) : it.removeAllRanges()),
        ot && document.body.removeChild(ot),
        nt()
    }
    return st
}
var copyToClipboard = copy;
const copy$1 = getDefaultExportFromCjs$2(copyToClipboard);
function useTimeoutFn(_e, $) {
    var et = reactExports.useRef(!1)
      , tt = reactExports.useRef()
      , nt = reactExports.useRef(_e)
      , rt = reactExports.useCallback(function() {
        return et.current
    }, [])
      , it = reactExports.useCallback(function() {
        et.current = !1,
        tt.current && clearTimeout(tt.current),
        tt.current = setTimeout(function() {
            et.current = !0,
            nt.current()
        }, $)
    }, [$])
      , ot = reactExports.useCallback(function() {
        et.current = null,
        tt.current && clearTimeout(tt.current)
    }, []);
    return reactExports.useEffect(function() {
        nt.current = _e
    }, [_e]),
    reactExports.useEffect(function() {
        return it(),
        ot
    }, [$]),
    [rt, ot, it]
}
function useDebounce(_e, $, et) {
    et === void 0 && (et = []);
    var tt = useTimeoutFn(_e, $)
      , nt = tt[0]
      , rt = tt[1]
      , it = tt[2];
    return reactExports.useEffect(it, et),
    [nt, rt]
}
var useInterval = function(_e, $) {
    var et = reactExports.useRef(function() {});
    reactExports.useEffect(function() {
        et.current = _e
    }),
    reactExports.useEffect(function() {
        if ($ !== null) {
            var tt = setInterval(function() {
                return et.current()
            }, $ || 0);
            return function() {
                return clearInterval(tt)
            }
        }
    }, [$])
}
  , getValue$1 = function(_e, $) {
    return new URLSearchParams(_e).get($)
}
  , useSearchParam = function(_e) {
    var $ = window.location
      , et = reactExports.useState(function() {
        return getValue$1($.search, _e)
    })
      , tt = et[0]
      , nt = et[1];
    return reactExports.useEffect(function() {
        var rt = function() {
            nt(getValue$1($.search, _e))
        };
        return on(window, "popstate", rt),
        on(window, "pushstate", rt),
        on(window, "replacestate", rt),
        function() {
            off(window, "popstate", rt),
            off(window, "pushstate", rt),
            off(window, "replacestate", rt)
        }
    }, []),
    tt
}
  , useSearchParamServer = function() {
    return null
};
const useSearchParam$1 = isBrowser ? useSearchParam : useSearchParamServer;
function getDefaultExportFromCjs(_e) {
    return _e && _e.__esModule && Object.prototype.hasOwnProperty.call(_e, "default") ? _e.default : _e
}
var browser$1 = {
    exports: {}
}, process = browser$1.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
    throw new Error("setTimeout has not been defined")
}
function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined")
}
(function() {
    try {
        typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout
    } catch {
        cachedSetTimeout = defaultSetTimout
    }
    try {
        typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout
    } catch {
        cachedClearTimeout = defaultClearTimeout
    }
}
)();
function runTimeout(_e) {
    if (cachedSetTimeout === setTimeout)
        return setTimeout(_e, 0);
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
        return cachedSetTimeout = setTimeout,
        setTimeout(_e, 0);
    try {
        return cachedSetTimeout(_e, 0)
    } catch {
        try {
            return cachedSetTimeout.call(null, _e, 0)
        } catch {
            return cachedSetTimeout.call(this, _e, 0)
        }
    }
}
function runClearTimeout(_e) {
    if (cachedClearTimeout === clearTimeout)
        return clearTimeout(_e);
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
        return cachedClearTimeout = clearTimeout,
        clearTimeout(_e);
    try {
        return cachedClearTimeout(_e)
    } catch {
        try {
            return cachedClearTimeout.call(null, _e)
        } catch {
            return cachedClearTimeout.call(this, _e)
        }
    }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
    !draining || !currentQueue || (draining = !1,
    currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1,
    queue.length && drainQueue())
}
function drainQueue() {
    if (!draining) {
        var _e = runTimeout(cleanUpNextTick);
        draining = !0;
        for (var $ = queue.length; $; ) {
            for (currentQueue = queue,
            queue = []; ++queueIndex < $; )
                currentQueue && currentQueue[queueIndex].run();
            queueIndex = -1,
            $ = queue.length
        }
        currentQueue = null,
        draining = !1,
        runClearTimeout(_e)
    }
}
process.nextTick = function(_e) {
    var $ = new Array(arguments.length - 1);
    if (arguments.length > 1)
        for (var et = 1; et < arguments.length; et++)
            $[et - 1] = arguments[et];
    queue.push(new Item(_e,$)),
    queue.length === 1 && !draining && runTimeout(drainQueue)
}
;
function Item(_e, $) {
    this.fun = _e,
    this.array = $
}
Item.prototype.run = function() {
    this.fun.apply(null, this.array)
}
;
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop$1() {}
process.on = noop$1;
process.addListener = noop$1;
process.once = noop$1;
process.off = noop$1;
process.removeListener = noop$1;
process.removeAllListeners = noop$1;
process.emit = noop$1;
process.prependListener = noop$1;
process.prependOnceListener = noop$1;
process.listeners = function(_e) {
    return []
}
;
process.binding = function(_e) {
    throw new Error("process.binding is not supported")
}
;
process.cwd = function() {
    return "/"
}
;
process.chdir = function(_e) {
    throw new Error("process.chdir is not supported")
}
;
process.umask = function() {
    return 0
}
;
var browserExports = browser$1.exports;
const process$1 = getDefaultExportFromCjs(browserExports);
function bind(_e, $) {
    return function() {
        return _e.apply($, arguments)
    }
}
const {toString: toString$4} = Object.prototype
  , {getPrototypeOf: getPrototypeOf$1} = Object
  , kindOf = (_e => $ => {
    const et = toString$4.call($);
    return _e[et] || (_e[et] = et.slice(8, -1).toLowerCase())
}
)(Object.create(null))
  , kindOfTest = _e => (_e = _e.toLowerCase(),
$ => kindOf($) === _e)
  , typeOfTest = _e => $ => typeof $ === _e
  , {isArray: isArray$4} = Array
  , isUndefined = typeOfTest("undefined");
function isBuffer$1(_e) {
    return _e !== null && !isUndefined(_e) && _e.constructor !== null && !isUndefined(_e.constructor) && isFunction$2(_e.constructor.isBuffer) && _e.constructor.isBuffer(_e)
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(_e) {
    let $;
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? $ = ArrayBuffer.isView(_e) : $ = _e && _e.buffer && isArrayBuffer(_e.buffer),
    $
}
const isString$2 = typeOfTest("string")
  , isFunction$2 = typeOfTest("function")
  , isNumber = typeOfTest("number")
  , isObject$e = _e => _e !== null && typeof _e == "object"
  , isBoolean = _e => _e === !0 || _e === !1
  , isPlainObject$2 = _e => {
    if (kindOf(_e) !== "object")
        return !1;
    const $ = getPrototypeOf$1(_e);
    return ($ === null || $ === Object.prototype || Object.getPrototypeOf($) === null) && !(Symbol.toStringTag in _e) && !(Symbol.iterator in _e)
}
  , isDate$1 = kindOfTest("Date")
  , isFile = kindOfTest("File")
  , isBlob = kindOfTest("Blob")
  , isFileList = kindOfTest("FileList")
  , isStream = _e => isObject$e(_e) && isFunction$2(_e.pipe)
  , isFormData = _e => {
    let $;
    return _e && (typeof FormData == "function" && _e instanceof FormData || isFunction$2(_e.append) && (($ = kindOf(_e)) === "formdata" || $ === "object" && isFunction$2(_e.toString) && _e.toString() === "[object FormData]"))
}
  , isURLSearchParams = kindOfTest("URLSearchParams")
  , [isReadableStream,isRequest,isResponse,isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest)
  , trim = _e => _e.trim ? _e.trim() : _e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach$1(_e, $, {allOwnKeys: et=!1}={}) {
    if (_e === null || typeof _e > "u")
        return;
    let tt, nt;
    if (typeof _e != "object" && (_e = [_e]),
    isArray$4(_e))
        for (tt = 0,
        nt = _e.length; tt < nt; tt++)
            $.call(null, _e[tt], tt, _e);
    else {
        const rt = et ? Object.getOwnPropertyNames(_e) : Object.keys(_e)
          , it = rt.length;
        let ot;
        for (tt = 0; tt < it; tt++)
            ot = rt[tt],
            $.call(null, _e[ot], ot, _e)
    }
}
function findKey(_e, $) {
    $ = $.toLowerCase();
    const et = Object.keys(_e);
    let tt = et.length, nt;
    for (; tt-- > 0; )
        if (nt = et[tt],
        $ === nt.toLowerCase())
            return nt;
    return null
}
const _global$1 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : globalThis
  , isContextDefined = _e => !isUndefined(_e) && _e !== _global$1;
function merge$1() {
    const {caseless: _e} = isContextDefined(this) && this || {}
      , $ = {}
      , et = (tt, nt) => {
        const rt = _e && findKey($, nt) || nt;
        isPlainObject$2($[rt]) && isPlainObject$2(tt) ? $[rt] = merge$1($[rt], tt) : isPlainObject$2(tt) ? $[rt] = merge$1({}, tt) : isArray$4(tt) ? $[rt] = tt.slice() : $[rt] = tt
    }
    ;
    for (let tt = 0, nt = arguments.length; tt < nt; tt++)
        arguments[tt] && forEach$1(arguments[tt], et);
    return $
}
const extend$3 = (_e, $, et, {allOwnKeys: tt}={}) => (forEach$1($, (nt, rt) => {
    et && isFunction$2(nt) ? _e[rt] = bind(nt, et) : _e[rt] = nt
}
, {
    allOwnKeys: tt
}),
_e)
  , stripBOM = _e => (_e.charCodeAt(0) === 65279 && (_e = _e.slice(1)),
_e)
  , inherits = (_e, $, et, tt) => {
    _e.prototype = Object.create($.prototype, tt),
    _e.prototype.constructor = _e,
    Object.defineProperty(_e, "super", {
        value: $.prototype
    }),
    et && Object.assign(_e.prototype, et)
}
  , toFlatObject = (_e, $, et, tt) => {
    let nt, rt, it;
    const ot = {};
    if ($ = $ || {},
    _e == null)
        return $;
    do {
        for (nt = Object.getOwnPropertyNames(_e),
        rt = nt.length; rt-- > 0; )
            it = nt[rt],
            (!tt || tt(it, _e, $)) && !ot[it] && ($[it] = _e[it],
            ot[it] = !0);
        _e = et !== !1 && getPrototypeOf$1(_e)
    } while (_e && (!et || et(_e, $)) && _e !== Object.prototype);
    return $
}
  , endsWith = (_e, $, et) => {
    _e = String(_e),
    (et === void 0 || et > _e.length) && (et = _e.length),
    et -= $.length;
    const tt = _e.indexOf($, et);
    return tt !== -1 && tt === et
}
  , toArray$1 = _e => {
    if (!_e)
        return null;
    if (isArray$4(_e))
        return _e;
    let $ = _e.length;
    if (!isNumber($))
        return null;
    const et = new Array($);
    for (; $-- > 0; )
        et[$] = _e[$];
    return et
}
  , isTypedArray$1 = (_e => $ => _e && $ instanceof _e)(typeof Uint8Array < "u" && getPrototypeOf$1(Uint8Array))
  , forEachEntry = (_e, $) => {
    const tt = (_e && _e[Symbol.iterator]).call(_e);
    let nt;
    for (; (nt = tt.next()) && !nt.done; ) {
        const rt = nt.value;
        $.call(_e, rt[0], rt[1])
    }
}
  , matchAll = (_e, $) => {
    let et;
    const tt = [];
    for (; (et = _e.exec($)) !== null; )
        tt.push(et);
    return tt
}
  , isHTMLForm = kindOfTest("HTMLFormElement")
  , toCamelCase = _e => _e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function(et, tt, nt) {
    return tt.toUpperCase() + nt
})
  , hasOwnProperty$c = ( ({hasOwnProperty: _e}) => ($, et) => _e.call($, et))(Object.prototype)
  , isRegExp$3 = kindOfTest("RegExp")
  , reduceDescriptors = (_e, $) => {
    const et = Object.getOwnPropertyDescriptors(_e)
      , tt = {};
    forEach$1(et, (nt, rt) => {
        let it;
        (it = $(nt, rt, _e)) !== !1 && (tt[rt] = it || nt)
    }
    ),
    Object.defineProperties(_e, tt)
}
  , freezeMethods = _e => {
    reduceDescriptors(_e, ($, et) => {
        if (isFunction$2(_e) && ["arguments", "caller", "callee"].indexOf(et) !== -1)
            return !1;
        const tt = _e[et];
        if (isFunction$2(tt)) {
            if ($.enumerable = !1,
            "writable"in $) {
                $.writable = !1;
                return
            }
            $.set || ($.set = () => {
                throw Error("Can not rewrite read-only method '" + et + "'")
            }
            )
        }
    }
    )
}
  , toObjectSet = (_e, $) => {
    const et = {}
      , tt = nt => {
        nt.forEach(rt => {
            et[rt] = !0
        }
        )
    }
    ;
    return isArray$4(_e) ? tt(_e) : tt(String(_e).split($)),
    et
}
  , noop = () => {}
  , toFiniteNumber = (_e, $) => _e != null && Number.isFinite(_e = +_e) ? _e : $
  , ALPHA = "abcdefghijklmnopqrstuvwxyz"
  , DIGIT = "0123456789"
  , ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}
  , generateString = (_e=16, $=ALPHABET.ALPHA_DIGIT) => {
    let et = "";
    const {length: tt} = $;
    for (; _e--; )
        et += $[Math.random() * tt | 0];
    return et
}
;
function isSpecCompliantForm(_e) {
    return !!(_e && isFunction$2(_e.append) && _e[Symbol.toStringTag] === "FormData" && _e[Symbol.iterator])
}
const toJSONObject = _e => {
    const $ = new Array(10)
      , et = (tt, nt) => {
        if (isObject$e(tt)) {
            if ($.indexOf(tt) >= 0)
                return;
            if (!("toJSON"in tt)) {
                $[nt] = tt;
                const rt = isArray$4(tt) ? [] : {};
                return forEach$1(tt, (it, ot) => {
                    const st = et(it, nt + 1);
                    !isUndefined(st) && (rt[ot] = st)
                }
                ),
                $[nt] = void 0,
                rt
            }
        }
        return tt
    }
    ;
    return et(_e, 0)
}
  , isAsyncFn = kindOfTest("AsyncFunction")
  , isThenable$1 = _e => _e && (isObject$e(_e) || isFunction$2(_e)) && isFunction$2(_e.then) && isFunction$2(_e.catch)
  , _setImmediate = ( (_e, $) => _e ? setImmediate : $ ? ( (et, tt) => (_global$1.addEventListener("message", ({source: nt, data: rt}) => {
    nt === _global$1 && rt === et && tt.length && tt.shift()()
}
, !1),
nt => {
    tt.push(nt),
    _global$1.postMessage(et, "*")
}
))(`axios@${Math.random()}`, []) : et => setTimeout(et))(typeof setImmediate == "function", isFunction$2(_global$1.postMessage))
  , asap = typeof queueMicrotask < "u" ? queueMicrotask.bind(_global$1) : typeof process$1 < "u" && process$1.nextTick || _setImmediate
  , utils$1 = {
    isArray: isArray$4,
    isArrayBuffer,
    isBuffer: isBuffer$1,
    isFormData,
    isArrayBufferView,
    isString: isString$2,
    isNumber,
    isBoolean,
    isObject: isObject$e,
    isPlainObject: isPlainObject$2,
    isReadableStream,
    isRequest,
    isResponse,
    isHeaders,
    isUndefined,
    isDate: isDate$1,
    isFile,
    isBlob,
    isRegExp: isRegExp$3,
    isFunction: isFunction$2,
    isStream,
    isURLSearchParams,
    isTypedArray: isTypedArray$1,
    isFileList,
    forEach: forEach$1,
    merge: merge$1,
    extend: extend$3,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray: toArray$1,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty: hasOwnProperty$c,
    hasOwnProp: hasOwnProperty$c,
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop,
    toFiniteNumber,
    findKey,
    global: _global$1,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable: isThenable$1,
    setImmediate: _setImmediate,
    asap
};
function AxiosError$1(_e, $, et, tt, nt) {
    Error.call(this),
    Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack,
    this.message = _e,
    this.name = "AxiosError",
    $ && (this.code = $),
    et && (this.config = et),
    tt && (this.request = tt),
    nt && (this.response = nt,
    this.status = nt.status ? nt.status : null)
}
utils$1.inherits(AxiosError$1, Error, {
    toJSON: function() {
        return {
            message: this.message,
            name: this.name,
            description: this.description,
            number: this.number,
            fileName: this.fileName,
            lineNumber: this.lineNumber,
            columnNumber: this.columnNumber,
            stack: this.stack,
            config: utils$1.toJSONObject(this.config),
            code: this.code,
            status: this.status
        }
    }
});
const prototype$1 = AxiosError$1.prototype
  , descriptors = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(_e => {
    descriptors[_e] = {
        value: _e
    }
}
);
Object.defineProperties(AxiosError$1, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", {
    value: !0
});
AxiosError$1.from = (_e, $, et, tt, nt, rt) => {
    const it = Object.create(prototype$1);
    return utils$1.toFlatObject(_e, it, function(st) {
        return st !== Error.prototype
    }, ot => ot !== "isAxiosError"),
    AxiosError$1.call(it, _e.message, $, et, tt, nt),
    it.cause = _e,
    it.name = _e.name,
    rt && Object.assign(it, rt),
    it
}
;
const httpAdapter = null;
function isVisitable(_e) {
    return utils$1.isPlainObject(_e) || utils$1.isArray(_e)
}
function removeBrackets(_e) {
    return utils$1.endsWith(_e, "[]") ? _e.slice(0, -2) : _e
}
function renderKey(_e, $, et) {
    return _e ? _e.concat($).map(function(nt, rt) {
        return nt = removeBrackets(nt),
        !et && rt ? "[" + nt + "]" : nt
    }).join(et ? "." : "") : $
}
function isFlatArray(_e) {
    return utils$1.isArray(_e) && !_e.some(isVisitable)
}
const predicates = utils$1.toFlatObject(utils$1, {}, null, function($) {
    return /^is[A-Z]/.test($)
});
function toFormData$1(_e, $, et) {
    if (!utils$1.isObject(_e))
        throw new TypeError("target must be an object");
    $ = $ || new FormData,
    et = utils$1.toFlatObject(et, {
        metaTokens: !0,
        dots: !1,
        indexes: !1
    }, !1, function(yt, Et) {
        return !utils$1.isUndefined(Et[yt])
    });
    const tt = et.metaTokens
      , nt = et.visitor || ct
      , rt = et.dots
      , it = et.indexes
      , st = (et.Blob || typeof Blob < "u" && Blob) && utils$1.isSpecCompliantForm($);
    if (!utils$1.isFunction(nt))
        throw new TypeError("visitor must be a function");
    function lt(mt) {
        if (mt === null)
            return "";
        if (utils$1.isDate(mt))
            return mt.toISOString();
        if (!st && utils$1.isBlob(mt))
            throw new AxiosError$1("Blob is not supported. Use a Buffer instead.");
        return utils$1.isArrayBuffer(mt) || utils$1.isTypedArray(mt) ? st && typeof Blob == "function" ? new Blob([mt]) : Buffer$2.from(mt) : mt
    }
    function ct(mt, yt, Et) {
        let _t = mt;
        if (mt && !Et && typeof mt == "object") {
            if (utils$1.endsWith(yt, "{}"))
                yt = tt ? yt : yt.slice(0, -2),
                mt = JSON.stringify(mt);
            else if (utils$1.isArray(mt) && isFlatArray(mt) || (utils$1.isFileList(mt) || utils$1.endsWith(yt, "[]")) && (_t = utils$1.toArray(mt)))
                return yt = removeBrackets(yt),
                _t.forEach(function(St, Ct) {
                    !(utils$1.isUndefined(St) || St === null) && $.append(it === !0 ? renderKey([yt], Ct, rt) : it === null ? yt : yt + "[]", lt(St))
                }),
                !1
        }
        return isVisitable(mt) ? !0 : ($.append(renderKey(Et, yt, rt), lt(mt)),
        !1)
    }
    const dt = []
      , pt = Object.assign(predicates, {
        defaultVisitor: ct,
        convertValue: lt,
        isVisitable
    });
    function ht(mt, yt) {
        if (!utils$1.isUndefined(mt)) {
            if (dt.indexOf(mt) !== -1)
                throw Error("Circular reference detected in " + yt.join("."));
            dt.push(mt),
            utils$1.forEach(mt, function(_t, wt) {
                (!(utils$1.isUndefined(_t) || _t === null) && nt.call($, _t, utils$1.isString(wt) ? wt.trim() : wt, yt, pt)) === !0 && ht(_t, yt ? yt.concat(wt) : [wt])
            }),
            dt.pop()
        }
    }
    if (!utils$1.isObject(_e))
        throw new TypeError("data must be an object");
    return ht(_e),
    $
}
function encode$1(_e) {
    const $ = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
    };
    return encodeURIComponent(_e).replace(/[!'()~]|%20|%00/g, function(tt) {
        return $[tt]
    })
}
function AxiosURLSearchParams(_e, $) {
    this._pairs = [],
    _e && toFormData$1(_e, this, $)
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function($, et) {
    this._pairs.push([$, et])
}
;
prototype.toString = function($) {
    const et = $ ? function(tt) {
        return $.call(this, tt, encode$1)
    }
    : encode$1;
    return this._pairs.map(function(nt) {
        return et(nt[0]) + "=" + et(nt[1])
    }, "").join("&")
}
;
function encode(_e) {
    return encodeURIComponent(_e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}
function buildURL(_e, $, et) {
    if (!$)
        return _e;
    const tt = et && et.encode || encode;
    utils$1.isFunction(et) && (et = {
        serialize: et
    });
    const nt = et && et.serialize;
    let rt;
    if (nt ? rt = nt($, et) : rt = utils$1.isURLSearchParams($) ? $.toString() : new AxiosURLSearchParams($,et).toString(tt),
    rt) {
        const it = _e.indexOf("#");
        it !== -1 && (_e = _e.slice(0, it)),
        _e += (_e.indexOf("?") === -1 ? "?" : "&") + rt
    }
    return _e
}
class InterceptorManager {
    constructor() {
        this.handlers = []
    }
    use($, et, tt) {
        return this.handlers.push({
            fulfilled: $,
            rejected: et,
            synchronous: tt ? tt.synchronous : !1,
            runWhen: tt ? tt.runWhen : null
        }),
        this.handlers.length - 1
    }
    eject($) {
        this.handlers[$] && (this.handlers[$] = null)
    }
    clear() {
        this.handlers && (this.handlers = [])
    }
    forEach($) {
        utils$1.forEach(this.handlers, function(tt) {
            tt !== null && $(tt)
        })
    }
}
const transitionalDefaults = {
    silentJSONParsing: !0,
    forcedJSONParsing: !0,
    clarifyTimeoutError: !1
}
  , URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams
  , FormData$1 = typeof FormData < "u" ? FormData : null
  , Blob$1 = typeof Blob < "u" ? Blob : null
  , platform$1 = {
    isBrowser: !0,
    classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
    },
    protocols: ["http", "https", "file", "blob", "url", "data"]
}
  , hasBrowserEnv = typeof window < "u" && typeof document < "u"
  , _navigator = typeof navigator == "object" && navigator || void 0
  , hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0)
  , hasStandardBrowserWebWorkerEnv = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function"
  , origin = hasBrowserEnv && window.location.href || "http://localhost"
  , utils = Object.freeze(Object.defineProperty({
    __proto__: null,
    hasBrowserEnv,
    hasStandardBrowserEnv,
    hasStandardBrowserWebWorkerEnv,
    navigator: _navigator,
    origin
}, Symbol.toStringTag, {
    value: "Module"
}))
  , platform = {
    ...utils,
    ...platform$1
};
function toURLEncodedForm(_e, $) {
    return toFormData$1(_e, new platform.classes.URLSearchParams, Object.assign({
        visitor: function(et, tt, nt, rt) {
            return platform.isNode && utils$1.isBuffer(et) ? (this.append(tt, et.toString("base64")),
            !1) : rt.defaultVisitor.apply(this, arguments)
        }
    }, $))
}
function parsePropPath(_e) {
    return utils$1.matchAll(/\w+|\[(\w*)]/g, _e).map($ => $[0] === "[]" ? "" : $[1] || $[0])
}
function arrayToObject(_e) {
    const $ = {}
      , et = Object.keys(_e);
    let tt;
    const nt = et.length;
    let rt;
    for (tt = 0; tt < nt; tt++)
        rt = et[tt],
        $[rt] = _e[rt];
    return $
}
function formDataToJSON(_e) {
    function $(et, tt, nt, rt) {
        let it = et[rt++];
        if (it === "__proto__")
            return !0;
        const ot = Number.isFinite(+it)
          , st = rt >= et.length;
        return it = !it && utils$1.isArray(nt) ? nt.length : it,
        st ? (utils$1.hasOwnProp(nt, it) ? nt[it] = [nt[it], tt] : nt[it] = tt,
        !ot) : ((!nt[it] || !utils$1.isObject(nt[it])) && (nt[it] = []),
        $(et, tt, nt[it], rt) && utils$1.isArray(nt[it]) && (nt[it] = arrayToObject(nt[it])),
        !ot)
    }
    if (utils$1.isFormData(_e) && utils$1.isFunction(_e.entries)) {
        const et = {};
        return utils$1.forEachEntry(_e, (tt, nt) => {
            $(parsePropPath(tt), nt, et, 0)
        }
        ),
        et
    }
    return null
}
function stringifySafely(_e, $, et) {
    if (utils$1.isString(_e))
        try {
            return ($ || JSON.parse)(_e),
            utils$1.trim(_e)
        } catch (tt) {
            if (tt.name !== "SyntaxError")
                throw tt
        }
    return (et || JSON.stringify)(_e)
}
const defaults$1 = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http", "fetch"],
    transformRequest: [function($, et) {
        const tt = et.getContentType() || ""
          , nt = tt.indexOf("application/json") > -1
          , rt = utils$1.isObject($);
        if (rt && utils$1.isHTMLForm($) && ($ = new FormData($)),
        utils$1.isFormData($))
            return nt ? JSON.stringify(formDataToJSON($)) : $;
        if (utils$1.isArrayBuffer($) || utils$1.isBuffer($) || utils$1.isStream($) || utils$1.isFile($) || utils$1.isBlob($) || utils$1.isReadableStream($))
            return $;
        if (utils$1.isArrayBufferView($))
            return $.buffer;
        if (utils$1.isURLSearchParams($))
            return et.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1),
            $.toString();
        let ot;
        if (rt) {
            if (tt.indexOf("application/x-www-form-urlencoded") > -1)
                return toURLEncodedForm($, this.formSerializer).toString();
            if ((ot = utils$1.isFileList($)) || tt.indexOf("multipart/form-data") > -1) {
                const st = this.env && this.env.FormData;
                return toFormData$1(ot ? {
                    "files[]": $
                } : $, st && new st, this.formSerializer)
            }
        }
        return rt || nt ? (et.setContentType("application/json", !1),
        stringifySafely($)) : $
    }
    ],
    transformResponse: [function($) {
        const et = this.transitional || defaults$1.transitional
          , tt = et && et.forcedJSONParsing
          , nt = this.responseType === "json";
        if (utils$1.isResponse($) || utils$1.isReadableStream($))
            return $;
        if ($ && utils$1.isString($) && (tt && !this.responseType || nt)) {
            const it = !(et && et.silentJSONParsing) && nt;
            try {
                return JSON.parse($)
            } catch (ot) {
                if (it)
                    throw ot.name === "SyntaxError" ? AxiosError$1.from(ot, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response) : ot
            }
        }
        return $
    }
    ],
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
    },
    validateStatus: function($) {
        return $ >= 200 && $ < 300
    },
    headers: {
        common: {
            Accept: "application/json, text/plain, */*",
            "Content-Type": void 0
        }
    }
};
utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], _e => {
    defaults$1.headers[_e] = {}
}
);
const ignoreDuplicateOf = utils$1.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"])
  , parseHeaders = _e => {
    const $ = {};
    let et, tt, nt;
    return _e && _e.split(`
`).forEach(function(it) {
        nt = it.indexOf(":"),
        et = it.substring(0, nt).trim().toLowerCase(),
        tt = it.substring(nt + 1).trim(),
        !(!et || $[et] && ignoreDuplicateOf[et]) && (et === "set-cookie" ? $[et] ? $[et].push(tt) : $[et] = [tt] : $[et] = $[et] ? $[et] + ", " + tt : tt)
    }),
    $
}
  , $internals = Symbol("internals");
function normalizeHeader(_e) {
    return _e && String(_e).trim().toLowerCase()
}
function normalizeValue(_e) {
    return _e === !1 || _e == null ? _e : utils$1.isArray(_e) ? _e.map(normalizeValue) : String(_e)
}
function parseTokens(_e) {
    const $ = Object.create(null)
      , et = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let tt;
    for (; tt = et.exec(_e); )
        $[tt[1]] = tt[2];
    return $
}
const isValidHeaderName = _e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(_e.trim());
function matchHeaderValue(_e, $, et, tt, nt) {
    if (utils$1.isFunction(tt))
        return tt.call(this, $, et);
    if (nt && ($ = et),
    !!utils$1.isString($)) {
        if (utils$1.isString(tt))
            return $.indexOf(tt) !== -1;
        if (utils$1.isRegExp(tt))
            return tt.test($)
    }
}
function formatHeader(_e) {
    return _e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, ($, et, tt) => et.toUpperCase() + tt)
}
function buildAccessors(_e, $) {
    const et = utils$1.toCamelCase(" " + $);
    ["get", "set", "has"].forEach(tt => {
        Object.defineProperty(_e, tt + et, {
            value: function(nt, rt, it) {
                return this[tt].call(this, $, nt, rt, it)
            },
            configurable: !0
        })
    }
    )
}
let AxiosHeaders$1 = class {
    constructor($) {
        $ && this.set($)
    }
    set($, et, tt) {
        const nt = this;
        function rt(ot, st, lt) {
            const ct = normalizeHeader(st);
            if (!ct)
                throw new Error("header name must be a non-empty string");
            const dt = utils$1.findKey(nt, ct);
            (!dt || nt[dt] === void 0 || lt === !0 || lt === void 0 && nt[dt] !== !1) && (nt[dt || st] = normalizeValue(ot))
        }
        const it = (ot, st) => utils$1.forEach(ot, (lt, ct) => rt(lt, ct, st));
        if (utils$1.isPlainObject($) || $ instanceof this.constructor)
            it($, et);
        else if (utils$1.isString($) && ($ = $.trim()) && !isValidHeaderName($))
            it(parseHeaders($), et);
        else if (utils$1.isHeaders($))
            for (const [ot,st] of $.entries())
                rt(st, ot, tt);
        else
            $ != null && rt(et, $, tt);
        return this
    }
    get($, et) {
        if ($ = normalizeHeader($),
        $) {
            const tt = utils$1.findKey(this, $);
            if (tt) {
                const nt = this[tt];
                if (!et)
                    return nt;
                if (et === !0)
                    return parseTokens(nt);
                if (utils$1.isFunction(et))
                    return et.call(this, nt, tt);
                if (utils$1.isRegExp(et))
                    return et.exec(nt);
                throw new TypeError("parser must be boolean|regexp|function")
            }
        }
    }
    has($, et) {
        if ($ = normalizeHeader($),
        $) {
            const tt = utils$1.findKey(this, $);
            return !!(tt && this[tt] !== void 0 && (!et || matchHeaderValue(this, this[tt], tt, et)))
        }
        return !1
    }
    delete($, et) {
        const tt = this;
        let nt = !1;
        function rt(it) {
            if (it = normalizeHeader(it),
            it) {
                const ot = utils$1.findKey(tt, it);
                ot && (!et || matchHeaderValue(tt, tt[ot], ot, et)) && (delete tt[ot],
                nt = !0)
            }
        }
        return utils$1.isArray($) ? $.forEach(rt) : rt($),
        nt
    }
    clear($) {
        const et = Object.keys(this);
        let tt = et.length
          , nt = !1;
        for (; tt--; ) {
            const rt = et[tt];
            (!$ || matchHeaderValue(this, this[rt], rt, $, !0)) && (delete this[rt],
            nt = !0)
        }
        return nt
    }
    normalize($) {
        const et = this
          , tt = {};
        return utils$1.forEach(this, (nt, rt) => {
            const it = utils$1.findKey(tt, rt);
            if (it) {
                et[it] = normalizeValue(nt),
                delete et[rt];
                return
            }
            const ot = $ ? formatHeader(rt) : String(rt).trim();
            ot !== rt && delete et[rt],
            et[ot] = normalizeValue(nt),
            tt[ot] = !0
        }
        ),
        this
    }
    concat(...$) {
        return this.constructor.concat(this, ...$)
    }
    toJSON($) {
        const et = Object.create(null);
        return utils$1.forEach(this, (tt, nt) => {
            tt != null && tt !== !1 && (et[nt] = $ && utils$1.isArray(tt) ? tt.join(", ") : tt)
        }
        ),
        et
    }
    [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]()
    }
    toString() {
        return Object.entries(this.toJSON()).map( ([$,et]) => $ + ": " + et).join(`
`)
    }
    get[Symbol.toStringTag]() {
        return "AxiosHeaders"
    }
    static from($) {
        return $ instanceof this ? $ : new this($)
    }
    static concat($, ...et) {
        const tt = new this($);
        return et.forEach(nt => tt.set(nt)),
        tt
    }
    static accessor($) {
        const tt = (this[$internals] = this[$internals] = {
            accessors: {}
        }).accessors
          , nt = this.prototype;
        function rt(it) {
            const ot = normalizeHeader(it);
            tt[ot] || (buildAccessors(nt, it),
            tt[ot] = !0)
        }
        return utils$1.isArray($) ? $.forEach(rt) : rt($),
        this
    }
}
;
AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({value: _e}, $) => {
    let et = $[0].toUpperCase() + $.slice(1);
    return {
        get: () => _e,
        set(tt) {
            this[et] = tt
        }
    }
}
);
utils$1.freezeMethods(AxiosHeaders$1);
function transformData(_e, $) {
    const et = this || defaults$1
      , tt = $ || et
      , nt = AxiosHeaders$1.from(tt.headers);
    let rt = tt.data;
    return utils$1.forEach(_e, function(ot) {
        rt = ot.call(et, rt, nt.normalize(), $ ? $.status : void 0)
    }),
    nt.normalize(),
    rt
}
function isCancel$1(_e) {
    return !!(_e && _e.__CANCEL__)
}
function CanceledError$1(_e, $, et) {
    AxiosError$1.call(this, _e ?? "canceled", AxiosError$1.ERR_CANCELED, $, et),
    this.name = "CanceledError"
}
utils$1.inherits(CanceledError$1, AxiosError$1, {
    __CANCEL__: !0
});
function settle(_e, $, et) {
    const tt = et.config.validateStatus;
    !et.status || !tt || tt(et.status) ? _e(et) : $(new AxiosError$1("Request failed with status code " + et.status,[AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(et.status / 100) - 4],et.config,et.request,et))
}
function parseProtocol(_e) {
    const $ = /^([-+\w]{1,25})(:?\/\/|:)/.exec(_e);
    return $ && $[1] || ""
}
function speedometer(_e, $) {
    _e = _e || 10;
    const et = new Array(_e)
      , tt = new Array(_e);
    let nt = 0, rt = 0, it;
    return $ = $ !== void 0 ? $ : 1e3,
    function(st) {
        const lt = Date.now()
          , ct = tt[rt];
        it || (it = lt),
        et[nt] = st,
        tt[nt] = lt;
        let dt = rt
          , pt = 0;
        for (; dt !== nt; )
            pt += et[dt++],
            dt = dt % _e;
        if (nt = (nt + 1) % _e,
        nt === rt && (rt = (rt + 1) % _e),
        lt - it < $)
            return;
        const ht = ct && lt - ct;
        return ht ? Math.round(pt * 1e3 / ht) : void 0
    }
}
function throttle(_e, $) {
    let et = 0, tt = 1e3 / $, nt, rt;
    const it = (lt, ct=Date.now()) => {
        et = ct,
        nt = null,
        rt && (clearTimeout(rt),
        rt = null),
        _e.apply(null, lt)
    }
    ;
    return [ (...lt) => {
        const ct = Date.now()
          , dt = ct - et;
        dt >= tt ? it(lt, ct) : (nt = lt,
        rt || (rt = setTimeout( () => {
            rt = null,
            it(nt)
        }
        , tt - dt)))
    }
    , () => nt && it(nt)]
}
const progressEventReducer = (_e, $, et=3) => {
    let tt = 0;
    const nt = speedometer(50, 250);
    return throttle(rt => {
        const it = rt.loaded
          , ot = rt.lengthComputable ? rt.total : void 0
          , st = it - tt
          , lt = nt(st)
          , ct = it <= ot;
        tt = it;
        const dt = {
            loaded: it,
            total: ot,
            progress: ot ? it / ot : void 0,
            bytes: st,
            rate: lt || void 0,
            estimated: lt && ot && ct ? (ot - it) / lt : void 0,
            event: rt,
            lengthComputable: ot != null,
            [$ ? "download" : "upload"]: !0
        };
        _e(dt)
    }
    , et)
}
  , progressEventDecorator = (_e, $) => {
    const et = _e != null;
    return [tt => $[0]({
        lengthComputable: et,
        total: _e,
        loaded: tt
    }), $[1]]
}
  , asyncDecorator = _e => (...$) => utils$1.asap( () => _e(...$))
  , isURLSameOrigin = platform.hasStandardBrowserEnv ? ( (_e, $) => et => (et = new URL(et,platform.origin),
_e.protocol === et.protocol && _e.host === et.host && ($ || _e.port === et.port)))(new URL(platform.origin), platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)) : () => !0
  , cookies = platform.hasStandardBrowserEnv ? {
    write(_e, $, et, tt, nt, rt) {
        const it = [_e + "=" + encodeURIComponent($)];
        utils$1.isNumber(et) && it.push("expires=" + new Date(et).toGMTString()),
        utils$1.isString(tt) && it.push("path=" + tt),
        utils$1.isString(nt) && it.push("domain=" + nt),
        rt === !0 && it.push("secure"),
        document.cookie = it.join("; ")
    },
    read(_e) {
        const $ = document.cookie.match(new RegExp("(^|;\\s*)(" + _e + ")=([^;]*)"));
        return $ ? decodeURIComponent($[3]) : null
    },
    remove(_e) {
        this.write(_e, "", Date.now() - 864e5)
    }
} : {
    write() {},
    read() {
        return null
    },
    remove() {}
};
function isAbsoluteURL(_e) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(_e)
}
function combineURLs(_e, $) {
    return $ ? _e.replace(/\/?\/$/, "") + "/" + $.replace(/^\/+/, "") : _e
}
function buildFullPath(_e, $) {
    return _e && !isAbsoluteURL($) ? combineURLs(_e, $) : $
}
const headersToObject = _e => _e instanceof AxiosHeaders$1 ? {
    ..._e
} : _e;
function mergeConfig$1(_e, $) {
    $ = $ || {};
    const et = {};
    function tt(lt, ct, dt, pt) {
        return utils$1.isPlainObject(lt) && utils$1.isPlainObject(ct) ? utils$1.merge.call({
            caseless: pt
        }, lt, ct) : utils$1.isPlainObject(ct) ? utils$1.merge({}, ct) : utils$1.isArray(ct) ? ct.slice() : ct
    }
    function nt(lt, ct, dt, pt) {
        if (utils$1.isUndefined(ct)) {
            if (!utils$1.isUndefined(lt))
                return tt(void 0, lt, dt, pt)
        } else
            return tt(lt, ct, dt, pt)
    }
    function rt(lt, ct) {
        if (!utils$1.isUndefined(ct))
            return tt(void 0, ct)
    }
    function it(lt, ct) {
        if (utils$1.isUndefined(ct)) {
            if (!utils$1.isUndefined(lt))
                return tt(void 0, lt)
        } else
            return tt(void 0, ct)
    }
    function ot(lt, ct, dt) {
        if (dt in $)
            return tt(lt, ct);
        if (dt in _e)
            return tt(void 0, lt)
    }
    const st = {
        url: rt,
        method: rt,
        data: rt,
        baseURL: it,
        transformRequest: it,
        transformResponse: it,
        paramsSerializer: it,
        timeout: it,
        timeoutMessage: it,
        withCredentials: it,
        withXSRFToken: it,
        adapter: it,
        responseType: it,
        xsrfCookieName: it,
        xsrfHeaderName: it,
        onUploadProgress: it,
        onDownloadProgress: it,
        decompress: it,
        maxContentLength: it,
        maxBodyLength: it,
        beforeRedirect: it,
        transport: it,
        httpAgent: it,
        httpsAgent: it,
        cancelToken: it,
        socketPath: it,
        responseEncoding: it,
        validateStatus: ot,
        headers: (lt, ct, dt) => nt(headersToObject(lt), headersToObject(ct), dt, !0)
    };
    return utils$1.forEach(Object.keys(Object.assign({}, _e, $)), function(ct) {
        const dt = st[ct] || nt
          , pt = dt(_e[ct], $[ct], ct);
        utils$1.isUndefined(pt) && dt !== ot || (et[ct] = pt)
    }),
    et
}
const resolveConfig = _e => {
    const $ = mergeConfig$1({}, _e);
    let {data: et, withXSRFToken: tt, xsrfHeaderName: nt, xsrfCookieName: rt, headers: it, auth: ot} = $;
    $.headers = it = AxiosHeaders$1.from(it),
    $.url = buildURL(buildFullPath($.baseURL, $.url), _e.params, _e.paramsSerializer),
    ot && it.set("Authorization", "Basic " + btoa((ot.username || "") + ":" + (ot.password ? unescape(encodeURIComponent(ot.password)) : "")));
    let st;
    if (utils$1.isFormData(et)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv)
            it.setContentType(void 0);
        else if ((st = it.getContentType()) !== !1) {
            const [lt,...ct] = st ? st.split(";").map(dt => dt.trim()).filter(Boolean) : [];
            it.setContentType([lt || "multipart/form-data", ...ct].join("; "))
        }
    }
    if (platform.hasStandardBrowserEnv && (tt && utils$1.isFunction(tt) && (tt = tt($)),
    tt || tt !== !1 && isURLSameOrigin($.url))) {
        const lt = nt && rt && cookies.read(rt);
        lt && it.set(nt, lt)
    }
    return $
}
  , isXHRAdapterSupported = typeof XMLHttpRequest < "u"
  , xhrAdapter = isXHRAdapterSupported && function(_e) {
    return new Promise(function(et, tt) {
        const nt = resolveConfig(_e);
        let rt = nt.data;
        const it = AxiosHeaders$1.from(nt.headers).normalize();
        let {responseType: ot, onUploadProgress: st, onDownloadProgress: lt} = nt, ct, dt, pt, ht, mt;
        function yt() {
            ht && ht(),
            mt && mt(),
            nt.cancelToken && nt.cancelToken.unsubscribe(ct),
            nt.signal && nt.signal.removeEventListener("abort", ct)
        }
        let Et = new XMLHttpRequest;
        Et.open(nt.method.toUpperCase(), nt.url, !0),
        Et.timeout = nt.timeout;
        function _t() {
            if (!Et)
                return;
            const St = AxiosHeaders$1.from("getAllResponseHeaders"in Et && Et.getAllResponseHeaders())
              , Nt = {
                data: !ot || ot === "text" || ot === "json" ? Et.responseText : Et.response,
                status: Et.status,
                statusText: Et.statusText,
                headers: St,
                config: _e,
                request: Et
            };
            settle(function(kt) {
                et(kt),
                yt()
            }, function(kt) {
                tt(kt),
                yt()
            }, Nt),
            Et = null
        }
        "onloadend"in Et ? Et.onloadend = _t : Et.onreadystatechange = function() {
            !Et || Et.readyState !== 4 || Et.status === 0 && !(Et.responseURL && Et.responseURL.indexOf("file:") === 0) || setTimeout(_t)
        }
        ,
        Et.onabort = function() {
            Et && (tt(new AxiosError$1("Request aborted",AxiosError$1.ECONNABORTED,_e,Et)),
            Et = null)
        }
        ,
        Et.onerror = function() {
            tt(new AxiosError$1("Network Error",AxiosError$1.ERR_NETWORK,_e,Et)),
            Et = null
        }
        ,
        Et.ontimeout = function() {
            let Ct = nt.timeout ? "timeout of " + nt.timeout + "ms exceeded" : "timeout exceeded";
            const Nt = nt.transitional || transitionalDefaults;
            nt.timeoutErrorMessage && (Ct = nt.timeoutErrorMessage),
            tt(new AxiosError$1(Ct,Nt.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,_e,Et)),
            Et = null
        }
        ,
        rt === void 0 && it.setContentType(null),
        "setRequestHeader"in Et && utils$1.forEach(it.toJSON(), function(Ct, Nt) {
            Et.setRequestHeader(Nt, Ct)
        }),
        utils$1.isUndefined(nt.withCredentials) || (Et.withCredentials = !!nt.withCredentials),
        ot && ot !== "json" && (Et.responseType = nt.responseType),
        lt && ([pt,mt] = progressEventReducer(lt, !0),
        Et.addEventListener("progress", pt)),
        st && Et.upload && ([dt,ht] = progressEventReducer(st),
        Et.upload.addEventListener("progress", dt),
        Et.upload.addEventListener("loadend", ht)),
        (nt.cancelToken || nt.signal) && (ct = St => {
            Et && (tt(!St || St.type ? new CanceledError$1(null,_e,Et) : St),
            Et.abort(),
            Et = null)
        }
        ,
        nt.cancelToken && nt.cancelToken.subscribe(ct),
        nt.signal && (nt.signal.aborted ? ct() : nt.signal.addEventListener("abort", ct)));
        const wt = parseProtocol(nt.url);
        if (wt && platform.protocols.indexOf(wt) === -1) {
            tt(new AxiosError$1("Unsupported protocol " + wt + ":",AxiosError$1.ERR_BAD_REQUEST,_e));
            return
        }
        Et.send(rt || null)
    }
    )
}
  , composeSignals = (_e, $) => {
    const {length: et} = _e = _e ? _e.filter(Boolean) : [];
    if ($ || et) {
        let tt = new AbortController, nt;
        const rt = function(lt) {
            if (!nt) {
                nt = !0,
                ot();
                const ct = lt instanceof Error ? lt : this.reason;
                tt.abort(ct instanceof AxiosError$1 ? ct : new CanceledError$1(ct instanceof Error ? ct.message : ct))
            }
        };
        let it = $ && setTimeout( () => {
            it = null,
            rt(new AxiosError$1(`timeout ${$} of ms exceeded`,AxiosError$1.ETIMEDOUT))
        }
        , $);
        const ot = () => {
            _e && (it && clearTimeout(it),
            it = null,
            _e.forEach(lt => {
                lt.unsubscribe ? lt.unsubscribe(rt) : lt.removeEventListener("abort", rt)
            }
            ),
            _e = null)
        }
        ;
        _e.forEach(lt => lt.addEventListener("abort", rt));
        const {signal: st} = tt;
        return st.unsubscribe = () => utils$1.asap(ot),
        st
    }
}
  , streamChunk = function*(_e, $) {
    let et = _e.byteLength;
    if (et < $) {
        yield _e;
        return
    }
    let tt = 0, nt;
    for (; tt < et; )
        nt = tt + $,
        yield _e.slice(tt, nt),
        tt = nt
}
  , readBytes = async function*(_e, $) {
    for await(const et of readStream(_e))
        yield*streamChunk(et, $)
}
  , readStream = async function*(_e) {
    if (_e[Symbol.asyncIterator]) {
        yield*_e;
        return
    }
    const $ = _e.getReader();
    try {
        for (; ; ) {
            const {done: et, value: tt} = await $.read();
            if (et)
                break;
            yield tt
        }
    } finally {
        await $.cancel()
    }
}
  , trackStream = (_e, $, et, tt) => {
    const nt = readBytes(_e, $);
    let rt = 0, it, ot = st => {
        it || (it = !0,
        tt && tt(st))
    }
    ;
    return new ReadableStream({
        async pull(st) {
            try {
                const {done: lt, value: ct} = await nt.next();
                if (lt) {
                    ot(),
                    st.close();
                    return
                }
                let dt = ct.byteLength;
                if (et) {
                    let pt = rt += dt;
                    et(pt)
                }
                st.enqueue(new Uint8Array(ct))
            } catch (lt) {
                throw ot(lt),
                lt
            }
        },
        cancel(st) {
            return ot(st),
            nt.return()
        }
    },{
        highWaterMark: 2
    })
}
  , isFetchSupported = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function"
  , isReadableStreamSupported = isFetchSupported && typeof ReadableStream == "function"
  , encodeText = isFetchSupported && (typeof TextEncoder == "function" ? (_e => $ => _e.encode($))(new TextEncoder) : async _e => new Uint8Array(await new Response(_e).arrayBuffer()))
  , test$2 = (_e, ...$) => {
    try {
        return !!_e(...$)
    } catch {
        return !1
    }
}
  , supportsRequestStream = isReadableStreamSupported && test$2( () => {
    let _e = !1;
    const $ = new Request(platform.origin,{
        body: new ReadableStream,
        method: "POST",
        get duplex() {
            return _e = !0,
            "half"
        }
    }).headers.has("Content-Type");
    return _e && !$
}
)
  , DEFAULT_CHUNK_SIZE = 64 * 1024
  , supportsResponseStream = isReadableStreamSupported && test$2( () => utils$1.isReadableStream(new Response("").body))
  , resolvers = {
    stream: supportsResponseStream && (_e => _e.body)
};
isFetchSupported && (_e => {
    ["text", "arrayBuffer", "blob", "formData", "stream"].forEach($ => {
        !resolvers[$] && (resolvers[$] = utils$1.isFunction(_e[$]) ? et => et[$]() : (et, tt) => {
            throw new AxiosError$1(`Response type '${$}' is not supported`,AxiosError$1.ERR_NOT_SUPPORT,tt)
        }
        )
    }
    )
}
)(new Response);
const getBodyLength = async _e => {
    if (_e == null)
        return 0;
    if (utils$1.isBlob(_e))
        return _e.size;
    if (utils$1.isSpecCompliantForm(_e))
        return (await new Request(platform.origin,{
            method: "POST",
            body: _e
        }).arrayBuffer()).byteLength;
    if (utils$1.isArrayBufferView(_e) || utils$1.isArrayBuffer(_e))
        return _e.byteLength;
    if (utils$1.isURLSearchParams(_e) && (_e = _e + ""),
    utils$1.isString(_e))
        return (await encodeText(_e)).byteLength
}
  , resolveBodyLength = async (_e, $) => {
    const et = utils$1.toFiniteNumber(_e.getContentLength());
    return et ?? getBodyLength($)
}
  , fetchAdapter = isFetchSupported && (async _e => {
    let {url: $, method: et, data: tt, signal: nt, cancelToken: rt, timeout: it, onDownloadProgress: ot, onUploadProgress: st, responseType: lt, headers: ct, withCredentials: dt="same-origin", fetchOptions: pt} = resolveConfig(_e);
    lt = lt ? (lt + "").toLowerCase() : "text";
    let ht = composeSignals([nt, rt && rt.toAbortSignal()], it), mt;
    const yt = ht && ht.unsubscribe && ( () => {
        ht.unsubscribe()
    }
    );
    let Et;
    try {
        if (st && supportsRequestStream && et !== "get" && et !== "head" && (Et = await resolveBodyLength(ct, tt)) !== 0) {
            let Nt = new Request($,{
                method: "POST",
                body: tt,
                duplex: "half"
            }), Lt;
            if (utils$1.isFormData(tt) && (Lt = Nt.headers.get("content-type")) && ct.setContentType(Lt),
            Nt.body) {
                const [kt,Ut] = progressEventDecorator(Et, progressEventReducer(asyncDecorator(st)));
                tt = trackStream(Nt.body, DEFAULT_CHUNK_SIZE, kt, Ut)
            }
        }
        utils$1.isString(dt) || (dt = dt ? "include" : "omit");
        const _t = "credentials"in Request.prototype;
        mt = new Request($,{
            ...pt,
            signal: ht,
            method: et.toUpperCase(),
            headers: ct.normalize().toJSON(),
            body: tt,
            duplex: "half",
            credentials: _t ? dt : void 0
        });
        let wt = await fetch(mt);
        const St = supportsResponseStream && (lt === "stream" || lt === "response");
        if (supportsResponseStream && (ot || St && yt)) {
            const Nt = {};
            ["status", "statusText", "headers"].forEach(Jt => {
                Nt[Jt] = wt[Jt]
            }
            );
            const Lt = utils$1.toFiniteNumber(wt.headers.get("content-length"))
              , [kt,Ut] = ot && progressEventDecorator(Lt, progressEventReducer(asyncDecorator(ot), !0)) || [];
            wt = new Response(trackStream(wt.body, DEFAULT_CHUNK_SIZE, kt, () => {
                Ut && Ut(),
                yt && yt()
            }
            ),Nt)
        }
        lt = lt || "text";
        let Ct = await resolvers[utils$1.findKey(resolvers, lt) || "text"](wt, _e);
        return !St && yt && yt(),
        await new Promise( (Nt, Lt) => {
            settle(Nt, Lt, {
                data: Ct,
                headers: AxiosHeaders$1.from(wt.headers),
                status: wt.status,
                statusText: wt.statusText,
                config: _e,
                request: mt
            })
        }
        )
    } catch (_t) {
        throw yt && yt(),
        _t && _t.name === "TypeError" && /fetch/i.test(_t.message) ? Object.assign(new AxiosError$1("Network Error",AxiosError$1.ERR_NETWORK,_e,mt), {
            cause: _t.cause || _t
        }) : AxiosError$1.from(_t, _t && _t.code, _e, mt)
    }
}
)
  , knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter,
    fetch: fetchAdapter
};
utils$1.forEach(knownAdapters, (_e, $) => {
    if (_e) {
        try {
            Object.defineProperty(_e, "name", {
                value: $
            })
        } catch {}
        Object.defineProperty(_e, "adapterName", {
            value: $
        })
    }
}
);
const renderReason = _e => `- ${_e}`
  , isResolvedHandle = _e => utils$1.isFunction(_e) || _e === null || _e === !1
  , adapters = {
    getAdapter: _e => {
        _e = utils$1.isArray(_e) ? _e : [_e];
        const {length: $} = _e;
        let et, tt;
        const nt = {};
        for (let rt = 0; rt < $; rt++) {
            et = _e[rt];
            let it;
            if (tt = et,
            !isResolvedHandle(et) && (tt = knownAdapters[(it = String(et)).toLowerCase()],
            tt === void 0))
                throw new AxiosError$1(`Unknown adapter '${it}'`);
            if (tt)
                break;
            nt[it || "#" + rt] = tt
        }
        if (!tt) {
            const rt = Object.entries(nt).map( ([ot,st]) => `adapter ${ot} ` + (st === !1 ? "is not supported by the environment" : "is not available in the build"));
            let it = $ ? rt.length > 1 ? `since :
` + rt.map(renderReason).join(`
`) : " " + renderReason(rt[0]) : "as no adapter specified";
            throw new AxiosError$1("There is no suitable adapter to dispatch the request " + it,"ERR_NOT_SUPPORT")
        }
        return tt
    }
    ,
    adapters: knownAdapters
};
function throwIfCancellationRequested(_e) {
    if (_e.cancelToken && _e.cancelToken.throwIfRequested(),
    _e.signal && _e.signal.aborted)
        throw new CanceledError$1(null,_e)
}
function dispatchRequest(_e) {
    return throwIfCancellationRequested(_e),
    _e.headers = AxiosHeaders$1.from(_e.headers),
    _e.data = transformData.call(_e, _e.transformRequest),
    ["post", "put", "patch"].indexOf(_e.method) !== -1 && _e.headers.setContentType("application/x-www-form-urlencoded", !1),
    adapters.getAdapter(_e.adapter || defaults$1.adapter)(_e).then(function(tt) {
        return throwIfCancellationRequested(_e),
        tt.data = transformData.call(_e, _e.transformResponse, tt),
        tt.headers = AxiosHeaders$1.from(tt.headers),
        tt
    }, function(tt) {
        return isCancel$1(tt) || (throwIfCancellationRequested(_e),
        tt && tt.response && (tt.response.data = transformData.call(_e, _e.transformResponse, tt.response),
        tt.response.headers = AxiosHeaders$1.from(tt.response.headers))),
        Promise.reject(tt)
    })
}
const VERSION$1 = "1.7.9"
  , validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach( (_e, $) => {
    validators$1[_e] = function(tt) {
        return typeof tt === _e || "a" + ($ < 1 ? "n " : " ") + _e
    }
}
);
const deprecatedWarnings = {};
validators$1.transitional = function($, et, tt) {
    function nt(rt, it) {
        return "[Axios v" + VERSION$1 + "] Transitional option '" + rt + "'" + it + (tt ? ". " + tt : "")
    }
    return (rt, it, ot) => {
        if ($ === !1)
            throw new AxiosError$1(nt(it, " has been removed" + (et ? " in " + et : "")),AxiosError$1.ERR_DEPRECATED);
        return et && !deprecatedWarnings[it] && (deprecatedWarnings[it] = !0),
        $ ? $(rt, it, ot) : !0
    }
}
;
validators$1.spelling = function($) {
    return (et, tt) => !0
}
;
function assertOptions(_e, $, et) {
    if (typeof _e != "object")
        throw new AxiosError$1("options must be an object",AxiosError$1.ERR_BAD_OPTION_VALUE);
    const tt = Object.keys(_e);
    let nt = tt.length;
    for (; nt-- > 0; ) {
        const rt = tt[nt]
          , it = $[rt];
        if (it) {
            const ot = _e[rt]
              , st = ot === void 0 || it(ot, rt, _e);
            if (st !== !0)
                throw new AxiosError$1("option " + rt + " must be " + st,AxiosError$1.ERR_BAD_OPTION_VALUE);
            continue
        }
        if (et !== !0)
            throw new AxiosError$1("Unknown option " + rt,AxiosError$1.ERR_BAD_OPTION)
    }
}
const validator = {
    assertOptions,
    validators: validators$1
}
  , validators = validator.validators;
let Axios$1 = class {
    constructor($) {
        this.defaults = $,
        this.interceptors = {
            request: new InterceptorManager,
            response: new InterceptorManager
        }
    }
    async request($, et) {
        try {
            return await this._request($, et)
        } catch (tt) {
            if (tt instanceof Error) {
                let nt = {};
                Error.captureStackTrace ? Error.captureStackTrace(nt) : nt = new Error;
                const rt = nt.stack ? nt.stack.replace(/^.+\n/, "") : "";
                try {
                    tt.stack ? rt && !String(tt.stack).endsWith(rt.replace(/^.+\n.+\n/, "")) && (tt.stack += `
` + rt) : tt.stack = rt
                } catch {}
            }
            throw tt
        }
    }
    _request($, et) {
        typeof $ == "string" ? (et = et || {},
        et.url = $) : et = $ || {},
        et = mergeConfig$1(this.defaults, et);
        const {transitional: tt, paramsSerializer: nt, headers: rt} = et;
        tt !== void 0 && validator.assertOptions(tt, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
        }, !1),
        nt != null && (utils$1.isFunction(nt) ? et.paramsSerializer = {
            serialize: nt
        } : validator.assertOptions(nt, {
            encode: validators.function,
            serialize: validators.function
        }, !0)),
        validator.assertOptions(et, {
            baseUrl: validators.spelling("baseURL"),
            withXsrfToken: validators.spelling("withXSRFToken")
        }, !0),
        et.method = (et.method || this.defaults.method || "get").toLowerCase();
        let it = rt && utils$1.merge(rt.common, rt[et.method]);
        rt && utils$1.forEach(["delete", "get", "head", "post", "put", "patch", "common"], mt => {
            delete rt[mt]
        }
        ),
        et.headers = AxiosHeaders$1.concat(it, rt);
        const ot = [];
        let st = !0;
        this.interceptors.request.forEach(function(yt) {
            typeof yt.runWhen == "function" && yt.runWhen(et) === !1 || (st = st && yt.synchronous,
            ot.unshift(yt.fulfilled, yt.rejected))
        });
        const lt = [];
        this.interceptors.response.forEach(function(yt) {
            lt.push(yt.fulfilled, yt.rejected)
        });
        let ct, dt = 0, pt;
        if (!st) {
            const mt = [dispatchRequest.bind(this), void 0];
            for (mt.unshift.apply(mt, ot),
            mt.push.apply(mt, lt),
            pt = mt.length,
            ct = Promise.resolve(et); dt < pt; )
                ct = ct.then(mt[dt++], mt[dt++]);
            return ct
        }
        pt = ot.length;
        let ht = et;
        for (dt = 0; dt < pt; ) {
            const mt = ot[dt++]
              , yt = ot[dt++];
            try {
                ht = mt(ht)
            } catch (Et) {
                yt.call(this, Et);
                break
            }
        }
        try {
            ct = dispatchRequest.call(this, ht)
        } catch (mt) {
            return Promise.reject(mt)
        }
        for (dt = 0,
        pt = lt.length; dt < pt; )
            ct = ct.then(lt[dt++], lt[dt++]);
        return ct
    }
    getUri($) {
        $ = mergeConfig$1(this.defaults, $);
        const et = buildFullPath($.baseURL, $.url);
        return buildURL(et, $.params, $.paramsSerializer)
    }
}
;
utils$1.forEach(["delete", "get", "head", "options"], function($) {
    Axios$1.prototype[$] = function(et, tt) {
        return this.request(mergeConfig$1(tt || {}, {
            method: $,
            url: et,
            data: (tt || {}).data
        }))
    }
});
utils$1.forEach(["post", "put", "patch"], function($) {
    function et(tt) {
        return function(rt, it, ot) {
            return this.request(mergeConfig$1(ot || {}, {
                method: $,
                headers: tt ? {
                    "Content-Type": "multipart/form-data"
                } : {},
                url: rt,
                data: it
            }))
        }
    }
    Axios$1.prototype[$] = et(),
    Axios$1.prototype[$ + "Form"] = et(!0)
});
let CancelToken$1 = class q_ {
    constructor($) {
        if (typeof $ != "function")
            throw new TypeError("executor must be a function.");
        let et;
        this.promise = new Promise(function(rt) {
            et = rt
        }
        );
        const tt = this;
        this.promise.then(nt => {
            if (!tt._listeners)
                return;
            let rt = tt._listeners.length;
            for (; rt-- > 0; )
                tt._listeners[rt](nt);
            tt._listeners = null
        }
        ),
        this.promise.then = nt => {
            let rt;
            const it = new Promise(ot => {
                tt.subscribe(ot),
                rt = ot
            }
            ).then(nt);
            return it.cancel = function() {
                tt.unsubscribe(rt)
            }
            ,
            it
        }
        ,
        $(function(rt, it, ot) {
            tt.reason || (tt.reason = new CanceledError$1(rt,it,ot),
            et(tt.reason))
        })
    }
    throwIfRequested() {
        if (this.reason)
            throw this.reason
    }
    subscribe($) {
        if (this.reason) {
            $(this.reason);
            return
        }
        this._listeners ? this._listeners.push($) : this._listeners = [$]
    }
    unsubscribe($) {
        if (!this._listeners)
            return;
        const et = this._listeners.indexOf($);
        et !== -1 && this._listeners.splice(et, 1)
    }
    toAbortSignal() {
        const $ = new AbortController
          , et = tt => {
            $.abort(tt)
        }
        ;
        return this.subscribe(et),
        $.signal.unsubscribe = () => this.unsubscribe(et),
        $.signal
    }
    static source() {
        let $;
        return {
            token: new q_(function(nt) {
                $ = nt
            }
            ),
            cancel: $
        }
    }
}
;
function spread$1(_e) {
    return function(et) {
        return _e.apply(null, et)
    }
}
function isAxiosError$1(_e) {
    return utils$1.isObject(_e) && _e.isAxiosError === !0
}
const HttpStatusCode$1 = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode$1).forEach( ([_e,$]) => {
    HttpStatusCode$1[$] = _e
}
);
function createInstance(_e) {
    const $ = new Axios$1(_e)
      , et = bind(Axios$1.prototype.request, $);
    return utils$1.extend(et, Axios$1.prototype, $, {
        allOwnKeys: !0
    }),
    utils$1.extend(et, $, null, {
        allOwnKeys: !0
    }),
    et.create = function(nt) {
        return createInstance(mergeConfig$1(_e, nt))
    }
    ,
    et
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError$1;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel$1;
axios.VERSION = VERSION$1;
axios.toFormData = toFormData$1;
axios.AxiosError = AxiosError$1;
axios.Cancel = axios.CanceledError;
axios.all = function($) {
    return Promise.all($)
}
;
axios.spread = spread$1;
axios.isAxiosError = isAxiosError$1;
axios.mergeConfig = mergeConfig$1;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = _e => formDataToJSON(utils$1.isHTMLForm(_e) ? new FormData(_e) : _e);
axios.getAdapter = adapters.getAdapter;
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const {Axios, AxiosError, CanceledError, isCancel, CancelToken, VERSION, all, Cancel, isAxiosError, spread, toFormData, AxiosHeaders, HttpStatusCode, formToJSON, getAdapter, mergeConfig} = axios;
function asyncGeneratorStep(_e, $, et, tt, nt, rt, it) {
    try {
        var ot = _e[rt](it)
          , st = ot.value
    } catch (lt) {
        return void et(lt)
    }
    ot.done ? $(st) : Promise.resolve(st).then(tt, nt)
}
function _asyncToGenerator(_e) {
    return function() {
        var $ = this
          , et = arguments;
        return new Promise(function(tt, nt) {
            var rt = _e.apply($, et);
            function it(st) {
                asyncGeneratorStep(rt, tt, nt, it, ot, "next", st)
            }
            function ot(st) {
                asyncGeneratorStep(rt, tt, nt, it, ot, "throw", st)
            }
            it(void 0)
        }
        )
    }
}
function _extends$2() {
    return _extends$2 = Object.assign ? Object.assign.bind() : function(_e) {
        for (var $ = 1; $ < arguments.length; $++) {
            var et = arguments[$];
            for (var tt in et)
                ({}).hasOwnProperty.call(et, tt) && (_e[tt] = et[tt])
        }
        return _e
    }
    ,
    _extends$2.apply(null, arguments)
}
var regeneratorRuntime$1 = {
    exports: {}
}
  , _typeof$1 = {
    exports: {}
};
(function(_e) {
    function $(et) {
        "@babel/helpers - typeof";
        return _e.exports = $ = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(tt) {
            return typeof tt
        }
        : function(tt) {
            return tt && typeof Symbol == "function" && tt.constructor === Symbol && tt !== Symbol.prototype ? "symbol" : typeof tt
        }
        ,
        _e.exports.__esModule = !0,
        _e.exports.default = _e.exports,
        $(et)
    }
    _e.exports = $,
    _e.exports.__esModule = !0,
    _e.exports.default = _e.exports
}
)(_typeof$1);
var _typeofExports = _typeof$1.exports;
(function(_e) {
    var $ = _typeofExports.default;
    function et() {
        _e.exports = et = function() {
            return nt
        }
        ,
        _e.exports.__esModule = !0,
        _e.exports.default = _e.exports;
        var tt, nt = {}, rt = Object.prototype, it = rt.hasOwnProperty, ot = Object.defineProperty || function(Ht, qt, Wt) {
            Ht[qt] = Wt.value
        }
        , st = typeof Symbol == "function" ? Symbol : {}, lt = st.iterator || "@@iterator", ct = st.asyncIterator || "@@asyncIterator", dt = st.toStringTag || "@@toStringTag";
        function pt(Ht, qt, Wt) {
            return Object.defineProperty(Ht, qt, {
                value: Wt,
                enumerable: !0,
                configurable: !0,
                writable: !0
            }),
            Ht[qt]
        }
        try {
            pt({}, "")
        } catch {
            pt = function(Wt, Mt, Yt) {
                return Wt[Mt] = Yt
            }
        }
        function ht(Ht, qt, Wt, Mt) {
            var Yt = qt && qt.prototype instanceof Ct ? qt : Ct
              , un = Object.create(Yt.prototype)
              , hn = new jt(Mt || []);
            return ot(un, "_invoke", {
                value: zt(Ht, Wt, hn)
            }),
            un
        }
        function mt(Ht, qt, Wt) {
            try {
                return {
                    type: "normal",
                    arg: Ht.call(qt, Wt)
                }
            } catch (Mt) {
                return {
                    type: "throw",
                    arg: Mt
                }
            }
        }
        nt.wrap = ht;
        var yt = "suspendedStart"
          , Et = "suspendedYield"
          , _t = "executing"
          , wt = "completed"
          , St = {};
        function Ct() {}
        function Nt() {}
        function Lt() {}
        var kt = {};
        pt(kt, lt, function() {
            return this
        });
        var Ut = Object.getPrototypeOf
          , Jt = Ut && Ut(Ut(Ft([])));
        Jt && Jt !== rt && it.call(Jt, lt) && (kt = Jt);
        var Pt = Lt.prototype = Ct.prototype = Object.create(kt);
        function Xt(Ht) {
            ["next", "throw", "return"].forEach(function(qt) {
                pt(Ht, qt, function(Wt) {
                    return this._invoke(qt, Wt)
                })
            })
        }
        function rn(Ht, qt) {
            function Wt(Yt, un, hn, _n) {
                var kn = mt(Ht[Yt], Ht, un);
                if (kn.type !== "throw") {
                    var Dn = kn.arg
                      , jn = Dn.value;
                    return jn && $(jn) == "object" && it.call(jn, "__await") ? qt.resolve(jn.__await).then(function(Bn) {
                        Wt("next", Bn, hn, _n)
                    }, function(Bn) {
                        Wt("throw", Bn, hn, _n)
                    }) : qt.resolve(jn).then(function(Bn) {
                        Dn.value = Bn,
                        hn(Dn)
                    }, function(Bn) {
                        return Wt("throw", Bn, hn, _n)
                    })
                }
                _n(kn.arg)
            }
            var Mt;
            ot(this, "_invoke", {
                value: function(un, hn) {
                    function _n() {
                        return new qt(function(kn, Dn) {
                            Wt(un, hn, kn, Dn)
                        }
                        )
                    }
                    return Mt = Mt ? Mt.then(_n, _n) : _n()
                }
            })
        }
        function zt(Ht, qt, Wt) {
            var Mt = yt;
            return function(Yt, un) {
                if (Mt === _t)
                    throw Error("Generator is already running");
                if (Mt === wt) {
                    if (Yt === "throw")
                        throw un;
                    return {
                        value: tt,
                        done: !0
                    }
                }
                for (Wt.method = Yt,
                Wt.arg = un; ; ) {
                    var hn = Wt.delegate;
                    if (hn) {
                        var _n = xt(hn, Wt);
                        if (_n) {
                            if (_n === St)
                                continue;
                            return _n
                        }
                    }
                    if (Wt.method === "next")
                        Wt.sent = Wt._sent = Wt.arg;
                    else if (Wt.method === "throw") {
                        if (Mt === yt)
                            throw Mt = wt,
                            Wt.arg;
                        Wt.dispatchException(Wt.arg)
                    } else
                        Wt.method === "return" && Wt.abrupt("return", Wt.arg);
                    Mt = _t;
                    var kn = mt(Ht, qt, Wt);
                    if (kn.type === "normal") {
                        if (Mt = Wt.done ? wt : Et,
                        kn.arg === St)
                            continue;
                        return {
                            value: kn.arg,
                            done: Wt.done
                        }
                    }
                    kn.type === "throw" && (Mt = wt,
                    Wt.method = "throw",
                    Wt.arg = kn.arg)
                }
            }
        }
        function xt(Ht, qt) {
            var Wt = qt.method
              , Mt = Ht.iterator[Wt];
            if (Mt === tt)
                return qt.delegate = null,
                Wt === "throw" && Ht.iterator.return && (qt.method = "return",
                qt.arg = tt,
                xt(Ht, qt),
                qt.method === "throw") || Wt !== "return" && (qt.method = "throw",
                qt.arg = new TypeError("The iterator does not provide a '" + Wt + "' method")),
                St;
            var Yt = mt(Mt, Ht.iterator, qt.arg);
            if (Yt.type === "throw")
                return qt.method = "throw",
                qt.arg = Yt.arg,
                qt.delegate = null,
                St;
            var un = Yt.arg;
            return un ? un.done ? (qt[Ht.resultName] = un.value,
            qt.next = Ht.nextLoc,
            qt.method !== "return" && (qt.method = "next",
            qt.arg = tt),
            qt.delegate = null,
            St) : un : (qt.method = "throw",
            qt.arg = new TypeError("iterator result is not an object"),
            qt.delegate = null,
            St)
        }
        function $t(Ht) {
            var qt = {
                tryLoc: Ht[0]
            };
            1 in Ht && (qt.catchLoc = Ht[1]),
            2 in Ht && (qt.finallyLoc = Ht[2],
            qt.afterLoc = Ht[3]),
            this.tryEntries.push(qt)
        }
        function Dt(Ht) {
            var qt = Ht.completion || {};
            qt.type = "normal",
            delete qt.arg,
            Ht.completion = qt
        }
        function jt(Ht) {
            this.tryEntries = [{
                tryLoc: "root"
            }],
            Ht.forEach($t, this),
            this.reset(!0)
        }
        function Ft(Ht) {
            if (Ht || Ht === "") {
                var qt = Ht[lt];
                if (qt)
                    return qt.call(Ht);
                if (typeof Ht.next == "function")
                    return Ht;
                if (!isNaN(Ht.length)) {
                    var Wt = -1
                      , Mt = function Yt() {
                        for (; ++Wt < Ht.length; )
                            if (it.call(Ht, Wt))
                                return Yt.value = Ht[Wt],
                                Yt.done = !1,
                                Yt;
                        return Yt.value = tt,
                        Yt.done = !0,
                        Yt
                    };
                    return Mt.next = Mt
                }
            }
            throw new TypeError($(Ht) + " is not iterable")
        }
        return Nt.prototype = Lt,
        ot(Pt, "constructor", {
            value: Lt,
            configurable: !0
        }),
        ot(Lt, "constructor", {
            value: Nt,
            configurable: !0
        }),
        Nt.displayName = pt(Lt, dt, "GeneratorFunction"),
        nt.isGeneratorFunction = function(Ht) {
            var qt = typeof Ht == "function" && Ht.constructor;
            return !!qt && (qt === Nt || (qt.displayName || qt.name) === "GeneratorFunction")
        }
        ,
        nt.mark = function(Ht) {
            return Object.setPrototypeOf ? Object.setPrototypeOf(Ht, Lt) : (Ht.__proto__ = Lt,
            pt(Ht, dt, "GeneratorFunction")),
            Ht.prototype = Object.create(Pt),
            Ht
        }
        ,
        nt.awrap = function(Ht) {
            return {
                __await: Ht
            }
        }
        ,
        Xt(rn.prototype),
        pt(rn.prototype, ct, function() {
            return this
        }),
        nt.AsyncIterator = rn,
        nt.async = function(Ht, qt, Wt, Mt, Yt) {
            Yt === void 0 && (Yt = Promise);
            var un = new rn(ht(Ht, qt, Wt, Mt),Yt);
            return nt.isGeneratorFunction(qt) ? un : un.next().then(function(hn) {
                return hn.done ? hn.value : un.next()
            })
        }
        ,
        Xt(Pt),
        pt(Pt, dt, "Generator"),
        pt(Pt, lt, function() {
            return this
        }),
        pt(Pt, "toString", function() {
            return "[object Generator]"
        }),
        nt.keys = function(Ht) {
            var qt = Object(Ht)
              , Wt = [];
            for (var Mt in qt)
                Wt.push(Mt);
            return Wt.reverse(),
            function Yt() {
                for (; Wt.length; ) {
                    var un = Wt.pop();
                    if (un in qt)
                        return Yt.value = un,
                        Yt.done = !1,
                        Yt
                }
                return Yt.done = !0,
                Yt
            }
        }
        ,
        nt.values = Ft,
        jt.prototype = {
            constructor: jt,
            reset: function(qt) {
                if (this.prev = 0,
                this.next = 0,
                this.sent = this._sent = tt,
                this.done = !1,
                this.delegate = null,
                this.method = "next",
                this.arg = tt,
                this.tryEntries.forEach(Dt),
                !qt)
                    for (var Wt in this)
                        Wt.charAt(0) === "t" && it.call(this, Wt) && !isNaN(+Wt.slice(1)) && (this[Wt] = tt)
            },
            stop: function() {
                this.done = !0;
                var qt = this.tryEntries[0].completion;
                if (qt.type === "throw")
                    throw qt.arg;
                return this.rval
            },
            dispatchException: function(qt) {
                if (this.done)
                    throw qt;
                var Wt = this;
                function Mt(Dn, jn) {
                    return hn.type = "throw",
                    hn.arg = qt,
                    Wt.next = Dn,
                    jn && (Wt.method = "next",
                    Wt.arg = tt),
                    !!jn
                }
                for (var Yt = this.tryEntries.length - 1; Yt >= 0; --Yt) {
                    var un = this.tryEntries[Yt]
                      , hn = un.completion;
                    if (un.tryLoc === "root")
                        return Mt("end");
                    if (un.tryLoc <= this.prev) {
                        var _n = it.call(un, "catchLoc")
                          , kn = it.call(un, "finallyLoc");
                        if (_n && kn) {
                            if (this.prev < un.catchLoc)
                                return Mt(un.catchLoc, !0);
                            if (this.prev < un.finallyLoc)
                                return Mt(un.finallyLoc)
                        } else if (_n) {
                            if (this.prev < un.catchLoc)
                                return Mt(un.catchLoc, !0)
                        } else {
                            if (!kn)
                                throw Error("try statement without catch or finally");
                            if (this.prev < un.finallyLoc)
                                return Mt(un.finallyLoc)
                        }
                    }
                }
            },
            abrupt: function(qt, Wt) {
                for (var Mt = this.tryEntries.length - 1; Mt >= 0; --Mt) {
                    var Yt = this.tryEntries[Mt];
                    if (Yt.tryLoc <= this.prev && it.call(Yt, "finallyLoc") && this.prev < Yt.finallyLoc) {
                        var un = Yt;
                        break
                    }
                }
                un && (qt === "break" || qt === "continue") && un.tryLoc <= Wt && Wt <= un.finallyLoc && (un = null);
                var hn = un ? un.completion : {};
                return hn.type = qt,
                hn.arg = Wt,
                un ? (this.method = "next",
                this.next = un.finallyLoc,
                St) : this.complete(hn)
            },
            complete: function(qt, Wt) {
                if (qt.type === "throw")
                    throw qt.arg;
                return qt.type === "break" || qt.type === "continue" ? this.next = qt.arg : qt.type === "return" ? (this.rval = this.arg = qt.arg,
                this.method = "return",
                this.next = "end") : qt.type === "normal" && Wt && (this.next = Wt),
                St
            },
            finish: function(qt) {
                for (var Wt = this.tryEntries.length - 1; Wt >= 0; --Wt) {
                    var Mt = this.tryEntries[Wt];
                    if (Mt.finallyLoc === qt)
                        return this.complete(Mt.completion, Mt.afterLoc),
                        Dt(Mt),
                        St
                }
            },
            catch: function(qt) {
                for (var Wt = this.tryEntries.length - 1; Wt >= 0; --Wt) {
                    var Mt = this.tryEntries[Wt];
                    if (Mt.tryLoc === qt) {
                        var Yt = Mt.completion;
                        if (Yt.type === "throw") {
                            var un = Yt.arg;
                            Dt(Mt)
                        }
                        return un
                    }
                }
                throw Error("illegal catch attempt")
            },
            delegateYield: function(qt, Wt, Mt) {
                return this.delegate = {
                    iterator: Ft(qt),
                    resultName: Wt,
                    nextLoc: Mt
                },
                this.method === "next" && (this.arg = tt),
                St
            }
        },
        nt
    }
    _e.exports = et,
    _e.exports.__esModule = !0,
    _e.exports.default = _e.exports
}
)(regeneratorRuntime$1);
var regeneratorRuntimeExports = regeneratorRuntime$1.exports
  , runtime = regeneratorRuntimeExports()
  , regenerator = runtime;
try {
    regeneratorRuntime = runtime
} catch {
    typeof globalThis == "object" ? globalThis.regeneratorRuntime = runtime : Function("r", "regeneratorRuntime = r")(runtime)
}
const _regeneratorRuntime = getDefaultExportFromCjs$2(regenerator)
  , perf = typeof performance == "object" && performance && typeof performance.now == "function" ? performance : Date
  , warned = new Set
  , PROCESS = typeof process$1 == "object" && process$1 ? process$1 : {}
  , emitWarning = (_e, $, et, tt) => {
    typeof PROCESS.emitWarning == "function" && PROCESS.emitWarning(_e, $, et, tt)
}
;
let AC = globalThis.AbortController
  , AS = globalThis.AbortSignal;
var H_;
if (typeof AC > "u") {
    AS = class {
        constructor() {
            Br(this, "onabort");
            Br(this, "_onabort", []);
            Br(this, "reason");
            Br(this, "aborted", !1)
        }
        addEventListener(tt, nt) {
            this._onabort.push(nt)
        }
    }
    ,
    AC = class {
        constructor() {
            Br(this, "signal", new AS);
            $()
        }
        abort(tt) {
            var nt, rt;
            if (!this.signal.aborted) {
                this.signal.reason = tt,
                this.signal.aborted = !0;
                for (const it of this.signal._onabort)
                    it(tt);
                (rt = (nt = this.signal).onabort) == null || rt.call(nt, tt)
            }
        }
    }
    ;
    let _e = ((H_ = PROCESS.env) == null ? void 0 : H_.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
    const $ = () => {
        _e && (_e = !1,
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", $))
    }
}
const shouldWarn = _e => !warned.has(_e)
  , isPosInt = _e => _e && _e === Math.floor(_e) && _e > 0 && isFinite(_e)
  , getUintArray = _e => isPosInt(_e) ? _e <= Math.pow(2, 8) ? Uint8Array : _e <= Math.pow(2, 16) ? Uint16Array : _e <= Math.pow(2, 32) ? Uint32Array : _e <= Number.MAX_SAFE_INTEGER ? ZeroArray : null : null;
class ZeroArray extends Array {
    constructor($) {
        super($),
        this.fill(0)
    }
}
var au, Fm;
let Stack$1 = (au = class {
    constructor($, et) {
        Br(this, "heap");
        Br(this, "length");
        if (!nn(au, Fm))
            throw new TypeError("instantiate Stack using Stack.create(n)");
        this.heap = new et($),
        this.length = 0
    }
    static create($) {
        const et = getUintArray($);
        if (!et)
            return [];
        Yn(au, Fm, !0);
        const tt = new au($,et);
        return Yn(au, Fm, !1),
        tt
    }
    push($) {
        this.heap[this.length++] = $
    }
    pop() {
        return this.heap[--this.length]
    }
}
,
Fm = new WeakMap,
gr(au, Fm, !1),
au);
var G_, K_, Dl, $a, Bl, Ul, zm, Wm, hs, Fl, as, zo, Yr, js, yl, Is, bs, zl, Es, Wl, Hl, _l, Gl, hp, Fs, vr, sv, Hp, ku, N0, El, Z_, Gp, Hm, M0, np, rp, av, Hy, Gy, Fo, lv, A0, ip, cv;
const uv = class uv {
    constructor($) {
        gr(this, vr);
        gr(this, Dl);
        gr(this, $a);
        gr(this, Bl);
        gr(this, Ul);
        gr(this, zm);
        gr(this, Wm);
        Br(this, "ttl");
        Br(this, "ttlResolution");
        Br(this, "ttlAutopurge");
        Br(this, "updateAgeOnGet");
        Br(this, "updateAgeOnHas");
        Br(this, "allowStale");
        Br(this, "noDisposeOnSet");
        Br(this, "noUpdateTTL");
        Br(this, "maxEntrySize");
        Br(this, "sizeCalculation");
        Br(this, "noDeleteOnFetchRejection");
        Br(this, "noDeleteOnStaleGet");
        Br(this, "allowStaleOnFetchAbort");
        Br(this, "allowStaleOnFetchRejection");
        Br(this, "ignoreFetchAbort");
        gr(this, hs);
        gr(this, Fl);
        gr(this, as);
        gr(this, zo);
        gr(this, Yr);
        gr(this, js);
        gr(this, yl);
        gr(this, Is);
        gr(this, bs);
        gr(this, zl);
        gr(this, Es);
        gr(this, Wl);
        gr(this, Hl);
        gr(this, _l);
        gr(this, Gl);
        gr(this, hp);
        gr(this, Fs);
        gr(this, Hp, () => {}
        );
        gr(this, ku, () => {}
        );
        gr(this, N0, () => {}
        );
        gr(this, El, () => !1);
        gr(this, Gp, $ => {}
        );
        gr(this, Hm, ($, et, tt) => {}
        );
        gr(this, M0, ($, et, tt, nt) => {
            if (tt || nt)
                throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
            return 0
        }
        );
        Br(this, G_, "LRUCache");
        const {max: et=0, ttl: tt, ttlResolution: nt=1, ttlAutopurge: rt, updateAgeOnGet: it, updateAgeOnHas: ot, allowStale: st, dispose: lt, disposeAfter: ct, noDisposeOnSet: dt, noUpdateTTL: pt, maxSize: ht=0, maxEntrySize: mt=0, sizeCalculation: yt, fetchMethod: Et, memoMethod: _t, noDeleteOnFetchRejection: wt, noDeleteOnStaleGet: St, allowStaleOnFetchRejection: Ct, allowStaleOnFetchAbort: Nt, ignoreFetchAbort: Lt} = $;
        if (et !== 0 && !isPosInt(et))
            throw new TypeError("max option must be a nonnegative integer");
        const kt = et ? getUintArray(et) : Array;
        if (!kt)
            throw new Error("invalid max value: " + et);
        if (Yn(this, Dl, et),
        Yn(this, $a, ht),
        this.maxEntrySize = mt || nn(this, $a),
        this.sizeCalculation = yt,
        this.sizeCalculation) {
            if (!nn(this, $a) && !this.maxEntrySize)
                throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
            if (typeof this.sizeCalculation != "function")
                throw new TypeError("sizeCalculation set to non-function")
        }
        if (_t !== void 0 && typeof _t != "function")
            throw new TypeError("memoMethod must be a function if defined");
        if (Yn(this, Wm, _t),
        Et !== void 0 && typeof Et != "function")
            throw new TypeError("fetchMethod must be a function if specified");
        if (Yn(this, zm, Et),
        Yn(this, hp, !!Et),
        Yn(this, as, new Map),
        Yn(this, zo, new Array(et).fill(void 0)),
        Yn(this, Yr, new Array(et).fill(void 0)),
        Yn(this, js, new kt(et)),
        Yn(this, yl, new kt(et)),
        Yn(this, Is, 0),
        Yn(this, bs, 0),
        Yn(this, zl, Stack$1.create(et)),
        Yn(this, hs, 0),
        Yn(this, Fl, 0),
        typeof lt == "function" && Yn(this, Bl, lt),
        typeof ct == "function" ? (Yn(this, Ul, ct),
        Yn(this, Es, [])) : (Yn(this, Ul, void 0),
        Yn(this, Es, void 0)),
        Yn(this, Gl, !!nn(this, Bl)),
        Yn(this, Fs, !!nn(this, Ul)),
        this.noDisposeOnSet = !!dt,
        this.noUpdateTTL = !!pt,
        this.noDeleteOnFetchRejection = !!wt,
        this.allowStaleOnFetchRejection = !!Ct,
        this.allowStaleOnFetchAbort = !!Nt,
        this.ignoreFetchAbort = !!Lt,
        this.maxEntrySize !== 0) {
            if (nn(this, $a) !== 0 && !isPosInt(nn(this, $a)))
                throw new TypeError("maxSize must be a positive integer if specified");
            if (!isPosInt(this.maxEntrySize))
                throw new TypeError("maxEntrySize must be a positive integer if specified");
            tr(this, vr, Z_).call(this)
        }
        if (this.allowStale = !!st,
        this.noDeleteOnStaleGet = !!St,
        this.updateAgeOnGet = !!it,
        this.updateAgeOnHas = !!ot,
        this.ttlResolution = isPosInt(nt) || nt === 0 ? nt : 1,
        this.ttlAutopurge = !!rt,
        this.ttl = tt || 0,
        this.ttl) {
            if (!isPosInt(this.ttl))
                throw new TypeError("ttl must be a positive integer if specified");
            tr(this, vr, sv).call(this)
        }
        if (nn(this, Dl) === 0 && this.ttl === 0 && nn(this, $a) === 0)
            throw new TypeError("At least one of max, maxSize, or ttl is required");
        if (!this.ttlAutopurge && !nn(this, Dl) && !nn(this, $a)) {
            const Ut = "LRU_CACHE_UNBOUNDED";
            shouldWarn(Ut) && (warned.add(Ut),
            emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.", "UnboundedCacheWarning", Ut, uv))
        }
    }
    static unsafeExposeInternals($) {
        return {
            starts: nn($, Hl),
            ttls: nn($, _l),
            sizes: nn($, Wl),
            keyMap: nn($, as),
            keyList: nn($, zo),
            valList: nn($, Yr),
            next: nn($, js),
            prev: nn($, yl),
            get head() {
                return nn($, Is)
            },
            get tail() {
                return nn($, bs)
            },
            free: nn($, zl),
            isBackgroundFetch: et => {
                var tt;
                return tr(tt = $, vr, Fo).call(tt, et)
            }
            ,
            backgroundFetch: (et, tt, nt, rt) => {
                var it;
                return tr(it = $, vr, Gy).call(it, et, tt, nt, rt)
            }
            ,
            moveToTail: et => {
                var tt;
                return tr(tt = $, vr, A0).call(tt, et)
            }
            ,
            indexes: et => {
                var tt;
                return tr(tt = $, vr, np).call(tt, et)
            }
            ,
            rindexes: et => {
                var tt;
                return tr(tt = $, vr, rp).call(tt, et)
            }
            ,
            isStale: et => {
                var tt;
                return nn(tt = $, El).call(tt, et)
            }
        }
    }
    get max() {
        return nn(this, Dl)
    }
    get maxSize() {
        return nn(this, $a)
    }
    get calculatedSize() {
        return nn(this, Fl)
    }
    get size() {
        return nn(this, hs)
    }
    get fetchMethod() {
        return nn(this, zm)
    }
    get memoMethod() {
        return nn(this, Wm)
    }
    get dispose() {
        return nn(this, Bl)
    }
    get disposeAfter() {
        return nn(this, Ul)
    }
    getRemainingTTL($) {
        return nn(this, as).has($) ? 1 / 0 : 0
    }
    *entries() {
        for (const $ of tr(this, vr, np).call(this))
            nn(this, Yr)[$] !== void 0 && nn(this, zo)[$] !== void 0 && !tr(this, vr, Fo).call(this, nn(this, Yr)[$]) && (yield[nn(this, zo)[$], nn(this, Yr)[$]])
    }
    *rentries() {
        for (const $ of tr(this, vr, rp).call(this))
            nn(this, Yr)[$] !== void 0 && nn(this, zo)[$] !== void 0 && !tr(this, vr, Fo).call(this, nn(this, Yr)[$]) && (yield[nn(this, zo)[$], nn(this, Yr)[$]])
    }
    *keys() {
        for (const $ of tr(this, vr, np).call(this)) {
            const et = nn(this, zo)[$];
            et !== void 0 && !tr(this, vr, Fo).call(this, nn(this, Yr)[$]) && (yield et)
        }
    }
    *rkeys() {
        for (const $ of tr(this, vr, rp).call(this)) {
            const et = nn(this, zo)[$];
            et !== void 0 && !tr(this, vr, Fo).call(this, nn(this, Yr)[$]) && (yield et)
        }
    }
    *values() {
        for (const $ of tr(this, vr, np).call(this))
            nn(this, Yr)[$] !== void 0 && !tr(this, vr, Fo).call(this, nn(this, Yr)[$]) && (yield nn(this, Yr)[$])
    }
    *rvalues() {
        for (const $ of tr(this, vr, rp).call(this))
            nn(this, Yr)[$] !== void 0 && !tr(this, vr, Fo).call(this, nn(this, Yr)[$]) && (yield nn(this, Yr)[$])
    }
    [(K_ = Symbol.iterator,
    G_ = Symbol.toStringTag,
    K_)]() {
        return this.entries()
    }
    find($, et={}) {
        for (const tt of tr(this, vr, np).call(this)) {
            const nt = nn(this, Yr)[tt]
              , rt = tr(this, vr, Fo).call(this, nt) ? nt.__staleWhileFetching : nt;
            if (rt !== void 0 && $(rt, nn(this, zo)[tt], this))
                return this.get(nn(this, zo)[tt], et)
        }
    }
    forEach($, et=this) {
        for (const tt of tr(this, vr, np).call(this)) {
            const nt = nn(this, Yr)[tt]
              , rt = tr(this, vr, Fo).call(this, nt) ? nt.__staleWhileFetching : nt;
            rt !== void 0 && $.call(et, rt, nn(this, zo)[tt], this)
        }
    }
    rforEach($, et=this) {
        for (const tt of tr(this, vr, rp).call(this)) {
            const nt = nn(this, Yr)[tt]
              , rt = tr(this, vr, Fo).call(this, nt) ? nt.__staleWhileFetching : nt;
            rt !== void 0 && $.call(et, rt, nn(this, zo)[tt], this)
        }
    }
    purgeStale() {
        let $ = !1;
        for (const et of tr(this, vr, rp).call(this, {
            allowStale: !0
        }))
            nn(this, El).call(this, et) && (tr(this, vr, ip).call(this, nn(this, zo)[et], "expire"),
            $ = !0);
        return $
    }
    info($) {
        const et = nn(this, as).get($);
        if (et === void 0)
            return;
        const tt = nn(this, Yr)[et]
          , nt = tr(this, vr, Fo).call(this, tt) ? tt.__staleWhileFetching : tt;
        if (nt === void 0)
            return;
        const rt = {
            value: nt
        };
        if (nn(this, _l) && nn(this, Hl)) {
            const it = nn(this, _l)[et]
              , ot = nn(this, Hl)[et];
            if (it && ot) {
                const st = it - (perf.now() - ot);
                rt.ttl = st,
                rt.start = Date.now()
            }
        }
        return nn(this, Wl) && (rt.size = nn(this, Wl)[et]),
        rt
    }
    dump() {
        const $ = [];
        for (const et of tr(this, vr, np).call(this, {
            allowStale: !0
        })) {
            const tt = nn(this, zo)[et]
              , nt = nn(this, Yr)[et]
              , rt = tr(this, vr, Fo).call(this, nt) ? nt.__staleWhileFetching : nt;
            if (rt === void 0 || tt === void 0)
                continue;
            const it = {
                value: rt
            };
            if (nn(this, _l) && nn(this, Hl)) {
                it.ttl = nn(this, _l)[et];
                const ot = perf.now() - nn(this, Hl)[et];
                it.start = Math.floor(Date.now() - ot)
            }
            nn(this, Wl) && (it.size = nn(this, Wl)[et]),
            $.unshift([tt, it])
        }
        return $
    }
    load($) {
        this.clear();
        for (const [et,tt] of $) {
            if (tt.start) {
                const nt = Date.now() - tt.start;
                tt.start = perf.now() - nt
            }
            this.set(et, tt.value, tt)
        }
    }
    set($, et, tt={}) {
        var pt, ht, mt, yt, Et;
        if (et === void 0)
            return this.delete($),
            this;
        const {ttl: nt=this.ttl, start: rt, noDisposeOnSet: it=this.noDisposeOnSet, sizeCalculation: ot=this.sizeCalculation, status: st} = tt;
        let {noUpdateTTL: lt=this.noUpdateTTL} = tt;
        const ct = nn(this, M0).call(this, $, et, tt.size || 0, ot);
        if (this.maxEntrySize && ct > this.maxEntrySize)
            return st && (st.set = "miss",
            st.maxEntrySizeExceeded = !0),
            tr(this, vr, ip).call(this, $, "set"),
            this;
        let dt = nn(this, hs) === 0 ? void 0 : nn(this, as).get($);
        if (dt === void 0)
            dt = nn(this, hs) === 0 ? nn(this, bs) : nn(this, zl).length !== 0 ? nn(this, zl).pop() : nn(this, hs) === nn(this, Dl) ? tr(this, vr, Hy).call(this, !1) : nn(this, hs),
            nn(this, zo)[dt] = $,
            nn(this, Yr)[dt] = et,
            nn(this, as).set($, dt),
            nn(this, js)[nn(this, bs)] = dt,
            nn(this, yl)[dt] = nn(this, bs),
            Yn(this, bs, dt),
            Np(this, hs)._++,
            nn(this, Hm).call(this, dt, ct, st),
            st && (st.set = "add"),
            lt = !1;
        else {
            tr(this, vr, A0).call(this, dt);
            const _t = nn(this, Yr)[dt];
            if (et !== _t) {
                if (nn(this, hp) && tr(this, vr, Fo).call(this, _t)) {
                    _t.__abortController.abort(new Error("replaced"));
                    const {__staleWhileFetching: wt} = _t;
                    wt !== void 0 && !it && (nn(this, Gl) && ((pt = nn(this, Bl)) == null || pt.call(this, wt, $, "set")),
                    nn(this, Fs) && ((ht = nn(this, Es)) == null || ht.push([wt, $, "set"])))
                } else
                    it || (nn(this, Gl) && ((mt = nn(this, Bl)) == null || mt.call(this, _t, $, "set")),
                    nn(this, Fs) && ((yt = nn(this, Es)) == null || yt.push([_t, $, "set"])));
                if (nn(this, Gp).call(this, dt),
                nn(this, Hm).call(this, dt, ct, st),
                nn(this, Yr)[dt] = et,
                st) {
                    st.set = "replace";
                    const wt = _t && tr(this, vr, Fo).call(this, _t) ? _t.__staleWhileFetching : _t;
                    wt !== void 0 && (st.oldValue = wt)
                }
            } else
                st && (st.set = "update")
        }
        if (nt !== 0 && !nn(this, _l) && tr(this, vr, sv).call(this),
        nn(this, _l) && (lt || nn(this, N0).call(this, dt, nt, rt),
        st && nn(this, ku).call(this, st, dt)),
        !it && nn(this, Fs) && nn(this, Es)) {
            const _t = nn(this, Es);
            let wt;
            for (; wt = _t == null ? void 0 : _t.shift(); )
                (Et = nn(this, Ul)) == null || Et.call(this, ...wt)
        }
        return this
    }
    pop() {
        var $;
        try {
            for (; nn(this, hs); ) {
                const et = nn(this, Yr)[nn(this, Is)];
                if (tr(this, vr, Hy).call(this, !0),
                tr(this, vr, Fo).call(this, et)) {
                    if (et.__staleWhileFetching)
                        return et.__staleWhileFetching
                } else if (et !== void 0)
                    return et
            }
        } finally {
            if (nn(this, Fs) && nn(this, Es)) {
                const et = nn(this, Es);
                let tt;
                for (; tt = et == null ? void 0 : et.shift(); )
                    ($ = nn(this, Ul)) == null || $.call(this, ...tt)
            }
        }
    }
    has($, et={}) {
        const {updateAgeOnHas: tt=this.updateAgeOnHas, status: nt} = et
          , rt = nn(this, as).get($);
        if (rt !== void 0) {
            const it = nn(this, Yr)[rt];
            if (tr(this, vr, Fo).call(this, it) && it.__staleWhileFetching === void 0)
                return !1;
            if (nn(this, El).call(this, rt))
                nt && (nt.has = "stale",
                nn(this, ku).call(this, nt, rt));
            else
                return tt && nn(this, Hp).call(this, rt),
                nt && (nt.has = "hit",
                nn(this, ku).call(this, nt, rt)),
                !0
        } else
            nt && (nt.has = "miss");
        return !1
    }
    peek($, et={}) {
        const {allowStale: tt=this.allowStale} = et
          , nt = nn(this, as).get($);
        if (nt === void 0 || !tt && nn(this, El).call(this, nt))
            return;
        const rt = nn(this, Yr)[nt];
        return tr(this, vr, Fo).call(this, rt) ? rt.__staleWhileFetching : rt
    }
    async fetch($, et={}) {
        const {allowStale: tt=this.allowStale, updateAgeOnGet: nt=this.updateAgeOnGet, noDeleteOnStaleGet: rt=this.noDeleteOnStaleGet, ttl: it=this.ttl, noDisposeOnSet: ot=this.noDisposeOnSet, size: st=0, sizeCalculation: lt=this.sizeCalculation, noUpdateTTL: ct=this.noUpdateTTL, noDeleteOnFetchRejection: dt=this.noDeleteOnFetchRejection, allowStaleOnFetchRejection: pt=this.allowStaleOnFetchRejection, ignoreFetchAbort: ht=this.ignoreFetchAbort, allowStaleOnFetchAbort: mt=this.allowStaleOnFetchAbort, context: yt, forceRefresh: Et=!1, status: _t, signal: wt} = et;
        if (!nn(this, hp))
            return _t && (_t.fetch = "get"),
            this.get($, {
                allowStale: tt,
                updateAgeOnGet: nt,
                noDeleteOnStaleGet: rt,
                status: _t
            });
        const St = {
            allowStale: tt,
            updateAgeOnGet: nt,
            noDeleteOnStaleGet: rt,
            ttl: it,
            noDisposeOnSet: ot,
            size: st,
            sizeCalculation: lt,
            noUpdateTTL: ct,
            noDeleteOnFetchRejection: dt,
            allowStaleOnFetchRejection: pt,
            allowStaleOnFetchAbort: mt,
            ignoreFetchAbort: ht,
            status: _t,
            signal: wt
        };
        let Ct = nn(this, as).get($);
        if (Ct === void 0) {
            _t && (_t.fetch = "miss");
            const Nt = tr(this, vr, Gy).call(this, $, Ct, St, yt);
            return Nt.__returned = Nt
        } else {
            const Nt = nn(this, Yr)[Ct];
            if (tr(this, vr, Fo).call(this, Nt)) {
                const Pt = tt && Nt.__staleWhileFetching !== void 0;
                return _t && (_t.fetch = "inflight",
                Pt && (_t.returnedStale = !0)),
                Pt ? Nt.__staleWhileFetching : Nt.__returned = Nt
            }
            const Lt = nn(this, El).call(this, Ct);
            if (!Et && !Lt)
                return _t && (_t.fetch = "hit"),
                tr(this, vr, A0).call(this, Ct),
                nt && nn(this, Hp).call(this, Ct),
                _t && nn(this, ku).call(this, _t, Ct),
                Nt;
            const kt = tr(this, vr, Gy).call(this, $, Ct, St, yt)
              , Jt = kt.__staleWhileFetching !== void 0 && tt;
            return _t && (_t.fetch = Lt ? "stale" : "refresh",
            Jt && Lt && (_t.returnedStale = !0)),
            Jt ? kt.__staleWhileFetching : kt.__returned = kt
        }
    }
    async forceFetch($, et={}) {
        const tt = await this.fetch($, et);
        if (tt === void 0)
            throw new Error("fetch() returned undefined");
        return tt
    }
    memo($, et={}) {
        const tt = nn(this, Wm);
        if (!tt)
            throw new Error("no memoMethod provided to constructor");
        const {context: nt, forceRefresh: rt, ...it} = et
          , ot = this.get($, it);
        if (!rt && ot !== void 0)
            return ot;
        const st = tt($, ot, {
            options: it,
            context: nt
        });
        return this.set($, st, it),
        st
    }
    get($, et={}) {
        const {allowStale: tt=this.allowStale, updateAgeOnGet: nt=this.updateAgeOnGet, noDeleteOnStaleGet: rt=this.noDeleteOnStaleGet, status: it} = et
          , ot = nn(this, as).get($);
        if (ot !== void 0) {
            const st = nn(this, Yr)[ot]
              , lt = tr(this, vr, Fo).call(this, st);
            return it && nn(this, ku).call(this, it, ot),
            nn(this, El).call(this, ot) ? (it && (it.get = "stale"),
            lt ? (it && tt && st.__staleWhileFetching !== void 0 && (it.returnedStale = !0),
            tt ? st.__staleWhileFetching : void 0) : (rt || tr(this, vr, ip).call(this, $, "expire"),
            it && tt && (it.returnedStale = !0),
            tt ? st : void 0)) : (it && (it.get = "hit"),
            lt ? st.__staleWhileFetching : (tr(this, vr, A0).call(this, ot),
            nt && nn(this, Hp).call(this, ot),
            st))
        } else
            it && (it.get = "miss")
    }
    delete($) {
        return tr(this, vr, ip).call(this, $, "delete")
    }
    clear() {
        return tr(this, vr, cv).call(this, "delete")
    }
}
;
Dl = new WeakMap,
$a = new WeakMap,
Bl = new WeakMap,
Ul = new WeakMap,
zm = new WeakMap,
Wm = new WeakMap,
hs = new WeakMap,
Fl = new WeakMap,
as = new WeakMap,
zo = new WeakMap,
Yr = new WeakMap,
js = new WeakMap,
yl = new WeakMap,
Is = new WeakMap,
bs = new WeakMap,
zl = new WeakMap,
Es = new WeakMap,
Wl = new WeakMap,
Hl = new WeakMap,
_l = new WeakMap,
Gl = new WeakMap,
hp = new WeakMap,
Fs = new WeakMap,
vr = new WeakSet,
sv = function() {
    const $ = new ZeroArray(nn(this, Dl))
      , et = new ZeroArray(nn(this, Dl));
    Yn(this, _l, $),
    Yn(this, Hl, et),
    Yn(this, N0, (rt, it, ot=perf.now()) => {
        if (et[rt] = it !== 0 ? ot : 0,
        $[rt] = it,
        it !== 0 && this.ttlAutopurge) {
            const st = setTimeout( () => {
                nn(this, El).call(this, rt) && tr(this, vr, ip).call(this, nn(this, zo)[rt], "expire")
            }
            , it + 1);
            st.unref && st.unref()
        }
    }
    ),
    Yn(this, Hp, rt => {
        et[rt] = $[rt] !== 0 ? perf.now() : 0
    }
    ),
    Yn(this, ku, (rt, it) => {
        if ($[it]) {
            const ot = $[it]
              , st = et[it];
            if (!ot || !st)
                return;
            rt.ttl = ot,
            rt.start = st,
            rt.now = tt || nt();
            const lt = rt.now - st;
            rt.remainingTTL = ot - lt
        }
    }
    );
    let tt = 0;
    const nt = () => {
        const rt = perf.now();
        if (this.ttlResolution > 0) {
            tt = rt;
            const it = setTimeout( () => tt = 0, this.ttlResolution);
            it.unref && it.unref()
        }
        return rt
    }
    ;
    this.getRemainingTTL = rt => {
        const it = nn(this, as).get(rt);
        if (it === void 0)
            return 0;
        const ot = $[it]
          , st = et[it];
        if (!ot || !st)
            return 1 / 0;
        const lt = (tt || nt()) - st;
        return ot - lt
    }
    ,
    Yn(this, El, rt => {
        const it = et[rt]
          , ot = $[rt];
        return !!ot && !!it && (tt || nt()) - it > ot
    }
    )
}
,
Hp = new WeakMap,
ku = new WeakMap,
N0 = new WeakMap,
El = new WeakMap,
Z_ = function() {
    const $ = new ZeroArray(nn(this, Dl));
    Yn(this, Fl, 0),
    Yn(this, Wl, $),
    Yn(this, Gp, et => {
        Yn(this, Fl, nn(this, Fl) - $[et]),
        $[et] = 0
    }
    ),
    Yn(this, M0, (et, tt, nt, rt) => {
        if (tr(this, vr, Fo).call(this, tt))
            return 0;
        if (!isPosInt(nt))
            if (rt) {
                if (typeof rt != "function")
                    throw new TypeError("sizeCalculation must be a function");
                if (nt = rt(tt, et),
                !isPosInt(nt))
                    throw new TypeError("sizeCalculation return invalid (expect positive integer)")
            } else
                throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
        return nt
    }
    ),
    Yn(this, Hm, (et, tt, nt) => {
        if ($[et] = tt,
        nn(this, $a)) {
            const rt = nn(this, $a) - $[et];
            for (; nn(this, Fl) > rt; )
                tr(this, vr, Hy).call(this, !0)
        }
        Yn(this, Fl, nn(this, Fl) + $[et]),
        nt && (nt.entrySize = tt,
        nt.totalCalculatedSize = nn(this, Fl))
    }
    )
}
,
Gp = new WeakMap,
Hm = new WeakMap,
M0 = new WeakMap,
np = function*({allowStale: $=this.allowStale}={}) {
    if (nn(this, hs))
        for (let et = nn(this, bs); !(!tr(this, vr, av).call(this, et) || (($ || !nn(this, El).call(this, et)) && (yield et),
        et === nn(this, Is))); )
            et = nn(this, yl)[et]
}
,
rp = function*({allowStale: $=this.allowStale}={}) {
    if (nn(this, hs))
        for (let et = nn(this, Is); !(!tr(this, vr, av).call(this, et) || (($ || !nn(this, El).call(this, et)) && (yield et),
        et === nn(this, bs))); )
            et = nn(this, js)[et]
}
,
av = function($) {
    return $ !== void 0 && nn(this, as).get(nn(this, zo)[$]) === $
}
,
Hy = function($) {
    var rt, it;
    const et = nn(this, Is)
      , tt = nn(this, zo)[et]
      , nt = nn(this, Yr)[et];
    return nn(this, hp) && tr(this, vr, Fo).call(this, nt) ? nt.__abortController.abort(new Error("evicted")) : (nn(this, Gl) || nn(this, Fs)) && (nn(this, Gl) && ((rt = nn(this, Bl)) == null || rt.call(this, nt, tt, "evict")),
    nn(this, Fs) && ((it = nn(this, Es)) == null || it.push([nt, tt, "evict"]))),
    nn(this, Gp).call(this, et),
    $ && (nn(this, zo)[et] = void 0,
    nn(this, Yr)[et] = void 0,
    nn(this, zl).push(et)),
    nn(this, hs) === 1 ? (Yn(this, Is, Yn(this, bs, 0)),
    nn(this, zl).length = 0) : Yn(this, Is, nn(this, js)[et]),
    nn(this, as).delete(tt),
    Np(this, hs)._--,
    et
}
,
Gy = function($, et, tt, nt) {
    const rt = et === void 0 ? void 0 : nn(this, Yr)[et];
    if (tr(this, vr, Fo).call(this, rt))
        return rt;
    const it = new AC
      , {signal: ot} = tt;
    ot == null || ot.addEventListener("abort", () => it.abort(ot.reason), {
        signal: it.signal
    });
    const st = {
        signal: it.signal,
        options: tt,
        context: nt
    }
      , lt = (yt, Et=!1) => {
        const {aborted: _t} = it.signal
          , wt = tt.ignoreFetchAbort && yt !== void 0;
        if (tt.status && (_t && !Et ? (tt.status.fetchAborted = !0,
        tt.status.fetchError = it.signal.reason,
        wt && (tt.status.fetchAbortIgnored = !0)) : tt.status.fetchResolved = !0),
        _t && !wt && !Et)
            return dt(it.signal.reason);
        const St = ht;
        return nn(this, Yr)[et] === ht && (yt === void 0 ? St.__staleWhileFetching ? nn(this, Yr)[et] = St.__staleWhileFetching : tr(this, vr, ip).call(this, $, "fetch") : (tt.status && (tt.status.fetchUpdated = !0),
        this.set($, yt, st.options))),
        yt
    }
      , ct = yt => (tt.status && (tt.status.fetchRejected = !0,
    tt.status.fetchError = yt),
    dt(yt))
      , dt = yt => {
        const {aborted: Et} = it.signal
          , _t = Et && tt.allowStaleOnFetchAbort
          , wt = _t || tt.allowStaleOnFetchRejection
          , St = wt || tt.noDeleteOnFetchRejection
          , Ct = ht;
        if (nn(this, Yr)[et] === ht && (!St || Ct.__staleWhileFetching === void 0 ? tr(this, vr, ip).call(this, $, "fetch") : _t || (nn(this, Yr)[et] = Ct.__staleWhileFetching)),
        wt)
            return tt.status && Ct.__staleWhileFetching !== void 0 && (tt.status.returnedStale = !0),
            Ct.__staleWhileFetching;
        if (Ct.__returned === Ct)
            throw yt
    }
      , pt = (yt, Et) => {
        var wt;
        const _t = (wt = nn(this, zm)) == null ? void 0 : wt.call(this, $, rt, st);
        _t && _t instanceof Promise && _t.then(St => yt(St === void 0 ? void 0 : St), Et),
        it.signal.addEventListener("abort", () => {
            (!tt.ignoreFetchAbort || tt.allowStaleOnFetchAbort) && (yt(void 0),
            tt.allowStaleOnFetchAbort && (yt = St => lt(St, !0)))
        }
        )
    }
    ;
    tt.status && (tt.status.fetchDispatched = !0);
    const ht = new Promise(pt).then(lt, ct)
      , mt = Object.assign(ht, {
        __abortController: it,
        __staleWhileFetching: rt,
        __returned: void 0
    });
    return et === void 0 ? (this.set($, mt, {
        ...st.options,
        status: void 0
    }),
    et = nn(this, as).get($)) : nn(this, Yr)[et] = mt,
    mt
}
,
Fo = function($) {
    if (!nn(this, hp))
        return !1;
    const et = $;
    return !!et && et instanceof Promise && et.hasOwnProperty("__staleWhileFetching") && et.__abortController instanceof AC
}
,
lv = function($, et) {
    nn(this, yl)[et] = $,
    nn(this, js)[$] = et
}
,
A0 = function($) {
    $ !== nn(this, bs) && ($ === nn(this, Is) ? Yn(this, Is, nn(this, js)[$]) : tr(this, vr, lv).call(this, nn(this, yl)[$], nn(this, js)[$]),
    tr(this, vr, lv).call(this, nn(this, bs), $),
    Yn(this, bs, $))
}
,
ip = function($, et) {
    var nt, rt, it, ot;
    let tt = !1;
    if (nn(this, hs) !== 0) {
        const st = nn(this, as).get($);
        if (st !== void 0)
            if (tt = !0,
            nn(this, hs) === 1)
                tr(this, vr, cv).call(this, et);
            else {
                nn(this, Gp).call(this, st);
                const lt = nn(this, Yr)[st];
                if (tr(this, vr, Fo).call(this, lt) ? lt.__abortController.abort(new Error("deleted")) : (nn(this, Gl) || nn(this, Fs)) && (nn(this, Gl) && ((nt = nn(this, Bl)) == null || nt.call(this, lt, $, et)),
                nn(this, Fs) && ((rt = nn(this, Es)) == null || rt.push([lt, $, et]))),
                nn(this, as).delete($),
                nn(this, zo)[st] = void 0,
                nn(this, Yr)[st] = void 0,
                st === nn(this, bs))
                    Yn(this, bs, nn(this, yl)[st]);
                else if (st === nn(this, Is))
                    Yn(this, Is, nn(this, js)[st]);
                else {
                    const ct = nn(this, yl)[st];
                    nn(this, js)[ct] = nn(this, js)[st];
                    const dt = nn(this, js)[st];
                    nn(this, yl)[dt] = nn(this, yl)[st]
                }
                Np(this, hs)._--,
                nn(this, zl).push(st)
            }
    }
    if (nn(this, Fs) && ((it = nn(this, Es)) != null && it.length)) {
        const st = nn(this, Es);
        let lt;
        for (; lt = st == null ? void 0 : st.shift(); )
            (ot = nn(this, Ul)) == null || ot.call(this, ...lt)
    }
    return tt
}
,
cv = function($) {
    var et, tt, nt;
    for (const rt of tr(this, vr, rp).call(this, {
        allowStale: !0
    })) {
        const it = nn(this, Yr)[rt];
        if (tr(this, vr, Fo).call(this, it))
            it.__abortController.abort(new Error("deleted"));
        else {
            const ot = nn(this, zo)[rt];
            nn(this, Gl) && ((et = nn(this, Bl)) == null || et.call(this, it, ot, $)),
            nn(this, Fs) && ((tt = nn(this, Es)) == null || tt.push([it, ot, $]))
        }
    }
    if (nn(this, as).clear(),
    nn(this, Yr).fill(void 0),
    nn(this, zo).fill(void 0),
    nn(this, _l) && nn(this, Hl) && (nn(this, _l).fill(0),
    nn(this, Hl).fill(0)),
    nn(this, Wl) && nn(this, Wl).fill(0),
    Yn(this, Is, 0),
    Yn(this, bs, 0),
    nn(this, zl).length = 0,
    Yn(this, Fl, 0),
    Yn(this, hs, 0),
    nn(this, Fs) && nn(this, Es)) {
        const rt = nn(this, Es);
        let it;
        for (; it = rt == null ? void 0 : rt.shift(); )
            (nt = nn(this, Ul)) == null || nt.call(this, ...it)
    }
}
;
let LRUCache = uv;
var has$7 = Object.prototype.hasOwnProperty;
function dequal(_e, $) {
    var et, tt;
    if (_e === $)
        return !0;
    if (_e && $ && (et = _e.constructor) === $.constructor) {
        if (et === Date)
            return _e.getTime() === $.getTime();
        if (et === RegExp)
            return _e.toString() === $.toString();
        if (et === Array) {
            if ((tt = _e.length) === $.length)
                for (; tt-- && dequal(_e[tt], $[tt]); )
                    ;
            return tt === -1
        }
        if (!et || typeof _e == "object") {
            tt = 0;
            for (et in _e)
                if (has$7.call(_e, et) && ++tt && !has$7.call($, et) || !(et in $) || !dequal(_e[et], $[et]))
                    return !1;
            return Object.keys($).length === tt
        }
    }
    return _e !== _e && $ !== $
}
var actions = {
    REQUEST_START: "REQUEST_START",
    REQUEST_END: "REQUEST_END"
}
  , DEFAULT_OPTIONS = {
    manual: !1,
    useCache: !0,
    ssr: !0,
    autoCancel: !0
}
  , useAxios$1 = makeUseAxios();
useAxios$1.__ssrPromises;
useAxios$1.resetConfigure;
useAxios$1.configure;
useAxios$1.loadCache;
useAxios$1.serializeCache;
useAxios$1.clearCache;
function isReactEvent(_e) {
    return _e && _e.nativeEvent && _e.nativeEvent instanceof Event
}
function createCacheKey(_e) {
    var $ = _extends$2({}, _e);
    return delete $.cancelToken,
    JSON.stringify($)
}
function configToObject(_e) {
    return typeof _e == "string" ? {
        url: _e
    } : Object.assign({}, _e)
}
function makeUseAxios(_e) {
    var $, et, tt, nt = [];
    function rt() {
        $ = new LRUCache({
            max: 500
        }),
        et = axios,
        tt = DEFAULT_OPTIONS
    }
    function it(Ct) {
        Ct === void 0 && (Ct = {}),
        Ct.axios !== void 0 && (et = Ct.axios),
        Ct.cache !== void 0 && ($ = Ct.cache),
        Ct.defaultOptions !== void 0 && (tt = _extends$2({}, DEFAULT_OPTIONS, Ct.defaultOptions))
    }
    rt(),
    it(_e);
    function ot(Ct) {
        $.load(Ct)
    }
    function st() {
        return lt.apply(this, arguments)
    }
    function lt() {
        return lt = _asyncToGenerator(_regeneratorRuntime.mark(function Ct() {
            var Nt;
            return _regeneratorRuntime.wrap(function(kt) {
                for (; ; )
                    switch (kt.prev = kt.next) {
                    case 0:
                        return Nt = [].concat(nt),
                        nt.length = 0,
                        kt.next = 4,
                        Promise.all(Nt);
                    case 4:
                        return kt.abrupt("return", $.dump());
                    case 5:
                    case "end":
                        return kt.stop()
                    }
            }, Ct)
        })),
        lt.apply(this, arguments)
    }
    function ct() {
        $.clear()
    }
    return Object.assign(St, {
        __ssrPromises: nt,
        resetConfigure: rt,
        configure: it,
        loadCache: ot,
        serializeCache: st,
        clearCache: ct
    });
    function dt(Ct, Nt) {
        if ($) {
            var Lt = createCacheKey(Ct)
              , kt = _extends$2({}, Nt);
            delete kt.config,
            delete kt.request,
            $.set(Lt, kt)
        }
    }
    function pt(Ct, Nt) {
        var Lt = !Nt.manual && mt(Ct, Nt);
        return _extends$2({
            loading: !Nt.manual && !Lt,
            error: null
        }, Lt ? {
            data: Lt.data,
            response: Lt
        } : null)
    }
    function ht(Ct, Nt) {
        var Lt;
        switch (Nt.type) {
        case actions.REQUEST_START:
            return _extends$2({}, Ct, {
                loading: !0,
                error: null
            });
        case actions.REQUEST_END:
            return _extends$2({}, Ct, {
                loading: !1
            }, Nt.error ? {} : {
                data: Nt.payload.data,
                error: null
            }, (Lt = {},
            Lt[Nt.error ? "error" : "response"] = Nt.payload,
            Lt))
        }
    }
    function mt(Ct, Nt, Lt) {
        if (!(!$ || !Nt.useCache)) {
            var kt = createCacheKey(Ct)
              , Ut = $.get(kt);
            return Ut && Lt && Lt({
                type: actions.REQUEST_END,
                payload: Ut
            }),
            Ut
        }
    }
    function yt(Ct, Nt) {
        return Et.apply(this, arguments)
    }
    function Et() {
        return Et = _asyncToGenerator(_regeneratorRuntime.mark(function Ct(Nt, Lt) {
            var kt;
            return _regeneratorRuntime.wrap(function(Jt) {
                for (; ; )
                    switch (Jt.prev = Jt.next) {
                    case 0:
                        return Jt.prev = 0,
                        Lt({
                            type: actions.REQUEST_START
                        }),
                        Jt.next = 4,
                        et(Nt);
                    case 4:
                        return kt = Jt.sent,
                        dt(Nt, kt),
                        Lt({
                            type: actions.REQUEST_END,
                            payload: kt
                        }),
                        Jt.abrupt("return", kt);
                    case 10:
                        throw Jt.prev = 10,
                        Jt.t0 = Jt.catch(0),
                        isCancel(Jt.t0) || Lt({
                            type: actions.REQUEST_END,
                            payload: Jt.t0,
                            error: !0
                        }),
                        Jt.t0;
                    case 14:
                    case "end":
                        return Jt.stop()
                    }
            }, Ct, null, [[0, 10]])
        })),
        Et.apply(this, arguments)
    }
    function _t(Ct, Nt, Lt) {
        return wt.apply(this, arguments)
    }
    function wt() {
        return wt = _asyncToGenerator(_regeneratorRuntime.mark(function Ct(Nt, Lt, kt) {
            return _regeneratorRuntime.wrap(function(Jt) {
                for (; ; )
                    switch (Jt.prev = Jt.next) {
                    case 0:
                        return Jt.abrupt("return", mt(Nt, Lt, kt) || yt(Nt, kt));
                    case 1:
                    case "end":
                        return Jt.stop()
                    }
            }, Ct)
        })),
        wt.apply(this, arguments)
    }
    function St(Ct, Nt) {
        var Lt = React.useMemo(function() {
            return configToObject(Ct)
        }, useDeepCompareMemoize(Ct))
          , kt = React.useMemo(function() {
            return _extends$2({}, tt, Nt)
        }, useDeepCompareMemoize(Nt))
          , Ut = React.useRef()
          , Jt = React.useReducer(ht, pt(Lt, kt))
          , Pt = Jt[0]
          , Xt = Jt[1];
        typeof window > "u" && kt.ssr && !kt.manual && St.__ssrPromises.push(et(Lt));
        var rn = React.useCallback(function() {
            Ut.current && Ut.current.abort()
        }, [])
          , zt = React.useCallback(function($t) {
            return kt.autoCancel && rn(),
            Ut.current = new AbortController,
            $t.signal = Ut.current.signal,
            $t
        }, [rn, kt.autoCancel]);
        React.useEffect(function() {
            return kt.manual || _t(zt(Lt), kt, Xt).catch(function() {}),
            function() {
                kt.autoCancel && rn()
            }
        }, [Lt, kt, zt, rn]);
        var xt = React.useCallback(function($t, Dt) {
            return $t = configToObject($t),
            _t(zt(_extends$2({}, Lt, isReactEvent($t) ? null : $t)), _extends$2({
                useCache: !1
            }, Dt), Xt)
        }, [Lt, zt]);
        return [Pt, xt, rn]
    }
}
function useDeepCompareMemoize(_e) {
    var $ = React.useRef()
      , et = React.useRef(0);
    return dequal(_e, $.current) || ($.current = _e,
    et.current += 1),
    [et.current]
}
var PriceTypes = (_e => (_e.Price = "price",
_e.MarketCap = "marketCap",
_e))(PriceTypes || {})
  , UnitTypes = (_e => (_e.USD = "USD",
_e.SOL = "SOL",
_e))(UnitTypes || {})
  , Env = (_e => (_e.development = "development",
_e.production = "production",
_e))(Env || {})
  , API_Code = (_e => (_e[_e.Success = 200] = "Success",
_e[_e.Need_Login = 401] = "Need_Login",
_e[_e.Ticker_Not_Found = 70001] = "Ticker_Not_Found",
_e[_e.Point_Not_Enough = 20123] = "Point_Not_Enough",
_e))(API_Code || {})
  , ExploreTypes = (_e => (_e.Token = "token",
_e.Account = "account",
_e.TX = "tx",
_e))(ExploreTypes || {})
  , SearchType = (_e => (_e.TICKERS = "TICKERS",
_e.POSTS = "POSTS",
_e.USERS = "USERS",
_e))(SearchType || {})
  , Sort_Direction = (_e => (_e.DESC = "DESC",
_e.ASC = "ASC",
_e))(Sort_Direction || {})
  , Market_Type = (_e => (_e.Markets = "Markets",
_e.NewPairs = "NewPairs",
_e))(Market_Type || {});
const appAxiosInstance = axios.create({
    headers: {
        "Content-Type": "application/json"
    },
    baseURL: "https://api.super.exchange",
    timeout: 6e4
});
appAxiosInstance.interceptors.request.use(_e => {
    const $ = useStore$1.getState().token
      , et = void 0;
    return _e.headers["Accept-Language"] = "en",
    ($ || et) && (_e.headers.Token = `${$}`),
    _e
}
, async _e => _e);
appAxiosInstance.interceptors.response.use(_e => {
    const {code: $, msg: et} = _e.data;
    return $ === API_Code.Need_Login ? (useStore$1.getState().clearUserInfo(),
    _e) : ($ === API_Code.Success || $ === API_Code.Ticker_Not_Found || $ === API_Code.Point_Not_Enough || $ && Vt.error(et),
    _e)
}
, async _e => {
    throw _e
}
);
const useAxios = makeUseAxios({
    axios: appAxiosInstance,
    cache: !1
})
  , createRequest = (_e, $) => (et, tt, nt=!0, rt=!1) => {
    const [it,ot] = reactExports.useState(!0)
      , [st,lt] = reactExports.useState(void 0)
      , [ct,dt] = reactExports.useState(null)
      , [{data: pt, loading: ht, error: mt},yt] = useAxios($(et), {
        manual: tt || !1,
        autoCancel: nt
    });
    return useUpdateEffect( () => {
        lt(pt)
    }
    , [pt]),
    useUpdateEffect( () => {
        dt(mt)
    }
    , [mt, rt]),
    reactExports.useEffect( () => {
        ot(ht)
    }
    , [ht]),
    {
        data: st,
        fetching: ht,
        loading: it,
        error: ct,
        execute: yt,
        request: async Et => (ot(!0),
        dt(null),
        appAxiosInstance($(Et)).then(_t => (lt(_t.data),
        _t.data)).catch(_t => {
            dt(_t)
        }
        ).finally( () => {
            ot(!1)
        }
        )),
        refresh: async Et => appAxiosInstance($(Et)).then(_t => (lt(_t.data),
        _t.data)).catch(_t => {
            dt(_t)
        }
        )
    }
}
  , globalEthPriceUsd = createRequest("globalEthPriceUsd", () => ({
    url: "/v1/global/sol_usd_price",
    method: "GET"
}))
  , moderatorAddRestriction = createRequest("moderatorAddRestriction", ({requestBody: _e}) => ({
    url: "/v1/moderators/add_restriction",
    method: "POST",
    data: _e,
    headers: {
        "Content-Type": "application/json"
    }
}))
  , moderatorRemoveRestriction = createRequest("moderatorRemoveRestriction", ({requestBody: _e}) => ({
    url: "/v1/moderators/remove_restriction",
    method: "POST",
    data: _e,
    headers: {
        "Content-Type": "application/json"
    }
}))
  , moderatorRestrictedUsers = createRequest("moderatorRestrictedUsers", ({market_id: _e, limit: $, from: et}) => ({
    url: `/v1/moderators/restricted_users/${_e}`,
    method: "GET",
    params: {
        limit: $,
        from: et
    }
}))
  , pointsGetPointsExchangeSign = createRequest("pointsGetPointsExchangeSign", ({requestBody: _e}) => ({
    url: "/v1/points/exchange/sign",
    method: "POST",
    data: _e,
    headers: {
        "Content-Type": "application/json"
    }
}))
  , pointsQueryEstimatedPoints = createRequest("pointsQueryEstimatedPoints", () => ({
    url: "/v1/points/estimated",
    method: "GET"
}))
  , pointsQueryInviteCode = createRequest("pointsQueryInviteCode", () => ({
    url: "/v1/points/invite/code",
    method: "GET"
}))
  , pointsQueryInviteDetail = createRequest("pointsQueryInviteDetail", ({cursor: _e, limit: $}) => ({
    url: "/v1/points/invite/detail",
    method: "GET",
    params: {
        cursor: _e,
        limit: $
    }
}))
  , pointsQueryPoints = createRequest("pointsQueryPoints", () => ({
    url: "/v1/points",
    method: "GET"
}))
  , pointsQueryPointsDetail = createRequest("pointsQueryPointsDetail", ({cursor: _e, limit: $}) => ({
    url: "/v1/points/detail",
    method: "GET",
    params: {
        cursor: _e,
        limit: $
    }
}))
  , postSearch = createRequest("postSearch", ({search_type: _e, param: $, limit: et, cursor: tt, post_type: nt}) => ({
    url: "/v1/search/by_type",
    method: "GET",
    params: {
        search_type: _e,
        param: $,
        limit: et,
        cursor: tt,
        post_type: nt
    }
}))
  , tickerGetInitializeTransaction = createRequest("tickerGetInitializeTransaction", ({requestBody: _e}) => ({
    url: "/v1/tickers/initialize_transaction",
    method: "POST",
    data: _e,
    headers: {
        "Content-Type": "application/json"
    }
}))
  , tickerGetTicker = createRequest("tickerGetTicker", ({symbol: _e}) => ({
    url: `/v1/tickers/${_e}`,
    method: "GET"
}))
  , tickerGetTickers = createRequest("tickerGetTickers", ({sorted_by: _e, sort_direction: $, page_cursor: et, limit: tt, search: nt, new_pairs_resolution: rt}) => ({
    url: "/v1/tickers",
    method: "GET",
    params: {
        sorted_by: _e,
        sort_direction: $,
        page_cursor: et,
        limit: tt,
        search: nt,
        new_pairs_resolution: rt
    }
}))
  , tokenHoldingsServiceQueryTokenDistribution = createRequest("tokenHoldingsServiceQueryTokenDistribution", ({market_id: _e}) => ({
    url: `/v1/token_distribution/${_e}`,
    method: "GET"
}))
  , tokenHoldingsServiceQueryTokenHoldings = createRequest("tokenHoldingsServiceQueryTokenHoldings", ({account: _e, allow_zero_balance: $}) => ({
    url: `/v1/token_holdings/${_e}`,
    method: "GET",
    params: {
        allow_zero_balance: $
    }
}))
  , tokenHoldingsServiceQueryTokenHoldingsHistories = createRequest("tokenHoldingsServiceQueryTokenHoldingsHistories", ({account: _e, limit: $, from: et}) => ({
    url: `/v1/token_holdings_histories/${_e}`,
    method: "GET",
    params: {
        limit: $,
        from: et
    }
}))
  , transactionQuerySwapTransactionHistories = createRequest("transactionQuerySwapTransactionHistories", ({market_id: _e, limit: $, from: et}) => ({
    url: `/v1/swap_histories/${_e}`,
    method: "GET",
    params: {
        limit: $,
        from: et
    }
}))
  , userGenerateUploadUrls = createRequest("userGenerateUploadUrls", ({requestBody: _e}) => ({
    url: "/v1/users/generate_upload_urls",
    method: "POST",
    data: _e,
    headers: {
        "Content-Type": "application/json"
    }
}))
  , userLogin = createRequest("userLogin", ({requestBody: _e}) => ({
    url: "/v1/users/login",
    method: "POST",
    data: _e,
    headers: {
        "Content-Type": "application/json"
    }
}))
  , userQueryMyInfo = createRequest("userQueryMyInfo", () => ({
    url: "/v1/users/my_info",
    method: "GET"
}))
  , userSearchModeratorUsers = createRequest("userSearchModeratorUsers", ({market_id: _e, param: $, limit: et, cursor: tt}) => ({
    url: "/v1/users/moderator_search",
    method: "GET",
    params: {
        market_id: _e,
        param: $,
        limit: et,
        cursor: tt
    }
}));
var dist$1 = {}
  , useWebsocket = {}
  , constants = {};
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.isEventSourceSupported = _e.isReactNative = _e.ReadyState = _e.DEFAULT_HEARTBEAT = _e.UNPARSABLE_JSON_OBJECT = _e.DEFAULT_RECONNECT_INTERVAL_MS = _e.DEFAULT_RECONNECT_LIMIT = _e.SOCKET_IO_PING_CODE = _e.SOCKET_IO_PATH = _e.SOCKET_IO_PING_INTERVAL = _e.DEFAULT_EVENT_SOURCE_OPTIONS = _e.EMPTY_EVENT_HANDLERS = _e.DEFAULT_OPTIONS = void 0;
    var $ = 1
      , et = 1e3 * $;
    _e.DEFAULT_OPTIONS = {},
    _e.EMPTY_EVENT_HANDLERS = {},
    _e.DEFAULT_EVENT_SOURCE_OPTIONS = {
        withCredentials: !1,
        events: _e.EMPTY_EVENT_HANDLERS
    },
    _e.SOCKET_IO_PING_INTERVAL = 25 * et,
    _e.SOCKET_IO_PATH = "/socket.io/?EIO=3&transport=websocket",
    _e.SOCKET_IO_PING_CODE = "2",
    _e.DEFAULT_RECONNECT_LIMIT = 20,
    _e.DEFAULT_RECONNECT_INTERVAL_MS = 5e3,
    _e.UNPARSABLE_JSON_OBJECT = {},
    _e.DEFAULT_HEARTBEAT = {
        message: "ping",
        timeout: 6e4,
        interval: 25e3
    };
    var tt;
    (function(rt) {
        rt[rt.UNINSTANTIATED = -1] = "UNINSTANTIATED",
        rt[rt.CONNECTING = 0] = "CONNECTING",
        rt[rt.OPEN = 1] = "OPEN",
        rt[rt.CLOSING = 2] = "CLOSING",
        rt[rt.CLOSED = 3] = "CLOSED"
    }
    )(tt || (_e.ReadyState = tt = {}));
    var nt = function() {
        try {
            return "EventSource"in globalThis
        } catch {
            return !1
        }
    };
    _e.isReactNative = typeof navigator < "u" && navigator.product === "ReactNative",
    _e.isEventSourceSupported = !_e.isReactNative && nt()
}
)(constants);
var createOrJoin = {}
  , globals = {};
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.resetWebSockets = _e.sharedWebSockets = void 0,
    _e.sharedWebSockets = {};
    var $ = function(et) {
        if (et && _e.sharedWebSockets.hasOwnProperty(et))
            delete _e.sharedWebSockets[et];
        else
            for (var tt in _e.sharedWebSockets)
                _e.sharedWebSockets.hasOwnProperty(tt) && delete _e.sharedWebSockets[tt]
    };
    _e.resetWebSockets = $
}
)(globals);
var attachListener = {}
  , socketIo = {};
Object.defineProperty(socketIo, "__esModule", {
    value: !0
});
socketIo.setUpSocketIOPing = socketIo.appendQueryParams = socketIo.parseSocketIOUrl = void 0;
var constants_1$7 = constants
  , parseSocketIOUrl = function(_e) {
    if (_e) {
        var $ = /^https|wss/.test(_e)
          , et = _e.replace(/^(https?|wss?)(:\/\/)?/, "")
          , tt = et.replace(/\/$/, "")
          , nt = $ ? "wss" : "ws";
        return "".concat(nt, "://").concat(tt).concat(constants_1$7.SOCKET_IO_PATH)
    } else if (_e === "") {
        var $ = /^https/.test(window.location.protocol)
          , nt = $ ? "wss" : "ws"
          , rt = window.location.port ? ":".concat(window.location.port) : "";
        return "".concat(nt, "://").concat(window.location.hostname).concat(rt).concat(constants_1$7.SOCKET_IO_PATH)
    }
    return _e
};
socketIo.parseSocketIOUrl = parseSocketIOUrl;
var appendQueryParams = function(_e, $) {
    $ === void 0 && ($ = {});
    var et = /\?([\w]+=[\w]+)/
      , tt = et.test(_e)
      , nt = "".concat(Object.entries($).reduce(function(rt, it) {
        var ot = it[0]
          , st = it[1];
        return rt + "".concat(ot, "=").concat(st, "&")
    }, "").slice(0, -1));
    return "".concat(_e).concat(tt ? "&" : "?").concat(nt)
};
socketIo.appendQueryParams = appendQueryParams;
var setUpSocketIOPing = function(_e, $) {
    $ === void 0 && ($ = constants_1$7.SOCKET_IO_PING_INTERVAL);
    var et = function() {
        return _e(constants_1$7.SOCKET_IO_PING_CODE)
    };
    return window.setInterval(et, $)
};
socketIo.setUpSocketIOPing = setUpSocketIOPing;
var heartbeat$1 = {};
Object.defineProperty(heartbeat$1, "__esModule", {
    value: !0
});
heartbeat$1.heartbeat = heartbeat;
var constants_1$6 = constants;
function heartbeat(_e, $, et) {
    var tt = et || {}
      , nt = tt.interval
      , rt = nt === void 0 ? constants_1$6.DEFAULT_HEARTBEAT.interval : nt
      , it = tt.timeout
      , ot = it === void 0 ? constants_1$6.DEFAULT_HEARTBEAT.timeout : it
      , st = tt.message
      , lt = st === void 0 ? constants_1$6.DEFAULT_HEARTBEAT.message : st
      , ct = setInterval(function() {
        if ($.current + ot <= Date.now())
            _e.close();
        else if ($.current + rt <= Date.now())
            try {
                typeof lt == "function" ? _e.send(lt()) : _e.send(lt)
            } catch {
                _e.close()
            }
    }, rt);
    return _e.addEventListener("close", function() {
        clearInterval(ct)
    }),
    function() {}
}
var util = {}
  , manageSubscribers = {};
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.resetSubscribers = _e.removeSubscriber = _e.addSubscriber = _e.hasSubscribers = _e.getSubscribers = void 0;
    var $ = {}
      , et = []
      , tt = function(st) {
        return (0,
        _e.hasSubscribers)(st) ? Array.from($[st]) : et
    };
    _e.getSubscribers = tt;
    var nt = function(st) {
        var lt;
        return ((lt = $[st]) === null || lt === void 0 ? void 0 : lt.size) > 0
    };
    _e.hasSubscribers = nt;
    var rt = function(st, lt) {
        $[st] = $[st] || new Set,
        $[st].add(lt)
    };
    _e.addSubscriber = rt;
    var it = function(st, lt) {
        $[st].delete(lt)
    };
    _e.removeSubscriber = it;
    var ot = function(st) {
        if (st && $.hasOwnProperty(st))
            delete $[st];
        else
            for (var lt in $)
                $.hasOwnProperty(lt) && delete $[lt]
    };
    _e.resetSubscribers = ot
}
)(manageSubscribers);
Object.defineProperty(util, "__esModule", {
    value: !0
});
util.assertIsWebSocket = assertIsWebSocket;
util.resetGlobalState = resetGlobalState;
var globals_1$2 = globals
  , manage_subscribers_1$2 = manageSubscribers;
function assertIsWebSocket(_e, $) {
    if (!$ && !(_e instanceof WebSocket))
        throw new Error("")
}
function resetGlobalState(_e) {
    (0,
    manage_subscribers_1$2.resetSubscribers)(_e),
    (0,
    globals_1$2.resetWebSockets)(_e)
}
var __assign$5 = commonjsGlobal$1 && commonjsGlobal$1.__assign || function() {
    return __assign$5 = Object.assign || function(_e) {
        for (var $, et = 1, tt = arguments.length; et < tt; et++) {
            $ = arguments[et];
            for (var nt in $)
                Object.prototype.hasOwnProperty.call($, nt) && (_e[nt] = $[nt])
        }
        return _e
    }
    ,
    __assign$5.apply(this, arguments)
}
;
Object.defineProperty(attachListener, "__esModule", {
    value: !0
});
attachListener.attachListeners = void 0;
var socket_io_1$1 = socketIo
  , heartbeat_1$1 = heartbeat$1
  , constants_1$5 = constants
  , util_1$1 = util
  , bindMessageHandler$1 = function(_e, $, et, tt) {
    _e.onmessage = function(nt) {
        var rt;
        $.current.onMessage && $.current.onMessage(nt),
        typeof (tt == null ? void 0 : tt.current) == "number" && (tt.current = Date.now()),
        !(typeof $.current.filter == "function" && $.current.filter(nt) !== !0) && ($.current.heartbeat && typeof $.current.heartbeat != "boolean" && ((rt = $.current.heartbeat) === null || rt === void 0 ? void 0 : rt.returnMessage) === nt.data || et(nt))
    }
}
  , bindOpenHandler$1 = function(_e, $, et, tt, nt) {
    _e.onopen = function(rt) {
        if ($.current.onOpen && $.current.onOpen(rt),
        tt.current = 0,
        et(constants_1$5.ReadyState.OPEN),
        $.current.heartbeat && _e instanceof WebSocket) {
            var it = typeof $.current.heartbeat == "boolean" ? void 0 : $.current.heartbeat;
            nt.current = Date.now(),
            (0,
            heartbeat_1$1.heartbeat)(_e, nt, it)
        }
    }
}
  , bindCloseHandler$1 = function(_e, $, et, tt, nt) {
    if (constants_1$5.isEventSourceSupported && _e instanceof EventSource)
        return function() {}
        ;
    (0,
    util_1$1.assertIsWebSocket)(_e, $.current.skipAssert);
    var rt;
    return _e.onclose = function(it) {
        var ot;
        if ($.current.onClose && $.current.onClose(it),
        et(constants_1$5.ReadyState.CLOSED),
        $.current.shouldReconnect && $.current.shouldReconnect(it)) {
            var st = (ot = $.current.reconnectAttempts) !== null && ot !== void 0 ? ot : constants_1$5.DEFAULT_RECONNECT_LIMIT;
            if (nt.current < st) {
                var lt = typeof $.current.reconnectInterval == "function" ? $.current.reconnectInterval(nt.current) : $.current.reconnectInterval;
                rt = window.setTimeout(function() {
                    nt.current++,
                    tt()
                }, lt ?? constants_1$5.DEFAULT_RECONNECT_INTERVAL_MS)
            } else
                $.current.onReconnectStop && $.current.onReconnectStop(st)
        }
    }
    ,
    function() {
        return rt && window.clearTimeout(rt)
    }
}
  , bindErrorHandler$1 = function(_e, $, et, tt, nt) {
    var rt;
    return _e.onerror = function(it) {
        var ot;
        if ($.current.onError && $.current.onError(it),
        constants_1$5.isEventSourceSupported && _e instanceof EventSource && ($.current.onClose && $.current.onClose(__assign$5(__assign$5({}, it), {
            code: 1006,
            reason: "An error occurred with the EventSource: ".concat(it),
            wasClean: !1
        })),
        et(constants_1$5.ReadyState.CLOSED),
        _e.close()),
        $.current.retryOnError)
            if (nt.current < ((ot = $.current.reconnectAttempts) !== null && ot !== void 0 ? ot : constants_1$5.DEFAULT_RECONNECT_LIMIT)) {
                var st = typeof $.current.reconnectInterval == "function" ? $.current.reconnectInterval(nt.current) : $.current.reconnectInterval;
                rt = window.setTimeout(function() {
                    nt.current++,
                    tt()
                }, st ?? constants_1$5.DEFAULT_RECONNECT_INTERVAL_MS)
            } else
                $.current.onReconnectStop && $.current.onReconnectStop($.current.reconnectAttempts)
    }
    ,
    function() {
        return rt && window.clearTimeout(rt)
    }
}
  , attachListeners = function(_e, $, et, tt, nt, rt, it) {
    var ot = $.setLastMessage, st = $.setReadyState, lt, ct, dt;
    return et.current.fromSocketIO && (lt = (0,
    socket_io_1$1.setUpSocketIOPing)(it)),
    bindMessageHandler$1(_e, et, ot, rt),
    bindOpenHandler$1(_e, et, st, nt, rt),
    ct = bindCloseHandler$1(_e, et, st, tt, nt),
    dt = bindErrorHandler$1(_e, et, st, tt, nt),
    function() {
        st(constants_1$5.ReadyState.CLOSING),
        ct(),
        dt(),
        _e.close(),
        lt && clearInterval(lt)
    }
};
attachListener.attachListeners = attachListeners;
var attachSharedListeners$1 = {}
  , __assign$4 = commonjsGlobal$1 && commonjsGlobal$1.__assign || function() {
    return __assign$4 = Object.assign || function(_e) {
        for (var $, et = 1, tt = arguments.length; et < tt; et++) {
            $ = arguments[et];
            for (var nt in $)
                Object.prototype.hasOwnProperty.call($, nt) && (_e[nt] = $[nt])
        }
        return _e
    }
    ,
    __assign$4.apply(this, arguments)
}
;
Object.defineProperty(attachSharedListeners$1, "__esModule", {
    value: !0
});
attachSharedListeners$1.attachSharedListeners = void 0;
var globals_1$1 = globals
  , constants_1$4 = constants
  , manage_subscribers_1$1 = manageSubscribers
  , socket_io_1 = socketIo
  , heartbeat_1 = heartbeat$1
  , bindMessageHandler = function(_e, $, et) {
    _e.onmessage = function(tt) {
        (0,
        manage_subscribers_1$1.getSubscribers)($).forEach(function(nt) {
            var rt;
            nt.optionsRef.current.onMessage && nt.optionsRef.current.onMessage(tt),
            typeof ((rt = nt == null ? void 0 : nt.lastMessageTime) === null || rt === void 0 ? void 0 : rt.current) == "number" && (nt.lastMessageTime.current = Date.now()),
            !(typeof nt.optionsRef.current.filter == "function" && nt.optionsRef.current.filter(tt) !== !0) && (et && typeof et != "boolean" && (et == null ? void 0 : et.returnMessage) === tt.data || nt.setLastMessage(tt))
        })
    }
}
  , bindOpenHandler = function(_e, $, et) {
    _e.onopen = function(tt) {
        (0,
        manage_subscribers_1$1.getSubscribers)($).forEach(function(nt) {
            nt.reconnectCount.current = 0,
            nt.optionsRef.current.onOpen && nt.optionsRef.current.onOpen(tt),
            nt.setReadyState(constants_1$4.ReadyState.OPEN),
            et && _e instanceof WebSocket && (nt.lastMessageTime.current = Date.now(),
            (0,
            heartbeat_1.heartbeat)(_e, nt.lastMessageTime, typeof et == "boolean" ? void 0 : et))
        })
    }
}
  , bindCloseHandler = function(_e, $) {
    _e instanceof WebSocket && (_e.onclose = function(et) {
        (0,
        manage_subscribers_1$1.getSubscribers)($).forEach(function(tt) {
            tt.optionsRef.current.onClose && tt.optionsRef.current.onClose(et),
            tt.setReadyState(constants_1$4.ReadyState.CLOSED)
        }),
        delete globals_1$1.sharedWebSockets[$],
        (0,
        manage_subscribers_1$1.getSubscribers)($).forEach(function(tt) {
            var nt;
            if (tt.optionsRef.current.shouldReconnect && tt.optionsRef.current.shouldReconnect(et)) {
                var rt = (nt = tt.optionsRef.current.reconnectAttempts) !== null && nt !== void 0 ? nt : constants_1$4.DEFAULT_RECONNECT_LIMIT;
                if (tt.reconnectCount.current < rt) {
                    var it = typeof tt.optionsRef.current.reconnectInterval == "function" ? tt.optionsRef.current.reconnectInterval(tt.reconnectCount.current) : tt.optionsRef.current.reconnectInterval;
                    setTimeout(function() {
                        tt.reconnectCount.current++,
                        tt.reconnect.current()
                    }, it ?? constants_1$4.DEFAULT_RECONNECT_INTERVAL_MS)
                } else
                    tt.optionsRef.current.onReconnectStop && tt.optionsRef.current.onReconnectStop(tt.optionsRef.current.reconnectAttempts)
            }
        })
    }
    )
}
  , bindErrorHandler = function(_e, $) {
    _e.onerror = function(et) {
        (0,
        manage_subscribers_1$1.getSubscribers)($).forEach(function(tt) {
            tt.optionsRef.current.onError && tt.optionsRef.current.onError(et),
            constants_1$4.isEventSourceSupported && _e instanceof EventSource && (tt.optionsRef.current.onClose && tt.optionsRef.current.onClose(__assign$4(__assign$4({}, et), {
                code: 1006,
                reason: "An error occurred with the EventSource: ".concat(et),
                wasClean: !1
            })),
            tt.setReadyState(constants_1$4.ReadyState.CLOSED))
        }),
        constants_1$4.isEventSourceSupported && _e instanceof EventSource && _e.close()
    }
}
  , attachSharedListeners = function(_e, $, et, tt) {
    var nt;
    return et.current.fromSocketIO && (nt = (0,
    socket_io_1.setUpSocketIOPing)(tt)),
    bindMessageHandler(_e, $, et.current.heartbeat),
    bindCloseHandler(_e, $),
    bindOpenHandler(_e, $, et.current.heartbeat),
    bindErrorHandler(_e, $),
    function() {
        nt && clearInterval(nt)
    }
};
attachSharedListeners$1.attachSharedListeners = attachSharedListeners;
Object.defineProperty(createOrJoin, "__esModule", {
    value: !0
});
createOrJoin.createOrJoinSocket = void 0;
var globals_1 = globals
  , constants_1$3 = constants
  , attach_listener_1 = attachListener
  , attach_shared_listeners_1 = attachSharedListeners$1
  , manage_subscribers_1 = manageSubscribers
  , cleanSubscribers = function(_e, $, et, tt, nt) {
    return function() {
        if ((0,
        manage_subscribers_1.removeSubscriber)(_e, $),
        !(0,
        manage_subscribers_1.hasSubscribers)(_e)) {
            try {
                var rt = globals_1.sharedWebSockets[_e];
                rt instanceof WebSocket && (rt.onclose = function(it) {
                    et.current.onClose && et.current.onClose(it),
                    tt(constants_1$3.ReadyState.CLOSED)
                }
                ),
                rt.close()
            } catch {}
            nt && nt(),
            delete globals_1.sharedWebSockets[_e]
        }
    }
}
  , createOrJoinSocket = function(_e, $, et, tt, nt, rt, it, ot, st) {
    if (!constants_1$3.isEventSourceSupported && tt.current.eventSourceOptions)
        throw constants_1$3.isReactNative ? new Error("EventSource is not supported in ReactNative") : new Error("EventSource is not supported");
    if (tt.current.share) {
        var lt = null;
        globals_1.sharedWebSockets[$] === void 0 ? (globals_1.sharedWebSockets[$] = tt.current.eventSourceOptions ? new EventSource($,tt.current.eventSourceOptions) : new WebSocket($,tt.current.protocols),
        _e.current = globals_1.sharedWebSockets[$],
        et(constants_1$3.ReadyState.CONNECTING),
        lt = (0,
        attach_shared_listeners_1.attachSharedListeners)(globals_1.sharedWebSockets[$], $, tt, st)) : (_e.current = globals_1.sharedWebSockets[$],
        et(globals_1.sharedWebSockets[$].readyState));
        var ct = {
            setLastMessage: nt,
            setReadyState: et,
            optionsRef: tt,
            reconnectCount: it,
            lastMessageTime: ot,
            reconnect: rt
        };
        return (0,
        manage_subscribers_1.addSubscriber)($, ct),
        cleanSubscribers($, ct, tt, et, lt)
    } else {
        if (_e.current = tt.current.eventSourceOptions ? new EventSource($,tt.current.eventSourceOptions) : new WebSocket($,tt.current.protocols),
        et(constants_1$3.ReadyState.CONNECTING),
        !_e.current)
            throw new Error("WebSocket failed to be created");
        return (0,
        attach_listener_1.attachListeners)(_e.current, {
            setLastMessage: nt,
            setReadyState: et
        }, tt, rt.current, it, ot, st)
    }
};
createOrJoin.createOrJoinSocket = createOrJoinSocket;
var getUrl = {};
(function(_e) {
    var $ = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(st, lt, ct, dt) {
        function pt(ht) {
            return ht instanceof ct ? ht : new ct(function(mt) {
                mt(ht)
            }
            )
        }
        return new (ct || (ct = Promise))(function(ht, mt) {
            function yt(wt) {
                try {
                    _t(dt.next(wt))
                } catch (St) {
                    mt(St)
                }
            }
            function Et(wt) {
                try {
                    _t(dt.throw(wt))
                } catch (St) {
                    mt(St)
                }
            }
            function _t(wt) {
                wt.done ? ht(wt.value) : pt(wt.value).then(yt, Et)
            }
            _t((dt = dt.apply(st, lt || [])).next())
        }
        )
    }
      , et = commonjsGlobal$1 && commonjsGlobal$1.__generator || function(st, lt) {
        var ct = {
            label: 0,
            sent: function() {
                if (ht[0] & 1)
                    throw ht[1];
                return ht[1]
            },
            trys: [],
            ops: []
        }, dt, pt, ht, mt = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
        return mt.next = yt(0),
        mt.throw = yt(1),
        mt.return = yt(2),
        typeof Symbol == "function" && (mt[Symbol.iterator] = function() {
            return this
        }
        ),
        mt;
        function yt(_t) {
            return function(wt) {
                return Et([_t, wt])
            }
        }
        function Et(_t) {
            if (dt)
                throw new TypeError("Generator is already executing.");
            for (; mt && (mt = 0,
            _t[0] && (ct = 0)),
            ct; )
                try {
                    if (dt = 1,
                    pt && (ht = _t[0] & 2 ? pt.return : _t[0] ? pt.throw || ((ht = pt.return) && ht.call(pt),
                    0) : pt.next) && !(ht = ht.call(pt, _t[1])).done)
                        return ht;
                    switch (pt = 0,
                    ht && (_t = [_t[0] & 2, ht.value]),
                    _t[0]) {
                    case 0:
                    case 1:
                        ht = _t;
                        break;
                    case 4:
                        return ct.label++,
                        {
                            value: _t[1],
                            done: !1
                        };
                    case 5:
                        ct.label++,
                        pt = _t[1],
                        _t = [0];
                        continue;
                    case 7:
                        _t = ct.ops.pop(),
                        ct.trys.pop();
                        continue;
                    default:
                        if (ht = ct.trys,
                        !(ht = ht.length > 0 && ht[ht.length - 1]) && (_t[0] === 6 || _t[0] === 2)) {
                            ct = 0;
                            continue
                        }
                        if (_t[0] === 3 && (!ht || _t[1] > ht[0] && _t[1] < ht[3])) {
                            ct.label = _t[1];
                            break
                        }
                        if (_t[0] === 6 && ct.label < ht[1]) {
                            ct.label = ht[1],
                            ht = _t;
                            break
                        }
                        if (ht && ct.label < ht[2]) {
                            ct.label = ht[2],
                            ct.ops.push(_t);
                            break
                        }
                        ht[2] && ct.ops.pop(),
                        ct.trys.pop();
                        continue
                    }
                    _t = lt.call(st, ct)
                } catch (wt) {
                    _t = [6, wt],
                    pt = 0
                } finally {
                    dt = ht = 0
                }
            if (_t[0] & 5)
                throw _t[1];
            return {
                value: _t[0] ? _t[1] : void 0,
                done: !0
            }
        }
    }
      , tt = commonjsGlobal$1 && commonjsGlobal$1.__spreadArray || function(st, lt, ct) {
        if (ct || arguments.length === 2)
            for (var dt = 0, pt = lt.length, ht; dt < pt; dt++)
                (ht || !(dt in lt)) && (ht || (ht = Array.prototype.slice.call(lt, 0, dt)),
                ht[dt] = lt[dt]);
        return st.concat(ht || Array.prototype.slice.call(lt))
    }
    ;
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.getUrl = void 0;
    var nt = socketIo
      , rt = constants
      , it = function(st) {
        return new Promise(function(lt) {
            return window.setTimeout(lt, st)
        }
        )
    }
      , ot = function(st, lt) {
        for (var ct = [], dt = 2; dt < arguments.length; dt++)
            ct[dt - 2] = arguments[dt];
        return $(void 0, tt([st, lt], ct, !0), void 0, function(pt, ht, mt) {
            var yt, Et, _t, wt, St, Ct, Nt, Lt;
            return mt === void 0 && (mt = 0),
            et(this, function(kt) {
                switch (kt.label) {
                case 0:
                    if (typeof pt != "function")
                        return [3, 10];
                    kt.label = 1;
                case 1:
                    return kt.trys.push([1, 3, , 9]),
                    [4, pt()];
                case 2:
                    return yt = kt.sent(),
                    [3, 9];
                case 3:
                    return kt.sent(),
                    ht.current.retryOnError ? (Et = (Ct = ht.current.reconnectAttempts) !== null && Ct !== void 0 ? Ct : rt.DEFAULT_RECONNECT_LIMIT,
                    mt < Et ? (_t = typeof ht.current.reconnectInterval == "function" ? ht.current.reconnectInterval(mt) : ht.current.reconnectInterval,
                    [4, it(_t ?? rt.DEFAULT_RECONNECT_INTERVAL_MS)]) : [3, 5]) : [3, 7];
                case 4:
                    return kt.sent(),
                    [2, (0,
                    _e.getUrl)(pt, ht, mt + 1)];
                case 5:
                    return (Lt = (Nt = ht.current).onReconnectStop) === null || Lt === void 0 || Lt.call(Nt, mt),
                    [2, null];
                case 6:
                    return [3, 8];
                case 7:
                    return [2, null];
                case 8:
                    return [3, 9];
                case 9:
                    return [3, 11];
                case 10:
                    yt = pt,
                    kt.label = 11;
                case 11:
                    return wt = ht.current.fromSocketIO ? (0,
                    nt.parseSocketIOUrl)(yt) : yt,
                    St = ht.current.queryParams ? (0,
                    nt.appendQueryParams)(wt, ht.current.queryParams) : wt,
                    [2, St]
                }
            })
        })
    };
    _e.getUrl = ot
}
)(getUrl);
var proxy$1 = {};
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.websocketWrapper = void 0;
    var $ = function(et, tt) {
        return new Proxy(et,{
            get: function(nt, rt) {
                var it = nt[rt];
                return rt === "reconnect" ? tt : typeof it == "function" ? function() {}
                : it
            },
            set: function(nt, rt, it) {
                return /^on/.test(rt) ? !1 : (nt[rt] = it,
                !0)
            }
        })
    };
    _e.websocketWrapper = $,
    _e.default = _e.websocketWrapper
}
)(proxy$1);
var __assign$3 = commonjsGlobal$1 && commonjsGlobal$1.__assign || function() {
    return __assign$3 = Object.assign || function(_e) {
        for (var $, et = 1, tt = arguments.length; et < tt; et++) {
            $ = arguments[et];
            for (var nt in $)
                Object.prototype.hasOwnProperty.call($, nt) && (_e[nt] = $[nt])
        }
        return _e
    }
    ,
    __assign$3.apply(this, arguments)
}
  , __awaiter = commonjsGlobal$1 && commonjsGlobal$1.__awaiter || function(_e, $, et, tt) {
    function nt(rt) {
        return rt instanceof et ? rt : new et(function(it) {
            it(rt)
        }
        )
    }
    return new (et || (et = Promise))(function(rt, it) {
        function ot(ct) {
            try {
                lt(tt.next(ct))
            } catch (dt) {
                it(dt)
            }
        }
        function st(ct) {
            try {
                lt(tt.throw(ct))
            } catch (dt) {
                it(dt)
            }
        }
        function lt(ct) {
            ct.done ? rt(ct.value) : nt(ct.value).then(ot, st)
        }
        lt((tt = tt.apply(_e, $ || [])).next())
    }
    )
}
  , __generator = commonjsGlobal$1 && commonjsGlobal$1.__generator || function(_e, $) {
    var et = {
        label: 0,
        sent: function() {
            if (rt[0] & 1)
                throw rt[1];
            return rt[1]
        },
        trys: [],
        ops: []
    }, tt, nt, rt, it = Object.create((typeof Iterator == "function" ? Iterator : Object).prototype);
    return it.next = ot(0),
    it.throw = ot(1),
    it.return = ot(2),
    typeof Symbol == "function" && (it[Symbol.iterator] = function() {
        return this
    }
    ),
    it;
    function ot(lt) {
        return function(ct) {
            return st([lt, ct])
        }
    }
    function st(lt) {
        if (tt)
            throw new TypeError("Generator is already executing.");
        for (; it && (it = 0,
        lt[0] && (et = 0)),
        et; )
            try {
                if (tt = 1,
                nt && (rt = lt[0] & 2 ? nt.return : lt[0] ? nt.throw || ((rt = nt.return) && rt.call(nt),
                0) : nt.next) && !(rt = rt.call(nt, lt[1])).done)
                    return rt;
                switch (nt = 0,
                rt && (lt = [lt[0] & 2, rt.value]),
                lt[0]) {
                case 0:
                case 1:
                    rt = lt;
                    break;
                case 4:
                    return et.label++,
                    {
                        value: lt[1],
                        done: !1
                    };
                case 5:
                    et.label++,
                    nt = lt[1],
                    lt = [0];
                    continue;
                case 7:
                    lt = et.ops.pop(),
                    et.trys.pop();
                    continue;
                default:
                    if (rt = et.trys,
                    !(rt = rt.length > 0 && rt[rt.length - 1]) && (lt[0] === 6 || lt[0] === 2)) {
                        et = 0;
                        continue
                    }
                    if (lt[0] === 3 && (!rt || lt[1] > rt[0] && lt[1] < rt[3])) {
                        et.label = lt[1];
                        break
                    }
                    if (lt[0] === 6 && et.label < rt[1]) {
                        et.label = rt[1],
                        rt = lt;
                        break
                    }
                    if (rt && et.label < rt[2]) {
                        et.label = rt[2],
                        et.ops.push(lt);
                        break
                    }
                    rt[2] && et.ops.pop(),
                    et.trys.pop();
                    continue
                }
                lt = $.call(_e, et)
            } catch (ct) {
                lt = [6, ct],
                nt = 0
            } finally {
                tt = rt = 0
            }
        if (lt[0] & 5)
            throw lt[1];
        return {
            value: lt[0] ? lt[1] : void 0,
            done: !0
        }
    }
}
  , __importDefault = commonjsGlobal$1 && commonjsGlobal$1.__importDefault || function(_e) {
    return _e && _e.__esModule ? _e : {
        default: _e
    }
}
;
Object.defineProperty(useWebsocket, "__esModule", {
    value: !0
});
useWebsocket.useWebSocket = void 0;
var react_1$2 = reactExports
  , react_dom_1 = reactDomExports
  , constants_1$2 = constants
  , create_or_join_1 = createOrJoin
  , get_url_1 = getUrl
  , proxy_1 = __importDefault(proxy$1)
  , util_1 = util
  , useWebSocket$1 = function(_e, $, et) {
    $ === void 0 && ($ = constants_1$2.DEFAULT_OPTIONS),
    et === void 0 && (et = !0);
    var tt = (0,
    react_1$2.useState)(null)
      , nt = tt[0]
      , rt = tt[1]
      , it = (0,
    react_1$2.useState)({})
      , ot = it[0]
      , st = it[1]
      , lt = (0,
    react_1$2.useMemo)(function() {
        if (nt)
            try {
                return JSON.parse(nt.data)
            } catch {
                return constants_1$2.UNPARSABLE_JSON_OBJECT
            }
        return null
    }, [nt])
      , ct = (0,
    react_1$2.useRef)(null)
      , dt = (0,
    react_1$2.useRef)(null)
      , pt = (0,
    react_1$2.useRef)(function() {})
      , ht = (0,
    react_1$2.useRef)(0)
      , mt = (0,
    react_1$2.useRef)(Date.now())
      , yt = (0,
    react_1$2.useRef)([])
      , Et = (0,
    react_1$2.useRef)(null)
      , _t = (0,
    react_1$2.useRef)($);
    _t.current = $;
    var wt = ct.current && ot[ct.current] !== void 0 ? ot[ct.current] : _e !== null && et === !0 ? constants_1$2.ReadyState.CONNECTING : constants_1$2.ReadyState.UNINSTANTIATED
      , St = $.queryParams ? JSON.stringify($.queryParams) : null
      , Ct = (0,
    react_1$2.useCallback)(function(kt, Ut) {
        var Jt;
        Ut === void 0 && (Ut = !0),
        !(constants_1$2.isEventSourceSupported && dt.current instanceof EventSource) && (((Jt = dt.current) === null || Jt === void 0 ? void 0 : Jt.readyState) === constants_1$2.ReadyState.OPEN ? ((0,
        util_1.assertIsWebSocket)(dt.current, _t.current.skipAssert),
        dt.current.send(kt)) : Ut && yt.current.push(kt))
    }, [])
      , Nt = (0,
    react_1$2.useCallback)(function(kt, Ut) {
        Ut === void 0 && (Ut = !0),
        Ct(JSON.stringify(kt), Ut)
    }, [Ct])
      , Lt = (0,
    react_1$2.useCallback)(function() {
        return _t.current.share !== !0 || constants_1$2.isEventSourceSupported && dt.current instanceof EventSource ? dt.current : (Et.current === null && dt.current && ((0,
        util_1.assertIsWebSocket)(dt.current, _t.current.skipAssert),
        Et.current = (0,
        proxy_1.default)(dt.current, pt)),
        Et.current)
    }, []);
    return (0,
    react_1$2.useEffect)(function() {
        if (_e !== null && et === !0) {
            var kt, Ut = !1, Jt = !0, Pt = function() {
                return __awaiter(void 0, void 0, void 0, function() {
                    var Xt, rn, zt;
                    return __generator(this, function(xt) {
                        switch (xt.label) {
                        case 0:
                            return Xt = ct,
                            [4, (0,
                            get_url_1.getUrl)(_e, _t)];
                        case 1:
                            return Xt.current = xt.sent(),
                            ct.current === null ? (ct.current = "ABORTED",
                            (0,
                            react_dom_1.flushSync)(function() {
                                return st(function($t) {
                                    return __assign$3(__assign$3({}, $t), {
                                        ABORTED: constants_1$2.ReadyState.CLOSED
                                    })
                                })
                            }),
                            [2]) : (rn = function($t) {
                                Ut || (0,
                                react_dom_1.flushSync)(function() {
                                    return rt($t)
                                })
                            }
                            ,
                            zt = function($t) {
                                Ut || (0,
                                react_dom_1.flushSync)(function() {
                                    return st(function(Dt) {
                                        var jt;
                                        return __assign$3(__assign$3({}, Dt), ct.current && (jt = {},
                                        jt[ct.current] = $t,
                                        jt))
                                    })
                                })
                            }
                            ,
                            Jt && (kt = (0,
                            create_or_join_1.createOrJoinSocket)(dt, ct.current, zt, _t, rn, pt, ht, mt, Ct)),
                            [2])
                        }
                    })
                })
            };
            return pt.current = function() {
                Ut || (Et.current && (Et.current = null),
                kt == null || kt(),
                Pt())
            }
            ,
            Pt(),
            function() {
                Ut = !0,
                Jt = !1,
                Et.current && (Et.current = null),
                kt == null || kt(),
                rt(null)
            }
        } else
            (_e === null || et === !1) && (ht.current = 0,
            st(function(Xt) {
                var rn;
                return __assign$3(__assign$3({}, Xt), ct.current && (rn = {},
                rn[ct.current] = constants_1$2.ReadyState.CLOSED,
                rn))
            }))
    }, [_e, et, St, Ct]),
    (0,
    react_1$2.useEffect)(function() {
        wt === constants_1$2.ReadyState.OPEN && yt.current.splice(0).forEach(function(kt) {
            Ct(kt)
        })
    }, [wt]),
    {
        sendMessage: Ct,
        sendJsonMessage: Nt,
        lastMessage: nt,
        lastJsonMessage: lt,
        readyState: wt,
        getWebSocket: Lt
    }
};
useWebsocket.useWebSocket = useWebSocket$1;
var useSocketIo = {}
  , __assign$2 = commonjsGlobal$1 && commonjsGlobal$1.__assign || function() {
    return __assign$2 = Object.assign || function(_e) {
        for (var $, et = 1, tt = arguments.length; et < tt; et++) {
            $ = arguments[et];
            for (var nt in $)
                Object.prototype.hasOwnProperty.call($, nt) && (_e[nt] = $[nt])
        }
        return _e
    }
    ,
    __assign$2.apply(this, arguments)
}
;
Object.defineProperty(useSocketIo, "__esModule", {
    value: !0
});
useSocketIo.useSocketIO = void 0;
var react_1$1 = reactExports
  , use_websocket_1$1 = useWebsocket
  , constants_1$1 = constants
  , emptyEvent = {
    type: "empty",
    payload: null
}
  , getSocketData = function(_e) {
    if (!_e || !_e.data)
        return emptyEvent;
    var $ = _e.data.match(/\[.*]/);
    if (!$)
        return emptyEvent;
    var et = JSON.parse($);
    return !Array.isArray(et) || !et[1] ? emptyEvent : {
        type: et[0],
        payload: et[1]
    }
}
  , useSocketIO = function(_e, $, et) {
    $ === void 0 && ($ = constants_1$1.DEFAULT_OPTIONS),
    et === void 0 && (et = !0);
    var tt = (0,
    react_1$1.useMemo)(function() {
        return __assign$2(__assign$2({}, $), {
            fromSocketIO: !0
        })
    }, [])
      , nt = (0,
    use_websocket_1$1.useWebSocket)(_e, tt, et)
      , rt = nt.sendMessage
      , it = nt.sendJsonMessage
      , ot = nt.lastMessage
      , st = nt.readyState
      , lt = nt.getWebSocket
      , ct = (0,
    react_1$1.useMemo)(function() {
        return getSocketData(ot)
    }, [ot]);
    return {
        sendMessage: rt,
        sendJsonMessage: it,
        lastMessage: ct,
        lastJsonMessage: ct,
        readyState: st,
        getWebSocket: lt
    }
};
useSocketIo.useSocketIO = useSocketIO;
var useEventSource$1 = {}
  , __assign = commonjsGlobal$1 && commonjsGlobal$1.__assign || function() {
    return __assign = Object.assign || function(_e) {
        for (var $, et = 1, tt = arguments.length; et < tt; et++) {
            $ = arguments[et];
            for (var nt in $)
                Object.prototype.hasOwnProperty.call($, nt) && (_e[nt] = $[nt])
        }
        return _e
    }
    ,
    __assign.apply(this, arguments)
}
  , __rest$1 = commonjsGlobal$1 && commonjsGlobal$1.__rest || function(_e, $) {
    var et = {};
    for (var tt in _e)
        Object.prototype.hasOwnProperty.call(_e, tt) && $.indexOf(tt) < 0 && (et[tt] = _e[tt]);
    if (_e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var nt = 0, tt = Object.getOwnPropertySymbols(_e); nt < tt.length; nt++)
            $.indexOf(tt[nt]) < 0 && Object.prototype.propertyIsEnumerable.call(_e, tt[nt]) && (et[tt[nt]] = _e[tt[nt]]);
    return et
}
;
Object.defineProperty(useEventSource$1, "__esModule", {
    value: !0
});
useEventSource$1.useEventSource = void 0;
var react_1 = reactExports
  , use_websocket_1 = useWebsocket
  , constants_1 = constants
  , useEventSource = function(_e, $, et) {
    $ === void 0 && ($ = constants_1.DEFAULT_EVENT_SOURCE_OPTIONS);
    var tt = $.withCredentials
      , nt = $.events
      , rt = __rest$1($, ["withCredentials", "events"]);
    et === void 0 && (et = !0);
    var it = __assign(__assign({}, rt), {
        eventSourceOptions: {
            withCredentials: tt
        }
    })
      , ot = (0,
    react_1.useRef)(constants_1.EMPTY_EVENT_HANDLERS);
    nt && (ot.current = nt);
    var st = (0,
    use_websocket_1.useWebSocket)(_e, it, et)
      , lt = st.lastMessage
      , ct = st.readyState
      , dt = st.getWebSocket;
    return (0,
    react_1.useEffect)(function() {
        lt != null && lt.type && Object.entries(ot.current).forEach(function(pt) {
            var ht = pt[0]
              , mt = pt[1];
            ht === lt.type && mt(lt)
        })
    }, [lt]),
    {
        lastEvent: lt,
        readyState: ct,
        getEventSource: dt
    }
};
useEventSource$1.useEventSource = useEventSource;
(function(_e) {
    Object.defineProperty(_e, "__esModule", {
        value: !0
    }),
    _e.resetGlobalState = _e.useEventSource = _e.ReadyState = _e.useSocketIO = _e.default = void 0;
    var $ = useWebsocket;
    Object.defineProperty(_e, "default", {
        enumerable: !0,
        get: function() {
            return $.useWebSocket
        }
    });
    var et = useSocketIo;
    Object.defineProperty(_e, "useSocketIO", {
        enumerable: !0,
        get: function() {
            return et.useSocketIO
        }
    });
    var tt = constants;
    Object.defineProperty(_e, "ReadyState", {
        enumerable: !0,
        get: function() {
            return tt.ReadyState
        }
    });
    var nt = useEventSource$1;
    Object.defineProperty(_e, "useEventSource", {
        enumerable: !0,
        get: function() {
            return nt.useEventSource
        }
    });
    var rt = util;
    Object.defineProperty(_e, "resetGlobalState", {
        enumerable: !0,
        get: function() {
            return rt.resetGlobalState
        }
    })
}
)(dist$1);
const useWebSocket = getDefaultExportFromCjs$2(dist$1)
  , usePriceStore = create$1()(_e => ({
    tickers: {},
    updateTickers: $ => _e(et => ({
        tickers: Object.entries({
            [$.msym]: $,
            ...et.tickers
        }).slice(0, 20).reduce( (tt, nt, rt) => ({
            ...tt,
            [nt[0]]: nt[1]
        }), {})
    })),
    clearTickers: () => _e($ => ({
        tickers: {}
    })),
    tickersRank: {},
    updateTickersRank: $ => _e(et => ({
        tickersRank: Object.entries({
            ...et.tickersRank,
            [$.msym]: $
        }).slice(0, 20).reduce( (tt, nt, rt) => ({
            ...tt,
            [nt[0]]: nt[1]
        }), {})
    })),
    clearTickersRank: () => _e($ => ({
        tickersRank: {}
    })),
    trades: [],
    updateTrades: $ => _e(et => ({
        trades: [...et.trades, $]
    })),
    clearTrades: () => _e($ => ({
        trades: []
    })),
    marketCreated: [],
    updateMarketCreated: $ => _e(et => ({
        marketCreated: [...et.marketCreated, $]
    })),
    clearMarketCreated: () => _e($ => ({
        marketCreated: []
    }))
}));
var lodash = {
    exports: {}
};
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash.exports;
(function(_e, $) {
    (function() {
        var et, tt = "4.17.21", nt = 200, rt = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", it = "Expected a function", ot = "Invalid `variable` option passed into `_.template`", st = "__lodash_hash_undefined__", lt = 500, ct = "__lodash_placeholder__", dt = 1, pt = 2, ht = 4, mt = 1, yt = 2, Et = 1, _t = 2, wt = 4, St = 8, Ct = 16, Nt = 32, Lt = 64, kt = 128, Ut = 256, Jt = 512, Pt = 30, Xt = "...", rn = 800, zt = 16, xt = 1, $t = 2, Dt = 3, jt = 1 / 0, Ft = 9007199254740991, Ht = 17976931348623157e292, qt = NaN, Wt = 4294967295, Mt = Wt - 1, Yt = Wt >>> 1, un = [["ary", kt], ["bind", Et], ["bindKey", _t], ["curry", St], ["curryRight", Ct], ["flip", Jt], ["partial", Nt], ["partialRight", Lt], ["rearg", Ut]], hn = "[object Arguments]", _n = "[object Array]", kn = "[object AsyncFunction]", Dn = "[object Boolean]", jn = "[object Date]", Bn = "[object DOMException]", Un = "[object Error]", Hn = "[object Function]", cr = "[object GeneratorFunction]", Gn = "[object Map]", Mn = "[object Number]", rr = "[object Null]", Zn = "[object Object]", pr = "[object Promise]", Ur = "[object Proxy]", xr = "[object RegExp]", wr = "[object Set]", Rn = "[object String]", Vn = "[object Symbol]", qn = "[object Undefined]", dr = "[object WeakMap]", or = "[object WeakSet]", ir = "[object ArrayBuffer]", Cr = "[object DataView]", br = "[object Float32Array]", an = "[object Float64Array]", Kt = "[object Int8Array]", Gt = "[object Int16Array]", fn = "[object Int32Array]", En = "[object Uint8Array]", vn = "[object Uint8ClampedArray]", Tn = "[object Uint16Array]", sr = "[object Uint32Array]", lr = /\b__p \+= '';/g, wn = /\b(__p \+=) '' \+/g, Pn = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Cn = /&(?:amp|lt|gt|quot|#39);/g, zn = /[&<>"']/g, ur = RegExp(Cn.source), hr = RegExp(zn.source), Ir = /<%-([\s\S]+?)%>/g, _o = /<%([\s\S]+?)%>/g, Xr = /<%=([\s\S]+?)%>/g, jr = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, zs = /^\w*$/, bo = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Jr = /[\\^$.*+?()[\]{}|]/g, Zo = RegExp(Jr.source), ro = /^\s+/, go = /\s/, Sl = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, xo = /\{\n\/\* \[wrapped with (.+)\] \*/, To = /,? & /, Cl = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, mo = /[()=,{}\[\]\/\s]/, Ro = /\\(\\)?/g, lu = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, yo = /\w*$/, Io = /^[-+]0x[0-9a-f]+$/i, ws = /^0b[01]+$/i, Os = /^\[object .+?Constructor\]$/, Ws = /^0o[0-7]+$/i, Hs = /^(?:0|[1-9]\d*)$/, xs = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Ss = /($^)/, Nu = /['\n\r\u2028\u2029\\]/g, $l = "\\ud800-\\udfff", Mu = "\\u0300-\\u036f", Pu = "\\ufe20-\\ufe2f", Du = "\\u20d0-\\u20ff", cu = Mu + Pu + Du, uu = "\\u2700-\\u27bf", du = "a-z\\xdf-\\xf6\\xf8-\\xff", gp = "\\xac\\xb1\\xd7\\xf7", mp = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Bu = "\\u2000-\\u206f", yp = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Uu = "A-Z\\xc0-\\xd6\\xd8-\\xde", P0 = "\\ufe0e\\ufe0f", D0 = gp + mp + Bu + yp, Gm = "[']", Kp = "[" + $l + "]", ju = "[" + D0 + "]", Fu = "[" + cu + "]", Vp = "\\d+", fu = "[" + uu + "]", Km = "[" + du + "]", B0 = "[^" + $l + D0 + Vp + uu + du + Uu + "]", Eo = "\\ud83c[\\udffb-\\udfff]", Ky = "(?:" + Fu + "|" + Eo + ")", Yp = "[^" + $l + "]", qp = "(?:\\ud83c[\\udde6-\\uddff]){2}", Vm = "[\\ud800-\\udbff][\\udc00-\\udfff]", zu = "[" + Uu + "]", U0 = "\\u200d", j0 = "(?:" + Km + "|" + B0 + ")", Vy = "(?:" + zu + "|" + B0 + ")", F0 = "(?:" + Gm + "(?:d|ll|m|re|s|t|ve))?", Ym = "(?:" + Gm + "(?:D|LL|M|RE|S|T|VE))?", qm = Ky + "?", z0 = "[" + P0 + "]?", Yy = "(?:" + U0 + "(?:" + [Yp, qp, Vm].join("|") + ")" + z0 + qm + ")*", Zm = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", qy = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", W0 = z0 + qm + Yy, H0 = "(?:" + [fu, qp, Vm].join("|") + ")" + W0, Zy = "(?:" + [Yp + Fu + "?", Fu, qp, Vm, Kp].join("|") + ")", Xy = RegExp(Gm, "g"), Zp = RegExp(Fu, "g"), pu = RegExp(Eo + "(?=" + Eo + ")|" + Zy + W0, "g"), Xm = RegExp([zu + "?" + Km + "+" + F0 + "(?=" + [ju, zu, "$"].join("|") + ")", Vy + "+" + Ym + "(?=" + [ju, zu + j0, "$"].join("|") + ")", zu + "?" + j0 + "+" + F0, zu + "+" + Ym, qy, Zm, Vp, H0].join("|"), "g"), Qm = RegExp("[" + U0 + $l + cu + P0 + "]"), hu = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, G0 = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], Qy = -1, No = {};
        No[br] = No[an] = No[Kt] = No[Gt] = No[fn] = No[En] = No[vn] = No[Tn] = No[sr] = !0,
        No[hn] = No[_n] = No[ir] = No[Dn] = No[Cr] = No[jn] = No[Un] = No[Hn] = No[Gn] = No[Mn] = No[Zn] = No[xr] = No[wr] = No[Rn] = No[dr] = !1;
        var Oo = {};
        Oo[hn] = Oo[_n] = Oo[ir] = Oo[Cr] = Oo[Dn] = Oo[jn] = Oo[br] = Oo[an] = Oo[Kt] = Oo[Gt] = Oo[fn] = Oo[Gn] = Oo[Mn] = Oo[Zn] = Oo[xr] = Oo[wr] = Oo[Rn] = Oo[Vn] = Oo[En] = Oo[vn] = Oo[Tn] = Oo[sr] = !0,
        Oo[Un] = Oo[Hn] = Oo[dr] = !1;
        var K0 = {
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "A",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "a",
            : "C",
            : "c",
            : "D",
            : "d",
            : "E",
            : "E",
            : "E",
            : "E",
            : "e",
            : "e",
            : "e",
            : "e",
            : "I",
            : "I",
            : "I",
            : "I",
            : "i",
            : "i",
            : "i",
            : "i",
            : "N",
            : "n",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "O",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "o",
            : "U",
            : "U",
            : "U",
            : "U",
            : "u",
            : "u",
            : "u",
            : "u",
            : "Y",
            : "y",
            : "y",
            : "Ae",
            : "ae",
            : "Th",
            : "th",
            : "ss",
            : "A",
            : "A",
            : "A",
            : "a",
            : "a",
            : "a",
            : "C",
            : "C",
            : "C",
            : "C",
            : "c",
            : "c",
            : "c",
            : "c",
            : "D",
            : "D",
            : "d",
            : "d",
            : "E",
            : "E",
            : "E",
            : "E",
            : "E",
            : "e",
            : "e",
            : "e",
            : "e",
            : "e",
            : "G",
            : "G",
            : "G",
            : "G",
            : "g",
            : "g",
            : "g",
            : "g",
            : "H",
            : "H",
            : "h",
            : "h",
            : "I",
            : "I",
            : "I",
            : "I",
            : "I",
            : "i",
            : "i",
            : "i",
            : "i",
            : "i",
            : "J",
            : "j",
            : "K",
            : "k",
            : "k",
            : "L",
            : "L",
            : "L",
            : "L",
            : "L",
            : "l",
            : "l",
            : "l",
            : "l",
            : "l",
            : "N",
            : "N",
            : "N",
            : "N",
            : "n",
            : "n",
            : "n",
            : "n",
            : "O",
            : "O",
            : "O",
            : "o",
            : "o",
            : "o",
            : "R",
            : "R",
            : "R",
            : "r",
            : "r",
            : "r",
            : "S",
            : "S",
            : "S",
            : "S",
            : "s",
            : "s",
            : "s",
            : "s",
            : "T",
            : "T",
            : "T",
            : "t",
            : "t",
            : "t",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "U",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "u",
            : "W",
            : "w",
            : "Y",
            : "y",
            : "Y",
            : "Z",
            : "Z",
            : "Z",
            : "z",
            : "z",
            : "z",
            : "IJ",
            : "ij",
            : "Oe",
            : "oe",
            : "'n",
            : "s"
        }
          , Jy = {
            "&": "&amp;",
            "<": "&lt;",
            ">": "&gt;",
            '"': "&quot;",
            "'": "&#39;"
        }
          , V0 = {
            "&amp;": "&",
            "&lt;": "<",
            "&gt;": ">",
            "&quot;": '"',
            "&#39;": "'"
        }
          , Y0 = {
            "\\": "\\",
            "'": "'",
            "\n": "n",
            "\r": "r",
            "\u2028": "u2028",
            "\u2029": "u2029"
        }
          , e1 = parseFloat
          , q0 = parseInt
          , Z0 = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis
          , X0 = typeof self == "object" && self && self.Object === Object && self
          , rs = Z0 || X0 || Function("return this")()
          , Jm = $ && !$.nodeType && $
          , gu = Jm && !0 && _e && !_e.nodeType && _e
          , Q0 = gu && gu.exports === Jm
          , Xp = Q0 && Z0.process
          , ks = function() {
            try {
                var In = gu && gu.require && gu.require("util").types;
                return In || Xp && Xp.binding && Xp.binding("util")
            } catch {}
        }()
          , e0 = ks && ks.isArrayBuffer
          , J0 = ks && ks.isDate
          , ey = ks && ks.isMap
          , ty = ks && ks.isRegExp
          , t0 = ks && ks.isSet
          , ny = ks && ks.isTypedArray;
        function Ls(In, Kn, Wn) {
            switch (Wn.length) {
            case 0:
                return In.call(Kn);
            case 1:
                return In.call(Kn, Wn[0]);
            case 2:
                return In.call(Kn, Wn[0], Wn[1]);
            case 3:
                return In.call(Kn, Wn[0], Wn[1], Wn[2])
            }
            return In.apply(Kn, Wn)
        }
        function ry(In, Kn, Wn, Tr) {
            for (var zr = -1, po = In == null ? 0 : In.length; ++zr < po; ) {
                var Xo = In[zr];
                Kn(Tr, Xo, Wn(Xo), In)
            }
            return Tr
        }
        function Gs(In, Kn) {
            for (var Wn = -1, Tr = In == null ? 0 : In.length; ++Wn < Tr && Kn(In[Wn], Wn, In) !== !1; )
                ;
            return In
        }
        function t1(In, Kn) {
            for (var Wn = In == null ? 0 : In.length; Wn-- && Kn(In[Wn], Wn, In) !== !1; )
                ;
            return In
        }
        function iy(In, Kn) {
            for (var Wn = -1, Tr = In == null ? 0 : In.length; ++Wn < Tr; )
                if (!Kn(In[Wn], Wn, In))
                    return !1;
            return !0
        }
        function Kl(In, Kn) {
            for (var Wn = -1, Tr = In == null ? 0 : In.length, zr = 0, po = []; ++Wn < Tr; ) {
                var Xo = In[Wn];
                Kn(Xo, Wn, In) && (po[zr++] = Xo)
            }
            return po
        }
        function Qp(In, Kn) {
            var Wn = In == null ? 0 : In.length;
            return !!Wn && na(In, Kn, 0) > -1
        }
        function Wu(In, Kn, Wn) {
            for (var Tr = -1, zr = In == null ? 0 : In.length; ++Tr < zr; )
                if (Wn(Kn, In[Tr]))
                    return !0;
            return !1
        }
        function Mo(In, Kn) {
            for (var Wn = -1, Tr = In == null ? 0 : In.length, zr = Array(Tr); ++Wn < Tr; )
                zr[Wn] = Kn(In[Wn], Wn, In);
            return zr
        }
        function Vl(In, Kn) {
            for (var Wn = -1, Tr = Kn.length, zr = In.length; ++Wn < Tr; )
                In[zr + Wn] = Kn[Wn];
            return In
        }
        function vp(In, Kn, Wn, Tr) {
            var zr = -1
              , po = In == null ? 0 : In.length;
            for (Tr && po && (Wn = In[++zr]); ++zr < po; )
                Wn = Kn(Wn, In[zr], zr, In);
            return Wn
        }
        function oy(In, Kn, Wn, Tr) {
            var zr = In == null ? 0 : In.length;
            for (Tr && zr && (Wn = In[--zr]); zr--; )
                Wn = Kn(Wn, In[zr], zr, In);
            return Wn
        }
        function Jp(In, Kn) {
            for (var Wn = -1, Tr = In == null ? 0 : In.length; ++Wn < Tr; )
                if (Kn(In[Wn], Wn, In))
                    return !0;
            return !1
        }
        var os = _g("length");
        function sy(In) {
            return In.split("")
        }
        function n0(In) {
            return In.match(Cl) || []
        }
        function r0(In, Kn, Wn) {
            var Tr;
            return Wn(In, function(zr, po, Xo) {
                if (Kn(zr, po, Xo))
                    return Tr = po,
                    !1
            }),
            Tr
        }
        function _p(In, Kn, Wn, Tr) {
            for (var zr = In.length, po = Wn + (Tr ? 1 : -1); Tr ? po-- : ++po < zr; )
                if (Kn(In[po], po, In))
                    return po;
            return -1
        }
        function na(In, Kn, Wn) {
            return Kn === Kn ? r1(In, Kn, Wn) : _p(In, _h, Wn)
        }
        function i0(In, Kn, Wn, Tr) {
            for (var zr = Wn - 1, po = In.length; ++zr < po; )
                if (Tr(In[zr], Kn))
                    return zr;
            return -1
        }
        function _h(In) {
            return In !== In
        }
        function Hu(In, Kn) {
            var Wn = In == null ? 0 : In.length;
            return Wn ? tm(In, Kn) / Wn : qt
        }
        function _g(In) {
            return function(Kn) {
                return Kn == null ? et : Kn[In]
            }
        }
        function o0(In) {
            return function(Kn) {
                return In == null ? et : In[Kn]
            }
        }
        function em(In, Kn, Wn, Tr, zr) {
            return zr(In, function(po, Xo, Co) {
                Wn = Tr ? (Tr = !1,
                po) : Kn(Wn, po, Xo, Co)
            }),
            Wn
        }
        function s0(In, Kn) {
            var Wn = In.length;
            for (In.sort(Kn); Wn--; )
                In[Wn] = In[Wn].value;
            return In
        }
        function tm(In, Kn) {
            for (var Wn, Tr = -1, zr = In.length; ++Tr < zr; ) {
                var po = Kn(In[Tr]);
                po !== et && (Wn = Wn === et ? po : Wn + po)
            }
            return Wn
        }
        function a0(In, Kn) {
            for (var Wn = -1, Tr = Array(In); ++Wn < In; )
                Tr[Wn] = Kn(Wn);
            return Tr
        }
        function n1(In, Kn) {
            return Mo(Kn, function(Wn) {
                return [Wn, In[Wn]]
            })
        }
        function nm(In) {
            return In && In.slice(0, u0(In) + 1).replace(ro, "")
        }
        function Ns(In) {
            return function(Kn) {
                return In(Kn)
            }
        }
        function rm(In, Kn) {
            return Mo(Kn, function(Wn) {
                return In[Wn]
            })
        }
        function bp(In, Kn) {
            return In.has(Kn)
        }
        function ay(In, Kn) {
            for (var Wn = -1, Tr = In.length; ++Wn < Tr && na(Kn, In[Wn], 0) > -1; )
                ;
            return Wn
        }
        function im(In, Kn) {
            for (var Wn = In.length; Wn-- && na(Kn, In[Wn], 0) > -1; )
                ;
            return Wn
        }
        function Yl(In, Kn) {
            for (var Wn = In.length, Tr = 0; Wn--; )
                In[Wn] === Kn && ++Tr;
            return Tr
        }
        var om = o0(K0)
          , sm = o0(Jy);
        function Ep(In) {
            return "\\" + Y0[In]
        }
        function l0(In, Kn) {
            return In == null ? et : In[Kn]
        }
        function Zl(In) {
            return Qm.test(In)
        }
        function mu(In) {
            return hu.test(In)
        }
        function ly(In) {
            for (var Kn, Wn = []; !(Kn = In.next()).done; )
                Wn.push(Kn.value);
            return Wn
        }
        function am(In) {
            var Kn = -1
              , Wn = Array(In.size);
            return In.forEach(function(Tr, zr) {
                Wn[++Kn] = [zr, Tr]
            }),
            Wn
        }
        function c0(In, Kn) {
            return function(Wn) {
                return In(Kn(Wn))
            }
        }
        function Al(In, Kn) {
            for (var Wn = -1, Tr = In.length, zr = 0, po = []; ++Wn < Tr; ) {
                var Xo = In[Wn];
                (Xo === Kn || Xo === ct) && (In[Wn] = ct,
                po[zr++] = Wn)
            }
            return po
        }
        function Sp(In) {
            var Kn = -1
              , Wn = Array(In.size);
            return In.forEach(function(Tr) {
                Wn[++Kn] = Tr
            }),
            Wn
        }
        function cy(In) {
            var Kn = -1
              , Wn = Array(In.size);
            return In.forEach(function(Tr) {
                Wn[++Kn] = [Tr, Tr]
            }),
            Wn
        }
        function r1(In, Kn, Wn) {
            for (var Tr = Wn - 1, zr = In.length; ++Tr < zr; )
                if (In[Tr] === Kn)
                    return Tr;
            return -1
        }
        function i1(In, Kn, Wn) {
            for (var Tr = Wn + 1; Tr--; )
                if (In[Tr] === Kn)
                    return Tr;
            return Tr
        }
        function yu(In) {
            return Zl(In) ? dy(In) : os(In)
        }
        function Ks(In) {
            return Zl(In) ? o1(In) : sy(In)
        }
        function u0(In) {
            for (var Kn = In.length; Kn-- && go.test(In.charAt(Kn)); )
                ;
            return Kn
        }
        var uy = o0(V0);
        function dy(In) {
            for (var Kn = pu.lastIndex = 0; pu.test(In); )
                ++Kn;
            return Kn
        }
        function o1(In) {
            return In.match(pu) || []
        }
        function s1(In) {
            return In.match(Xm) || []
        }
        var fy = function In(Kn) {
            Kn = Kn == null ? rs : vu.defaults(rs.Object(), Kn, vu.pick(rs, G0));
            var Wn = Kn.Array
              , Tr = Kn.Date
              , zr = Kn.Error
              , po = Kn.Function
              , Xo = Kn.Math
              , Co = Kn.Object
              , lm = Kn.RegExp
              , a1 = Kn.String
              , Vs = Kn.TypeError
              , _u = Wn.prototype
              , wp = po.prototype
              , Il = Co.prototype
              , Xl = Kn["__core-js_shared__"]
              , Gu = wp.toString
              , ho = Il.hasOwnProperty
              , bu = 0
              , d0 = function() {
                var ft = /[^.]+$/.exec(Xl && Xl.keys && Xl.keys.IE_PROTO || "");
                return ft ? "Symbol(src)_1." + ft : ""
            }()
              , xp = Il.toString
              , py = Gu.call(Co)
              , hy = rs._
              , gy = lm("^" + Gu.call(ho).replace(Jr, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$")
              , Tp = Q0 ? Kn.Buffer : et
              , Ql = Kn.Symbol
              , cm = Kn.Uint8Array
              , f0 = Tp ? Tp.allocUnsafe : et
              , Rp = c0(Co.getPrototypeOf, Co)
              , p0 = Co.create
              , my = Il.propertyIsEnumerable
              , um = _u.splice
              , h0 = Ql ? Ql.isConcatSpreadable : et
              , Ku = Ql ? Ql.iterator : et
              , Jl = Ql ? Ql.toStringTag : et
              , dm = function() {
                try {
                    var ft = Op(Co, "defineProperty");
                    return ft({}, "", {}),
                    ft
                } catch {}
            }()
              , l1 = Kn.clearTimeout !== rs.clearTimeout && Kn.clearTimeout
              , yy = Tr && Tr.now !== rs.Date.now && Tr.now
              , c1 = Kn.setTimeout !== rs.setTimeout && Kn.setTimeout
              , fm = Xo.ceil
              , pm = Xo.floor
              , g0 = Co.getOwnPropertySymbols
              , u1 = Tp ? Tp.isBuffer : et
              , m0 = Kn.isFinite
              , vy = _u.join
              , Vu = c0(Co.keys, Co)
              , Qo = Xo.max
              , ls = Xo.min
              , _y = Tr.now
              , by = Kn.parseInt
              , y0 = Xo.random
              , Ey = _u.reverse
              , v0 = Op(Kn, "DataView")
              , Cp = Op(Kn, "Map")
              , Jo = Op(Kn, "Promise")
              , Ol = Op(Kn, "Set")
              , Yu = Op(Kn, "WeakMap")
              , qu = Op(Co, "create")
              , hm = Yu && new Yu
              , Zu = {}
              , d1 = kp(v0)
              , f1 = kp(Cp)
              , Sy = kp(Jo)
              , p1 = kp(Ol)
              , h1 = kp(Yu)
              , gm = Ql ? Ql.prototype : et
              , $p = gm ? gm.valueOf : et
              , _0 = gm ? gm.toString : et;
            function pn(ft) {
                if (Yo(ft) && !Zr(ft) && !(ft instanceof vt)) {
                    if (ft instanceof Tt)
                        return ft;
                    if (ho.call(ft, "__wrapped__"))
                        return Qv(ft)
                }
                return new Tt(ft)
            }
            var Xu = function() {
                function ft() {}
                return function(gt) {
                    if (!Ko(gt))
                        return {};
                    if (p0)
                        return p0(gt);
                    ft.prototype = gt;
                    var Ot = new ft;
                    return ft.prototype = et,
                    Ot
                }
            }();
            function At() {}
            function Tt(ft, gt) {
                this.__wrapped__ = ft,
                this.__actions__ = [],
                this.__chain__ = !!gt,
                this.__index__ = 0,
                this.__values__ = et
            }
            pn.templateSettings = {
                escape: Ir,
                evaluate: _o,
                interpolate: Xr,
                variable: "",
                imports: {
                    _: pn
                }
            },
            pn.prototype = At.prototype,
            pn.prototype.constructor = pn,
            Tt.prototype = Xu(At.prototype),
            Tt.prototype.constructor = Tt;
            function vt(ft) {
                this.__wrapped__ = ft,
                this.__actions__ = [],
                this.__dir__ = 1,
                this.__filtered__ = !1,
                this.__iteratees__ = [],
                this.__takeCount__ = Wt,
                this.__views__ = []
            }
            function bt() {
                var ft = new vt(this.__wrapped__);
                return ft.__actions__ = Ys(this.__actions__),
                ft.__dir__ = this.__dir__,
                ft.__filtered__ = this.__filtered__,
                ft.__iteratees__ = Ys(this.__iteratees__),
                ft.__takeCount__ = this.__takeCount__,
                ft.__views__ = Ys(this.__views__),
                ft
            }
            function Rt() {
                if (this.__filtered__) {
                    var ft = new vt(this);
                    ft.__dir__ = -1,
                    ft.__filtered__ = !0
                } else
                    ft = this.clone(),
                    ft.__dir__ *= -1;
                return ft
            }
            function It() {
                var ft = this.__wrapped__.value()
                  , gt = this.__dir__
                  , Ot = Zr(ft)
                  , Qt = gt < 0
                  , sn = Ot ? ft.length : 0
                  , gn = bE(0, sn, this.__views__)
                  , xn = gn.start
                  , $n = gn.end
                  , Ln = $n - xn
                  , Xn = Qt ? $n : xn - 1
                  , Jn = this.__iteratees__
                  , nr = Jn.length
                  , Er = 0
                  , kr = ls(Ln, this.__takeCount__);
                if (!Ot || !Qt && sn == Ln && kr == Ln)
                    return Ev(ft, this.__actions__);
                var Pr = [];
                e: for (; Ln-- && Er < kr; ) {
                    Xn += gt;
                    for (var no = -1, Dr = ft[Xn]; ++no < nr; ) {
                        var ao = Jn[no]
                          , uo = ao.iteratee
                          , ba = ao.type
                          , Ds = uo(Dr);
                        if (ba == $t)
                            Dr = Ds;
                        else if (!Ds) {
                            if (ba == xt)
                                continue e;
                            break e
                        }
                    }
                    Pr[Er++] = Dr
                }
                return Pr
            }
            vt.prototype = Xu(At.prototype),
            vt.prototype.constructor = vt;
            function Bt(ft) {
                var gt = -1
                  , Ot = ft == null ? 0 : ft.length;
                for (this.clear(); ++gt < Ot; ) {
                    var Qt = ft[gt];
                    this.set(Qt[0], Qt[1])
                }
            }
            function Zt() {
                this.__data__ = qu ? qu(null) : {},
                this.size = 0
            }
            function tn(ft) {
                var gt = this.has(ft) && delete this.__data__[ft];
                return this.size -= gt ? 1 : 0,
                gt
            }
            function dn(ft) {
                var gt = this.__data__;
                if (qu) {
                    var Ot = gt[ft];
                    return Ot === st ? et : Ot
                }
                return ho.call(gt, ft) ? gt[ft] : et
            }
            function mn(ft) {
                var gt = this.__data__;
                return qu ? gt[ft] !== et : ho.call(gt, ft)
            }
            function Sn(ft, gt) {
                var Ot = this.__data__;
                return this.size += this.has(ft) ? 0 : 1,
                Ot[ft] = qu && gt === et ? st : gt,
                this
            }
            Bt.prototype.clear = Zt,
            Bt.prototype.delete = tn,
            Bt.prototype.get = dn,
            Bt.prototype.has = mn,
            Bt.prototype.set = Sn;
            function yn(ft) {
                var gt = -1
                  , Ot = ft == null ? 0 : ft.length;
                for (this.clear(); ++gt < Ot; ) {
                    var Qt = ft[gt];
                    this.set(Qt[0], Qt[1])
                }
            }
            function On() {
                this.__data__ = [],
                this.size = 0
            }
            function An(ft) {
                var gt = this.__data__
                  , Ot = Wr(gt, ft);
                if (Ot < 0)
                    return !1;
                var Qt = gt.length - 1;
                return Ot == Qt ? gt.pop() : um.call(gt, Ot, 1),
                --this.size,
                !0
            }
            function Nn(ft) {
                var gt = this.__data__
                  , Ot = Wr(gt, ft);
                return Ot < 0 ? et : gt[Ot][1]
            }
            function Fn(ft) {
                return Wr(this.__data__, ft) > -1
            }
            function Qn(ft, gt) {
                var Ot = this.__data__
                  , Qt = Wr(Ot, ft);
                return Qt < 0 ? (++this.size,
                Ot.push([ft, gt])) : Ot[Qt][1] = gt,
                this
            }
            yn.prototype.clear = On,
            yn.prototype.delete = An,
            yn.prototype.get = Nn,
            yn.prototype.has = Fn,
            yn.prototype.set = Qn;
            function er(ft) {
                var gt = -1
                  , Ot = ft == null ? 0 : ft.length;
                for (this.clear(); ++gt < Ot; ) {
                    var Qt = ft[gt];
                    this.set(Qt[0], Qt[1])
                }
            }
            function fr() {
                this.size = 0,
                this.__data__ = {
                    hash: new Bt,
                    map: new (Cp || yn),
                    string: new Bt
                }
            }
            function Nr(ft) {
                var gt = Ly(this, ft).delete(ft);
                return this.size -= gt ? 1 : 0,
                gt
            }
            function Rr(ft) {
                return Ly(this, ft).get(ft)
            }
            function _i(ft) {
                return Ly(this, ft).has(ft)
            }
            function eo(ft, gt) {
                var Ot = Ly(this, ft)
                  , Qt = Ot.size;
                return Ot.set(ft, gt),
                this.size += Ot.size == Qt ? 0 : 1,
                this
            }
            er.prototype.clear = fr,
            er.prototype.delete = Nr,
            er.prototype.get = Rr,
            er.prototype.has = _i,
            er.prototype.set = eo;
            function Gr(ft) {
                var gt = -1
                  , Ot = ft == null ? 0 : ft.length;
                for (this.__data__ = new er; ++gt < Ot; )
                    this.add(ft[gt])
            }
            function Ar(ft) {
                return this.__data__.set(ft, st),
                this
            }
            function Or(ft) {
                return this.__data__.has(ft)
            }
            Gr.prototype.add = Gr.prototype.push = Ar,
            Gr.prototype.has = Or;
            function Fr(ft) {
                var gt = this.__data__ = new yn(ft);
                this.size = gt.size
            }
            function Vo() {
                this.__data__ = new yn,
                this.size = 0
            }
            function lo(ft) {
                var gt = this.__data__
                  , Ot = gt.delete(ft);
                return this.size = gt.size,
                Ot
            }
            function to(ft) {
                return this.__data__.get(ft)
            }
            function Kr(ft) {
                return this.__data__.has(ft)
            }
            function mr(ft, gt) {
                var Ot = this.__data__;
                if (Ot instanceof yn) {
                    var Qt = Ot.__data__;
                    if (!Cp || Qt.length < nt - 1)
                        return Qt.push([ft, gt]),
                        this.size = ++Ot.size,
                        this;
                    Ot = this.__data__ = new er(Qt)
                }
                return Ot.set(ft, gt),
                this.size = Ot.size,
                this
            }
            Fr.prototype.clear = Vo,
            Fr.prototype.delete = lo,
            Fr.prototype.get = to,
            Fr.prototype.has = Kr,
            Fr.prototype.set = mr;
            function _r(ft, gt) {
                var Ot = Zr(ft)
                  , Qt = !Ot && Lp(ft)
                  , sn = !Ot && !Qt && ep(ft)
                  , gn = !Ot && !Qt && !sn && Rm(ft)
                  , xn = Ot || Qt || sn || gn
                  , $n = xn ? a0(ft.length, a1) : []
                  , Ln = $n.length;
                for (var Xn in ft)
                    (gt || ho.call(ft, Xn)) && !(xn && (Xn == "length" || sn && (Xn == "offset" || Xn == "parent") || gn && (Xn == "buffer" || Xn == "byteLength" || Xn == "byteOffset") || xu(Xn, Ln))) && $n.push(Xn);
                return $n
            }
            function vo(ft) {
                var gt = ft.length;
                return gt ? ft[m1(0, gt - 1)] : et
            }
            function ar(ft, gt) {
                return Ny(Ys(ft), Do(gt, 0, ft.length))
            }
            function $r(ft) {
                return Ny(Ys(ft))
            }
            function Vr(ft, gt, Ot) {
                (Ot !== et && !Ll(ft[gt], Ot) || Ot === et && !(gt in ft)) && so(ft, gt, Ot)
            }
            function Sr(ft, gt, Ot) {
                var Qt = ft[gt];
                (!(ho.call(ft, gt) && Ll(Qt, Ot)) || Ot === et && !(gt in ft)) && so(ft, gt, Ot)
            }
            function Wr(ft, gt) {
                for (var Ot = ft.length; Ot--; )
                    if (Ll(ft[Ot][0], gt))
                        return Ot;
                return -1
            }
            function Po(ft, gt, Ot, Qt) {
                return ms(ft, function(sn, gn, xn) {
                    gt(Qt, sn, Ot(sn), xn)
                }),
                Qt
            }
            function Wo(ft, gt) {
                return ft && tu(gt, _s(gt), ft)
            }
            function es(ft, gt) {
                return ft && tu(gt, Zs(gt), ft)
            }
            function so(ft, gt, Ot) {
                gt == "__proto__" && dm ? dm(ft, gt, {
                    configurable: !0,
                    enumerable: !0,
                    value: Ot,
                    writable: !0
                }) : ft[gt] = Ot
            }
            function gs(ft, gt) {
                for (var Ot = -1, Qt = gt.length, sn = Wn(Qt), gn = ft == null; ++Ot < Qt; )
                    sn[Ot] = gn ? et : z1(ft, gt[Ot]);
                return sn
            }
            function Do(ft, gt, Ot) {
                return ft === ft && (Ot !== et && (ft = ft <= Ot ? ft : Ot),
                gt !== et && (ft = ft >= gt ? ft : gt)),
                ft
            }
            function Bo(ft, gt, Ot, Qt, sn, gn) {
                var xn, $n = gt & dt, Ln = gt & pt, Xn = gt & ht;
                if (Ot && (xn = sn ? Ot(ft, Qt, sn, gn) : Ot(ft)),
                xn !== et)
                    return xn;
                if (!Ko(ft))
                    return ft;
                var Jn = Zr(ft);
                if (Jn) {
                    if (xn = SE(ft),
                    !$n)
                        return Ys(ft, xn)
                } else {
                    var nr = $s(ft)
                      , Er = nr == Hn || nr == cr;
                    if (ep(ft))
                        return xv(ft, $n);
                    if (nr == Zn || nr == hn || Er && !sn) {
                        if (xn = Ln || Er ? {} : Wv(ft),
                        !$n)
                            return Ln ? dE(ft, es(xn, ft)) : uE(ft, Wo(xn, ft))
                    } else {
                        if (!Oo[nr])
                            return sn ? ft : {};
                        xn = wE(ft, nr, $n)
                    }
                }
                gn || (gn = new Fr);
                var kr = gn.get(ft);
                if (kr)
                    return kr;
                gn.set(ft, xn),
                v_(ft) ? ft.forEach(function(Dr) {
                    xn.add(Bo(Dr, gt, Ot, Dr, ft, gn))
                }) : m_(ft) && ft.forEach(function(Dr, ao) {
                    xn.set(ao, Bo(Dr, gt, Ot, ao, ft, gn))
                });
                var Pr = Xn ? Ln ? $1 : C1 : Ln ? Zs : _s
                  , no = Jn ? et : Pr(ft);
                return Gs(no || ft, function(Dr, ao) {
                    no && (ao = Dr,
                    Dr = ft[ao]),
                    Sr(xn, ao, Bo(Dr, gt, Ot, ao, ft, gn))
                }),
                xn
            }
            function Uo(ft) {
                var gt = _s(ft);
                return function(Ot) {
                    return Ts(Ot, ft, gt)
                }
            }
            function Ts(ft, gt, Ot) {
                var Qt = Ot.length;
                if (ft == null)
                    return !Qt;
                for (ft = Co(ft); Qt--; ) {
                    var sn = Ot[Qt]
                      , gn = gt[sn]
                      , xn = ft[sn];
                    if (xn === et && !(sn in ft) || !gn(xn))
                        return !1
                }
                return !0
            }
            function Go(ft, gt, Ot) {
                if (typeof ft != "function")
                    throw new Vs(it);
                return R0(function() {
                    ft.apply(et, Ot)
                }, gt)
            }
            function Rs(ft, gt, Ot, Qt) {
                var sn = -1
                  , gn = Qp
                  , xn = !0
                  , $n = ft.length
                  , Ln = []
                  , Xn = gt.length;
                if (!$n)
                    return Ln;
                Ot && (gt = Mo(gt, Ns(Ot))),
                Qt ? (gn = Wu,
                xn = !1) : gt.length >= nt && (gn = bp,
                xn = !1,
                gt = new Gr(gt));
                e: for (; ++sn < $n; ) {
                    var Jn = ft[sn]
                      , nr = Ot == null ? Jn : Ot(Jn);
                    if (Jn = Qt || Jn !== 0 ? Jn : 0,
                    xn && nr === nr) {
                        for (var Er = Xn; Er--; )
                            if (gt[Er] === nr)
                                continue e;
                        Ln.push(Jn)
                    } else
                        gn(gt, nr, Qt) || Ln.push(Jn)
                }
                return Ln
            }
            var ms = Av(Ho)
              , Eu = Av(ys, !0);
            function Ap(ft, gt) {
                var Ot = !0;
                return ms(ft, function(Qt, sn, gn) {
                    return Ot = !!gt(Qt, sn, gn),
                    Ot
                }),
                Ot
            }
            function yr(ft, gt, Ot) {
                for (var Qt = -1, sn = ft.length; ++Qt < sn; ) {
                    var gn = ft[Qt]
                      , xn = gt(gn);
                    if (xn != null && ($n === et ? xn === xn && !_a(xn) : Ot(xn, $n)))
                        var $n = xn
                          , Ln = gn
                }
                return Ln
            }
            function qr(ft, gt, Ot, Qt) {
                var sn = ft.length;
                for (Ot = Qr(Ot),
                Ot < 0 && (Ot = -Ot > sn ? 0 : sn + Ot),
                Qt = Qt === et || Qt > sn ? sn : Qr(Qt),
                Qt < 0 && (Qt += sn),
                Qt = Ot > Qt ? 0 : b_(Qt); Ot < Qt; )
                    ft[Ot++] = gt;
                return ft
            }
            function Hr(ft, gt) {
                var Ot = [];
                return ms(ft, function(Qt, sn, gn) {
                    gt(Qt, sn, gn) && Ot.push(Qt)
                }),
                Ot
            }
            function Lr(ft, gt, Ot, Qt, sn) {
                var gn = -1
                  , xn = ft.length;
                for (Ot || (Ot = TE),
                sn || (sn = []); ++gn < xn; ) {
                    var $n = ft[gn];
                    gt > 0 && Ot($n) ? gt > 1 ? Lr($n, gt - 1, Ot, Qt, sn) : Vl(sn, $n) : Qt || (sn[sn.length] = $n)
                }
                return sn
            }
            var co = Iv()
              , $o = Iv(!0);
            function Ho(ft, gt) {
                return ft && co(ft, gt, _s)
            }
            function ys(ft, gt) {
                return ft && $o(ft, gt, _s)
            }
            function cs(ft, gt) {
                return Kl(gt, function(Ot) {
                    return Tu(ft[Ot])
                })
            }
            function Ao(ft, gt) {
                gt = _d(gt, ft);
                for (var Ot = 0, Qt = gt.length; ft != null && Ot < Qt; )
                    ft = ft[nu(gt[Ot++])];
                return Ot && Ot == Qt ? ft : et
            }
            function vs(ft, gt, Ot) {
                var Qt = gt(ft);
                return Zr(ft) ? Qt : Vl(Qt, Ot(ft))
            }
            function jo(ft) {
                return ft == null ? ft === et ? qn : rr : Jl && Jl in Co(ft) ? _E(ft) : kE(ft)
            }
            function us(ft, gt) {
                return ft > gt
            }
            function b0(ft, gt) {
                return ft != null && ho.call(ft, gt)
            }
            function wy(ft, gt) {
                return ft != null && gt in Co(ft)
            }
            function mm(ft, gt, Ot) {
                return ft >= ls(gt, Ot) && ft < Qo(gt, Ot)
            }
            function Qu(ft, gt, Ot) {
                for (var Qt = Ot ? Wu : Qp, sn = ft[0].length, gn = ft.length, xn = gn, $n = Wn(gn), Ln = 1 / 0, Xn = []; xn--; ) {
                    var Jn = ft[xn];
                    xn && gt && (Jn = Mo(Jn, Ns(gt))),
                    Ln = ls(Jn.length, Ln),
                    $n[xn] = !Ot && (gt || sn >= 120 && Jn.length >= 120) ? new Gr(xn && Jn) : et
                }
                Jn = ft[0];
                var nr = -1
                  , Er = $n[0];
                e: for (; ++nr < sn && Xn.length < Ln; ) {
                    var kr = Jn[nr]
                      , Pr = gt ? gt(kr) : kr;
                    if (kr = Ot || kr !== 0 ? kr : 0,
                    !(Er ? bp(Er, Pr) : Qt(Xn, Pr, Ot))) {
                        for (xn = gn; --xn; ) {
                            var no = $n[xn];
                            if (!(no ? bp(no, Pr) : Qt(ft[xn], Pr, Ot)))
                                continue e
                        }
                        Er && Er.push(Pr),
                        Xn.push(kr)
                    }
                }
                return Xn
            }
            function ym(ft, gt, Ot, Qt) {
                return Ho(ft, function(sn, gn, xn) {
                    gt(Qt, Ot(sn), gn, xn)
                }),
                Qt
            }
            function _c(ft, gt, Ot) {
                gt = _d(gt, ft),
                ft = Vv(ft, gt);
                var Qt = ft == null ? ft : ft[nu(xl(gt))];
                return Qt == null ? et : Ls(Qt, ft, Ot)
            }
            function Ip(ft) {
                return Yo(ft) && jo(ft) == hn
            }
            function vm(ft) {
                return Yo(ft) && jo(ft) == ir
            }
            function _m(ft) {
                return Yo(ft) && jo(ft) == jn
            }
            function eu(ft, gt, Ot, Qt, sn) {
                return ft === gt ? !0 : ft == null || gt == null || !Yo(ft) && !Yo(gt) ? ft !== ft && gt !== gt : bm(ft, gt, Ot, Qt, eu, sn)
            }
            function bm(ft, gt, Ot, Qt, sn, gn) {
                var xn = Zr(ft)
                  , $n = Zr(gt)
                  , Ln = xn ? _n : $s(ft)
                  , Xn = $n ? _n : $s(gt);
                Ln = Ln == hn ? Zn : Ln,
                Xn = Xn == hn ? Zn : Xn;
                var Jn = Ln == Zn
                  , nr = Xn == Zn
                  , Er = Ln == Xn;
                if (Er && ep(ft)) {
                    if (!ep(gt))
                        return !1;
                    xn = !0,
                    Jn = !1
                }
                if (Er && !Jn)
                    return gn || (gn = new Fr),
                    xn || Rm(ft) ? jv(ft, gt, Ot, Qt, sn, gn) : yE(ft, gt, Ln, Ot, Qt, sn, gn);
                if (!(Ot & mt)) {
                    var kr = Jn && ho.call(ft, "__wrapped__")
                      , Pr = nr && ho.call(gt, "__wrapped__");
                    if (kr || Pr) {
                        var no = kr ? ft.value() : ft
                          , Dr = Pr ? gt.value() : gt;
                        return gn || (gn = new Fr),
                        sn(no, Dr, Ot, Qt, gn)
                    }
                }
                return Er ? (gn || (gn = new Fr),
                vE(ft, gt, Ot, Qt, sn, gn)) : !1
            }
            function Em(ft) {
                return Yo(ft) && $s(ft) == Gn
            }
            function E0(ft, gt, Ot, Qt) {
                var sn = Ot.length
                  , gn = sn
                  , xn = !Qt;
                if (ft == null)
                    return !gn;
                for (ft = Co(ft); sn--; ) {
                    var $n = Ot[sn];
                    if (xn && $n[2] ? $n[1] !== ft[$n[0]] : !($n[0]in ft))
                        return !1
                }
                for (; ++sn < gn; ) {
                    $n = Ot[sn];
                    var Ln = $n[0]
                      , Xn = ft[Ln]
                      , Jn = $n[1];
                    if (xn && $n[2]) {
                        if (Xn === et && !(Ln in ft))
                            return !1
                    } else {
                        var nr = new Fr;
                        if (Qt)
                            var Er = Qt(Xn, Jn, Ln, ft, gt, nr);
                        if (!(Er === et ? eu(Jn, Xn, mt | yt, Qt, nr) : Er))
                            return !1
                    }
                }
                return !0
            }
            function ss(ft) {
                if (!Ko(ft) || CE(ft))
                    return !1;
                var gt = Tu(ft) ? gy : Os;
                return gt.test(kp(ft))
            }
            function ds(ft) {
                return Yo(ft) && jo(ft) == xr
            }
            function fs(ft) {
                return Yo(ft) && $s(ft) == wr
            }
            function ps(ft) {
                return Yo(ft) && jy(ft.length) && !!No[jo(ft)]
            }
            function Cs(ft) {
                return typeof ft == "function" ? ft : ft == null ? Xs : typeof ft == "object" ? Zr(ft) ? fv(ft[0], ft[1]) : dv(ft) : O_(ft)
            }
            function Ms(ft) {
                if (!T0(ft))
                    return Vu(ft);
                var gt = [];
                for (var Ot in Co(ft))
                    ho.call(ft, Ot) && Ot != "constructor" && gt.push(Ot);
                return gt
            }
            function Lo(ft) {
                if (!Ko(ft))
                    return OE(ft);
                var gt = T0(ft)
                  , Ot = [];
                for (var Qt in ft)
                    Qt == "constructor" && (gt || !ho.call(ft, Qt)) || Ot.push(Qt);
                return Ot
            }
            function Sm(ft, gt) {
                return ft < gt
            }
            function S0(ft, gt) {
                var Ot = -1
                  , Qt = qs(ft) ? Wn(ft.length) : [];
                return ms(ft, function(sn, gn, xn) {
                    Qt[++Ot] = gt(sn, gn, xn)
                }),
                Qt
            }
            function dv(ft) {
                var gt = I1(ft);
                return gt.length == 1 && gt[0][2] ? Gv(gt[0][0], gt[0][1]) : function(Ot) {
                    return Ot === ft || E0(Ot, ft, gt)
                }
            }
            function fv(ft, gt) {
                return k1(ft) && Hv(gt) ? Gv(nu(ft), gt) : function(Ot) {
                    var Qt = z1(Ot, ft);
                    return Qt === et && Qt === gt ? W1(Ot, ft) : eu(gt, Qt, mt | yt)
                }
            }
            function xy(ft, gt, Ot, Qt, sn) {
                ft !== gt && co(gt, function(gn, xn) {
                    if (sn || (sn = new Fr),
                    Ko(gn))
                        X_(ft, gt, xn, Ot, xy, Qt, sn);
                    else {
                        var $n = Qt ? Qt(N1(ft, xn), gn, xn + "", ft, gt, sn) : et;
                        $n === et && ($n = gn),
                        Vr(ft, xn, $n)
                    }
                }, Zs)
            }
            function X_(ft, gt, Ot, Qt, sn, gn, xn) {
                var $n = N1(ft, Ot)
                  , Ln = N1(gt, Ot)
                  , Xn = xn.get(Ln);
                if (Xn) {
                    Vr(ft, Ot, Xn);
                    return
                }
                var Jn = gn ? gn($n, Ln, Ot + "", ft, gt, xn) : et
                  , nr = Jn === et;
                if (nr) {
                    var Er = Zr(Ln)
                      , kr = !Er && ep(Ln)
                      , Pr = !Er && !kr && Rm(Ln);
                    Jn = Ln,
                    Er || kr || Pr ? Zr($n) ? Jn = $n : ts($n) ? Jn = Ys($n) : kr ? (nr = !1,
                    Jn = xv(Ln, !0)) : Pr ? (nr = !1,
                    Jn = Tv(Ln, !0)) : Jn = [] : C0(Ln) || Lp(Ln) ? (Jn = $n,
                    Lp($n) ? Jn = E_($n) : (!Ko($n) || Tu($n)) && (Jn = Wv(Ln))) : nr = !1
                }
                nr && (xn.set(Ln, Jn),
                sn(Jn, Ln, Qt, gn, xn),
                xn.delete(Ln)),
                Vr(ft, Ot, Jn)
            }
            function pv(ft, gt) {
                var Ot = ft.length;
                if (Ot)
                    return gt += gt < 0 ? Ot : 0,
                    xu(gt, Ot) ? ft[gt] : et
            }
            function hv(ft, gt, Ot) {
                gt.length ? gt = Mo(gt, function(gn) {
                    return Zr(gn) ? function(xn) {
                        return Ao(xn, gn.length === 1 ? gn[0] : gn)
                    }
                    : gn
                }) : gt = [Xs];
                var Qt = -1;
                gt = Mo(gt, Ns(Mr()));
                var sn = S0(ft, function(gn, xn, $n) {
                    var Ln = Mo(gt, function(Xn) {
                        return Xn(gn)
                    });
                    return {
                        criteria: Ln,
                        index: ++Qt,
                        value: gn
                    }
                });
                return s0(sn, function(gn, xn) {
                    return cE(gn, xn, Ot)
                })
            }
            function Q_(ft, gt) {
                return gv(ft, gt, function(Ot, Qt) {
                    return W1(ft, Qt)
                })
            }
            function gv(ft, gt, Ot) {
                for (var Qt = -1, sn = gt.length, gn = {}; ++Qt < sn; ) {
                    var xn = gt[Qt]
                      , $n = Ao(ft, xn);
                    Ot($n, xn) && w0(gn, _d(xn, ft), $n)
                }
                return gn
            }
            function J_(ft) {
                return function(gt) {
                    return Ao(gt, ft)
                }
            }
            function g1(ft, gt, Ot, Qt) {
                var sn = Qt ? i0 : na
                  , gn = -1
                  , xn = gt.length
                  , $n = ft;
                for (ft === gt && (gt = Ys(gt)),
                Ot && ($n = Mo(ft, Ns(Ot))); ++gn < xn; )
                    for (var Ln = 0, Xn = gt[gn], Jn = Ot ? Ot(Xn) : Xn; (Ln = sn($n, Jn, Ln, Qt)) > -1; )
                        $n !== ft && um.call($n, Ln, 1),
                        um.call(ft, Ln, 1);
                return ft
            }
            function mv(ft, gt) {
                for (var Ot = ft ? gt.length : 0, Qt = Ot - 1; Ot--; ) {
                    var sn = gt[Ot];
                    if (Ot == Qt || sn !== gn) {
                        var gn = sn;
                        xu(sn) ? um.call(ft, sn, 1) : b1(ft, sn)
                    }
                }
                return ft
            }
            function m1(ft, gt) {
                return ft + pm(y0() * (gt - ft + 1))
            }
            function _b(ft, gt, Ot, Qt) {
                for (var sn = -1, gn = Qo(fm((gt - ft) / (Ot || 1)), 0), xn = Wn(gn); gn--; )
                    xn[Qt ? gn : ++sn] = ft,
                    ft += Ot;
                return xn
            }
            function y1(ft, gt) {
                var Ot = "";
                if (!ft || gt < 1 || gt > Ft)
                    return Ot;
                do
                    gt % 2 && (Ot += ft),
                    gt = pm(gt / 2),
                    gt && (ft += ft);
                while (gt);
                return Ot
            }
            function oo(ft, gt) {
                return M1(Kv(ft, gt, Xs), ft + "")
            }
            function eE(ft) {
                return vo(Cm(ft))
            }
            function tE(ft, gt) {
                var Ot = Cm(ft);
                return Ny(Ot, Do(gt, 0, Ot.length))
            }
            function w0(ft, gt, Ot, Qt) {
                if (!Ko(ft))
                    return ft;
                gt = _d(gt, ft);
                for (var sn = -1, gn = gt.length, xn = gn - 1, $n = ft; $n != null && ++sn < gn; ) {
                    var Ln = nu(gt[sn])
                      , Xn = Ot;
                    if (Ln === "__proto__" || Ln === "constructor" || Ln === "prototype")
                        return ft;
                    if (sn != xn) {
                        var Jn = $n[Ln];
                        Xn = Qt ? Qt(Jn, Ln, $n) : et,
                        Xn === et && (Xn = Ko(Jn) ? Jn : xu(gt[sn + 1]) ? [] : {})
                    }
                    Sr($n, Ln, Xn),
                    $n = $n[Ln]
                }
                return ft
            }
            var yv = hm ? function(ft, gt) {
                return hm.set(ft, gt),
                ft
            }
            : Xs
              , nE = dm ? function(ft, gt) {
                return dm(ft, "toString", {
                    configurable: !0,
                    enumerable: !1,
                    value: G1(gt),
                    writable: !0
                })
            }
            : Xs;
            function rE(ft) {
                return Ny(Cm(ft))
            }
            function wl(ft, gt, Ot) {
                var Qt = -1
                  , sn = ft.length;
                gt < 0 && (gt = -gt > sn ? 0 : sn + gt),
                Ot = Ot > sn ? sn : Ot,
                Ot < 0 && (Ot += sn),
                sn = gt > Ot ? 0 : Ot - gt >>> 0,
                gt >>>= 0;
                for (var gn = Wn(sn); ++Qt < sn; )
                    gn[Qt] = ft[Qt + gt];
                return gn
            }
            function iE(ft, gt) {
                var Ot;
                return ms(ft, function(Qt, sn, gn) {
                    return Ot = gt(Qt, sn, gn),
                    !Ot
                }),
                !!Ot
            }
            function Ty(ft, gt, Ot) {
                var Qt = 0
                  , sn = ft == null ? Qt : ft.length;
                if (typeof gt == "number" && gt === gt && sn <= Yt) {
                    for (; Qt < sn; ) {
                        var gn = Qt + sn >>> 1
                          , xn = ft[gn];
                        xn !== null && !_a(xn) && (Ot ? xn <= gt : xn < gt) ? Qt = gn + 1 : sn = gn
                    }
                    return sn
                }
                return _1(ft, gt, Xs, Ot)
            }
            function _1(ft, gt, Ot, Qt) {
                var sn = 0
                  , gn = ft == null ? 0 : ft.length;
                if (gn === 0)
                    return 0;
                gt = Ot(gt);
                for (var xn = gt !== gt, $n = gt === null, Ln = _a(gt), Xn = gt === et; sn < gn; ) {
                    var Jn = pm((sn + gn) / 2)
                      , nr = Ot(ft[Jn])
                      , Er = nr !== et
                      , kr = nr === null
                      , Pr = nr === nr
                      , no = _a(nr);
                    if (xn)
                        var Dr = Qt || Pr;
                    else
                        Xn ? Dr = Pr && (Qt || Er) : $n ? Dr = Pr && Er && (Qt || !kr) : Ln ? Dr = Pr && Er && !kr && (Qt || !no) : kr || no ? Dr = !1 : Dr = Qt ? nr <= gt : nr < gt;
                    Dr ? sn = Jn + 1 : gn = Jn
                }
                return ls(gn, Mt)
            }
            function vv(ft, gt) {
                for (var Ot = -1, Qt = ft.length, sn = 0, gn = []; ++Ot < Qt; ) {
                    var xn = ft[Ot]
                      , $n = gt ? gt(xn) : xn;
                    if (!Ot || !Ll($n, Ln)) {
                        var Ln = $n;
                        gn[sn++] = xn === 0 ? 0 : xn
                    }
                }
                return gn
            }
            function _v(ft) {
                return typeof ft == "number" ? ft : _a(ft) ? qt : +ft
            }
            function ga(ft) {
                if (typeof ft == "string")
                    return ft;
                if (Zr(ft))
                    return Mo(ft, ga) + "";
                if (_a(ft))
                    return _0 ? _0.call(ft) : "";
                var gt = ft + "";
                return gt == "0" && 1 / ft == -1 / 0 ? "-0" : gt
            }
            function Ju(ft, gt, Ot) {
                var Qt = -1
                  , sn = Qp
                  , gn = ft.length
                  , xn = !0
                  , $n = []
                  , Ln = $n;
                if (Ot)
                    xn = !1,
                    sn = Wu;
                else if (gn >= nt) {
                    var Xn = gt ? null : gE(ft);
                    if (Xn)
                        return Sp(Xn);
                    xn = !1,
                    sn = bp,
                    Ln = new Gr
                } else
                    Ln = gt ? [] : $n;
                e: for (; ++Qt < gn; ) {
                    var Jn = ft[Qt]
                      , nr = gt ? gt(Jn) : Jn;
                    if (Jn = Ot || Jn !== 0 ? Jn : 0,
                    xn && nr === nr) {
                        for (var Er = Ln.length; Er--; )
                            if (Ln[Er] === nr)
                                continue e;
                        gt && Ln.push(nr),
                        $n.push(Jn)
                    } else
                        sn(Ln, nr, Ot) || (Ln !== $n && Ln.push(nr),
                        $n.push(Jn))
                }
                return $n
            }
            function b1(ft, gt) {
                return gt = _d(gt, ft),
                ft = Vv(ft, gt),
                ft == null || delete ft[nu(xl(gt))]
            }
            function bv(ft, gt, Ot, Qt) {
                return w0(ft, gt, Ot(Ao(ft, gt)), Qt)
            }
            function Ry(ft, gt, Ot, Qt) {
                for (var sn = ft.length, gn = Qt ? sn : -1; (Qt ? gn-- : ++gn < sn) && gt(ft[gn], gn, ft); )
                    ;
                return Ot ? wl(ft, Qt ? 0 : gn, Qt ? gn + 1 : sn) : wl(ft, Qt ? gn + 1 : 0, Qt ? sn : gn)
            }
            function Ev(ft, gt) {
                var Ot = ft;
                return Ot instanceof vt && (Ot = Ot.value()),
                vp(gt, function(Qt, sn) {
                    return sn.func.apply(sn.thisArg, Vl([Qt], sn.args))
                }, Ot)
            }
            function E1(ft, gt, Ot) {
                var Qt = ft.length;
                if (Qt < 2)
                    return Qt ? Ju(ft[0]) : [];
                for (var sn = -1, gn = Wn(Qt); ++sn < Qt; )
                    for (var xn = ft[sn], $n = -1; ++$n < Qt; )
                        $n != sn && (gn[sn] = Rs(gn[sn] || xn, ft[$n], gt, Ot));
                return Ju(Lr(gn, 1), gt, Ot)
            }
            function Sv(ft, gt, Ot) {
                for (var Qt = -1, sn = ft.length, gn = gt.length, xn = {}; ++Qt < sn; ) {
                    var $n = Qt < gn ? gt[Qt] : et;
                    Ot(xn, ft[Qt], $n)
                }
                return xn
            }
            function S1(ft) {
                return ts(ft) ? ft : []
            }
            function w1(ft) {
                return typeof ft == "function" ? ft : Xs
            }
            function _d(ft, gt) {
                return Zr(ft) ? ft : k1(ft, gt) ? [ft] : Xv(So(ft))
            }
            var oE = oo;
            function _f(ft, gt, Ot) {
                var Qt = ft.length;
                return Ot = Ot === et ? Qt : Ot,
                !gt && Ot >= Qt ? ft : wl(ft, gt, Ot)
            }
            var wv = l1 || function(ft) {
                return rs.clearTimeout(ft)
            }
            ;
            function xv(ft, gt) {
                if (gt)
                    return ft.slice();
                var Ot = ft.length
                  , Qt = f0 ? f0(Ot) : new ft.constructor(Ot);
                return ft.copy(Qt),
                Qt
            }
            function x1(ft) {
                var gt = new ft.constructor(ft.byteLength);
                return new cm(gt).set(new cm(ft)),
                gt
            }
            function sE(ft, gt) {
                var Ot = gt ? x1(ft.buffer) : ft.buffer;
                return new ft.constructor(Ot,ft.byteOffset,ft.byteLength)
            }
            function aE(ft) {
                var gt = new ft.constructor(ft.source,yo.exec(ft));
                return gt.lastIndex = ft.lastIndex,
                gt
            }
            function lE(ft) {
                return $p ? Co($p.call(ft)) : {}
            }
            function Tv(ft, gt) {
                var Ot = gt ? x1(ft.buffer) : ft.buffer;
                return new ft.constructor(Ot,ft.byteOffset,ft.length)
            }
            function Rv(ft, gt) {
                if (ft !== gt) {
                    var Ot = ft !== et
                      , Qt = ft === null
                      , sn = ft === ft
                      , gn = _a(ft)
                      , xn = gt !== et
                      , $n = gt === null
                      , Ln = gt === gt
                      , Xn = _a(gt);
                    if (!$n && !Xn && !gn && ft > gt || gn && xn && Ln && !$n && !Xn || Qt && xn && Ln || !Ot && Ln || !sn)
                        return 1;
                    if (!Qt && !gn && !Xn && ft < gt || Xn && Ot && sn && !Qt && !gn || $n && Ot && sn || !xn && sn || !Ln)
                        return -1
                }
                return 0
            }
            function cE(ft, gt, Ot) {
                for (var Qt = -1, sn = ft.criteria, gn = gt.criteria, xn = sn.length, $n = Ot.length; ++Qt < xn; ) {
                    var Ln = Rv(sn[Qt], gn[Qt]);
                    if (Ln) {
                        if (Qt >= $n)
                            return Ln;
                        var Xn = Ot[Qt];
                        return Ln * (Xn == "desc" ? -1 : 1)
                    }
                }
                return ft.index - gt.index
            }
            function Cv(ft, gt, Ot, Qt) {
                for (var sn = -1, gn = ft.length, xn = Ot.length, $n = -1, Ln = gt.length, Xn = Qo(gn - xn, 0), Jn = Wn(Ln + Xn), nr = !Qt; ++$n < Ln; )
                    Jn[$n] = gt[$n];
                for (; ++sn < xn; )
                    (nr || sn < gn) && (Jn[Ot[sn]] = ft[sn]);
                for (; Xn--; )
                    Jn[$n++] = ft[sn++];
                return Jn
            }
            function $v(ft, gt, Ot, Qt) {
                for (var sn = -1, gn = ft.length, xn = -1, $n = Ot.length, Ln = -1, Xn = gt.length, Jn = Qo(gn - $n, 0), nr = Wn(Jn + Xn), Er = !Qt; ++sn < Jn; )
                    nr[sn] = ft[sn];
                for (var kr = sn; ++Ln < Xn; )
                    nr[kr + Ln] = gt[Ln];
                for (; ++xn < $n; )
                    (Er || sn < gn) && (nr[kr + Ot[xn]] = ft[sn++]);
                return nr
            }
            function Ys(ft, gt) {
                var Ot = -1
                  , Qt = ft.length;
                for (gt || (gt = Wn(Qt)); ++Ot < Qt; )
                    gt[Ot] = ft[Ot];
                return gt
            }
            function tu(ft, gt, Ot, Qt) {
                var sn = !Ot;
                Ot || (Ot = {});
                for (var gn = -1, xn = gt.length; ++gn < xn; ) {
                    var $n = gt[gn]
                      , Ln = Qt ? Qt(Ot[$n], ft[$n], $n, Ot, ft) : et;
                    Ln === et && (Ln = ft[$n]),
                    sn ? so(Ot, $n, Ln) : Sr(Ot, $n, Ln)
                }
                return Ot
            }
            function uE(ft, gt) {
                return tu(ft, O1(ft), gt)
            }
            function dE(ft, gt) {
                return tu(ft, Fv(ft), gt)
            }
            function Cy(ft, gt) {
                return function(Ot, Qt) {
                    var sn = Zr(Ot) ? ry : Po
                      , gn = gt ? gt() : {};
                    return sn(Ot, ft, Mr(Qt, 2), gn)
                }
            }
            function wm(ft) {
                return oo(function(gt, Ot) {
                    var Qt = -1
                      , sn = Ot.length
                      , gn = sn > 1 ? Ot[sn - 1] : et
                      , xn = sn > 2 ? Ot[2] : et;
                    for (gn = ft.length > 3 && typeof gn == "function" ? (sn--,
                    gn) : et,
                    xn && Ps(Ot[0], Ot[1], xn) && (gn = sn < 3 ? et : gn,
                    sn = 1),
                    gt = Co(gt); ++Qt < sn; ) {
                        var $n = Ot[Qt];
                        $n && ft(gt, $n, Qt, gn)
                    }
                    return gt
                })
            }
            function Av(ft, gt) {
                return function(Ot, Qt) {
                    if (Ot == null)
                        return Ot;
                    if (!qs(Ot))
                        return ft(Ot, Qt);
                    for (var sn = Ot.length, gn = gt ? sn : -1, xn = Co(Ot); (gt ? gn-- : ++gn < sn) && Qt(xn[gn], gn, xn) !== !1; )
                        ;
                    return Ot
                }
            }
            function Iv(ft) {
                return function(gt, Ot, Qt) {
                    for (var sn = -1, gn = Co(gt), xn = Qt(gt), $n = xn.length; $n--; ) {
                        var Ln = xn[ft ? $n : ++sn];
                        if (Ot(gn[Ln], Ln, gn) === !1)
                            break
                    }
                    return gt
                }
            }
            function fE(ft, gt, Ot) {
                var Qt = gt & Et
                  , sn = x0(ft);
                function gn() {
                    var xn = this && this !== rs && this instanceof gn ? sn : ft;
                    return xn.apply(Qt ? Ot : this, arguments)
                }
                return gn
            }
            function Ov(ft) {
                return function(gt) {
                    gt = So(gt);
                    var Ot = Zl(gt) ? Ks(gt) : et
                      , Qt = Ot ? Ot[0] : gt.charAt(0)
                      , sn = Ot ? _f(Ot, 1).join("") : gt.slice(1);
                    return Qt[ft]() + sn
                }
            }
            function xm(ft) {
                return function(gt) {
                    return vp(A_($_(gt).replace(Xy, "")), ft, "")
                }
            }
            function x0(ft) {
                return function() {
                    var gt = arguments;
                    switch (gt.length) {
                    case 0:
                        return new ft;
                    case 1:
                        return new ft(gt[0]);
                    case 2:
                        return new ft(gt[0],gt[1]);
                    case 3:
                        return new ft(gt[0],gt[1],gt[2]);
                    case 4:
                        return new ft(gt[0],gt[1],gt[2],gt[3]);
                    case 5:
                        return new ft(gt[0],gt[1],gt[2],gt[3],gt[4]);
                    case 6:
                        return new ft(gt[0],gt[1],gt[2],gt[3],gt[4],gt[5]);
                    case 7:
                        return new ft(gt[0],gt[1],gt[2],gt[3],gt[4],gt[5],gt[6])
                    }
                    var Ot = Xu(ft.prototype)
                      , Qt = ft.apply(Ot, gt);
                    return Ko(Qt) ? Qt : Ot
                }
            }
            function pE(ft, gt, Ot) {
                var Qt = x0(ft);
                function sn() {
                    for (var gn = arguments.length, xn = Wn(gn), $n = gn, Ln = Tm(sn); $n--; )
                        xn[$n] = arguments[$n];
                    var Xn = gn < 3 && xn[0] !== Ln && xn[gn - 1] !== Ln ? [] : Al(xn, Ln);
                    if (gn -= Xn.length,
                    gn < Ot)
                        return Pv(ft, gt, $y, sn.placeholder, et, xn, Xn, et, et, Ot - gn);
                    var Jn = this && this !== rs && this instanceof sn ? Qt : ft;
                    return Ls(Jn, this, xn)
                }
                return sn
            }
            function kv(ft) {
                return function(gt, Ot, Qt) {
                    var sn = Co(gt);
                    if (!qs(gt)) {
                        var gn = Mr(Ot, 3);
                        gt = _s(gt),
                        Ot = function($n) {
                            return gn(sn[$n], $n, sn)
                        }
                    }
                    var xn = ft(gt, Ot, Qt);
                    return xn > -1 ? sn[gn ? gt[xn] : xn] : et
                }
            }
            function Lv(ft) {
                return wu(function(gt) {
                    var Ot = gt.length
                      , Qt = Ot
                      , sn = Tt.prototype.thru;
                    for (ft && gt.reverse(); Qt--; ) {
                        var gn = gt[Qt];
                        if (typeof gn != "function")
                            throw new Vs(it);
                        if (sn && !xn && ky(gn) == "wrapper")
                            var xn = new Tt([],!0)
                    }
                    for (Qt = xn ? Qt : Ot; ++Qt < Ot; ) {
                        gn = gt[Qt];
                        var $n = ky(gn)
                          , Ln = $n == "wrapper" ? A1(gn) : et;
                        Ln && L1(Ln[0]) && Ln[1] == (kt | St | Nt | Ut) && !Ln[4].length && Ln[9] == 1 ? xn = xn[ky(Ln[0])].apply(xn, Ln[3]) : xn = gn.length == 1 && L1(gn) ? xn[$n]() : xn.thru(gn)
                    }
                    return function() {
                        var Xn = arguments
                          , Jn = Xn[0];
                        if (xn && Xn.length == 1 && Zr(Jn))
                            return xn.plant(Jn).value();
                        for (var nr = 0, Er = Ot ? gt[nr].apply(this, Xn) : Jn; ++nr < Ot; )
                            Er = gt[nr].call(this, Er);
                        return Er
                    }
                })
            }
            function $y(ft, gt, Ot, Qt, sn, gn, xn, $n, Ln, Xn) {
                var Jn = gt & kt
                  , nr = gt & Et
                  , Er = gt & _t
                  , kr = gt & (St | Ct)
                  , Pr = gt & Jt
                  , no = Er ? et : x0(ft);
                function Dr() {
                    for (var ao = arguments.length, uo = Wn(ao), ba = ao; ba--; )
                        uo[ba] = arguments[ba];
                    if (kr)
                        var Ds = Tm(Dr)
                          , xa = Yl(uo, Ds);
                    if (Qt && (uo = Cv(uo, Qt, sn, kr)),
                    gn && (uo = $v(uo, gn, xn, kr)),
                    ao -= xa,
                    kr && ao < Xn) {
                        var ns = Al(uo, Ds);
                        return Pv(ft, gt, $y, Dr.placeholder, Ot, uo, ns, $n, Ln, Xn - ao)
                    }
                    var Nl = nr ? Ot : this
                      , Cu = Er ? Nl[ft] : ft;
                    return ao = uo.length,
                    $n ? uo = LE(uo, $n) : Pr && ao > 1 && uo.reverse(),
                    Jn && Ln < ao && (uo.length = Ln),
                    this && this !== rs && this instanceof Dr && (Cu = no || x0(Cu)),
                    Cu.apply(Nl, uo)
                }
                return Dr
            }
            function Nv(ft, gt) {
                return function(Ot, Qt) {
                    return ym(Ot, ft, gt(Qt), {})
                }
            }
            function Ay(ft, gt) {
                return function(Ot, Qt) {
                    var sn;
                    if (Ot === et && Qt === et)
                        return gt;
                    if (Ot !== et && (sn = Ot),
                    Qt !== et) {
                        if (sn === et)
                            return Qt;
                        typeof Ot == "string" || typeof Qt == "string" ? (Ot = ga(Ot),
                        Qt = ga(Qt)) : (Ot = _v(Ot),
                        Qt = _v(Qt)),
                        sn = ft(Ot, Qt)
                    }
                    return sn
                }
            }
            function T1(ft) {
                return wu(function(gt) {
                    return gt = Mo(gt, Ns(Mr())),
                    oo(function(Ot) {
                        var Qt = this;
                        return ft(gt, function(sn) {
                            return Ls(sn, Qt, Ot)
                        })
                    })
                })
            }
            function Iy(ft, gt) {
                gt = gt === et ? " " : ga(gt);
                var Ot = gt.length;
                if (Ot < 2)
                    return Ot ? y1(gt, ft) : gt;
                var Qt = y1(gt, fm(ft / yu(gt)));
                return Zl(gt) ? _f(Ks(Qt), 0, ft).join("") : Qt.slice(0, ft)
            }
            function hE(ft, gt, Ot, Qt) {
                var sn = gt & Et
                  , gn = x0(ft);
                function xn() {
                    for (var $n = -1, Ln = arguments.length, Xn = -1, Jn = Qt.length, nr = Wn(Jn + Ln), Er = this && this !== rs && this instanceof xn ? gn : ft; ++Xn < Jn; )
                        nr[Xn] = Qt[Xn];
                    for (; Ln--; )
                        nr[Xn++] = arguments[++$n];
                    return Ls(Er, sn ? Ot : this, nr)
                }
                return xn
            }
            function Mv(ft) {
                return function(gt, Ot, Qt) {
                    return Qt && typeof Qt != "number" && Ps(gt, Ot, Qt) && (Ot = Qt = et),
                    gt = Ru(gt),
                    Ot === et ? (Ot = gt,
                    gt = 0) : Ot = Ru(Ot),
                    Qt = Qt === et ? gt < Ot ? 1 : -1 : Ru(Qt),
                    _b(gt, Ot, Qt, ft)
                }
            }
            function Oy(ft) {
                return function(gt, Ot) {
                    return typeof gt == "string" && typeof Ot == "string" || (gt = Tl(gt),
                    Ot = Tl(Ot)),
                    ft(gt, Ot)
                }
            }
            function Pv(ft, gt, Ot, Qt, sn, gn, xn, $n, Ln, Xn) {
                var Jn = gt & St
                  , nr = Jn ? xn : et
                  , Er = Jn ? et : xn
                  , kr = Jn ? gn : et
                  , Pr = Jn ? et : gn;
                gt |= Jn ? Nt : Lt,
                gt &= ~(Jn ? Lt : Nt),
                gt & wt || (gt &= -4);
                var no = [ft, gt, sn, kr, nr, Pr, Er, $n, Ln, Xn]
                  , Dr = Ot.apply(et, no);
                return L1(ft) && Yv(Dr, no),
                Dr.placeholder = Qt,
                qv(Dr, ft, gt)
            }
            function R1(ft) {
                var gt = Xo[ft];
                return function(Ot, Qt) {
                    if (Ot = Tl(Ot),
                    Qt = Qt == null ? 0 : ls(Qr(Qt), 292),
                    Qt && m0(Ot)) {
                        var sn = (So(Ot) + "e").split("e")
                          , gn = gt(sn[0] + "e" + (+sn[1] + Qt));
                        return sn = (So(gn) + "e").split("e"),
                        +(sn[0] + "e" + (+sn[1] - Qt))
                    }
                    return gt(Ot)
                }
            }
            var gE = Ol && 1 / Sp(new Ol([, -0]))[1] == jt ? function(ft) {
                return new Ol(ft)
            }
            : Y1;
            function Dv(ft) {
                return function(gt) {
                    var Ot = $s(gt);
                    return Ot == Gn ? am(gt) : Ot == wr ? cy(gt) : n1(gt, ft(gt))
                }
            }
            function Su(ft, gt, Ot, Qt, sn, gn, xn, $n) {
                var Ln = gt & _t;
                if (!Ln && typeof ft != "function")
                    throw new Vs(it);
                var Xn = Qt ? Qt.length : 0;
                if (Xn || (gt &= -97,
                Qt = sn = et),
                xn = xn === et ? xn : Qo(Qr(xn), 0),
                $n = $n === et ? $n : Qr($n),
                Xn -= sn ? sn.length : 0,
                gt & Lt) {
                    var Jn = Qt
                      , nr = sn;
                    Qt = sn = et
                }
                var Er = Ln ? et : A1(ft)
                  , kr = [ft, gt, Ot, Qt, sn, Jn, nr, gn, xn, $n];
                if (Er && IE(kr, Er),
                ft = kr[0],
                gt = kr[1],
                Ot = kr[2],
                Qt = kr[3],
                sn = kr[4],
                $n = kr[9] = kr[9] === et ? Ln ? 0 : ft.length : Qo(kr[9] - Xn, 0),
                !$n && gt & (St | Ct) && (gt &= -25),
                !gt || gt == Et)
                    var Pr = fE(ft, gt, Ot);
                else
                    gt == St || gt == Ct ? Pr = pE(ft, gt, $n) : (gt == Nt || gt == (Et | Nt)) && !sn.length ? Pr = hE(ft, gt, Ot, Qt) : Pr = $y.apply(et, kr);
                var no = Er ? yv : Yv;
                return qv(no(Pr, kr), ft, gt)
            }
            function Bv(ft, gt, Ot, Qt) {
                return ft === et || Ll(ft, Il[Ot]) && !ho.call(Qt, Ot) ? gt : ft
            }
            function Uv(ft, gt, Ot, Qt, sn, gn) {
                return Ko(ft) && Ko(gt) && (gn.set(gt, ft),
                xy(ft, gt, et, Uv, gn),
                gn.delete(gt)),
                ft
            }
            function mE(ft) {
                return C0(ft) ? et : ft
            }
            function jv(ft, gt, Ot, Qt, sn, gn) {
                var xn = Ot & mt
                  , $n = ft.length
                  , Ln = gt.length;
                if ($n != Ln && !(xn && Ln > $n))
                    return !1;
                var Xn = gn.get(ft)
                  , Jn = gn.get(gt);
                if (Xn && Jn)
                    return Xn == gt && Jn == ft;
                var nr = -1
                  , Er = !0
                  , kr = Ot & yt ? new Gr : et;
                for (gn.set(ft, gt),
                gn.set(gt, ft); ++nr < $n; ) {
                    var Pr = ft[nr]
                      , no = gt[nr];
                    if (Qt)
                        var Dr = xn ? Qt(no, Pr, nr, gt, ft, gn) : Qt(Pr, no, nr, ft, gt, gn);
                    if (Dr !== et) {
                        if (Dr)
                            continue;
                        Er = !1;
                        break
                    }
                    if (kr) {
                        if (!Jp(gt, function(ao, uo) {
                            if (!bp(kr, uo) && (Pr === ao || sn(Pr, ao, Ot, Qt, gn)))
                                return kr.push(uo)
                        })) {
                            Er = !1;
                            break
                        }
                    } else if (!(Pr === no || sn(Pr, no, Ot, Qt, gn))) {
                        Er = !1;
                        break
                    }
                }
                return gn.delete(ft),
                gn.delete(gt),
                Er
            }
            function yE(ft, gt, Ot, Qt, sn, gn, xn) {
                switch (Ot) {
                case Cr:
                    if (ft.byteLength != gt.byteLength || ft.byteOffset != gt.byteOffset)
                        return !1;
                    ft = ft.buffer,
                    gt = gt.buffer;
                case ir:
                    return !(ft.byteLength != gt.byteLength || !gn(new cm(ft), new cm(gt)));
                case Dn:
                case jn:
                case Mn:
                    return Ll(+ft, +gt);
                case Un:
                    return ft.name == gt.name && ft.message == gt.message;
                case xr:
                case Rn:
                    return ft == gt + "";
                case Gn:
                    var $n = am;
                case wr:
                    var Ln = Qt & mt;
                    if ($n || ($n = Sp),
                    ft.size != gt.size && !Ln)
                        return !1;
                    var Xn = xn.get(ft);
                    if (Xn)
                        return Xn == gt;
                    Qt |= yt,
                    xn.set(ft, gt);
                    var Jn = jv($n(ft), $n(gt), Qt, sn, gn, xn);
                    return xn.delete(ft),
                    Jn;
                case Vn:
                    if ($p)
                        return $p.call(ft) == $p.call(gt)
                }
                return !1
            }
            function vE(ft, gt, Ot, Qt, sn, gn) {
                var xn = Ot & mt
                  , $n = C1(ft)
                  , Ln = $n.length
                  , Xn = C1(gt)
                  , Jn = Xn.length;
                if (Ln != Jn && !xn)
                    return !1;
                for (var nr = Ln; nr--; ) {
                    var Er = $n[nr];
                    if (!(xn ? Er in gt : ho.call(gt, Er)))
                        return !1
                }
                var kr = gn.get(ft)
                  , Pr = gn.get(gt);
                if (kr && Pr)
                    return kr == gt && Pr == ft;
                var no = !0;
                gn.set(ft, gt),
                gn.set(gt, ft);
                for (var Dr = xn; ++nr < Ln; ) {
                    Er = $n[nr];
                    var ao = ft[Er]
                      , uo = gt[Er];
                    if (Qt)
                        var ba = xn ? Qt(uo, ao, Er, gt, ft, gn) : Qt(ao, uo, Er, ft, gt, gn);
                    if (!(ba === et ? ao === uo || sn(ao, uo, Ot, Qt, gn) : ba)) {
                        no = !1;
                        break
                    }
                    Dr || (Dr = Er == "constructor")
                }
                if (no && !Dr) {
                    var Ds = ft.constructor
                      , xa = gt.constructor;
                    Ds != xa && "constructor"in ft && "constructor"in gt && !(typeof Ds == "function" && Ds instanceof Ds && typeof xa == "function" && xa instanceof xa) && (no = !1)
                }
                return gn.delete(ft),
                gn.delete(gt),
                no
            }
            function wu(ft) {
                return M1(Kv(ft, et, t_), ft + "")
            }
            function C1(ft) {
                return vs(ft, _s, O1)
            }
            function $1(ft) {
                return vs(ft, Zs, Fv)
            }
            var A1 = hm ? function(ft) {
                return hm.get(ft)
            }
            : Y1;
            function ky(ft) {
                for (var gt = ft.name + "", Ot = Zu[gt], Qt = ho.call(Zu, gt) ? Ot.length : 0; Qt--; ) {
                    var sn = Ot[Qt]
                      , gn = sn.func;
                    if (gn == null || gn == ft)
                        return sn.name
                }
                return gt
            }
            function Tm(ft) {
                var gt = ho.call(pn, "placeholder") ? pn : ft;
                return gt.placeholder
            }
            function Mr() {
                var ft = pn.iteratee || K1;
                return ft = ft === K1 ? Cs : ft,
                arguments.length ? ft(arguments[0], arguments[1]) : ft
            }
            function Ly(ft, gt) {
                var Ot = ft.__data__;
                return RE(gt) ? Ot[typeof gt == "string" ? "string" : "hash"] : Ot.map
            }
            function I1(ft) {
                for (var gt = _s(ft), Ot = gt.length; Ot--; ) {
                    var Qt = gt[Ot]
                      , sn = ft[Qt];
                    gt[Ot] = [Qt, sn, Hv(sn)]
                }
                return gt
            }
            function Op(ft, gt) {
                var Ot = l0(ft, gt);
                return ss(Ot) ? Ot : et
            }
            function _E(ft) {
                var gt = ho.call(ft, Jl)
                  , Ot = ft[Jl];
                try {
                    ft[Jl] = et;
                    var Qt = !0
                } catch {}
                var sn = xp.call(ft);
                return Qt && (gt ? ft[Jl] = Ot : delete ft[Jl]),
                sn
            }
            var O1 = g0 ? function(ft) {
                return ft == null ? [] : (ft = Co(ft),
                Kl(g0(ft), function(gt) {
                    return my.call(ft, gt)
                }))
            }
            : q1
              , Fv = g0 ? function(ft) {
                for (var gt = []; ft; )
                    Vl(gt, O1(ft)),
                    ft = Rp(ft);
                return gt
            }
            : q1
              , $s = jo;
            (v0 && $s(new v0(new ArrayBuffer(1))) != Cr || Cp && $s(new Cp) != Gn || Jo && $s(Jo.resolve()) != pr || Ol && $s(new Ol) != wr || Yu && $s(new Yu) != dr) && ($s = function(ft) {
                var gt = jo(ft)
                  , Ot = gt == Zn ? ft.constructor : et
                  , Qt = Ot ? kp(Ot) : "";
                if (Qt)
                    switch (Qt) {
                    case d1:
                        return Cr;
                    case f1:
                        return Gn;
                    case Sy:
                        return pr;
                    case p1:
                        return wr;
                    case h1:
                        return dr
                    }
                return gt
            }
            );
            function bE(ft, gt, Ot) {
                for (var Qt = -1, sn = Ot.length; ++Qt < sn; ) {
                    var gn = Ot[Qt]
                      , xn = gn.size;
                    switch (gn.type) {
                    case "drop":
                        ft += xn;
                        break;
                    case "dropRight":
                        gt -= xn;
                        break;
                    case "take":
                        gt = ls(gt, ft + xn);
                        break;
                    case "takeRight":
                        ft = Qo(ft, gt - xn);
                        break
                    }
                }
                return {
                    start: ft,
                    end: gt
                }
            }
            function EE(ft) {
                var gt = ft.match(xo);
                return gt ? gt[1].split(To) : []
            }
            function zv(ft, gt, Ot) {
                gt = _d(gt, ft);
                for (var Qt = -1, sn = gt.length, gn = !1; ++Qt < sn; ) {
                    var xn = nu(gt[Qt]);
                    if (!(gn = ft != null && Ot(ft, xn)))
                        break;
                    ft = ft[xn]
                }
                return gn || ++Qt != sn ? gn : (sn = ft == null ? 0 : ft.length,
                !!sn && jy(sn) && xu(xn, sn) && (Zr(ft) || Lp(ft)))
            }
            function SE(ft) {
                var gt = ft.length
                  , Ot = new ft.constructor(gt);
                return gt && typeof ft[0] == "string" && ho.call(ft, "index") && (Ot.index = ft.index,
                Ot.input = ft.input),
                Ot
            }
            function Wv(ft) {
                return typeof ft.constructor == "function" && !T0(ft) ? Xu(Rp(ft)) : {}
            }
            function wE(ft, gt, Ot) {
                var Qt = ft.constructor;
                switch (gt) {
                case ir:
                    return x1(ft);
                case Dn:
                case jn:
                    return new Qt(+ft);
                case Cr:
                    return sE(ft, Ot);
                case br:
                case an:
                case Kt:
                case Gt:
                case fn:
                case En:
                case vn:
                case Tn:
                case sr:
                    return Tv(ft, Ot);
                case Gn:
                    return new Qt;
                case Mn:
                case Rn:
                    return new Qt(ft);
                case xr:
                    return aE(ft);
                case wr:
                    return new Qt;
                case Vn:
                    return lE(ft)
                }
            }
            function xE(ft, gt) {
                var Ot = gt.length;
                if (!Ot)
                    return ft;
                var Qt = Ot - 1;
                return gt[Qt] = (Ot > 1 ? "& " : "") + gt[Qt],
                gt = gt.join(Ot > 2 ? ", " : " "),
                ft.replace(Sl, `{
/* [wrapped with ` + gt + `] */
`)
            }
            function TE(ft) {
                return Zr(ft) || Lp(ft) || !!(h0 && ft && ft[h0])
            }
            function xu(ft, gt) {
                var Ot = typeof ft;
                return gt = gt ?? Ft,
                !!gt && (Ot == "number" || Ot != "symbol" && Hs.test(ft)) && ft > -1 && ft % 1 == 0 && ft < gt
            }
            function Ps(ft, gt, Ot) {
                if (!Ko(Ot))
                    return !1;
                var Qt = typeof gt;
                return (Qt == "number" ? qs(Ot) && xu(gt, Ot.length) : Qt == "string" && gt in Ot) ? Ll(Ot[gt], ft) : !1
            }
            function k1(ft, gt) {
                if (Zr(ft))
                    return !1;
                var Ot = typeof ft;
                return Ot == "number" || Ot == "symbol" || Ot == "boolean" || ft == null || _a(ft) ? !0 : zs.test(ft) || !jr.test(ft) || gt != null && ft in Co(gt)
            }
            function RE(ft) {
                var gt = typeof ft;
                return gt == "string" || gt == "number" || gt == "symbol" || gt == "boolean" ? ft !== "__proto__" : ft === null
            }
            function L1(ft) {
                var gt = ky(ft)
                  , Ot = pn[gt];
                if (typeof Ot != "function" || !(gt in vt.prototype))
                    return !1;
                if (ft === Ot)
                    return !0;
                var Qt = A1(Ot);
                return !!Qt && ft === Qt[0]
            }
            function CE(ft) {
                return !!d0 && d0 in ft
            }
            var $E = Xl ? Tu : Z1;
            function T0(ft) {
                var gt = ft && ft.constructor
                  , Ot = typeof gt == "function" && gt.prototype || Il;
                return ft === Ot
            }
            function Hv(ft) {
                return ft === ft && !Ko(ft)
            }
            function Gv(ft, gt) {
                return function(Ot) {
                    return Ot == null ? !1 : Ot[ft] === gt && (gt !== et || ft in Co(Ot))
                }
            }
            function AE(ft) {
                var gt = By(ft, function(Qt) {
                    return Ot.size === lt && Ot.clear(),
                    Qt
                })
                  , Ot = gt.cache;
                return gt
            }
            function IE(ft, gt) {
                var Ot = ft[1]
                  , Qt = gt[1]
                  , sn = Ot | Qt
                  , gn = sn < (Et | _t | kt)
                  , xn = Qt == kt && Ot == St || Qt == kt && Ot == Ut && ft[7].length <= gt[8] || Qt == (kt | Ut) && gt[7].length <= gt[8] && Ot == St;
                if (!(gn || xn))
                    return ft;
                Qt & Et && (ft[2] = gt[2],
                sn |= Ot & Et ? 0 : wt);
                var $n = gt[3];
                if ($n) {
                    var Ln = ft[3];
                    ft[3] = Ln ? Cv(Ln, $n, gt[4]) : $n,
                    ft[4] = Ln ? Al(ft[3], ct) : gt[4]
                }
                return $n = gt[5],
                $n && (Ln = ft[5],
                ft[5] = Ln ? $v(Ln, $n, gt[6]) : $n,
                ft[6] = Ln ? Al(ft[5], ct) : gt[6]),
                $n = gt[7],
                $n && (ft[7] = $n),
                Qt & kt && (ft[8] = ft[8] == null ? gt[8] : ls(ft[8], gt[8])),
                ft[9] == null && (ft[9] = gt[9]),
                ft[0] = gt[0],
                ft[1] = sn,
                ft
            }
            function OE(ft) {
                var gt = [];
                if (ft != null)
                    for (var Ot in Co(ft))
                        gt.push(Ot);
                return gt
            }
            function kE(ft) {
                return xp.call(ft)
            }
            function Kv(ft, gt, Ot) {
                return gt = Qo(gt === et ? ft.length - 1 : gt, 0),
                function() {
                    for (var Qt = arguments, sn = -1, gn = Qo(Qt.length - gt, 0), xn = Wn(gn); ++sn < gn; )
                        xn[sn] = Qt[gt + sn];
                    sn = -1;
                    for (var $n = Wn(gt + 1); ++sn < gt; )
                        $n[sn] = Qt[sn];
                    return $n[gt] = Ot(xn),
                    Ls(ft, this, $n)
                }
            }
            function Vv(ft, gt) {
                return gt.length < 2 ? ft : Ao(ft, wl(gt, 0, -1))
            }
            function LE(ft, gt) {
                for (var Ot = ft.length, Qt = ls(gt.length, Ot), sn = Ys(ft); Qt--; ) {
                    var gn = gt[Qt];
                    ft[Qt] = xu(gn, Ot) ? sn[gn] : et
                }
                return ft
            }
            function N1(ft, gt) {
                if (!(gt === "constructor" && typeof ft[gt] == "function") && gt != "__proto__")
                    return ft[gt]
            }
            var Yv = Zv(yv)
              , R0 = c1 || function(ft, gt) {
                return rs.setTimeout(ft, gt)
            }
              , M1 = Zv(nE);
            function qv(ft, gt, Ot) {
                var Qt = gt + "";
                return M1(ft, xE(Qt, NE(EE(Qt), Ot)))
            }
            function Zv(ft) {
                var gt = 0
                  , Ot = 0;
                return function() {
                    var Qt = _y()
                      , sn = zt - (Qt - Ot);
                    if (Ot = Qt,
                    sn > 0) {
                        if (++gt >= rn)
                            return arguments[0]
                    } else
                        gt = 0;
                    return ft.apply(et, arguments)
                }
            }
            function Ny(ft, gt) {
                var Ot = -1
                  , Qt = ft.length
                  , sn = Qt - 1;
                for (gt = gt === et ? Qt : gt; ++Ot < gt; ) {
                    var gn = m1(Ot, sn)
                      , xn = ft[gn];
                    ft[gn] = ft[Ot],
                    ft[Ot] = xn
                }
                return ft.length = gt,
                ft
            }
            var Xv = AE(function(ft) {
                var gt = [];
                return ft.charCodeAt(0) === 46 && gt.push(""),
                ft.replace(bo, function(Ot, Qt, sn, gn) {
                    gt.push(sn ? gn.replace(Ro, "$1") : Qt || Ot)
                }),
                gt
            });
            function nu(ft) {
                if (typeof ft == "string" || _a(ft))
                    return ft;
                var gt = ft + "";
                return gt == "0" && 1 / ft == -1 / 0 ? "-0" : gt
            }
            function kp(ft) {
                if (ft != null) {
                    try {
                        return Gu.call(ft)
                    } catch {}
                    try {
                        return ft + ""
                    } catch {}
                }
                return ""
            }
            function NE(ft, gt) {
                return Gs(un, function(Ot) {
                    var Qt = "_." + Ot[0];
                    gt & Ot[1] && !Qp(ft, Qt) && ft.push(Qt)
                }),
                ft.sort()
            }
            function Qv(ft) {
                if (ft instanceof vt)
                    return ft.clone();
                var gt = new Tt(ft.__wrapped__,ft.__chain__);
                return gt.__actions__ = Ys(ft.__actions__),
                gt.__index__ = ft.__index__,
                gt.__values__ = ft.__values__,
                gt
            }
            function ME(ft, gt, Ot) {
                (Ot ? Ps(ft, gt, Ot) : gt === et) ? gt = 1 : gt = Qo(Qr(gt), 0);
                var Qt = ft == null ? 0 : ft.length;
                if (!Qt || gt < 1)
                    return [];
                for (var sn = 0, gn = 0, xn = Wn(fm(Qt / gt)); sn < Qt; )
                    xn[gn++] = wl(ft, sn, sn += gt);
                return xn
            }
            function PE(ft) {
                for (var gt = -1, Ot = ft == null ? 0 : ft.length, Qt = 0, sn = []; ++gt < Ot; ) {
                    var gn = ft[gt];
                    gn && (sn[Qt++] = gn)
                }
                return sn
            }
            function DE() {
                var ft = arguments.length;
                if (!ft)
                    return [];
                for (var gt = Wn(ft - 1), Ot = arguments[0], Qt = ft; Qt--; )
                    gt[Qt - 1] = arguments[Qt];
                return Vl(Zr(Ot) ? Ys(Ot) : [Ot], Lr(gt, 1))
            }
            var BE = oo(function(ft, gt) {
                return ts(ft) ? Rs(ft, Lr(gt, 1, ts, !0)) : []
            })
              , UE = oo(function(ft, gt) {
                var Ot = xl(gt);
                return ts(Ot) && (Ot = et),
                ts(ft) ? Rs(ft, Lr(gt, 1, ts, !0), Mr(Ot, 2)) : []
            })
              , jE = oo(function(ft, gt) {
                var Ot = xl(gt);
                return ts(Ot) && (Ot = et),
                ts(ft) ? Rs(ft, Lr(gt, 1, ts, !0), et, Ot) : []
            });
            function FE(ft, gt, Ot) {
                var Qt = ft == null ? 0 : ft.length;
                return Qt ? (gt = Ot || gt === et ? 1 : Qr(gt),
                wl(ft, gt < 0 ? 0 : gt, Qt)) : []
            }
            function zE(ft, gt, Ot) {
                var Qt = ft == null ? 0 : ft.length;
                return Qt ? (gt = Ot || gt === et ? 1 : Qr(gt),
                gt = Qt - gt,
                wl(ft, 0, gt < 0 ? 0 : gt)) : []
            }
            function WE(ft, gt) {
                return ft && ft.length ? Ry(ft, Mr(gt, 3), !0, !0) : []
            }
            function HE(ft, gt) {
                return ft && ft.length ? Ry(ft, Mr(gt, 3), !0) : []
            }
            function GE(ft, gt, Ot, Qt) {
                var sn = ft == null ? 0 : ft.length;
                return sn ? (Ot && typeof Ot != "number" && Ps(ft, gt, Ot) && (Ot = 0,
                Qt = sn),
                qr(ft, gt, Ot, Qt)) : []
            }
            function Jv(ft, gt, Ot) {
                var Qt = ft == null ? 0 : ft.length;
                if (!Qt)
                    return -1;
                var sn = Ot == null ? 0 : Qr(Ot);
                return sn < 0 && (sn = Qo(Qt + sn, 0)),
                _p(ft, Mr(gt, 3), sn)
            }
            function e_(ft, gt, Ot) {
                var Qt = ft == null ? 0 : ft.length;
                if (!Qt)
                    return -1;
                var sn = Qt - 1;
                return Ot !== et && (sn = Qr(Ot),
                sn = Ot < 0 ? Qo(Qt + sn, 0) : ls(sn, Qt - 1)),
                _p(ft, Mr(gt, 3), sn, !0)
            }
            function t_(ft) {
                var gt = ft == null ? 0 : ft.length;
                return gt ? Lr(ft, 1) : []
            }
            function KE(ft) {
                var gt = ft == null ? 0 : ft.length;
                return gt ? Lr(ft, jt) : []
            }
            function VE(ft, gt) {
                var Ot = ft == null ? 0 : ft.length;
                return Ot ? (gt = gt === et ? 1 : Qr(gt),
                Lr(ft, gt)) : []
            }
            function YE(ft) {
                for (var gt = -1, Ot = ft == null ? 0 : ft.length, Qt = {}; ++gt < Ot; ) {
                    var sn = ft[gt];
                    Qt[sn[0]] = sn[1]
                }
                return Qt
            }
            function n_(ft) {
                return ft && ft.length ? ft[0] : et
            }
            function qE(ft, gt, Ot) {
                var Qt = ft == null ? 0 : ft.length;
                if (!Qt)
                    return -1;
                var sn = Ot == null ? 0 : Qr(Ot);
                return sn < 0 && (sn = Qo(Qt + sn, 0)),
                na(ft, gt, sn)
            }
            function ZE(ft) {
                var gt = ft == null ? 0 : ft.length;
                return gt ? wl(ft, 0, -1) : []
            }
            var XE = oo(function(ft) {
                var gt = Mo(ft, S1);
                return gt.length && gt[0] === ft[0] ? Qu(gt) : []
            })
              , QE = oo(function(ft) {
                var gt = xl(ft)
                  , Ot = Mo(ft, S1);
                return gt === xl(Ot) ? gt = et : Ot.pop(),
                Ot.length && Ot[0] === ft[0] ? Qu(Ot, Mr(gt, 2)) : []
            })
              , JE = oo(function(ft) {
                var gt = xl(ft)
                  , Ot = Mo(ft, S1);
                return gt = typeof gt == "function" ? gt : et,
                gt && Ot.pop(),
                Ot.length && Ot[0] === ft[0] ? Qu(Ot, et, gt) : []
            });
            function eS(ft, gt) {
                return ft == null ? "" : vy.call(ft, gt)
            }
            function xl(ft) {
                var gt = ft == null ? 0 : ft.length;
                return gt ? ft[gt - 1] : et
            }
            function tS(ft, gt, Ot) {
                var Qt = ft == null ? 0 : ft.length;
                if (!Qt)
                    return -1;
                var sn = Qt;
                return Ot !== et && (sn = Qr(Ot),
                sn = sn < 0 ? Qo(Qt + sn, 0) : ls(sn, Qt - 1)),
                gt === gt ? i1(ft, gt, sn) : _p(ft, _h, sn, !0)
            }
            function nS(ft, gt) {
                return ft && ft.length ? pv(ft, Qr(gt)) : et
            }
            var rS = oo(r_);
            function r_(ft, gt) {
                return ft && ft.length && gt && gt.length ? g1(ft, gt) : ft
            }
            function iS(ft, gt, Ot) {
                return ft && ft.length && gt && gt.length ? g1(ft, gt, Mr(Ot, 2)) : ft
            }
            function oS(ft, gt, Ot) {
                return ft && ft.length && gt && gt.length ? g1(ft, gt, et, Ot) : ft
            }
            var sS = wu(function(ft, gt) {
                var Ot = ft == null ? 0 : ft.length
                  , Qt = gs(ft, gt);
                return mv(ft, Mo(gt, function(sn) {
                    return xu(sn, Ot) ? +sn : sn
                }).sort(Rv)),
                Qt
            });
            function aS(ft, gt) {
                var Ot = [];
                if (!(ft && ft.length))
                    return Ot;
                var Qt = -1
                  , sn = []
                  , gn = ft.length;
                for (gt = Mr(gt, 3); ++Qt < gn; ) {
                    var xn = ft[Qt];
                    gt(xn, Qt, ft) && (Ot.push(xn),
                    sn.push(Qt))
                }
                return mv(ft, sn),
                Ot
            }
            function P1(ft) {
                return ft == null ? ft : Ey.call(ft)
            }
            function lS(ft, gt, Ot) {
                var Qt = ft == null ? 0 : ft.length;
                return Qt ? (Ot && typeof Ot != "number" && Ps(ft, gt, Ot) ? (gt = 0,
                Ot = Qt) : (gt = gt == null ? 0 : Qr(gt),
                Ot = Ot === et ? Qt : Qr(Ot)),
                wl(ft, gt, Ot)) : []
            }
            function cS(ft, gt) {
                return Ty(ft, gt)
            }
            function uS(ft, gt, Ot) {
                return _1(ft, gt, Mr(Ot, 2))
            }
            function dS(ft, gt) {
                var Ot = ft == null ? 0 : ft.length;
                if (Ot) {
                    var Qt = Ty(ft, gt);
                    if (Qt < Ot && Ll(ft[Qt], gt))
                        return Qt
                }
                return -1
            }
            function fS(ft, gt) {
                return Ty(ft, gt, !0)
            }
            function pS(ft, gt, Ot) {
                return _1(ft, gt, Mr(Ot, 2), !0)
            }
            function hS(ft, gt) {
                var Ot = ft == null ? 0 : ft.length;
                if (Ot) {
                    var Qt = Ty(ft, gt, !0) - 1;
                    if (Ll(ft[Qt], gt))
                        return Qt
                }
                return -1
            }
            function gS(ft) {
                return ft && ft.length ? vv(ft) : []
            }
            function mS(ft, gt) {
                return ft && ft.length ? vv(ft, Mr(gt, 2)) : []
            }
            function yS(ft) {
                var gt = ft == null ? 0 : ft.length;
                return gt ? wl(ft, 1, gt) : []
            }
            function vS(ft, gt, Ot) {
                return ft && ft.length ? (gt = Ot || gt === et ? 1 : Qr(gt),
                wl(ft, 0, gt < 0 ? 0 : gt)) : []
            }
            function _S(ft, gt, Ot) {
                var Qt = ft == null ? 0 : ft.length;
                return Qt ? (gt = Ot || gt === et ? 1 : Qr(gt),
                gt = Qt - gt,
                wl(ft, gt < 0 ? 0 : gt, Qt)) : []
            }
            function bS(ft, gt) {
                return ft && ft.length ? Ry(ft, Mr(gt, 3), !1, !0) : []
            }
            function ES(ft, gt) {
                return ft && ft.length ? Ry(ft, Mr(gt, 3)) : []
            }
            var SS = oo(function(ft) {
                return Ju(Lr(ft, 1, ts, !0))
            })
              , wS = oo(function(ft) {
                var gt = xl(ft);
                return ts(gt) && (gt = et),
                Ju(Lr(ft, 1, ts, !0), Mr(gt, 2))
            })
              , xS = oo(function(ft) {
                var gt = xl(ft);
                return gt = typeof gt == "function" ? gt : et,
                Ju(Lr(ft, 1, ts, !0), et, gt)
            });
            function TS(ft) {
                return ft && ft.length ? Ju(ft) : []
            }
            function RS(ft, gt) {
                return ft && ft.length ? Ju(ft, Mr(gt, 2)) : []
            }
            function CS(ft, gt) {
                return gt = typeof gt == "function" ? gt : et,
                ft && ft.length ? Ju(ft, et, gt) : []
            }
            function D1(ft) {
                if (!(ft && ft.length))
                    return [];
                var gt = 0;
                return ft = Kl(ft, function(Ot) {
                    if (ts(Ot))
                        return gt = Qo(Ot.length, gt),
                        !0
                }),
                a0(gt, function(Ot) {
                    return Mo(ft, _g(Ot))
                })
            }
            function i_(ft, gt) {
                if (!(ft && ft.length))
                    return [];
                var Ot = D1(ft);
                return gt == null ? Ot : Mo(Ot, function(Qt) {
                    return Ls(gt, et, Qt)
                })
            }
            var $S = oo(function(ft, gt) {
                return ts(ft) ? Rs(ft, gt) : []
            })
              , IS = oo(function(ft) {
                return E1(Kl(ft, ts))
            })
              , kS = oo(function(ft) {
                var gt = xl(ft);
                return ts(gt) && (gt = et),
                E1(Kl(ft, ts), Mr(gt, 2))
            })
              , LS = oo(function(ft) {
                var gt = xl(ft);
                return gt = typeof gt == "function" ? gt : et,
                E1(Kl(ft, ts), et, gt)
            })
              , NS = oo(D1);
            function PS(ft, gt) {
                return Sv(ft || [], gt || [], Sr)
            }
            function DS(ft, gt) {
                return Sv(ft || [], gt || [], w0)
            }
            var BS = oo(function(ft) {
                var gt = ft.length
                  , Ot = gt > 1 ? ft[gt - 1] : et;
                return Ot = typeof Ot == "function" ? (ft.pop(),
                Ot) : et,
                i_(ft, Ot)
            });
            function o_(ft) {
                var gt = pn(ft);
                return gt.__chain__ = !0,
                gt
            }
            function US(ft, gt) {
                return gt(ft),
                ft
            }
            function My(ft, gt) {
                return gt(ft)
            }
            var jS = wu(function(ft) {
                var gt = ft.length
                  , Ot = gt ? ft[0] : 0
                  , Qt = this.__wrapped__
                  , sn = function(gn) {
                    return gs(gn, ft)
                };
                return gt > 1 || this.__actions__.length || !(Qt instanceof vt) || !xu(Ot) ? this.thru(sn) : (Qt = Qt.slice(Ot, +Ot + (gt ? 1 : 0)),
                Qt.__actions__.push({
                    func: My,
                    args: [sn],
                    thisArg: et
                }),
                new Tt(Qt,this.__chain__).thru(function(gn) {
                    return gt && !gn.length && gn.push(et),
                    gn
                }))
            });
            function FS() {
                return o_(this)
            }
            function zS() {
                return new Tt(this.value(),this.__chain__)
            }
            function WS() {
                this.__values__ === et && (this.__values__ = __(this.value()));
                var ft = this.__index__ >= this.__values__.length
                  , gt = ft ? et : this.__values__[this.__index__++];
                return {
                    done: ft,
                    value: gt
                }
            }
            function HS() {
                return this
            }
            function GS(ft) {
                for (var gt, Ot = this; Ot instanceof At; ) {
                    var Qt = Qv(Ot);
                    Qt.__index__ = 0,
                    Qt.__values__ = et,
                    gt ? sn.__wrapped__ = Qt : gt = Qt;
                    var sn = Qt;
                    Ot = Ot.__wrapped__
                }
                return sn.__wrapped__ = ft,
                gt
            }
            function KS() {
                var ft = this.__wrapped__;
                if (ft instanceof vt) {
                    var gt = ft;
                    return this.__actions__.length && (gt = new vt(this)),
                    gt = gt.reverse(),
                    gt.__actions__.push({
                        func: My,
                        args: [P1],
                        thisArg: et
                    }),
                    new Tt(gt,this.__chain__)
                }
                return this.thru(P1)
            }
            function VS() {
                return Ev(this.__wrapped__, this.__actions__)
            }
            var YS = Cy(function(ft, gt, Ot) {
                ho.call(ft, Ot) ? ++ft[Ot] : so(ft, Ot, 1)
            });
            function qS(ft, gt, Ot) {
                var Qt = Zr(ft) ? iy : Ap;
                return Ot && Ps(ft, gt, Ot) && (gt = et),
                Qt(ft, Mr(gt, 3))
            }
            function ZS(ft, gt) {
                var Ot = Zr(ft) ? Kl : Hr;
                return Ot(ft, Mr(gt, 3))
            }
            var XS = kv(Jv)
              , QS = kv(e_);
            function JS(ft, gt) {
                return Lr(Py(ft, gt), 1)
            }
            function ew(ft, gt) {
                return Lr(Py(ft, gt), jt)
            }
            function tw(ft, gt, Ot) {
                return Ot = Ot === et ? 1 : Qr(Ot),
                Lr(Py(ft, gt), Ot)
            }
            function s_(ft, gt) {
                var Ot = Zr(ft) ? Gs : ms;
                return Ot(ft, Mr(gt, 3))
            }
            function a_(ft, gt) {
                var Ot = Zr(ft) ? t1 : Eu;
                return Ot(ft, Mr(gt, 3))
            }
            var nw = Cy(function(ft, gt, Ot) {
                ho.call(ft, Ot) ? ft[Ot].push(gt) : so(ft, Ot, [gt])
            });
            function rw(ft, gt, Ot, Qt) {
                ft = qs(ft) ? ft : Cm(ft),
                Ot = Ot && !Qt ? Qr(Ot) : 0;
                var sn = ft.length;
                return Ot < 0 && (Ot = Qo(sn + Ot, 0)),
                Fy(ft) ? Ot <= sn && ft.indexOf(gt, Ot) > -1 : !!sn && na(ft, gt, Ot) > -1
            }
            var iw = oo(function(ft, gt, Ot) {
                var Qt = -1
                  , sn = typeof gt == "function"
                  , gn = qs(ft) ? Wn(ft.length) : [];
                return ms(ft, function(xn) {
                    gn[++Qt] = sn ? Ls(gt, xn, Ot) : _c(xn, gt, Ot)
                }),
                gn
            })
              , ow = Cy(function(ft, gt, Ot) {
                so(ft, Ot, gt)
            });
            function Py(ft, gt) {
                var Ot = Zr(ft) ? Mo : S0;
                return Ot(ft, Mr(gt, 3))
            }
            function sw(ft, gt, Ot, Qt) {
                return ft == null ? [] : (Zr(gt) || (gt = gt == null ? [] : [gt]),
                Ot = Qt ? et : Ot,
                Zr(Ot) || (Ot = Ot == null ? [] : [Ot]),
                hv(ft, gt, Ot))
            }
            var aw = Cy(function(ft, gt, Ot) {
                ft[Ot ? 0 : 1].push(gt)
            }, function() {
                return [[], []]
            });
            function lw(ft, gt, Ot) {
                var Qt = Zr(ft) ? vp : em
                  , sn = arguments.length < 3;
                return Qt(ft, Mr(gt, 4), Ot, sn, ms)
            }
            function cw(ft, gt, Ot) {
                var Qt = Zr(ft) ? oy : em
                  , sn = arguments.length < 3;
                return Qt(ft, Mr(gt, 4), Ot, sn, Eu)
            }
            function uw(ft, gt) {
                var Ot = Zr(ft) ? Kl : Hr;
                return Ot(ft, Uy(Mr(gt, 3)))
            }
            function dw(ft) {
                var gt = Zr(ft) ? vo : eE;
                return gt(ft)
            }
            function fw(ft, gt, Ot) {
                (Ot ? Ps(ft, gt, Ot) : gt === et) ? gt = 1 : gt = Qr(gt);
                var Qt = Zr(ft) ? ar : tE;
                return Qt(ft, gt)
            }
            function pw(ft) {
                var gt = Zr(ft) ? $r : rE;
                return gt(ft)
            }
            function hw(ft) {
                if (ft == null)
                    return 0;
                if (qs(ft))
                    return Fy(ft) ? yu(ft) : ft.length;
                var gt = $s(ft);
                return gt == Gn || gt == wr ? ft.size : Ms(ft).length
            }
            function gw(ft, gt, Ot) {
                var Qt = Zr(ft) ? Jp : iE;
                return Ot && Ps(ft, gt, Ot) && (gt = et),
                Qt(ft, Mr(gt, 3))
            }
            var mw = oo(function(ft, gt) {
                if (ft == null)
                    return [];
                var Ot = gt.length;
                return Ot > 1 && Ps(ft, gt[0], gt[1]) ? gt = [] : Ot > 2 && Ps(gt[0], gt[1], gt[2]) && (gt = [gt[0]]),
                hv(ft, Lr(gt, 1), [])
            })
              , Dy = yy || function() {
                return rs.Date.now()
            }
            ;
            function yw(ft, gt) {
                if (typeof gt != "function")
                    throw new Vs(it);
                return ft = Qr(ft),
                function() {
                    if (--ft < 1)
                        return gt.apply(this, arguments)
                }
            }
            function l_(ft, gt, Ot) {
                return gt = Ot ? et : gt,
                gt = ft && gt == null ? ft.length : gt,
                Su(ft, kt, et, et, et, et, gt)
            }
            function c_(ft, gt) {
                var Ot;
                if (typeof gt != "function")
                    throw new Vs(it);
                return ft = Qr(ft),
                function() {
                    return --ft > 0 && (Ot = gt.apply(this, arguments)),
                    ft <= 1 && (gt = et),
                    Ot
                }
            }
            var B1 = oo(function(ft, gt, Ot) {
                var Qt = Et;
                if (Ot.length) {
                    var sn = Al(Ot, Tm(B1));
                    Qt |= Nt
                }
                return Su(ft, Qt, gt, Ot, sn)
            })
              , u_ = oo(function(ft, gt, Ot) {
                var Qt = Et | _t;
                if (Ot.length) {
                    var sn = Al(Ot, Tm(u_));
                    Qt |= Nt
                }
                return Su(gt, Qt, ft, Ot, sn)
            });
            function d_(ft, gt, Ot) {
                gt = Ot ? et : gt;
                var Qt = Su(ft, St, et, et, et, et, et, gt);
                return Qt.placeholder = d_.placeholder,
                Qt
            }
            function f_(ft, gt, Ot) {
                gt = Ot ? et : gt;
                var Qt = Su(ft, Ct, et, et, et, et, et, gt);
                return Qt.placeholder = f_.placeholder,
                Qt
            }
            function p_(ft, gt, Ot) {
                var Qt, sn, gn, xn, $n, Ln, Xn = 0, Jn = !1, nr = !1, Er = !0;
                if (typeof ft != "function")
                    throw new Vs(it);
                gt = Tl(gt) || 0,
                Ko(Ot) && (Jn = !!Ot.leading,
                nr = "maxWait"in Ot,
                gn = nr ? Qo(Tl(Ot.maxWait) || 0, gt) : gn,
                Er = "trailing"in Ot ? !!Ot.trailing : Er);
                function kr(ns) {
                    var Nl = Qt
                      , Cu = sn;
                    return Qt = sn = et,
                    Xn = ns,
                    xn = ft.apply(Cu, Nl),
                    xn
                }
                function Pr(ns) {
                    return Xn = ns,
                    $n = R0(ao, gt),
                    Jn ? kr(ns) : xn
                }
                function no(ns) {
                    var Nl = ns - Ln
                      , Cu = ns - Xn
                      , k_ = gt - Nl;
                    return nr ? ls(k_, gn - Cu) : k_
                }
                function Dr(ns) {
                    var Nl = ns - Ln
                      , Cu = ns - Xn;
                    return Ln === et || Nl >= gt || Nl < 0 || nr && Cu >= gn
                }
                function ao() {
                    var ns = Dy();
                    if (Dr(ns))
                        return uo(ns);
                    $n = R0(ao, no(ns))
                }
                function uo(ns) {
                    return $n = et,
                    Er && Qt ? kr(ns) : (Qt = sn = et,
                    xn)
                }
                function ba() {
                    $n !== et && wv($n),
                    Xn = 0,
                    Qt = Ln = sn = $n = et
                }
                function Ds() {
                    return $n === et ? xn : uo(Dy())
                }
                function xa() {
                    var ns = Dy()
                      , Nl = Dr(ns);
                    if (Qt = arguments,
                    sn = this,
                    Ln = ns,
                    Nl) {
                        if ($n === et)
                            return Pr(Ln);
                        if (nr)
                            return wv($n),
                            $n = R0(ao, gt),
                            kr(Ln)
                    }
                    return $n === et && ($n = R0(ao, gt)),
                    xn
                }
                return xa.cancel = ba,
                xa.flush = Ds,
                xa
            }
            var vw = oo(function(ft, gt) {
                return Go(ft, 1, gt)
            })
              , _w = oo(function(ft, gt, Ot) {
                return Go(ft, Tl(gt) || 0, Ot)
            });
            function bw(ft) {
                return Su(ft, Jt)
            }
            function By(ft, gt) {
                if (typeof ft != "function" || gt != null && typeof gt != "function")
                    throw new Vs(it);
                var Ot = function() {
                    var Qt = arguments
                      , sn = gt ? gt.apply(this, Qt) : Qt[0]
                      , gn = Ot.cache;
                    if (gn.has(sn))
                        return gn.get(sn);
                    var xn = ft.apply(this, Qt);
                    return Ot.cache = gn.set(sn, xn) || gn,
                    xn
                };
                return Ot.cache = new (By.Cache || er),
                Ot
            }
            By.Cache = er;
            function Uy(ft) {
                if (typeof ft != "function")
                    throw new Vs(it);
                return function() {
                    var gt = arguments;
                    switch (gt.length) {
                    case 0:
                        return !ft.call(this);
                    case 1:
                        return !ft.call(this, gt[0]);
                    case 2:
                        return !ft.call(this, gt[0], gt[1]);
                    case 3:
                        return !ft.call(this, gt[0], gt[1], gt[2])
                    }
                    return !ft.apply(this, gt)
                }
            }
            function Ew(ft) {
                return c_(2, ft)
            }
            var Sw = oE(function(ft, gt) {
                gt = gt.length == 1 && Zr(gt[0]) ? Mo(gt[0], Ns(Mr())) : Mo(Lr(gt, 1), Ns(Mr()));
                var Ot = gt.length;
                return oo(function(Qt) {
                    for (var sn = -1, gn = ls(Qt.length, Ot); ++sn < gn; )
                        Qt[sn] = gt[sn].call(this, Qt[sn]);
                    return Ls(ft, this, Qt)
                })
            })
              , U1 = oo(function(ft, gt) {
                var Ot = Al(gt, Tm(U1));
                return Su(ft, Nt, et, gt, Ot)
            })
              , h_ = oo(function(ft, gt) {
                var Ot = Al(gt, Tm(h_));
                return Su(ft, Lt, et, gt, Ot)
            })
              , ww = wu(function(ft, gt) {
                return Su(ft, Ut, et, et, et, gt)
            });
            function xw(ft, gt) {
                if (typeof ft != "function")
                    throw new Vs(it);
                return gt = gt === et ? gt : Qr(gt),
                oo(ft, gt)
            }
            function Tw(ft, gt) {
                if (typeof ft != "function")
                    throw new Vs(it);
                return gt = gt == null ? 0 : Qo(Qr(gt), 0),
                oo(function(Ot) {
                    var Qt = Ot[gt]
                      , sn = _f(Ot, 0, gt);
                    return Qt && Vl(sn, Qt),
                    Ls(ft, this, sn)
                })
            }
            function Rw(ft, gt, Ot) {
                var Qt = !0
                  , sn = !0;
                if (typeof ft != "function")
                    throw new Vs(it);
                return Ko(Ot) && (Qt = "leading"in Ot ? !!Ot.leading : Qt,
                sn = "trailing"in Ot ? !!Ot.trailing : sn),
                p_(ft, gt, {
                    leading: Qt,
                    maxWait: gt,
                    trailing: sn
                })
            }
            function Cw(ft) {
                return l_(ft, 1)
            }
            function $w(ft, gt) {
                return U1(w1(gt), ft)
            }
            function Aw() {
                if (!arguments.length)
                    return [];
                var ft = arguments[0];
                return Zr(ft) ? ft : [ft]
            }
            function Iw(ft) {
                return Bo(ft, ht)
            }
            function Ow(ft, gt) {
                return gt = typeof gt == "function" ? gt : et,
                Bo(ft, ht, gt)
            }
            function kw(ft) {
                return Bo(ft, dt | ht)
            }
            function Lw(ft, gt) {
                return gt = typeof gt == "function" ? gt : et,
                Bo(ft, dt | ht, gt)
            }
            function Nw(ft, gt) {
                return gt == null || Ts(ft, gt, _s(gt))
            }
            function Ll(ft, gt) {
                return ft === gt || ft !== ft && gt !== gt
            }
            var Mw = Oy(us)
              , Pw = Oy(function(ft, gt) {
                return ft >= gt
            })
              , Lp = Ip(function() {
                return arguments
            }()) ? Ip : function(ft) {
                return Yo(ft) && ho.call(ft, "callee") && !my.call(ft, "callee")
            }
              , Zr = Wn.isArray
              , Dw = e0 ? Ns(e0) : vm;
            function qs(ft) {
                return ft != null && jy(ft.length) && !Tu(ft)
            }
            function ts(ft) {
                return Yo(ft) && qs(ft)
            }
            function Bw(ft) {
                return ft === !0 || ft === !1 || Yo(ft) && jo(ft) == Dn
            }
            var ep = u1 || Z1
              , Uw = J0 ? Ns(J0) : _m;
            function jw(ft) {
                return Yo(ft) && ft.nodeType === 1 && !C0(ft)
            }
            function Fw(ft) {
                if (ft == null)
                    return !0;
                if (qs(ft) && (Zr(ft) || typeof ft == "string" || typeof ft.splice == "function" || ep(ft) || Rm(ft) || Lp(ft)))
                    return !ft.length;
                var gt = $s(ft);
                if (gt == Gn || gt == wr)
                    return !ft.size;
                if (T0(ft))
                    return !Ms(ft).length;
                for (var Ot in ft)
                    if (ho.call(ft, Ot))
                        return !1;
                return !0
            }
            function zw(ft, gt) {
                return eu(ft, gt)
            }
            function Ww(ft, gt, Ot) {
                Ot = typeof Ot == "function" ? Ot : et;
                var Qt = Ot ? Ot(ft, gt) : et;
                return Qt === et ? eu(ft, gt, et, Ot) : !!Qt
            }
            function j1(ft) {
                if (!Yo(ft))
                    return !1;
                var gt = jo(ft);
                return gt == Un || gt == Bn || typeof ft.message == "string" && typeof ft.name == "string" && !C0(ft)
            }
            function Hw(ft) {
                return typeof ft == "number" && m0(ft)
            }
            function Tu(ft) {
                if (!Ko(ft))
                    return !1;
                var gt = jo(ft);
                return gt == Hn || gt == cr || gt == kn || gt == Ur
            }
            function g_(ft) {
                return typeof ft == "number" && ft == Qr(ft)
            }
            function jy(ft) {
                return typeof ft == "number" && ft > -1 && ft % 1 == 0 && ft <= Ft
            }
            function Ko(ft) {
                var gt = typeof ft;
                return ft != null && (gt == "object" || gt == "function")
            }
            function Yo(ft) {
                return ft != null && typeof ft == "object"
            }
            var m_ = ey ? Ns(ey) : Em;
            function Gw(ft, gt) {
                return ft === gt || E0(ft, gt, I1(gt))
            }
            function Kw(ft, gt, Ot) {
                return Ot = typeof Ot == "function" ? Ot : et,
                E0(ft, gt, I1(gt), Ot)
            }
            function Vw(ft) {
                return y_(ft) && ft != +ft
            }
            function Yw(ft) {
                if ($E(ft))
                    throw new zr(rt);
                return ss(ft)
            }
            function qw(ft) {
                return ft === null
            }
            function Zw(ft) {
                return ft == null
            }
            function y_(ft) {
                return typeof ft == "number" || Yo(ft) && jo(ft) == Mn
            }
            function C0(ft) {
                if (!Yo(ft) || jo(ft) != Zn)
                    return !1;
                var gt = Rp(ft);
                if (gt === null)
                    return !0;
                var Ot = ho.call(gt, "constructor") && gt.constructor;
                return typeof Ot == "function" && Ot instanceof Ot && Gu.call(Ot) == py
            }
            var F1 = ty ? Ns(ty) : ds;
            function Xw(ft) {
                return g_(ft) && ft >= -9007199254740991 && ft <= Ft
            }
            var v_ = t0 ? Ns(t0) : fs;
            function Fy(ft) {
                return typeof ft == "string" || !Zr(ft) && Yo(ft) && jo(ft) == Rn
            }
            function _a(ft) {
                return typeof ft == "symbol" || Yo(ft) && jo(ft) == Vn
            }
            var Rm = ny ? Ns(ny) : ps;
            function Qw(ft) {
                return ft === et
            }
            function Jw(ft) {
                return Yo(ft) && $s(ft) == dr
            }
            function ex(ft) {
                return Yo(ft) && jo(ft) == or
            }
            var tx = Oy(Sm)
              , nx = Oy(function(ft, gt) {
                return ft <= gt
            });
            function __(ft) {
                if (!ft)
                    return [];
                if (qs(ft))
                    return Fy(ft) ? Ks(ft) : Ys(ft);
                if (Ku && ft[Ku])
                    return ly(ft[Ku]());
                var gt = $s(ft)
                  , Ot = gt == Gn ? am : gt == wr ? Sp : Cm;
                return Ot(ft)
            }
            function Ru(ft) {
                if (!ft)
                    return ft === 0 ? ft : 0;
                if (ft = Tl(ft),
                ft === jt || ft === -1 / 0) {
                    var gt = ft < 0 ? -1 : 1;
                    return gt * Ht
                }
                return ft === ft ? ft : 0
            }
            function Qr(ft) {
                var gt = Ru(ft)
                  , Ot = gt % 1;
                return gt === gt ? Ot ? gt - Ot : gt : 0
            }
            function b_(ft) {
                return ft ? Do(Qr(ft), 0, Wt) : 0
            }
            function Tl(ft) {
                if (typeof ft == "number")
                    return ft;
                if (_a(ft))
                    return qt;
                if (Ko(ft)) {
                    var gt = typeof ft.valueOf == "function" ? ft.valueOf() : ft;
                    ft = Ko(gt) ? gt + "" : gt
                }
                if (typeof ft != "string")
                    return ft === 0 ? ft : +ft;
                ft = nm(ft);
                var Ot = ws.test(ft);
                return Ot || Ws.test(ft) ? q0(ft.slice(2), Ot ? 2 : 8) : Io.test(ft) ? qt : +ft
            }
            function E_(ft) {
                return tu(ft, Zs(ft))
            }
            function rx(ft) {
                return ft ? Do(Qr(ft), -9007199254740991, Ft) : ft === 0 ? ft : 0
            }
            function So(ft) {
                return ft == null ? "" : ga(ft)
            }
            var ix = wm(function(ft, gt) {
                if (T0(gt) || qs(gt)) {
                    tu(gt, _s(gt), ft);
                    return
                }
                for (var Ot in gt)
                    ho.call(gt, Ot) && Sr(ft, Ot, gt[Ot])
            })
              , S_ = wm(function(ft, gt) {
                tu(gt, Zs(gt), ft)
            })
              , zy = wm(function(ft, gt, Ot, Qt) {
                tu(gt, Zs(gt), ft, Qt)
            })
              , ox = wm(function(ft, gt, Ot, Qt) {
                tu(gt, _s(gt), ft, Qt)
            })
              , sx = wu(gs);
            function ax(ft, gt) {
                var Ot = Xu(ft);
                return gt == null ? Ot : Wo(Ot, gt)
            }
            var lx = oo(function(ft, gt) {
                ft = Co(ft);
                var Ot = -1
                  , Qt = gt.length
                  , sn = Qt > 2 ? gt[2] : et;
                for (sn && Ps(gt[0], gt[1], sn) && (Qt = 1); ++Ot < Qt; )
                    for (var gn = gt[Ot], xn = Zs(gn), $n = -1, Ln = xn.length; ++$n < Ln; ) {
                        var Xn = xn[$n]
                          , Jn = ft[Xn];
                        (Jn === et || Ll(Jn, Il[Xn]) && !ho.call(ft, Xn)) && (ft[Xn] = gn[Xn])
                    }
                return ft
            })
              , cx = oo(function(ft) {
                return ft.push(et, Uv),
                Ls(w_, et, ft)
            });
            function ux(ft, gt) {
                return r0(ft, Mr(gt, 3), Ho)
            }
            function dx(ft, gt) {
                return r0(ft, Mr(gt, 3), ys)
            }
            function fx(ft, gt) {
                return ft == null ? ft : co(ft, Mr(gt, 3), Zs)
            }
            function hx(ft, gt) {
                return ft == null ? ft : $o(ft, Mr(gt, 3), Zs)
            }
            function gx(ft, gt) {
                return ft && Ho(ft, Mr(gt, 3))
            }
            function mx(ft, gt) {
                return ft && ys(ft, Mr(gt, 3))
            }
            function yx(ft) {
                return ft == null ? [] : cs(ft, _s(ft))
            }
            function vx(ft) {
                return ft == null ? [] : cs(ft, Zs(ft))
            }
            function z1(ft, gt, Ot) {
                var Qt = ft == null ? et : Ao(ft, gt);
                return Qt === et ? Ot : Qt
            }
            function _x(ft, gt) {
                return ft != null && zv(ft, gt, b0)
            }
            function W1(ft, gt) {
                return ft != null && zv(ft, gt, wy)
            }
            var bx = Nv(function(ft, gt, Ot) {
                gt != null && typeof gt.toString != "function" && (gt = xp.call(gt)),
                ft[gt] = Ot
            }, G1(Xs))
              , Ex = Nv(function(ft, gt, Ot) {
                gt != null && typeof gt.toString != "function" && (gt = xp.call(gt)),
                ho.call(ft, gt) ? ft[gt].push(Ot) : ft[gt] = [Ot]
            }, Mr)
              , Sx = oo(_c);
            function _s(ft) {
                return qs(ft) ? _r(ft) : Ms(ft)
            }
            function Zs(ft) {
                return qs(ft) ? _r(ft, !0) : Lo(ft)
            }
            function wx(ft, gt) {
                var Ot = {};
                return gt = Mr(gt, 3),
                Ho(ft, function(Qt, sn, gn) {
                    so(Ot, gt(Qt, sn, gn), Qt)
                }),
                Ot
            }
            function xx(ft, gt) {
                var Ot = {};
                return gt = Mr(gt, 3),
                Ho(ft, function(Qt, sn, gn) {
                    so(Ot, sn, gt(Qt, sn, gn))
                }),
                Ot
            }
            var Tx = wm(function(ft, gt, Ot) {
                xy(ft, gt, Ot)
            })
              , w_ = wm(function(ft, gt, Ot, Qt) {
                xy(ft, gt, Ot, Qt)
            })
              , Rx = wu(function(ft, gt) {
                var Ot = {};
                if (ft == null)
                    return Ot;
                var Qt = !1;
                gt = Mo(gt, function(gn) {
                    return gn = _d(gn, ft),
                    Qt || (Qt = gn.length > 1),
                    gn
                }),
                tu(ft, $1(ft), Ot),
                Qt && (Ot = Bo(Ot, dt | pt | ht, mE));
                for (var sn = gt.length; sn--; )
                    b1(Ot, gt[sn]);
                return Ot
            });
            function Cx(ft, gt) {
                return x_(ft, Uy(Mr(gt)))
            }
            var $x = wu(function(ft, gt) {
                return ft == null ? {} : Q_(ft, gt)
            });
            function x_(ft, gt) {
                if (ft == null)
                    return {};
                var Ot = Mo($1(ft), function(Qt) {
                    return [Qt]
                });
                return gt = Mr(gt),
                gv(ft, Ot, function(Qt, sn) {
                    return gt(Qt, sn[0])
                })
            }
            function Ax(ft, gt, Ot) {
                gt = _d(gt, ft);
                var Qt = -1
                  , sn = gt.length;
                for (sn || (sn = 1,
                ft = et); ++Qt < sn; ) {
                    var gn = ft == null ? et : ft[nu(gt[Qt])];
                    gn === et && (Qt = sn,
                    gn = Ot),
                    ft = Tu(gn) ? gn.call(ft) : gn
                }
                return ft
            }
            function Ix(ft, gt, Ot) {
                return ft == null ? ft : w0(ft, gt, Ot)
            }
            function Ox(ft, gt, Ot, Qt) {
                return Qt = typeof Qt == "function" ? Qt : et,
                ft == null ? ft : w0(ft, gt, Ot, Qt)
            }
            var T_ = Dv(_s)
              , R_ = Dv(Zs);
            function kx(ft, gt, Ot) {
                var Qt = Zr(ft)
                  , sn = Qt || ep(ft) || Rm(ft);
                if (gt = Mr(gt, 4),
                Ot == null) {
                    var gn = ft && ft.constructor;
                    sn ? Ot = Qt ? new gn : [] : Ko(ft) ? Ot = Tu(gn) ? Xu(Rp(ft)) : {} : Ot = {}
                }
                return (sn ? Gs : Ho)(ft, function(xn, $n, Ln) {
                    return gt(Ot, xn, $n, Ln)
                }),
                Ot
            }
            function Lx(ft, gt) {
                return ft == null ? !0 : b1(ft, gt)
            }
            function Nx(ft, gt, Ot) {
                return ft == null ? ft : bv(ft, gt, w1(Ot))
            }
            function Mx(ft, gt, Ot, Qt) {
                return Qt = typeof Qt == "function" ? Qt : et,
                ft == null ? ft : bv(ft, gt, w1(Ot), Qt)
            }
            function Cm(ft) {
                return ft == null ? [] : rm(ft, _s(ft))
            }
            function Px(ft) {
                return ft == null ? [] : rm(ft, Zs(ft))
            }
            function Dx(ft, gt, Ot) {
                return Ot === et && (Ot = gt,
                gt = et),
                Ot !== et && (Ot = Tl(Ot),
                Ot = Ot === Ot ? Ot : 0),
                gt !== et && (gt = Tl(gt),
                gt = gt === gt ? gt : 0),
                Do(Tl(ft), gt, Ot)
            }
            function Bx(ft, gt, Ot) {
                return gt = Ru(gt),
                Ot === et ? (Ot = gt,
                gt = 0) : Ot = Ru(Ot),
                ft = Tl(ft),
                mm(ft, gt, Ot)
            }
            function Ux(ft, gt, Ot) {
                if (Ot && typeof Ot != "boolean" && Ps(ft, gt, Ot) && (gt = Ot = et),
                Ot === et && (typeof gt == "boolean" ? (Ot = gt,
                gt = et) : typeof ft == "boolean" && (Ot = ft,
                ft = et)),
                ft === et && gt === et ? (ft = 0,
                gt = 1) : (ft = Ru(ft),
                gt === et ? (gt = ft,
                ft = 0) : gt = Ru(gt)),
                ft > gt) {
                    var Qt = ft;
                    ft = gt,
                    gt = Qt
                }
                if (Ot || ft % 1 || gt % 1) {
                    var sn = y0();
                    return ls(ft + sn * (gt - ft + e1("1e-" + ((sn + "").length - 1))), gt)
                }
                return m1(ft, gt)
            }
            var jx = xm(function(ft, gt, Ot) {
                return gt = gt.toLowerCase(),
                ft + (Ot ? C_(gt) : gt)
            });
            function C_(ft) {
                return H1(So(ft).toLowerCase())
            }
            function $_(ft) {
                return ft = So(ft),
                ft && ft.replace(xs, om).replace(Zp, "")
            }
            function Fx(ft, gt, Ot) {
                ft = So(ft),
                gt = ga(gt);
                var Qt = ft.length;
                Ot = Ot === et ? Qt : Do(Qr(Ot), 0, Qt);
                var sn = Ot;
                return Ot -= gt.length,
                Ot >= 0 && ft.slice(Ot, sn) == gt
            }
            function zx(ft) {
                return ft = So(ft),
                ft && hr.test(ft) ? ft.replace(zn, sm) : ft
            }
            function Wx(ft) {
                return ft = So(ft),
                ft && Zo.test(ft) ? ft.replace(Jr, "\\$&") : ft
            }
            var Hx = xm(function(ft, gt, Ot) {
                return ft + (Ot ? "-" : "") + gt.toLowerCase()
            })
              , Gx = xm(function(ft, gt, Ot) {
                return ft + (Ot ? " " : "") + gt.toLowerCase()
            })
              , Kx = Ov("toLowerCase");
            function Vx(ft, gt, Ot) {
                ft = So(ft),
                gt = Qr(gt);
                var Qt = gt ? yu(ft) : 0;
                if (!gt || Qt >= gt)
                    return ft;
                var sn = (gt - Qt) / 2;
                return Iy(pm(sn), Ot) + ft + Iy(fm(sn), Ot)
            }
            function Yx(ft, gt, Ot) {
                ft = So(ft),
                gt = Qr(gt);
                var Qt = gt ? yu(ft) : 0;
                return gt && Qt < gt ? ft + Iy(gt - Qt, Ot) : ft
            }
            function qx(ft, gt, Ot) {
                ft = So(ft),
                gt = Qr(gt);
                var Qt = gt ? yu(ft) : 0;
                return gt && Qt < gt ? Iy(gt - Qt, Ot) + ft : ft
            }
            function Zx(ft, gt, Ot) {
                return Ot || gt == null ? gt = 0 : gt && (gt = +gt),
                by(So(ft).replace(ro, ""), gt || 0)
            }
            function Xx(ft, gt, Ot) {
                return (Ot ? Ps(ft, gt, Ot) : gt === et) ? gt = 1 : gt = Qr(gt),
                y1(So(ft), gt)
            }
            function Qx() {
                var ft = arguments
                  , gt = So(ft[0]);
                return ft.length < 3 ? gt : gt.replace(ft[1], ft[2])
            }
            var Jx = xm(function(ft, gt, Ot) {
                return ft + (Ot ? "_" : "") + gt.toLowerCase()
            });
            function eT(ft, gt, Ot) {
                return Ot && typeof Ot != "number" && Ps(ft, gt, Ot) && (gt = Ot = et),
                Ot = Ot === et ? Wt : Ot >>> 0,
                Ot ? (ft = So(ft),
                ft && (typeof gt == "string" || gt != null && !F1(gt)) && (gt = ga(gt),
                !gt && Zl(ft)) ? _f(Ks(ft), 0, Ot) : ft.split(gt, Ot)) : []
            }
            var tT = xm(function(ft, gt, Ot) {
                return ft + (Ot ? " " : "") + H1(gt)
            });
            function nT(ft, gt, Ot) {
                return ft = So(ft),
                Ot = Ot == null ? 0 : Do(Qr(Ot), 0, ft.length),
                gt = ga(gt),
                ft.slice(Ot, Ot + gt.length) == gt
            }
            function rT(ft, gt, Ot) {
                var Qt = pn.templateSettings;
                Ot && Ps(ft, gt, Ot) && (gt = et),
                ft = So(ft),
                gt = zy({}, gt, Qt, Bv);
                var sn = zy({}, gt.imports, Qt.imports, Bv), gn = _s(sn), xn = rm(sn, gn), $n, Ln, Xn = 0, Jn = gt.interpolate || Ss, nr = "__p += '", Er = lm((gt.escape || Ss).source + "|" + Jn.source + "|" + (Jn === Xr ? lu : Ss).source + "|" + (gt.evaluate || Ss).source + "|$", "g"), kr = "//# sourceURL=" + (ho.call(gt, "sourceURL") ? (gt.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Qy + "]") + `
`;
                ft.replace(Er, function(Dr, ao, uo, ba, Ds, xa) {
                    return uo || (uo = ba),
                    nr += ft.slice(Xn, xa).replace(Nu, Ep),
                    ao && ($n = !0,
                    nr += `' +
__e(` + ao + `) +
'`),
                    Ds && (Ln = !0,
                    nr += `';
` + Ds + `;
__p += '`),
                    uo && (nr += `' +
((__t = (` + uo + `)) == null ? '' : __t) +
'`),
                    Xn = xa + Dr.length,
                    Dr
                }),
                nr += `';
`;
                var Pr = ho.call(gt, "variable") && gt.variable;
                if (!Pr)
                    nr = `with (obj) {
` + nr + `
}
`;
                else if (mo.test(Pr))
                    throw new zr(ot);
                nr = (Ln ? nr.replace(lr, "") : nr).replace(wn, "$1").replace(Pn, "$1;"),
                nr = "function(" + (Pr || "obj") + `) {
` + (Pr ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + ($n ? ", __e = _.escape" : "") + (Ln ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + nr + `return __p
}`;
                var no = I_(function() {
                    return po(gn, kr + "return " + nr).apply(et, xn)
                });
                if (no.source = nr,
                j1(no))
                    throw no;
                return no
            }
            function iT(ft) {
                return So(ft).toLowerCase()
            }
            function oT(ft) {
                return So(ft).toUpperCase()
            }
            function sT(ft, gt, Ot) {
                if (ft = So(ft),
                ft && (Ot || gt === et))
                    return nm(ft);
                if (!ft || !(gt = ga(gt)))
                    return ft;
                var Qt = Ks(ft)
                  , sn = Ks(gt)
                  , gn = ay(Qt, sn)
                  , xn = im(Qt, sn) + 1;
                return _f(Qt, gn, xn).join("")
            }
            function aT(ft, gt, Ot) {
                if (ft = So(ft),
                ft && (Ot || gt === et))
                    return ft.slice(0, u0(ft) + 1);
                if (!ft || !(gt = ga(gt)))
                    return ft;
                var Qt = Ks(ft)
                  , sn = im(Qt, Ks(gt)) + 1;
                return _f(Qt, 0, sn).join("")
            }
            function lT(ft, gt, Ot) {
                if (ft = So(ft),
                ft && (Ot || gt === et))
                    return ft.replace(ro, "");
                if (!ft || !(gt = ga(gt)))
                    return ft;
                var Qt = Ks(ft)
                  , sn = ay(Qt, Ks(gt));
                return _f(Qt, sn).join("")
            }
            function cT(ft, gt) {
                var Ot = Pt
                  , Qt = Xt;
                if (Ko(gt)) {
                    var sn = "separator"in gt ? gt.separator : sn;
                    Ot = "length"in gt ? Qr(gt.length) : Ot,
                    Qt = "omission"in gt ? ga(gt.omission) : Qt
                }
                ft = So(ft);
                var gn = ft.length;
                if (Zl(ft)) {
                    var xn = Ks(ft);
                    gn = xn.length
                }
                if (Ot >= gn)
                    return ft;
                var $n = Ot - yu(Qt);
                if ($n < 1)
                    return Qt;
                var Ln = xn ? _f(xn, 0, $n).join("") : ft.slice(0, $n);
                if (sn === et)
                    return Ln + Qt;
                if (xn && ($n += Ln.length - $n),
                F1(sn)) {
                    if (ft.slice($n).search(sn)) {
                        var Xn, Jn = Ln;
                        for (sn.global || (sn = lm(sn.source, So(yo.exec(sn)) + "g")),
                        sn.lastIndex = 0; Xn = sn.exec(Jn); )
                            var nr = Xn.index;
                        Ln = Ln.slice(0, nr === et ? $n : nr)
                    }
                } else if (ft.indexOf(ga(sn), $n) != $n) {
                    var Er = Ln.lastIndexOf(sn);
                    Er > -1 && (Ln = Ln.slice(0, Er))
                }
                return Ln + Qt
            }
            function uT(ft) {
                return ft = So(ft),
                ft && ur.test(ft) ? ft.replace(Cn, uy) : ft
            }
            var dT = xm(function(ft, gt, Ot) {
                return ft + (Ot ? " " : "") + gt.toUpperCase()
            })
              , H1 = Ov("toUpperCase");
            function A_(ft, gt, Ot) {
                return ft = So(ft),
                gt = Ot ? et : gt,
                gt === et ? mu(ft) ? s1(ft) : n0(ft) : ft.match(gt) || []
            }
            var I_ = oo(function(ft, gt) {
                try {
                    return Ls(ft, et, gt)
                } catch (Ot) {
                    return j1(Ot) ? Ot : new zr(Ot)
                }
            })
              , fT = wu(function(ft, gt) {
                return Gs(gt, function(Ot) {
                    Ot = nu(Ot),
                    so(ft, Ot, B1(ft[Ot], ft))
                }),
                ft
            });
            function pT(ft) {
                var gt = ft == null ? 0 : ft.length
                  , Ot = Mr();
                return ft = gt ? Mo(ft, function(Qt) {
                    if (typeof Qt[1] != "function")
                        throw new Vs(it);
                    return [Ot(Qt[0]), Qt[1]]
                }) : [],
                oo(function(Qt) {
                    for (var sn = -1; ++sn < gt; ) {
                        var gn = ft[sn];
                        if (Ls(gn[0], this, Qt))
                            return Ls(gn[1], this, Qt)
                    }
                })
            }
            function hT(ft) {
                return Uo(Bo(ft, dt))
            }
            function G1(ft) {
                return function() {
                    return ft
                }
            }
            function gT(ft, gt) {
                return ft == null || ft !== ft ? gt : ft
            }
            var mT = Lv()
              , yT = Lv(!0);
            function Xs(ft) {
                return ft
            }
            function K1(ft) {
                return Cs(typeof ft == "function" ? ft : Bo(ft, dt))
            }
            function vT(ft) {
                return dv(Bo(ft, dt))
            }
            function _T(ft, gt) {
                return fv(ft, Bo(gt, dt))
            }
            var bT = oo(function(ft, gt) {
                return function(Ot) {
                    return _c(Ot, ft, gt)
                }
            })
              , ET = oo(function(ft, gt) {
                return function(Ot) {
                    return _c(ft, Ot, gt)
                }
            });
            function V1(ft, gt, Ot) {
                var Qt = _s(gt)
                  , sn = cs(gt, Qt);
                Ot == null && !(Ko(gt) && (sn.length || !Qt.length)) && (Ot = gt,
                gt = ft,
                ft = this,
                sn = cs(gt, _s(gt)));
                var gn = !(Ko(Ot) && "chain"in Ot) || !!Ot.chain
                  , xn = Tu(ft);
                return Gs(sn, function($n) {
                    var Ln = gt[$n];
                    ft[$n] = Ln,
                    xn && (ft.prototype[$n] = function() {
                        var Xn = this.__chain__;
                        if (gn || Xn) {
                            var Jn = ft(this.__wrapped__)
                              , nr = Jn.__actions__ = Ys(this.__actions__);
                            return nr.push({
                                func: Ln,
                                args: arguments,
                                thisArg: ft
                            }),
                            Jn.__chain__ = Xn,
                            Jn
                        }
                        return Ln.apply(ft, Vl([this.value()], arguments))
                    }
                    )
                }),
                ft
            }
            function ST() {
                return rs._ === this && (rs._ = hy),
                this
            }
            function Y1() {}
            function wT(ft) {
                return ft = Qr(ft),
                oo(function(gt) {
                    return pv(gt, ft)
                })
            }
            var xT = T1(Mo)
              , TT = T1(iy)
              , RT = T1(Jp);
            function O_(ft) {
                return k1(ft) ? _g(nu(ft)) : J_(ft)
            }
            function CT(ft) {
                return function(gt) {
                    return ft == null ? et : Ao(ft, gt)
                }
            }
            var $T = Mv()
              , AT = Mv(!0);
            function q1() {
                return []
            }
            function Z1() {
                return !1
            }
            function IT() {
                return {}
            }
            function OT() {
                return ""
            }
            function kT() {
                return !0
            }
            function LT(ft, gt) {
                if (ft = Qr(ft),
                ft < 1 || ft > Ft)
                    return [];
                var Ot = Wt
                  , Qt = ls(ft, Wt);
                gt = Mr(gt),
                ft -= Wt;
                for (var sn = a0(Qt, gt); ++Ot < ft; )
                    gt(Ot);
                return sn
            }
            function NT(ft) {
                return Zr(ft) ? Mo(ft, nu) : _a(ft) ? [ft] : Ys(Xv(So(ft)))
            }
            function MT(ft) {
                var gt = ++bu;
                return So(ft) + gt
            }
            var PT = Ay(function(ft, gt) {
                return ft + gt
            }, 0)
              , DT = R1("ceil")
              , BT = Ay(function(ft, gt) {
                return ft / gt
            }, 1)
              , UT = R1("floor");
            function jT(ft) {
                return ft && ft.length ? yr(ft, Xs, us) : et
            }
            function FT(ft, gt) {
                return ft && ft.length ? yr(ft, Mr(gt, 2), us) : et
            }
            function zT(ft) {
                return Hu(ft, Xs)
            }
            function WT(ft, gt) {
                return Hu(ft, Mr(gt, 2))
            }
            function HT(ft) {
                return ft && ft.length ? yr(ft, Xs, Sm) : et
            }
            function GT(ft, gt) {
                return ft && ft.length ? yr(ft, Mr(gt, 2), Sm) : et
            }
            var KT = Ay(function(ft, gt) {
                return ft * gt
            }, 1)
              , VT = R1("round")
              , YT = Ay(function(ft, gt) {
                return ft - gt
            }, 0);
            function qT(ft) {
                return ft && ft.length ? tm(ft, Xs) : 0
            }
            function ZT(ft, gt) {
                return ft && ft.length ? tm(ft, Mr(gt, 2)) : 0
            }
            return pn.after = yw,
            pn.ary = l_,
            pn.assign = ix,
            pn.assignIn = S_,
            pn.assignInWith = zy,
            pn.assignWith = ox,
            pn.at = sx,
            pn.before = c_,
            pn.bind = B1,
            pn.bindAll = fT,
            pn.bindKey = u_,
            pn.castArray = Aw,
            pn.chain = o_,
            pn.chunk = ME,
            pn.compact = PE,
            pn.concat = DE,
            pn.cond = pT,
            pn.conforms = hT,
            pn.constant = G1,
            pn.countBy = YS,
            pn.create = ax,
            pn.curry = d_,
            pn.curryRight = f_,
            pn.debounce = p_,
            pn.defaults = lx,
            pn.defaultsDeep = cx,
            pn.defer = vw,
            pn.delay = _w,
            pn.difference = BE,
            pn.differenceBy = UE,
            pn.differenceWith = jE,
            pn.drop = FE,
            pn.dropRight = zE,
            pn.dropRightWhile = WE,
            pn.dropWhile = HE,
            pn.fill = GE,
            pn.filter = ZS,
            pn.flatMap = JS,
            pn.flatMapDeep = ew,
            pn.flatMapDepth = tw,
            pn.flatten = t_,
            pn.flattenDeep = KE,
            pn.flattenDepth = VE,
            pn.flip = bw,
            pn.flow = mT,
            pn.flowRight = yT,
            pn.fromPairs = YE,
            pn.functions = yx,
            pn.functionsIn = vx,
            pn.groupBy = nw,
            pn.initial = ZE,
            pn.intersection = XE,
            pn.intersectionBy = QE,
            pn.intersectionWith = JE,
            pn.invert = bx,
            pn.invertBy = Ex,
            pn.invokeMap = iw,
            pn.iteratee = K1,
            pn.keyBy = ow,
            pn.keys = _s,
            pn.keysIn = Zs,
            pn.map = Py,
            pn.mapKeys = wx,
            pn.mapValues = xx,
            pn.matches = vT,
            pn.matchesProperty = _T,
            pn.memoize = By,
            pn.merge = Tx,
            pn.mergeWith = w_,
            pn.method = bT,
            pn.methodOf = ET,
            pn.mixin = V1,
            pn.negate = Uy,
            pn.nthArg = wT,
            pn.omit = Rx,
            pn.omitBy = Cx,
            pn.once = Ew,
            pn.orderBy = sw,
            pn.over = xT,
            pn.overArgs = Sw,
            pn.overEvery = TT,
            pn.overSome = RT,
            pn.partial = U1,
            pn.partialRight = h_,
            pn.partition = aw,
            pn.pick = $x,
            pn.pickBy = x_,
            pn.property = O_,
            pn.propertyOf = CT,
            pn.pull = rS,
            pn.pullAll = r_,
            pn.pullAllBy = iS,
            pn.pullAllWith = oS,
            pn.pullAt = sS,
            pn.range = $T,
            pn.rangeRight = AT,
            pn.rearg = ww,
            pn.reject = uw,
            pn.remove = aS,
            pn.rest = xw,
            pn.reverse = P1,
            pn.sampleSize = fw,
            pn.set = Ix,
            pn.setWith = Ox,
            pn.shuffle = pw,
            pn.slice = lS,
            pn.sortBy = mw,
            pn.sortedUniq = gS,
            pn.sortedUniqBy = mS,
            pn.split = eT,
            pn.spread = Tw,
            pn.tail = yS,
            pn.take = vS,
            pn.takeRight = _S,
            pn.takeRightWhile = bS,
            pn.takeWhile = ES,
            pn.tap = US,
            pn.throttle = Rw,
            pn.thru = My,
            pn.toArray = __,
            pn.toPairs = T_,
            pn.toPairsIn = R_,
            pn.toPath = NT,
            pn.toPlainObject = E_,
            pn.transform = kx,
            pn.unary = Cw,
            pn.union = SS,
            pn.unionBy = wS,
            pn.unionWith = xS,
            pn.uniq = TS,
            pn.uniqBy = RS,
            pn.uniqWith = CS,
            pn.unset = Lx,
            pn.unzip = D1,
            pn.unzipWith = i_,
            pn.update = Nx,
            pn.updateWith = Mx,
            pn.values = Cm,
            pn.valuesIn = Px,
            pn.without = $S,
            pn.words = A_,
            pn.wrap = $w,
            pn.xor = IS,
            pn.xorBy = kS,
            pn.xorWith = LS,
            pn.zip = NS,
            pn.zipObject = PS,
            pn.zipObjectDeep = DS,
            pn.zipWith = BS,
            pn.entries = T_,
            pn.entriesIn = R_,
            pn.extend = S_,
            pn.extendWith = zy,
            V1(pn, pn),
            pn.add = PT,
            pn.attempt = I_,
            pn.camelCase = jx,
            pn.capitalize = C_,
            pn.ceil = DT,
            pn.clamp = Dx,
            pn.clone = Iw,
            pn.cloneDeep = kw,
            pn.cloneDeepWith = Lw,
            pn.cloneWith = Ow,
            pn.conformsTo = Nw,
            pn.deburr = $_,
            pn.defaultTo = gT,
            pn.divide = BT,
            pn.endsWith = Fx,
            pn.eq = Ll,
            pn.escape = zx,
            pn.escapeRegExp = Wx,
            pn.every = qS,
            pn.find = XS,
            pn.findIndex = Jv,
            pn.findKey = ux,
            pn.findLast = QS,
            pn.findLastIndex = e_,
            pn.findLastKey = dx,
            pn.floor = UT,
            pn.forEach = s_,
            pn.forEachRight = a_,
            pn.forIn = fx,
            pn.forInRight = hx,
            pn.forOwn = gx,
            pn.forOwnRight = mx,
            pn.get = z1,
            pn.gt = Mw,
            pn.gte = Pw,
            pn.has = _x,
            pn.hasIn = W1,
            pn.head = n_,
            pn.identity = Xs,
            pn.includes = rw,
            pn.indexOf = qE,
            pn.inRange = Bx,
            pn.invoke = Sx,
            pn.isArguments = Lp,
            pn.isArray = Zr,
            pn.isArrayBuffer = Dw,
            pn.isArrayLike = qs,
            pn.isArrayLikeObject = ts,
            pn.isBoolean = Bw,
            pn.isBuffer = ep,
            pn.isDate = Uw,
            pn.isElement = jw,
            pn.isEmpty = Fw,
            pn.isEqual = zw,
            pn.isEqualWith = Ww,
            pn.isError = j1,
            pn.isFinite = Hw,
            pn.isFunction = Tu,
            pn.isInteger = g_,
            pn.isLength = jy,
            pn.isMap = m_,
            pn.isMatch = Gw,
            pn.isMatchWith = Kw,
            pn.isNaN = Vw,
            pn.isNative = Yw,
            pn.isNil = Zw,
            pn.isNull = qw,
            pn.isNumber = y_,
            pn.isObject = Ko,
            pn.isObjectLike = Yo,
            pn.isPlainObject = C0,
            pn.isRegExp = F1,
            pn.isSafeInteger = Xw,
            pn.isSet = v_,
            pn.isString = Fy,
            pn.isSymbol = _a,
            pn.isTypedArray = Rm,
            pn.isUndefined = Qw,
            pn.isWeakMap = Jw,
            pn.isWeakSet = ex,
            pn.join = eS,
            pn.kebabCase = Hx,
            pn.last = xl,
            pn.lastIndexOf = tS,
            pn.lowerCase = Gx,
            pn.lowerFirst = Kx,
            pn.lt = tx,
            pn.lte = nx,
            pn.max = jT,
            pn.maxBy = FT,
            pn.mean = zT,
            pn.meanBy = WT,
            pn.min = HT,
            pn.minBy = GT,
            pn.stubArray = q1,
            pn.stubFalse = Z1,
            pn.stubObject = IT,
            pn.stubString = OT,
            pn.stubTrue = kT,
            pn.multiply = KT,
            pn.nth = nS,
            pn.noConflict = ST,
            pn.noop = Y1,
            pn.now = Dy,
            pn.pad = Vx,
            pn.padEnd = Yx,
            pn.padStart = qx,
            pn.parseInt = Zx,
            pn.random = Ux,
            pn.reduce = lw,
            pn.reduceRight = cw,
            pn.repeat = Xx,
            pn.replace = Qx,
            pn.result = Ax,
            pn.round = VT,
            pn.runInContext = In,
            pn.sample = dw,
            pn.size = hw,
            pn.snakeCase = Jx,
            pn.some = gw,
            pn.sortedIndex = cS,
            pn.sortedIndexBy = uS,
            pn.sortedIndexOf = dS,
            pn.sortedLastIndex = fS,
            pn.sortedLastIndexBy = pS,
            pn.sortedLastIndexOf = hS,
            pn.startCase = tT,
            pn.startsWith = nT,
            pn.subtract = YT,
            pn.sum = qT,
            pn.sumBy = ZT,
            pn.template = rT,
            pn.times = LT,
            pn.toFinite = Ru,
            pn.toInteger = Qr,
            pn.toLength = b_,
            pn.toLower = iT,
            pn.toNumber = Tl,
            pn.toSafeInteger = rx,
            pn.toString = So,
            pn.toUpper = oT,
            pn.trim = sT,
            pn.trimEnd = aT,
            pn.trimStart = lT,
            pn.truncate = cT,
            pn.unescape = uT,
            pn.uniqueId = MT,
            pn.upperCase = dT,
            pn.upperFirst = H1,
            pn.each = s_,
            pn.eachRight = a_,
            pn.first = n_,
            V1(pn, function() {
                var ft = {};
                return Ho(pn, function(gt, Ot) {
                    ho.call(pn.prototype, Ot) || (ft[Ot] = gt)
                }),
                ft
            }(), {
                chain: !1
            }),
            pn.VERSION = tt,
            Gs(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(ft) {
                pn[ft].placeholder = pn
            }),
            Gs(["drop", "take"], function(ft, gt) {
                vt.prototype[ft] = function(Ot) {
                    Ot = Ot === et ? 1 : Qo(Qr(Ot), 0);
                    var Qt = this.__filtered__ && !gt ? new vt(this) : this.clone();
                    return Qt.__filtered__ ? Qt.__takeCount__ = ls(Ot, Qt.__takeCount__) : Qt.__views__.push({
                        size: ls(Ot, Wt),
                        type: ft + (Qt.__dir__ < 0 ? "Right" : "")
                    }),
                    Qt
                }
                ,
                vt.prototype[ft + "Right"] = function(Ot) {
                    return this.reverse()[ft](Ot).reverse()
                }
            }),
            Gs(["filter", "map", "takeWhile"], function(ft, gt) {
                var Ot = gt + 1
                  , Qt = Ot == xt || Ot == Dt;
                vt.prototype[ft] = function(sn) {
                    var gn = this.clone();
                    return gn.__iteratees__.push({
                        iteratee: Mr(sn, 3),
                        type: Ot
                    }),
                    gn.__filtered__ = gn.__filtered__ || Qt,
                    gn
                }
            }),
            Gs(["head", "last"], function(ft, gt) {
                var Ot = "take" + (gt ? "Right" : "");
                vt.prototype[ft] = function() {
                    return this[Ot](1).value()[0]
                }
            }),
            Gs(["initial", "tail"], function(ft, gt) {
                var Ot = "drop" + (gt ? "" : "Right");
                vt.prototype[ft] = function() {
                    return this.__filtered__ ? new vt(this) : this[Ot](1)
                }
            }),
            vt.prototype.compact = function() {
                return this.filter(Xs)
            }
            ,
            vt.prototype.find = function(ft) {
                return this.filter(ft).head()
            }
            ,
            vt.prototype.findLast = function(ft) {
                return this.reverse().find(ft)
            }
            ,
            vt.prototype.invokeMap = oo(function(ft, gt) {
                return typeof ft == "function" ? new vt(this) : this.map(function(Ot) {
                    return _c(Ot, ft, gt)
                })
            }),
            vt.prototype.reject = function(ft) {
                return this.filter(Uy(Mr(ft)))
            }
            ,
            vt.prototype.slice = function(ft, gt) {
                ft = Qr(ft);
                var Ot = this;
                return Ot.__filtered__ && (ft > 0 || gt < 0) ? new vt(Ot) : (ft < 0 ? Ot = Ot.takeRight(-ft) : ft && (Ot = Ot.drop(ft)),
                gt !== et && (gt = Qr(gt),
                Ot = gt < 0 ? Ot.dropRight(-gt) : Ot.take(gt - ft)),
                Ot)
            }
            ,
            vt.prototype.takeRightWhile = function(ft) {
                return this.reverse().takeWhile(ft).reverse()
            }
            ,
            vt.prototype.toArray = function() {
                return this.take(Wt)
            }
            ,
            Ho(vt.prototype, function(ft, gt) {
                var Ot = /^(?:filter|find|map|reject)|While$/.test(gt)
                  , Qt = /^(?:head|last)$/.test(gt)
                  , sn = pn[Qt ? "take" + (gt == "last" ? "Right" : "") : gt]
                  , gn = Qt || /^find/.test(gt);
                sn && (pn.prototype[gt] = function() {
                    var xn = this.__wrapped__
                      , $n = Qt ? [1] : arguments
                      , Ln = xn instanceof vt
                      , Xn = $n[0]
                      , Jn = Ln || Zr(xn)
                      , nr = function(ao) {
                        var uo = sn.apply(pn, Vl([ao], $n));
                        return Qt && Er ? uo[0] : uo
                    };
                    Jn && Ot && typeof Xn == "function" && Xn.length != 1 && (Ln = Jn = !1);
                    var Er = this.__chain__
                      , kr = !!this.__actions__.length
                      , Pr = gn && !Er
                      , no = Ln && !kr;
                    if (!gn && Jn) {
                        xn = no ? xn : new vt(this);
                        var Dr = ft.apply(xn, $n);
                        return Dr.__actions__.push({
                            func: My,
                            args: [nr],
                            thisArg: et
                        }),
                        new Tt(Dr,Er)
                    }
                    return Pr && no ? ft.apply(this, $n) : (Dr = this.thru(nr),
                    Pr ? Qt ? Dr.value()[0] : Dr.value() : Dr)
                }
                )
            }),
            Gs(["pop", "push", "shift", "sort", "splice", "unshift"], function(ft) {
                var gt = _u[ft]
                  , Ot = /^(?:push|sort|unshift)$/.test(ft) ? "tap" : "thru"
                  , Qt = /^(?:pop|shift)$/.test(ft);
                pn.prototype[ft] = function() {
                    var sn = arguments;
                    if (Qt && !this.__chain__) {
                        var gn = this.value();
                        return gt.apply(Zr(gn) ? gn : [], sn)
                    }
                    return this[Ot](function(xn) {
                        return gt.apply(Zr(xn) ? xn : [], sn)
                    })
                }
            }),
            Ho(vt.prototype, function(ft, gt) {
                var Ot = pn[gt];
                if (Ot) {
                    var Qt = Ot.name + "";
                    ho.call(Zu, Qt) || (Zu[Qt] = []),
                    Zu[Qt].push({
                        name: gt,
                        func: Ot
                    })
                }
            }),
            Zu[$y(et, _t).name] = [{
                name: "wrapper",
                func: et
            }],
            vt.prototype.clone = bt,
            vt.prototype.reverse = Rt,
            vt.prototype.value = It,
            pn.prototype.at = jS,
            pn.prototype.chain = FS,
            pn.prototype.commit = zS,
            pn.prototype.next = WS,
            pn.prototype.plant = GS,
            pn.prototype.reverse = KS,
            pn.prototype.toJSON = pn.prototype.valueOf = pn.prototype.value = VS,
            pn.prototype.first = pn.prototype.head,
            Ku && (pn.prototype[Ku] = HS),
            pn
        }
          , vu = fy();
        gu ? ((gu.exports = vu)._ = vu,
        Jm._ = vu) : rs._ = vu
    }
    ).call(commonjsGlobal$1)
}
)(lodash, lodash.exports);
var lodashExports = lodash.exports
  , dayjs_min = {
    exports: {}
};
(function(_e, $) {
    (function(et, tt) {
        _e.exports = tt()
    }
    )(commonjsGlobal$1, function() {
        var et = 1e3
          , tt = 6e4
          , nt = 36e5
          , rt = "millisecond"
          , it = "second"
          , ot = "minute"
          , st = "hour"
          , lt = "day"
          , ct = "week"
          , dt = "month"
          , pt = "quarter"
          , ht = "year"
          , mt = "date"
          , yt = "Invalid Date"
          , Et = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/
          , _t = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g
          , wt = {
            name: "en",
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            ordinal: function(xt) {
                var $t = ["th", "st", "nd", "rd"]
                  , Dt = xt % 100;
                return "[" + xt + ($t[(Dt - 20) % 10] || $t[Dt] || $t[0]) + "]"
            }
        }
          , St = function(xt, $t, Dt) {
            var jt = String(xt);
            return !jt || jt.length >= $t ? xt : "" + Array($t + 1 - jt.length).join(Dt) + xt
        }
          , Ct = {
            s: St,
            z: function(xt) {
                var $t = -xt.utcOffset()
                  , Dt = Math.abs($t)
                  , jt = Math.floor(Dt / 60)
                  , Ft = Dt % 60;
                return ($t <= 0 ? "+" : "-") + St(jt, 2, "0") + ":" + St(Ft, 2, "0")
            },
            m: function xt($t, Dt) {
                if ($t.date() < Dt.date())
                    return -xt(Dt, $t);
                var jt = 12 * (Dt.year() - $t.year()) + (Dt.month() - $t.month())
                  , Ft = $t.clone().add(jt, dt)
                  , Ht = Dt - Ft < 0
                  , qt = $t.clone().add(jt + (Ht ? -1 : 1), dt);
                return +(-(jt + (Dt - Ft) / (Ht ? Ft - qt : qt - Ft)) || 0)
            },
            a: function(xt) {
                return xt < 0 ? Math.ceil(xt) || 0 : Math.floor(xt)
            },
            p: function(xt) {
                return {
                    M: dt,
                    y: ht,
                    w: ct,
                    d: lt,
                    D: mt,
                    h: st,
                    m: ot,
                    s: it,
                    ms: rt,
                    Q: pt
                }[xt] || String(xt || "").toLowerCase().replace(/s$/, "")
            },
            u: function(xt) {
                return xt === void 0
            }
        }
          , Nt = "en"
          , Lt = {};
        Lt[Nt] = wt;
        var kt = "$isDayjsObject"
          , Ut = function(xt) {
            return xt instanceof rn || !(!xt || !xt[kt])
        }
          , Jt = function xt($t, Dt, jt) {
            var Ft;
            if (!$t)
                return Nt;
            if (typeof $t == "string") {
                var Ht = $t.toLowerCase();
                Lt[Ht] && (Ft = Ht),
                Dt && (Lt[Ht] = Dt,
                Ft = Ht);
                var qt = $t.split("-");
                if (!Ft && qt.length > 1)
                    return xt(qt[0])
            } else {
                var Wt = $t.name;
                Lt[Wt] = $t,
                Ft = Wt
            }
            return !jt && Ft && (Nt = Ft),
            Ft || !jt && Nt
        }
          , Pt = function(xt, $t) {
            if (Ut(xt))
                return xt.clone();
            var Dt = typeof $t == "object" ? $t : {};
            return Dt.date = xt,
            Dt.args = arguments,
            new rn(Dt)
        }
          , Xt = Ct;
        Xt.l = Jt,
        Xt.i = Ut,
        Xt.w = function(xt, $t) {
            return Pt(xt, {
                locale: $t.$L,
                utc: $t.$u,
                x: $t.$x,
                $offset: $t.$offset
            })
        }
        ;
        var rn = function() {
            function xt(Dt) {
                this.$L = Jt(Dt.locale, null, !0),
                this.parse(Dt),
                this.$x = this.$x || Dt.x || {},
                this[kt] = !0
            }
            var $t = xt.prototype;
            return $t.parse = function(Dt) {
                this.$d = function(jt) {
                    var Ft = jt.date
                      , Ht = jt.utc;
                    if (Ft === null)
                        return new Date(NaN);
                    if (Xt.u(Ft))
                        return new Date;
                    if (Ft instanceof Date)
                        return new Date(Ft);
                    if (typeof Ft == "string" && !/Z$/i.test(Ft)) {
                        var qt = Ft.match(Et);
                        if (qt) {
                            var Wt = qt[2] - 1 || 0
                              , Mt = (qt[7] || "0").substring(0, 3);
                            return Ht ? new Date(Date.UTC(qt[1], Wt, qt[3] || 1, qt[4] || 0, qt[5] || 0, qt[6] || 0, Mt)) : new Date(qt[1],Wt,qt[3] || 1,qt[4] || 0,qt[5] || 0,qt[6] || 0,Mt)
                        }
                    }
                    return new Date(Ft)
                }(Dt),
                this.init()
            }
            ,
            $t.init = function() {
                var Dt = this.$d;
                this.$y = Dt.getFullYear(),
                this.$M = Dt.getMonth(),
                this.$D = Dt.getDate(),
                this.$W = Dt.getDay(),
                this.$H = Dt.getHours(),
                this.$m = Dt.getMinutes(),
                this.$s = Dt.getSeconds(),
                this.$ms = Dt.getMilliseconds()
            }
            ,
            $t.$utils = function() {
                return Xt
            }
            ,
            $t.isValid = function() {
                return this.$d.toString() !== yt
            }
            ,
            $t.isSame = function(Dt, jt) {
                var Ft = Pt(Dt);
                return this.startOf(jt) <= Ft && Ft <= this.endOf(jt)
            }
            ,
            $t.isAfter = function(Dt, jt) {
                return Pt(Dt) < this.startOf(jt)
            }
            ,
            $t.isBefore = function(Dt, jt) {
                return this.endOf(jt) < Pt(Dt)
            }
            ,
            $t.$g = function(Dt, jt, Ft) {
                return Xt.u(Dt) ? this[jt] : this.set(Ft, Dt)
            }
            ,
            $t.unix = function() {
                return Math.floor(this.valueOf() / 1e3)
            }
            ,
            $t.valueOf = function() {
                return this.$d.getTime()
            }
            ,
            $t.startOf = function(Dt, jt) {
                var Ft = this
                  , Ht = !!Xt.u(jt) || jt
                  , qt = Xt.p(Dt)
                  , Wt = function(jn, Bn) {
                    var Un = Xt.w(Ft.$u ? Date.UTC(Ft.$y, Bn, jn) : new Date(Ft.$y,Bn,jn), Ft);
                    return Ht ? Un : Un.endOf(lt)
                }
                  , Mt = function(jn, Bn) {
                    return Xt.w(Ft.toDate()[jn].apply(Ft.toDate("s"), (Ht ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(Bn)), Ft)
                }
                  , Yt = this.$W
                  , un = this.$M
                  , hn = this.$D
                  , _n = "set" + (this.$u ? "UTC" : "");
                switch (qt) {
                case ht:
                    return Ht ? Wt(1, 0) : Wt(31, 11);
                case dt:
                    return Ht ? Wt(1, un) : Wt(0, un + 1);
                case ct:
                    var kn = this.$locale().weekStart || 0
                      , Dn = (Yt < kn ? Yt + 7 : Yt) - kn;
                    return Wt(Ht ? hn - Dn : hn + (6 - Dn), un);
                case lt:
                case mt:
                    return Mt(_n + "Hours", 0);
                case st:
                    return Mt(_n + "Minutes", 1);
                case ot:
                    return Mt(_n + "Seconds", 2);
                case it:
                    return Mt(_n + "Milliseconds", 3);
                default:
                    return this.clone()
                }
            }
            ,
            $t.endOf = function(Dt) {
                return this.startOf(Dt, !1)
            }
            ,
            $t.$set = function(Dt, jt) {
                var Ft, Ht = Xt.p(Dt), qt = "set" + (this.$u ? "UTC" : ""), Wt = (Ft = {},
                Ft[lt] = qt + "Date",
                Ft[mt] = qt + "Date",
                Ft[dt] = qt + "Month",
                Ft[ht] = qt + "FullYear",
                Ft[st] = qt + "Hours",
                Ft[ot] = qt + "Minutes",
                Ft[it] = qt + "Seconds",
                Ft[rt] = qt + "Milliseconds",
                Ft)[Ht], Mt = Ht === lt ? this.$D + (jt - this.$W) : jt;
                if (Ht === dt || Ht === ht) {
                    var Yt = this.clone().set(mt, 1);
                    Yt.$d[Wt](Mt),
                    Yt.init(),
                    this.$d = Yt.set(mt, Math.min(this.$D, Yt.daysInMonth())).$d
                } else
                    Wt && this.$d[Wt](Mt);
                return this.init(),
                this
            }
            ,
            $t.set = function(Dt, jt) {
                return this.clone().$set(Dt, jt)
            }
            ,
            $t.get = function(Dt) {
                return this[Xt.p(Dt)]()
            }
            ,
            $t.add = function(Dt, jt) {
                var Ft, Ht = this;
                Dt = Number(Dt);
                var qt = Xt.p(jt)
                  , Wt = function(un) {
                    var hn = Pt(Ht);
                    return Xt.w(hn.date(hn.date() + Math.round(un * Dt)), Ht)
                };
                if (qt === dt)
                    return this.set(dt, this.$M + Dt);
                if (qt === ht)
                    return this.set(ht, this.$y + Dt);
                if (qt === lt)
                    return Wt(1);
                if (qt === ct)
                    return Wt(7);
                var Mt = (Ft = {},
                Ft[ot] = tt,
                Ft[st] = nt,
                Ft[it] = et,
                Ft)[qt] || 1
                  , Yt = this.$d.getTime() + Dt * Mt;
                return Xt.w(Yt, this)
            }
            ,
            $t.subtract = function(Dt, jt) {
                return this.add(-1 * Dt, jt)
            }
            ,
            $t.format = function(Dt) {
                var jt = this
                  , Ft = this.$locale();
                if (!this.isValid())
                    return Ft.invalidDate || yt;
                var Ht = Dt || "YYYY-MM-DDTHH:mm:ssZ"
                  , qt = Xt.z(this)
                  , Wt = this.$H
                  , Mt = this.$m
                  , Yt = this.$M
                  , un = Ft.weekdays
                  , hn = Ft.months
                  , _n = Ft.meridiem
                  , kn = function(Bn, Un, Hn, cr) {
                    return Bn && (Bn[Un] || Bn(jt, Ht)) || Hn[Un].slice(0, cr)
                }
                  , Dn = function(Bn) {
                    return Xt.s(Wt % 12 || 12, Bn, "0")
                }
                  , jn = _n || function(Bn, Un, Hn) {
                    var cr = Bn < 12 ? "AM" : "PM";
                    return Hn ? cr.toLowerCase() : cr
                }
                ;
                return Ht.replace(_t, function(Bn, Un) {
                    return Un || function(Hn) {
                        switch (Hn) {
                        case "YY":
                            return String(jt.$y).slice(-2);
                        case "YYYY":
                            return Xt.s(jt.$y, 4, "0");
                        case "M":
                            return Yt + 1;
                        case "MM":
                            return Xt.s(Yt + 1, 2, "0");
                        case "MMM":
                            return kn(Ft.monthsShort, Yt, hn, 3);
                        case "MMMM":
                            return kn(hn, Yt);
                        case "D":
                            return jt.$D;
                        case "DD":
                            return Xt.s(jt.$D, 2, "0");
                        case "d":
                            return String(jt.$W);
                        case "dd":
                            return kn(Ft.weekdaysMin, jt.$W, un, 2);
                        case "ddd":
                            return kn(Ft.weekdaysShort, jt.$W, un, 3);
                        case "dddd":
                            return un[jt.$W];
                        case "H":
                            return String(Wt);
                        case "HH":
                            return Xt.s(Wt, 2, "0");
                        case "h":
                            return Dn(1);
                        case "hh":
                            return Dn(2);
                        case "a":
                            return jn(Wt, Mt, !0);
                        case "A":
                            return jn(Wt, Mt, !1);
                        case "m":
                            return String(Mt);
                        case "mm":
                            return Xt.s(Mt, 2, "0");
                        case "s":
                            return String(jt.$s);
                        case "ss":
                            return Xt.s(jt.$s, 2, "0");
                        case "SSS":
                            return Xt.s(jt.$ms, 3, "0");
                        case "Z":
                            return qt
                        }
                        return null
                    }(Bn) || qt.replace(":", "")
                })
            }
            ,
            $t.utcOffset = function() {
                return 15 * -Math.round(this.$d.getTimezoneOffset() / 15)
            }
            ,
            $t.diff = function(Dt, jt, Ft) {
                var Ht, qt = this, Wt = Xt.p(jt), Mt = Pt(Dt), Yt = (Mt.utcOffset() - this.utcOffset()) * tt, un = this - Mt, hn = function() {
                    return Xt.m(qt, Mt)
                };
                switch (Wt) {
                case ht:
                    Ht = hn() / 12;
                    break;
                case dt:
                    Ht = hn();
                    break;
                case pt:
                    Ht = hn() / 3;
                    break;
                case ct:
                    Ht = (un - Yt) / 6048e5;
                    break;
                case lt:
                    Ht = (un - Yt) / 864e5;
                    break;
                case st:
                    Ht = un / nt;
                    break;
                case ot:
                    Ht = un / tt;
                    break;
                case it:
                    Ht = un / et;
                    break;
                default:
                    Ht = un
                }
                return Ft ? Ht : Xt.a(Ht)
            }
            ,
            $t.daysInMonth = function() {
                return this.endOf(dt).$D
            }
            ,
            $t.$locale = function() {
                return Lt[this.$L]
            }
            ,
            $t.locale = function(Dt, jt) {
                if (!Dt)
                    return this.$L;
                var Ft = this.clone()
                  , Ht = Jt(Dt, jt, !0);
                return Ht && (Ft.$L = Ht),
                Ft
            }
            ,
            $t.clone = function() {
                return Xt.w(this.$d, this)
            }
            ,
            $t.toDate = function() {
                return new Date(this.valueOf())
            }
            ,
            $t.toJSON = function() {
                return this.isValid() ? this.toISOString() : null
            }
            ,
            $t.toISOString = function() {
                return this.$d.toISOString()
            }
            ,
            $t.toString = function() {
                return this.$d.toUTCString()
            }
            ,
            xt
        }()
          , zt = rn.prototype;
        return Pt.prototype = zt,
        [["$ms", rt], ["$s", it], ["$m", ot], ["$H", st], ["$W", lt], ["$M", dt], ["$y", ht], ["$D", mt]].forEach(function(xt) {
            zt[xt[1]] = function($t) {
                return this.$g($t, xt[0], xt[1])
            }
        }),
        Pt.extend = function(xt, $t) {
            return xt.$i || (xt($t, rn, Pt),
            xt.$i = !0),
            Pt
        }
        ,
        Pt.locale = Jt,
        Pt.isDayjs = Ut,
        Pt.unix = function(xt) {
            return Pt(1e3 * xt)
        }
        ,
        Pt.en = Lt[Nt],
        Pt.Ls = Lt,
        Pt.p = {},
        Pt
    })
}
)(dayjs_min);
var dayjs_minExports = dayjs_min.exports;
const dayjs = getDefaultExportFromCjs$2(dayjs_minExports);
var SubscribeTypes = (_e => (_e.Candle = "CANDLE",
_e.CAP_CANDLE = "CAP_CANDLE",
_e.ALL_TICKER = "ALL_TICKER",
_e.TICKER = "TICKER",
_e.MARKET_CREATED = "MARKET_CREATED",
_e.MARKET_METADATA_UPDATED = "MARKET_METADATA_UPDATED",
_e.ALL_TRADE = "ALL_TRADE",
_e.TRADE = "TRADE",
_e.RANK = "RANK",
_e.ALL_RANK = "ALL_RANK",
_e))(SubscribeTypes || {});
const PricesContext = reactExports.createContext({
    tickerSub: !1,
    subscribeTickerCandle: _e => {}
    ,
    unsubscribeTickerCandle: _e => {}
    ,
    subscribeTicker: _e => {}
    ,
    unsubscribeTicker: _e => {}
    ,
    subscribeTickerTrade: _e => {}
    ,
    unsubscribeTickerTrade: _e => {}
    ,
    subscribeTickerRank: _e => {}
    ,
    unsubscribeTickerRank: _e => {}
    ,
    subscribeMarketCreated: () => {}
    ,
    unsubscribeMarketCreated: () => {}
    ,
    subscribeMarketMetadataUpdate: () => {}
    ,
    unsubscribeMarketMetadataUpdate: () => {}
    ,
    deletLatestDataByKey: _e => {}
    ,
    lastJsonMessage: {},
    socket: null,
    readyState: 0,
    latestDatas: {},
    subAllTickers: () => {}
    ,
    unsubAllTickers: () => {}
    ,
    subAllTrades: () => {}
    ,
    unsubAllTrades: () => {}
    ,
    targetTime: 0
});
function PricesContextProvider({children: _e}) {
    const $ = "wss://api.super.exchange/v1/stream"
      , [et,tt] = reactExports.useState(!1)
      , [nt,rt] = reactExports.useState({})
      , {updateTickers: it, updateTickersRank: ot} = usePriceStore()
      , [st] = reactExports.useState(dayjs(launchTimestamp).valueOf())
      , {sendMessage: lt, sendJsonMessage: ct, lastJsonMessage: dt, readyState: pt, getWebSocket: ht} = useWebSocket($, {
        onOpen: () => {}
        ,
        shouldReconnect: Ht => !0,
        onMessage: Ht => {
            const qt = JSON.parse(Ht.data);
            if (qt.data) {
                const Wt = qt.data;
                return ["ALL_TICKER", "ALL_RANK", "TICKER", "RANK"].includes(qt.type) ? qt.type === "ALL_TICKER" || qt.type === "TICKER" ? it(Wt) : (qt.type === "ALL_RANK" || qt.type === "RANK") && ot(Wt) : ["CANDLE", "CAP_CANDLE"].includes(qt.type) ? (store$2(STORAGE_KEY_PRICES, {
                    ...Wt,
                    ticker: qt.symbol,
                    resolution: qt.resolution
                }),
                window.dispatchEvent(new Event(EVENT_CHART_PRICE))) : rt(Mt => qt.type === "TRADE" ? lodashExports.has(Mt, "TRADE") ? {
                    ...Mt,
                    [qt.type]: [Wt, ...Mt[qt.type]]
                } : {
                    ...Mt,
                    [qt.type]: [Wt]
                } : {
                    ...Mt,
                    [qt.type]: Wt
                }),
                Ht
            }
        }
    })
      , mt = ht()
      , yt = () => {
        pt === dist$1.ReadyState.OPEN && ct({
            operation: "SUBSCRIBE",
            type: "ALL_TICKER"
        })
    }
      , Et = () => {
        ct({
            operation: "UNSUBSCRIBE",
            type: "ALL_TICKER"
        })
    }
      , _t = () => {
        pt === dist$1.ReadyState.OPEN && ct({
            operation: "SUBSCRIBE",
            type: "ALL_TRADE"
        })
    }
      , wt = () => {
        pt === dist$1.ReadyState.OPEN && (ct({
            operation: "UNSUBSCRIBE",
            type: "ALL_TRADE"
        }),
        zt("ALL_TRADE"))
    }
      , St = () => {
        pt === dist$1.ReadyState.OPEN && ct({
            operation: "SUBSCRIBE",
            type: "ALL_RANK"
        })
    }
      , Ct = () => {
        pt === dist$1.ReadyState.OPEN && (ct({
            operation: "UNSUBSCRIBE",
            type: "ALL_RANK"
        }),
        zt("ALL_RANK"))
    }
      , Nt = reactExports.useCallback(Ht => {
        pt === dist$1.ReadyState.OPEN && (ct({
            operation: "SUBSCRIBE",
            type: "TICKER",
            ...Ht
        }),
        tt(!0))
    }
    , [pt])
      , Lt = reactExports.useCallback(Ht => {
        pt === dist$1.ReadyState.OPEN && (ct({
            operation: "UNSUBSCRIBE",
            type: "TICKER",
            ...Ht
        }),
        zt("TICKER"))
    }
    , [pt])
      , kt = reactExports.useCallback(Ht => {
        pt === dist$1.ReadyState.OPEN && ct({
            operation: "SUBSCRIBE",
            type: "TRADE",
            ...Ht
        })
    }
    , [pt])
      , Ut = reactExports.useCallback(Ht => {
        pt === dist$1.ReadyState.OPEN && (ct({
            operation: "UNSUBSCRIBE",
            type: "TRADE",
            ...Ht
        }),
        zt("TRADE"))
    }
    , [pt])
      , Jt = reactExports.useCallback(Ht => {
        pt === dist$1.ReadyState.OPEN && ct({
            operation: "SUBSCRIBE",
            type: "RANK",
            ...Ht
        })
    }
    , [pt])
      , Pt = reactExports.useCallback(Ht => {
        pt === dist$1.ReadyState.OPEN && (ct({
            operation: "UNSUBSCRIBE",
            type: "RANK",
            ...Ht
        }),
        zt("RANK"))
    }
    , [pt])
      , Xt = reactExports.useCallback(Ht => {
        pt === dist$1.ReadyState.OPEN && (ct({
            operation: "SUBSCRIBE",
            ...Ht
        }),
        tt(!0))
    }
    , [pt])
      , rn = reactExports.useCallback(Ht => {
        pt === dist$1.ReadyState.OPEN && (ct({
            operation: "UNSUBSCRIBE",
            ...Ht
        }),
        rt(qt => (qt && qt.CANDLE && delete qt.CANDLE,
        qt)),
        tt(!1),
        zt("CANDLE"),
        zt("CAP_CANDLE"))
    }
    , [pt])
      , zt = reactExports.useCallback(Ht => {
        rt(qt => (qt && qt[Ht] && delete qt[Ht],
        qt))
    }
    , [])
      , xt = reactExports.useCallback( () => {
        pt === dist$1.ReadyState.OPEN && ct({
            operation: "SUBSCRIBE",
            type: "MARKET_CREATED"
        })
    }
    , [pt])
      , $t = reactExports.useCallback( () => {
        pt === dist$1.ReadyState.OPEN && (ct({
            operation: "UNSUBSCRIBE",
            type: "MARKET_CREATED"
        }),
        zt("MARKET_CREATED"))
    }
    , [pt])
      , Dt = reactExports.useCallback( () => {
        pt === dist$1.ReadyState.OPEN && ct({
            operation: "SUBSCRIBE",
            type: "MARKET_METADATA_UPDATED"
        })
    }
    , [pt])
      , jt = reactExports.useCallback( () => {
        pt === dist$1.ReadyState.OPEN && (ct({
            operation: "UNSUBSCRIBE",
            type: "MARKET_METADATA_UPDATED"
        }),
        zt("MARKET_METADATA_UPDATED"))
    }
    , [pt])
      , Ft = reactExports.useMemo( () => ({
        tickerSub: et,
        subscribeTickerCandle: Xt,
        unsubscribeTickerCandle: rn,
        subscribeTicker: Nt,
        unsubscribeTicker: Lt,
        subscribeTickerTrade: kt,
        unsubscribeTickerTrade: Ut,
        subscribeTickerRank: Jt,
        unsubscribeTickerRank: Pt,
        lastJsonMessage: dt,
        socket: mt,
        readyState: pt,
        latestDatas: nt,
        subscribeMarketCreated: xt,
        unsubscribeMarketCreated: $t,
        subscribeMarketMetadataUpdate: Dt,
        unsubscribeMarketMetadataUpdate: jt,
        deletLatestDataByKey: zt,
        subAllTickers: yt,
        unsubAllTickers: Et,
        subAllTrades: _t,
        unsubAllTrades: wt,
        subAllRank: St,
        unsubAllRank: Ct,
        targetTime: st
    }), [Xt, rn, et, dt, mt, pt, nt, xt, $t, Dt, jt, zt, wt, yt, st]);
    return jsxRuntimeExports.jsx(PricesContext.Provider, {
        value: Ft,
        children: _e
    })
}
function usePricesContext() {
    return reactExports.useContext(PricesContext)
}
const TradeContext = reactExports.createContext({
    token: {},
    isLoading: !0,
    tokenStatus: "Loading",
    tokenMetadata: {},
    hasAssociatedAddress: !1,
    createAddressFee: "",
    isCreateRule: !1,
    handleCreateRule: _e => {}
    ,
    refresh: _e => {}
    ,
    marketId: "",
    holders: [],
    requestHolders: _e => {}
    ,
    onRefreshHolders: _e => {}
    ,
    requestHoldersLoading: !1,
    changeTicker: _e => {}
});
function TradeContextProvider({children: _e}) {
    const {isModerator: $} = useStore$1()
      , {pathname: et} = useLocation()
      , {ticker: tt=""} = useParams()
      , nt = useSearchParam$1("ticker")
      , [rt,it] = reactExports.useState("")
      , {subscribeTicker: ot, unsubscribeTicker: st, subscribeTickerTrade: lt, unsubscribeTickerTrade: ct, subscribeTickerRank: dt, unsubscribeTickerRank: pt, readyState: ht} = usePricesContext()
      , mt = reactExports.useMemo( () => rt || tt || nt || "", [tt, nt, rt])
      , [yt,Et] = reactExports.useState("")
      , [_t,wt] = reactExports.useState([])
      , {data: St, loading: Ct, request: Nt, refresh: Lt, execute: kt} = tickerGetTicker({
        symbol: mt
    }, !0)
      , {publicKey: Ut} = useWallet()
      , {connection: Jt} = useConnection()
      , [Pt,Xt] = reactExports.useState()
      , [rn,zt] = reactExports.useState("Loading")
      , [xt,$t] = reactExports.useState()
      , [Dt,jt] = reactExports.useState()
      , [Ft,Ht] = reactExports.useState(!1)
      , {tickers: qt, tickersRank: Wt, clearTickersRank: Mt, clearTickers: Yt} = usePriceStore();
    reactExports.useEffect( () => {
        if (!(!mt || ht !== 1))
            return ot({
                symbol: mt
            }),
            lt({
                symbol: mt
            }),
            dt({
                symbol: mt
            }),
            () => {
                st({
                    symbol: mt
                }),
                ct({
                    symbol: mt
                }),
                pt({
                    symbol: mt
                })
            }
    }
    , [mt, ht]);
    const un = reactExports.useMemo( () => !!(mt && (et.includes("rules") || et.includes("moderator"))), [et, mt])
      , hn = useNavigate()
      , _n = Mn => {
        if ($) {
            hn(`/${mt}/moderator?type=rules`);
            return
        }
        hn(`/${mt}/rules`)
    }
    ;
    reactExports.useEffect( () => {
        mt && kt()
    }
    , [mt, et]),
    reactExports.useEffect( () => {
        var Mn;
        St && ((St == null ? void 0 : St.code) === 200 ? ($t(rr => ({
            ...rr,
            ...St.data
        })),
        Xt(rr => {
            var Zn, pr;
            return {
                ...rr,
                symbol: mt,
                address: (Zn = St.data) == null ? void 0 : Zn.market.token_mint,
                isNative: !1,
                ...(pr = St.data) == null ? void 0 : pr.market_metadata
            }
        }
        ),
        Et((Mn = St.data) == null ? void 0 : Mn.market.market_id),
        zt("Success")) : (St == null ? void 0 : St.code) === 70001 ? zt("Notfound") : zt("Error"))
    }
    , [St]),
    reactExports.useEffect( () => {
        if (lodashExports.isEmpty(qt) || !mt)
            return;
        const Mn = qt[mt];
        Mn && ($t(rr => ({
            ...rr,
            market_ticker: {
                ...rr == null ? void 0 : rr.market_ticker,
                market_cap: Mn.m_cap,
                buy_native_volume_5m: Mn.buy_nvol5m,
                buy_native_volume_1h: Mn.buy_nvol1h,
                buy_native_volume_24h: Mn.buy_nvol24h,
                native_volume_24h: Mn.nvol24h,
                native_volume_5m: Mn.nvol5m,
                native_volume_1h: Mn.nvol1h,
                price_change_24h: Mn.pc24h,
                price_change_1h: Mn.pc1h,
                price_change_5m: Mn.pc5m,
                buy_tx_count_5m: Mn.buy_txcnt5m,
                buy_tx_count_1h: Mn.buy_txcnt1h,
                buy_tx_count_24h: Mn.buy_txcnt24h,
                tx_count_5m: Mn.txcnt5m,
                tx_count_1h: Mn.txcnt1h,
                tx_count_24h: Mn.txcnt24h
            },
            market: {
                ...rr == null ? void 0 : rr.market,
                holders: Mn.holder_cnt,
                price: Mn.last
            }
        })),
        Yt()),
        Object.keys(qt).length > 15 && Yt()
    }
    , [qt, mt]),
    reactExports.useEffect( () => {
        if (lodashExports.isEmpty(Wt) || !mt)
            return;
        const Mn = Wt[mt];
        Mn && ($t(rr => ({
            ...rr,
            market_ticker: {
                ...rr == null ? void 0 : rr.market_ticker,
                rank: Mn.rank
            }
        })),
        Mt()),
        Object.keys(Wt).length > 15 && Mt()
    }
    , [Wt, mt]),
    reactExports.useCallback(async () => {
        if (!Ut || !xt || !Jt)
            return;
        const Mn = getAssociatedTokenAddressSync(new PublicKey(xt.market.token_mint), Ut, !0)
          , rr = await Jt.getAccountInfo(Mn);
        Ht(!!rr),
        kn()
    }
    , [xt, Ut]);
    const kn = reactExports.useCallback(async () => {
        if (!Jt)
            return;
        const Mn = getAccountLen([ExtensionType.ImmutableOwner])
          , rr = await Jt.getMinimumBalanceForRentExemption(Mn);
        jt(rr)
    }
    , [Jt])
      , {loading: Dn, request: jn, refresh: Bn} = tokenHoldingsServiceQueryTokenDistribution({
        market_id: yt
    }, !0)
      , Un = reactExports.useCallback( () => {
        yt && jn({
            market_id: yt
        }).then(Mn => {
            var rr;
            (Mn == null ? void 0 : Mn.code) === API_Code.Success && wt((rr = Mn == null ? void 0 : Mn.data) == null ? void 0 : rr.token_holders)
        }
        )
    }
    , [yt])
      , Hn = reactExports.useCallback( () => {
        yt && Bn({
            market_id: yt
        }).then(Mn => {
            var rr;
            (Mn == null ? void 0 : Mn.code) === API_Code.Success && wt((rr = Mn == null ? void 0 : Mn.data) == null ? void 0 : rr.token_holders)
        }
        )
    }
    , [yt]);
    reactExports.useEffect( () => {
        yt && Un()
    }
    , [yt]),
    useInterval( () => {
        Un()
    }
    , yt ? 5e3 : null);
    const cr = Mn => {
        it(Mn)
    }
      , Gn = reactExports.useMemo( () => ({
        token: Pt,
        isLoading: Ct,
        tokenStatus: rn,
        tokenMetadata: xt,
        createAddressFee: Dt,
        hasAssociatedAddress: Ft,
        isCreateRule: un,
        handleCreateRule: _n,
        refresh: Nt,
        holders: _t,
        requestHoldersLoading: Dn,
        requestHolders: Un,
        onRefreshHolders: Hn,
        marketId: yt,
        changeTicker: cr
    }), [Pt, Ct, xt, rn, Dt, Ft, un, Lt, _t, jn, Hn, Dn, yt, cr]);
    return jsxRuntimeExports.jsx(TradeContext.Provider, {
        value: Gn,
        children: _e
    })
}
function useTradeContext() {
    return reactExports.useContext(TradeContext)
}
const address = "quakeq7M2xRtm5sWahu5tqAW6SiX6Pu56fAVw5fKEHw"
  , metadata = {
    name: "gg_meme",
    version: "0.1.0",
    spec: "0.1.0",
    description: "Created with Anchor"
}

  , instructions = [{
    name: "buy_super",
    discriminator: [143, 214, 29, 74, 169, 226, 100, 253],
    accounts: [{
        name: "config",
        relations: ["market"]
    }, {
        name: "market",
        writable: !0
    }, {
        name: "native_vault",
        writable: !0,
        relations: ["market"]
    }, {
        name: "fee_recipient",
        writable: !0
    }, {
        name: "token_vault",
        writable: !0
    }, {
        name: "community_vault",
        writable: !0
    }, {
        name: "super_account",
        writable: !0,
        pda: {
            seeds: [{
                kind: "const",
                value: [115, 117, 112, 101, 114, 95, 97, 99, 99, 111, 117, 110, 116]
            }, {
                kind: "account",
                path: "payer"
            }, {
                kind: "account",
                path: "config"
            }]
        }
    }, {
        name: "token_recipient",
        writable: !0
    }, {
        name: "payer",
        writable: !0,
        signer: !0
    }, {
        name: "update_market_metadata_authority",
        signer: !0,
        relations: ["config"]
    }, {
        name: "token_program",
        address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
    }, {
        name: "system_program",
        address: "11111111111111111111111111111111"
    }],
    args: [{
        name: "args",
        type: {
            defined: {
                name: "BuySuperArgs"
            }
        }
    }]
}, {
    name: "buy_token",
    discriminator: [138, 127, 14, 91, 38, 87, 115, 105],
    accounts: [{
        name: "config",
        relations: ["market"]
    }, {
        name: "market",
        writable: !0
    }, {
        name: "native_vault",
        writable: !0,
        relations: ["market"]
    }, {
        name: "fee_recipient",
        writable: !0
    }, {
        name: "token_vault",
        writable: !0
    }, {
        name: "community_vault",
        writable: !0
    }, {
        name: "token_recipient",
        writable: !0
    }, {
        name: "payer",
        writable: !0,
        signer: !0
    }, {
        name: "token_program",
        address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
    }, {
        name: "system_program",
        address: "11111111111111111111111111111111"
    }],
    args: [{
        name: "args",
        type: {
            defined: {
                name: "BuyTokenArgs"
            }
        }
    }]
}, {
    name: "buy_token_exact_in",
    discriminator: [234, 141, 190, 236, 221, 89, 9, 143],
    accounts: [{
        name: "config",
        relations: ["market"]
    }, {
        name: "market",
        writable: !0
    }, {
        name: "native_vault",
        writable: !0,
        relations: ["market"]
    }, {
        name: "fee_recipient",
        writable: !0
    }, {
        name: "token_vault",
        writable: !0
    }, {
        name: "community_vault",
        writable: !0
    }, {
        name: "token_recipient",
        writable: !0
    }, {
        name: "payer",
        writable: !0,
        signer: !0
    }, {
        name: "token_program",
        address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
    }, {
        name: "system_program",
        address: "11111111111111111111111111111111"
    }],
    args: [{
        name: "args",
        type: {
            defined: {
                name: "BuyTokenExactInArgs"
            }
        }
    }]
}, {
    name: "create_super_account",
    discriminator: [5, 140, 235, 182, 62, 39, 109, 62],
    accounts: [{
        name: "config"
    }, {
        name: "super_account",
        writable: !0,
        pda: {
            seeds: [{
                kind: "const",
                value: [115, 117, 112, 101, 114, 95, 97, 99, 99, 111, 117, 110, 116]
            }, {
                kind: "account",
                path: "owner"
            }, {
                kind: "account",
                path: "config"
            }]
        }
    }, {
        name: "owner"
    }, {
        name: "payer",
        writable: !0,
        signer: !0
    }, {
        name: "system_program",
        address: "11111111111111111111111111111111"
    }],
    args: []
}, {
    name: "give_rewards",
    discriminator: [254, 219, 13, 211, 184, 19, 82, 47],
    accounts: [{
        name: "config",
        relations: ["market"]
    }, {
        name: "market"
    }, {
        name: "payer",
        writable: !0,
        signer: !0
    }, {
        name: "token_payer",
        writable: !0
    }, {
        name: "token_recipient",
        writable: !0
    }, {
        name: "token_program",
        address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
    }],
    args: [{
        name: "args",
        type: {
            defined: {
                name: "GiveRewardsArgs"
            }
        }
    }]
}, {
    name: "initialize_config",
    docs: ["Initializes a new config account."],
    discriminator: [208, 127, 21, 1, 194, 190, 196, 70],
    accounts: [{
        name: "config",
        writable: !0,
        signer: !0
    }, {
        name: "payer",
        writable: !0,
        signer: !0
    }, {
        name: "system_program",
        address: "11111111111111111111111111111111"
    }],
    args: [{
        name: "args",
        type: {
            defined: {
                name: "InitializeConfigArgs"
            }
        }
    }]
}, {
    name: "initialize_market",
    docs: ["Initializes a new market."],
    discriminator: [35, 35, 189, 193, 155, 48, 170, 203],
    accounts: [{
        name: "config"
    }, {
        name: "token_metadata",
        writable: !0
    }, {
        name: "token_mint",
        writable: !0,
        signer: !0
    }, {
        name: "token_vault",
        docs: ["The vault that holds the token."],
        writable: !0,
        pda: {
            seeds: [{
                kind: "account",
                path: "market"
            }, {
                kind: "const",
                value: [6, 221, 246, 225, 215, 101, 161, 147, 217, 203, 225, 70, 206, 235, 121, 172, 28, 180, 133, 237, 95, 91, 55, 145, 58, 140, 245, 133, 126, 255, 0, 169]
            }, {
                kind: "account",
                path: "token_mint"
            }],
            program: {
                kind: "const",
                value: [140, 151, 37, 143, 78, 36, 137, 241, 187, 61, 16, 41, 20, 142, 13, 131, 11, 90, 19, 153, 218, 255, 16, 132, 4, 142, 123, 216, 219, 233, 248, 89]
            }
        }
    }, {
        name: "community_vault",
        writable: !0
    }, {
        name: "market",
        writable: !0,
        pda: {
            seeds: [{
                kind: "const",
                value: [109, 97, 114, 107, 101, 116]
            }, {
                kind: "arg",
                path: "args.symbol"
            }, {
                kind: "account",
                path: "config"
            }]
        }
    }, {
        name: "native_vault",
        docs: ["The vault that holds the native token(SOL)."],
        writable: !0
    }, {
        name: "fee_recipient",
        writable: !0
    }, {
        name: "payer",
        writable: !0,
        signer: !0
    }, {
        name: "token_program",
        address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
    }, {
        name: "associated_token_program",
        address: "ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"
    }, {
        name: "metaplex_program",
        address: "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
    }, {
        name: "system_program",
        address: "11111111111111111111111111111111"
    }, {
        name: "rent",
        address: "SysvarRent111111111111111111111111111111111"
    }],
    args: [{
        name: "args",
        type: {
            defined: {
                name: "InitializeMarketArgs"
            }
        }
    }]
}, {
    name: "realloc_config",
    docs: ["Reallocates the config account."],
    discriminator: [39, 50, 148, 55, 7, 85, 147, 114],
    accounts: [{
        name: "config",
        writable: !0
    }, {
        name: "signer",
        writable: !0,
        signer: !0
    }, {
        name: "system_program",
        address: "11111111111111111111111111111111"
    }],
    args: []
}, {
    name: "sell_token",
    discriminator: [109, 61, 40, 187, 230, 176, 135, 174],
    accounts: [{
        name: "config",
        relations: ["market"]
    }, {
        name: "market",
        writable: !0
    }, {
        name: "native_vault",
        writable: !0,
        relations: ["market"]
    }, {
        name: "fee_recipient",
        writable: !0
    }, {
        name: "token_vault",
        writable: !0,
        relations: ["market"]
    }, {
        name: "native_recipient",
        writable: !0
    }, {
        name: "token_payer",
        writable: !0
    }, {
        name: "payer",
        signer: !0
    }, {
        name: "token_program",
        address: "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA"
    }, {
        name: "system_program",
        address: "11111111111111111111111111111111"
    }],
    args: [{
        name: "args",
        type: {
            defined: {
                name: "SellTokenArgs"
            }
        }
    }]
}, {
    name: "set_config_authority",
    docs: ["Sets the authority of the config account."],
    discriminator: [16, 200, 212, 18, 95, 43, 107, 89],
    accounts: [{
        name: "config",
        writable: !0
    }, {
        name: "authority",
        signer: !0,
        relations: ["config"]
    }],
    args: [{
        name: "authority",
        type: "pubkey"
    }]
}, {
    name: "set_create_market_config",
    docs: ["Sets the create market config of the config account."],
    discriminator: [182, 176, 151, 6, 99, 252, 142, 165],
    accounts: [{
        name: "config",
        writable: !0
    }, {
        name: "authority",
        signer: !0,
        relations: ["config"]
    }],
    args: [{
        name: "args",
        type: {
            defined: {
                name: "SetCreateMarketConfigArgs"
            }
        }
    }]
}, {
    name: "set_fee_recipient",
    docs: ["Sets the fee recipient of the config account."],
    discriminator: [227, 18, 215, 42, 237, 246, 151, 66],
    accounts: [{
        name: "config",
        writable: !0
    }, {
        name: "authority",
        signer: !0,
        relations: ["config"]
    }],
    args: [{
        name: "fee_recipient",
        type: "pubkey"
    }]
}, {
    name: "update_market_metadata",
    docs: ["Updates the metadata of a market."],
    discriminator: [28, 237, 190, 65, 132, 24, 133, 243],
    accounts: [{
        name: "config",
        relations: ["market"]
    }, {
        name: "market"
    }, {
        name: "token_metadata",
        writable: !0
    }, {
        name: "market_metadata_authority",
        signer: !0
    }, {
        name: "metaplex_program",
        address: "metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s"
    }],
    args: [{
        name: "args",
        type: {
            defined: {
                name: "UpdateMarketMetadataArgs"
            }
        }
    }]
}]
  , accounts = [{
    name: "Config",
    discriminator: [155, 12, 170, 224, 30, 250, 204, 130]
}, {
    name: "Market",
    discriminator: [219, 190, 213, 55, 0, 227, 198, 154]
}, {
    name: "SuperAccount",
    discriminator: [183, 136, 83, 244, 222, 229, 230, 80]
}]
  , errors = [{
    code: 6e3,
    name: "MakerFeeRateTooHigh",
    msg: "Maker fee rate too high"
}, {
    code: 6001,
    name: "TakerFeeRateTooHigh",
    msg: "Taker fee rate too high"
}, {
    code: 6002,
    name: "NotConfigAuthority",
    msg: "Not config authority"
}, {
    code: 6003,
    name: "AmountCannotBeZero",
    msg: "Amount cannot be zero"
}, {
    code: 6004,
    name: "ConfigAccountMismatch",
    msg: "Config account mismatch"
}, {
    code: 6005,
    name: "TokenMintAccountMismatch",
    msg: "Token mint account mismatch"
}, {
    code: 6006,
    name: "FeeRecipientMismatch",
    msg: "Fee recipient mismatch"
}, {
    code: 6007,
    name: "BuyAmountTooLarge",
    msg: "Buy amount too large"
}, {
    code: 6008,
    name: "PayAmountExceedsMaxPay",
    msg: "Pay amount exceeds max pay"
}, {
    code: 6009,
    name: "InvalidSymbolLength",
    msg: "Invalid symbol length"
}, {
    code: 6010,
    name: "InvalidSymbol",
    msg: "Invalid symbol"
}, {
    code: 6011,
    name: "NotMetadataAuthority",
    msg: "Invalid metadata authority"
}, {
    code: 6012,
    name: "SigVerificationFailed",
    msg: "Sig verification failed"
}, {
    code: 6013,
    name: "InitializeBuyAmountTooSmall",
    msg: "Initialize buy amount too small"
}, {
    code: 6014,
    name: "TokenVaultAccountMismatch",
    msg: "Token vault account mismatch"
}, {
    code: 6015,
    name: "CalculateYUnderflow",
    msg: "Underflow when calculating y"
}, {
    code: 6016,
    name: "TooMuchNativeTokenRequired",
    msg: "Too much native token required"
}, {
    code: 6017,
    name: "NativeVaultAccountMismatch",
    msg: "Native vault account mismatch"
}, {
    code: 6018,
    name: "ReceiveAmountTooSmall",
    msg: "Receive amount too small"
}, {
    code: 6019,
    name: "ReservedSymbol",
    msg: "Reserved symbol"
}, {
    code: 6020,
    name: "CommunityVaultAccountMismatch",
    msg: "Community vault account mismatch"
}, {
    code: 6021,
    name: "DonateRateTooHigh",
    msg: "Donate rate too high"
}, {
    code: 6022,
    name: "MissingCreateMarketAuthority",
    msg: "Missing create market authority"
}, {
    code: 6023,
    name: "CannotUseThisInstruction",
    msg: "Cannot use this instruction"
}, {
    code: 6024,
    name: "NonceUnexpected",
    msg: "Buy nonce unexpected"
}, {
    code: 6025,
    name: "BuyAmountUnexpected",
    msg: "Buy amount unexpected"
}, {
    code: 6026,
    name: "FeatureNotSupported",
    msg: "Feature not supported"
}]
  , types = [{
    name: "BuySuperArgs",
    type: {
        kind: "struct",
        fields: [{
            name: "next_nonce",
            type: "u32"
        }, {
            name: "next_buy_amount",
            type: "u64"
        }, {
            name: "max_pay",
            type: "u64"
        }, {
            name: "donate_rate",
            type: "u32"
        }]
    }
}, {
    name: "BuyTokenArgs",
    type: {
        kind: "struct",
        fields: [{
            name: "buy_amount",
            type: "u64"
        }, {
            name: "max_pay",
            type: "u64"
        }, {
            name: "donate_rate",
            type: "u32"
        }]
    }
}, {
    name: "BuyTokenExactInArgs",
    type: {
        kind: "struct",
        fields: [{
            name: "pay_amount",
            docs: ["The amount of the native token (SOL) to pay, not including fees.", "", "The actual amount paid will be `pay_amount + fees`.", "", "# Examples", "If you want to buy 1.234 SOL of token, you need to set pay_amount to 1.234 * 10^9,", "and the program will automatically add the trading fee on this basis."],
            type: "u64"
        }, {
            name: "min_receive",
            docs: ["The minimum amount of the token to receive."],
            type: "u64"
        }, {
            name: "donate_rate",
            type: "u32"
        }]
    }
}, {
    name: "Config",
    type: {
        kind: "struct",
        fields: [{
            name: "authority",
            type: "pubkey"
        }, {
            name: "fee_recipient",
            type: "pubkey"
        }, {
            name: "create_market_fee",
            docs: ["The fee to create a market."],
            type: "u64"
        }, {
            name: "create_market_min_buy_amount",
            docs: ["The minimum amount of token that must be bought when creating a market."],
            type: "u64"
        }, {
            name: "update_market_metadata_authority",
            docs: ["The pubkey of the update_market_metadata authority."],
            type: "pubkey"
        }, {
            name: "unused_1",
            type: "u32"
        }, {
            name: "unused_2",
            type: "u32"
        }, {
            name: "restrict_create_market",
            type: "bool"
        }]
    }
}, {
    name: "GiveRewardsArgs",
    type: {
        kind: "struct",
        fields: [{
            name: "post_id",
            type: "i64"
        }, {
            name: "post_author_id",
            type: "i64"
        }, {
            name: "comment_id",
            docs: ["comment_id=0 if give rewards to post"],
            type: "i64"
        }, {
            name: "amount",
            type: "u64"
        }, {
            name: "anonymous",
            type: "bool"
        }, {
            name: "message",
            type: "string"
        }]
    }
}, {
    name: "InitializeConfigArgs",
    type: {
        kind: "struct",
        fields: [{
            name: "authority",
            type: "pubkey"
        }, {
            name: "fee_recipient",
            type: "pubkey"
        }, {
            name: "create_market_fee",
            type: "u64"
        }, {
            name: "create_market_min_buy_amount",
            type: "u64"
        }, {
            name: "update_market_metadata_authority",
            type: "pubkey"
        }, {
            name: "restrict_create_market",
            type: "bool"
        }]
    }
}, {
    name: "InitializeMarketArgs",
    type: {
        kind: "struct",
        fields: [{
            name: "name",
            type: "string"
        }, {
            name: "symbol",
            type: "string"
        }, {
            name: "uri",
            type: "string"
        }]
    }
}, {
    name: "Market",
    type: {
        kind: "struct",
        fields: [{
            name: "config",
            type: "pubkey"
        }, {
            name: "token_mint",
            type: "pubkey"
        }, {
            name: "token_vault",
            docs: ["The vault that holds the token."],
            type: "pubkey"
        }, {
            name: "native_vault",
            docs: ["The vault that holds the native token(SOL)."],
            type: "pubkey"
        }, {
            name: "remaining_supply",
            type: "u64"
        }, {
            name: "symbol",
            type: "string"
        }, {
            name: "bump",
            type: {
                array: ["u8", 1]
            }
        }, {
            name: "native_vault_bump",
            type: {
                array: ["u8", 1]
            }
        }, {
            name: "community_vault",
            type: "pubkey"
        }, {
            name: "community_vault_bump",
            type: {
                array: ["u8", 1]
            }
        }]
    }
}, {
    name: "SellTokenArgs",
    type: {
        kind: "struct",
        fields: [{
            name: "sell_amount",
            type: "u64"
        }, {
            name: "min_receive",
            type: "u64"
        }]
    }
}, {
    name: "SetCreateMarketConfigArgs",
    type: {
        kind: "struct",
        fields: [{
            name: "create_market_fee",
            type: "u64"
        }, {
            name: "create_market_min_buy_amount",
            type: "u64"
        }, {
            name: "update_market_metadata_authority",
            type: "pubkey"
        }, {
            name: "restrict_create_market",
            type: "bool"
        }]
    }
}, {
    name: "SuperAccount",
    type: {
        kind: "struct",
        fields: [{
            name: "nonce",
            type: "u32"
        }, {
            name: "buy_amount",
            type: "u64"
        }]
    }
}, {
    name: "UpdateMarketMetadataArgs",
    type: {
        kind: "struct",
        fields: [{
            name: "name",
            type: "string"
        }, {
            name: "uri",
            type: "string"
        }, {
            name: "post_id",
            docs: ["Only used for logging."],
            type: "u64"
        }]
    }
}]
  , GgMemeIdl = {
    address,
    metadata,
    instructions,
    accounts,
    errors,
    types
};
function getProgram(anchorProvider) {
    let $ = DEV_PROGRAM_IDS[Program_Name.GgMeme];
    return Env_Mode.PORD === "production" && ($ = PROD_PROGRAM_IDS[Program_Name.GgMeme]),
    GgMemeIdl.address = $,
    new Program(GgMemeIdl,anchorProvider)
}
const useGgMemeProgram = () => {
    const {cluster: _e} = useCluster()
      , $ = useAnchorProvider()
      , et = getProgram($)
      , tt = getProgramAccountPublicKey(Program_Account_Name.ConfigAccount, _e.network)
      , nt = useQuery$1({
        queryKey: ["counter", "config", {
            cluster: _e
        }],
        queryFn: () => et.account.config.fetch(tt)
    });
    return {
        program: et,
        accounts: nt
    }
}
  , AccountSubscribeContext = reactExports.createContext({
    marketInfo: {},
    updateNativeBalance: "",
    updateTokenBalance: "",
    balanceSubscribeState: !1
});
function AccountSubscribeContextProvider({children: _e}) {
    const $ = "wss://mainnet.helius-rpc.com/?api-key=b1a83427-6f4f-4c28-9461-58fa53dd5a60"
      , {publicKey: et} = useWallet()
      , tt = reactExports.useMemo( () => et ? et.toBase58() : null, [et])
      , {program: nt} = useGgMemeProgram()
      , [rt,it] = reactExports.useState()
      , [ot,st] = reactExports.useState(!1)
      , [lt,ct] = reactExports.useState()
      , [dt,pt] = reactExports.useState()
      , {token: ht, tokenMetadata: mt} = useTradeContext()
      , [yt,Et] = reactExports.useState()
      , {setNativeBalance: _t} = useStore$1()
      , wt = reactExports.useMemo( () => {
        var xt;
        return lodashExports.isEmpty(mt) ? "" : (xt = mt == null ? void 0 : mt.market) == null ? void 0 : xt.market
    }
    , [mt])
      , St = reactExports.useMemo( () => !et || !ht || lodashExports.isEmpty(ht) ? null : getAssociatedTokenAddressSync(new PublicKey(ht.address), et, !0), [et, ht])
      , {sendMessage: Ct, sendJsonMessage: Nt, lastMessage: Lt, lastJsonMessage: kt, readyState: Ut, getWebSocket: Jt} = useWebSocket($, {
        onOpen: () => {}
        ,
        share: !0,
        shouldReconnect: xt => !0,
        onMessage: xt => {
            const $t = JSON.parse(xt.data);
            if (typeof $t.result == "number" && Et(Dt => ({
                ...Dt,
                [$t.id]: $t.result
            })),
            $t.params && $t.params.result.value.owner === nt.programId.toBase58()) {
                const jt = nt.coder.accounts.decode("market", Buffer$2.from($t.params.result.value.data[0], "base64"));
                it(jt)
            } else if ($t.params && $t.params.result.value.owner === SOLANA_OWNER)
                pt($t.params.result.value.lamports),
                _t($t.params.result.value.lamports),
                st(!0);
            else if ($t.params && $t.params.result.value.owner !== SOLANA_OWNER) {
                const Dt = $t.params.result.value.data.parsed.info;
                Dt && Dt.mint === mt.market.token_mint && Dt.tokenAmount && ct(Dt.tokenAmount.amount),
                st(!0)
            }
        }
    });
    useInterval( () => {
        Nt({
            jsonrpc: "2.0",
            method: "ping"
        })
    }
    , Ut === dist$1.ReadyState.OPEN ? WS_PING_INTERVAL : null);
    const Pt = xt => {
        Nt({
            jsonrpc: "2.0",
            id: "unsubMarket",
            method: "accountUnsubscribe",
            params: [xt]
        }),
        it(null),
        Et($t => delete $t.subMarket)
    }
      , Xt = xt => {
        Nt({
            jsonrpc: "2.0",
            id: "subMarket",
            method: "accountSubscribe",
            params: [xt, {
                encoding: "jsonParsed",
                commitment: "confirmed"
            }]
        })
    }
    ;
    reactExports.useEffect( () => {
        ht && yt && (yt != null && yt.subMarket) && (Pt(yt.subMarket),
        rn())
    }
    , [ht]),
    reactExports.useEffect( () => {
        Ut === dist$1.ReadyState.OPEN && wt && Xt(wt)
    }
    , [Ut, wt]),
    reactExports.useEffect( () => {
        rn()
    }
    , [tt]);
    const rn = () => {
        pt(""),
        ct(""),
        st(!1),
        yt != null && yt.subNativeToken && (Nt({
            jsonrpc: "2.0",
            id: "unsubNativeToken",
            method: "accountUnsubscribe",
            params: [yt == null ? void 0 : yt.subNativeToken]
        }),
        Et(xt => (delete xt.subNativeToken,
        xt))),
        yt != null && yt.subToken && (Nt({
            jsonrpc: "2.0",
            id: "unsubToken",
            method: "accountUnsubscribe",
            params: [yt == null ? void 0 : yt.subToken]
        }),
        Et(xt => (delete xt.subToken,
        xt)))
    }
    ;
    reactExports.useEffect( () => {
        Ut === dist$1.ReadyState.OPEN && St && Nt({
            jsonrpc: "2.0",
            id: "subToken",
            method: "accountSubscribe",
            params: [St, {
                encoding: "jsonParsed",
                commitment: "confirmed"
            }]
        }),
        Ut === dist$1.ReadyState.OPEN && St && Nt({
            jsonrpc: "2.0",
            id: "subNativeToken",
            method: "accountSubscribe",
            params: [et, {
                encoding: "jsonParsed",
                commitment: "confirmed"
            }]
        })
    }
    , [Ut, St]),
    reactExports.useEffect( () => () => {
        yt && (yt != null && yt.subMarket) && Pt(yt.subMarket),
        rn()
    }
    , []);
    const zt = reactExports.useMemo( () => ({
        marketInfo: rt,
        updateNativeBalance: dt,
        updateTokenBalance: lt,
        balanceSubscribeState: ot
    }), [rt, dt, lt, ot]);
    return jsxRuntimeExports.jsx(AccountSubscribeContext.Provider, {
        value: zt,
        children: _e
    })
}
function useAccountSubscribeContext() {
    return reactExports.useContext(AccountSubscribeContext)
}
const StyleContainer = styled("div")( () => ({}));
styled("article")( () => ({
    "@media screen and (max-width: 768px)": {
        boxSizing: "border-box",
        paddingLeft: "0.75rem",
        paddingRight: "0.75rem",
        width: "100%"
    },
    "@media screen and (min-width: 769px) and (max-width: 999px)": {
        padding: "0px 16px",
        width: "calc(100% - 32px)"
    },
    "@media screen and (min-width: 1000px) and (max-width: 1119px)": {
        padding: "0 24px",
        width: "calc(100% - 48px)"
    },
    "@media screen and (min-width: 1120px)": {
        margin: "0 auto",
        padding: "0 24px",
        width: "calc(100% - 48px)"
    }
}));
const Text = styled(Typography)( ({theme: _e, level: $=""}) => {
    let et = "";
    switch ($) {
    case "l0":
        et = _e.custom.textColor;
        break;
    case "l1":
        et = _e.custom.textColorL1;
        break;
    case "l2":
        et = _e.custom.textColorL2;
        break;
    case "l3":
        et = _e.custom.textColorL3;
        break;
    case "green":
        et = _e.palette.success.main;
        break;
    case "red":
        et = _e.palette.error.main;
        break;
    default:
        return
    }
    return {
        color: et
    }
}
);
function useCopyClipboard(_e=500) {
    const [$,et] = reactExports.useState(!1)
      , tt = reactExports.useCallback(nt => {
        const rt = copy$1(nt);
        et(rt)
    }
    , []);
    return reactExports.useEffect( () => {
        if ($) {
            const nt = setTimeout( () => {
                et(!1)
            }
            , _e);
            return () => {
                clearTimeout(nt)
            }
        }
    }
    , [$, et, _e]),
    [$, tt]
}
const usePostStore = create$1(_e => ({
    posting: {},
    addPosting: $ => {
        _e(et => {
            const tt = {
                ...et.posting
            };
            return tt[$.post_id] = $,
            et.posting = tt,
            et
        }
        )
    }
    ,
    removePosting: $ => {
        _e(et => {
            const tt = {
                ...et.posting
            };
            return delete tt[$.post_id],
            et.posting = tt,
            et
        }
        )
    }
    ,
    sharedPostId: "",
    setSharedPostId: $ => _e({
        sharedPostId: $
    }),
    sharedCommentId: "",
    setSharedCommentId: $ => _e({
        sharedCommentId: $
    })
}));
function useLogin() {
    const {setToken: _e, setInviteCode: $, setUserInfo: et, setSignAddress: tt, setHasBound: nt} = useStore$1()
      , {sharedPostId: rt, sharedCommentId: it} = usePostStore()
      , {publicKey: ot, signMessage: st, disconnect: lt} = useWallet()
      , [ct,dt] = reactExports.useState(null)
      , [pt,ht] = reactExports.useState(!1)
      , mt = store$2.get("INVITE_BY")
      , {data: yt, request: Et} = userLogin({
        requestBody: {
            message: "",
            address: "",
            signature: "",
            timestamp: "",
            invite_code: mt,
            post_id: rt,
            comment_id: it
        }
    }, !0)
      , _t = async () => {
        ht(!0);
        const St = Math.floor(Date.now() / 1e3).toString()
          , Ct = `Sign in to the super.exchange\r
\r
Timestamp: ${St}`
          , Nt = new TextEncoder().encode(Ct);
        try {
            const Lt = await st(Nt)
              , kt = Buffer$2.from(Lt).toString("base64");
            Et({
                requestBody: {
                    message: Ct,
                    address: ot && ot.toBase58(),
                    signature: kt,
                    timestamp: St,
                    invite_code: mt,
                    post_id: rt,
                    comment_id: it
                }
            }).then(Ut => (store$2.remove("INVITE_BY"),
            Ut))
        } catch (Lt) {
            dt(Lt),
            ht(!1)
        }
    }
      , wt = () => {
        lt()
    }
    ;
    return reactExports.useEffect( () => {
        (yt == null ? void 0 : yt.code) === 200 ? (tt(ot.toBase58()),
        _e(yt.data.token),
        $(yt.data.invite_code),
        et(yt.data.user)) : yt && yt.msg,
        ht(!1)
    }
    , [yt]),
    {
        login: _t,
        logout: wt,
        isLoginLoading: pt,
        signMessageError: ct
    }
}
function DefaultAvatar$2(_e) {
    const {size: $=24, userId: et=""} = _e
      , tt = [{
        bg: "#dcb7b6",
        portrait: "#d3605d"
    }, {
        bg: "#ECBDE4",
        portrait: "#EC8BDB"
    }, {
        bg: "#c6d7c6",
        portrait: "#90d68b"
    }, {
        bg: "#bed2f4",
        portrait: "#558cf0"
    }, {
        bg: "#e4bfbf",
        portrait: "#df908f"
    }, {
        bg: "#d8d7c4",
        portrait: "#d2d885"
    }, {
        bg: "#c6f5ef",
        portrait: "#7ef5e0"
    }, {
        bg: "#d4bee9",
        portrait: "#ad8de6"
    }, {
        bg: "#d7d0c3",
        portrait: "#d2b180"
    }, {
        bg: "#ebe9c1",
        portrait: "#ddeb5b"
    }]
      , nt = reactExports.useMemo( () => {
        let rt = Math.floor(Math.random() * 10) + 1;
        return et !== "" && (rt = Number(et.slice(-1))),
        et === "999" ? {
            bg: "#d9d9d9",
            portrait: "#979797"
        } : tt[rt]
    }
    , [et]);
    return jsxRuntimeExports.jsxs("svg", {
        width: $,
        height: $,
        viewBox: "0 0 500 500",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [jsxRuntimeExports.jsxs("g", {
            clipPath: "url(#clip0_19112_28109)",
            children: [jsxRuntimeExports.jsx("rect", {
                width: "500",
                height: "500",
                rx: "250",
                fill: nt.bg
            }), jsxRuntimeExports.jsx("path", {
                d: "M71 499.949C71 499.949 86.2911 361.384 261.284 359.765C261.284 359.765 425.978 357.182 428.6 499.949H71Z",
                fill: nt.portrait,
                stroke: "#231F20",
                strokeWidth: "2.40957",
                strokeMiterlimit: "10"
            }), jsxRuntimeExports.jsx("path", {
                d: "M135.874 263.206C135.874 263.206 87.2342 242.441 81.4127 291.519C74.7767 347.474 116.443 358.958 133.247 345.816C133.247 345.816 148.134 450.657 288.096 433.245C398.72 414.643 424.083 297.716 376.865 249.954C376.865 249.954 411.972 182.192 352.109 206.509C352.109 206.509 391.477 153.908 355.169 137.393C315.156 119.191 259.808 185.946 259.808 185.946C259.808 185.946 300.925 127.33 282.116 119.017C263.307 110.704 189.525 133.542 135.869 263.197L135.874 263.206Z",
                fill: nt.portrait,
                stroke: "#231F20",
                strokeWidth: "2.40957",
                strokeMiterlimit: "10"
            }), jsxRuntimeExports.jsx("path", {
                d: "M127.983 277.68C127.983 277.68 96.3936 265.825 98.4562 305.848C100.519 345.871 130.609 329.346 130.609 329.346",
                fill: nt.portrait
            }), jsxRuntimeExports.jsx("path", {
                d: "M127.983 277.68C127.983 277.68 96.3936 265.825 98.4562 305.848C100.519 345.871 130.609 329.346 130.609 329.346",
                stroke: "#231F20",
                strokeWidth: "2.40957",
                strokeMiterlimit: "10"
            })]
        }), jsxRuntimeExports.jsx("defs", {
            children: jsxRuntimeExports.jsx("clipPath", {
                id: "clip0_19112_28109",
                children: jsxRuntimeExports.jsx("rect", {
                    width: "500",
                    height: "500",
                    rx: "250",
                    fill: "white"
                })
            })
        })]
    })
}
function DefaultAvatar$1(_e) {
    const {size: $=24} = _e;
    return jsxRuntimeExports.jsxs("svg", {
        width: $,
        height: $,
        viewBox: "0 0 128 128",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [jsxRuntimeExports.jsxs("g", {
            clipPath: "url(#clip0_20466_5429)",
            children: [jsxRuntimeExports.jsx("circle", {
                cx: "64",
                cy: "64",
                r: "64",
                fill: "#4b4e53"
            }), jsxRuntimeExports.jsx("circle", {
                cx: "64",
                cy: "64",
                r: "51",
                fill: "#202020",
                stroke: "#202020",
                strokeMiterlimit: "10"
            }), jsxRuntimeExports.jsx("path", {
                d: "M57.9984 71.9941L58.0559 72.4286H58.4941H67.6706H68.2311L68.1673 71.8717C67.6397 67.2668 70.9423 64.6496 74.7161 61.7538C74.7653 61.7161 74.8145 61.6784 74.8638 61.6406C78.5059 58.8469 82.5 55.7832 82.5 50.3571C82.5 45.4598 80.5633 41.7199 77.2826 39.2185C74.0192 36.7302 69.4711 35.5 64.2824 35.5C56.5598 35.5 50.2162 39.0831 45.6199 44.4609L45.3076 44.8262L45.6604 45.1527L51.4486 50.5098L51.8109 50.8451L52.1508 50.4871C55.5533 46.9037 58.9604 45 63.0824 45C65.8073 45 67.929 45.5946 69.3569 46.6597C70.7651 47.7101 71.5471 49.2528 71.5471 51.2857C71.5471 52.8199 70.7195 54.1539 69.3677 55.5033C68.4032 56.4661 67.227 57.386 65.9758 58.3645C65.4601 58.7678 64.9317 59.181 64.4001 59.6114C60.8145 62.514 57.2194 66.1007 57.9984 71.9941ZM56.3706 84.6428C56.3706 88.6277 59.2006 91.5 63.1529 91.5C66.9641 91.5 69.8647 88.6277 69.8647 84.6428C69.8647 80.6505 66.9565 77.8571 63.1529 77.8571C59.2825 77.8571 56.3706 80.6468 56.3706 84.6428Z",
                fill: "white",
                stroke: "#4b4e53"
            })]
        }), jsxRuntimeExports.jsx("defs", {
            children: jsxRuntimeExports.jsx("clipPath", {
                id: "clip0_20466_5429",
                children: jsxRuntimeExports.jsx("rect", {
                    width: "128",
                    height: "128",
                    fill: "white"
                })
            })
        })]
    })
}
/*!
 *  decimal.js v10.5.0
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
    precision: 20,
    rounding: 4,
    modulo: 1,
    toExpNeg: -7,
    toExpPos: 21,
    minE: -9e15,
    maxE: EXP_LIMIT,
    crypto: !1
}, inexact, quadrant, external = !0, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER$2 = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P = {
    toStringTag: tag
};
P.absoluteValue = P.abs = function() {
    var _e = new this.constructor(this);
    return _e.s < 0 && (_e.s = 1),
    finalise(_e)
}
;
P.ceil = function() {
    return finalise(new this.constructor(this), this.e + 1, 2)
}
;
P.clampedTo = P.clamp = function(_e, $) {
    var et, tt = this, nt = tt.constructor;
    if (_e = new nt(_e),
    $ = new nt($),
    !_e.s || !$.s)
        return new nt(NaN);
    if (_e.gt($))
        throw Error(invalidArgument + $);
    return et = tt.cmp(_e),
    et < 0 ? _e : tt.cmp($) > 0 ? $ : new nt(tt)
}
;
P.comparedTo = P.cmp = function(_e) {
    var $, et, tt, nt, rt = this, it = rt.d, ot = (_e = new rt.constructor(_e)).d, st = rt.s, lt = _e.s;
    if (!it || !ot)
        return !st || !lt ? NaN : st !== lt ? st : it === ot ? 0 : !it ^ st < 0 ? 1 : -1;
    if (!it[0] || !ot[0])
        return it[0] ? st : ot[0] ? -lt : 0;
    if (st !== lt)
        return st;
    if (rt.e !== _e.e)
        return rt.e > _e.e ^ st < 0 ? 1 : -1;
    for (tt = it.length,
    nt = ot.length,
    $ = 0,
    et = tt < nt ? tt : nt; $ < et; ++$)
        if (it[$] !== ot[$])
            return it[$] > ot[$] ^ st < 0 ? 1 : -1;
    return tt === nt ? 0 : tt > nt ^ st < 0 ? 1 : -1
}
;
P.cosine = P.cos = function() {
    var _e, $, et = this, tt = et.constructor;
    return et.d ? et.d[0] ? (_e = tt.precision,
    $ = tt.rounding,
    tt.precision = _e + Math.max(et.e, et.sd()) + LOG_BASE,
    tt.rounding = 1,
    et = cosine(tt, toLessThanHalfPi(tt, et)),
    tt.precision = _e,
    tt.rounding = $,
    finalise(quadrant == 2 || quadrant == 3 ? et.neg() : et, _e, $, !0)) : new tt(1) : new tt(NaN)
}
;
P.cubeRoot = P.cbrt = function() {
    var _e, $, et, tt, nt, rt, it, ot, st, lt, ct = this, dt = ct.constructor;
    if (!ct.isFinite() || ct.isZero())
        return new dt(ct);
    for (external = !1,
    rt = ct.s * mathpow(ct.s * ct, 1 / 3),
    !rt || Math.abs(rt) == 1 / 0 ? (et = digitsToString(ct.d),
    _e = ct.e,
    (rt = (_e - et.length + 1) % 3) && (et += rt == 1 || rt == -2 ? "0" : "00"),
    rt = mathpow(et, 1 / 3),
    _e = mathfloor((_e + 1) / 3) - (_e % 3 == (_e < 0 ? -1 : 2)),
    rt == 1 / 0 ? et = "5e" + _e : (et = rt.toExponential(),
    et = et.slice(0, et.indexOf("e") + 1) + _e),
    tt = new dt(et),
    tt.s = ct.s) : tt = new dt(rt.toString()),
    it = (_e = dt.precision) + 3; ; )
        if (ot = tt,
        st = ot.times(ot).times(ot),
        lt = st.plus(ct),
        tt = divide(lt.plus(ct).times(ot), lt.plus(st), it + 2, 1),
        digitsToString(ot.d).slice(0, it) === (et = digitsToString(tt.d)).slice(0, it))
            if (et = et.slice(it - 3, it + 1),
            et == "9999" || !nt && et == "4999") {
                if (!nt && (finalise(ot, _e + 1, 0),
                ot.times(ot).times(ot).eq(ct))) {
                    tt = ot;
                    break
                }
                it += 4,
                nt = 1
            } else {
                (!+et || !+et.slice(1) && et.charAt(0) == "5") && (finalise(tt, _e + 1, 1),
                $ = !tt.times(tt).times(tt).eq(ct));
                break
            }
    return external = !0,
    finalise(tt, _e, dt.rounding, $)
}
;
P.decimalPlaces = P.dp = function() {
    var _e, $ = this.d, et = NaN;
    if ($) {
        if (_e = $.length - 1,
        et = (_e - mathfloor(this.e / LOG_BASE)) * LOG_BASE,
        _e = $[_e],
        _e)
            for (; _e % 10 == 0; _e /= 10)
                et--;
        et < 0 && (et = 0)
    }
    return et
}
;
P.dividedBy = P.div = function(_e) {
    return divide(this, new this.constructor(_e))
}
;
P.dividedToIntegerBy = P.divToInt = function(_e) {
    var $ = this
      , et = $.constructor;
    return finalise(divide($, new et(_e), 0, 1, 1), et.precision, et.rounding)
}
;
P.equals = P.eq = function(_e) {
    return this.cmp(_e) === 0
}
;
P.floor = function() {
    return finalise(new this.constructor(this), this.e + 1, 3)
}
;
P.greaterThan = P.gt = function(_e) {
    return this.cmp(_e) > 0
}
;
P.greaterThanOrEqualTo = P.gte = function(_e) {
    var $ = this.cmp(_e);
    return $ == 1 || $ === 0
}
;
P.hyperbolicCosine = P.cosh = function() {
    var _e, $, et, tt, nt, rt = this, it = rt.constructor, ot = new it(1);
    if (!rt.isFinite())
        return new it(rt.s ? 1 / 0 : NaN);
    if (rt.isZero())
        return ot;
    et = it.precision,
    tt = it.rounding,
    it.precision = et + Math.max(rt.e, rt.sd()) + 4,
    it.rounding = 1,
    nt = rt.d.length,
    nt < 32 ? (_e = Math.ceil(nt / 3),
    $ = (1 / tinyPow(4, _e)).toString()) : (_e = 16,
    $ = "2.3283064365386962890625e-10"),
    rt = taylorSeries(it, 1, rt.times($), new it(1), !0);
    for (var st, lt = _e, ct = new it(8); lt--; )
        st = rt.times(rt),
        rt = ot.minus(st.times(ct.minus(st.times(ct))));
    return finalise(rt, it.precision = et, it.rounding = tt, !0)
}
;
P.hyperbolicSine = P.sinh = function() {
    var _e, $, et, tt, nt = this, rt = nt.constructor;
    if (!nt.isFinite() || nt.isZero())
        return new rt(nt);
    if ($ = rt.precision,
    et = rt.rounding,
    rt.precision = $ + Math.max(nt.e, nt.sd()) + 4,
    rt.rounding = 1,
    tt = nt.d.length,
    tt < 3)
        nt = taylorSeries(rt, 2, nt, nt, !0);
    else {
        _e = 1.4 * Math.sqrt(tt),
        _e = _e > 16 ? 16 : _e | 0,
        nt = nt.times(1 / tinyPow(5, _e)),
        nt = taylorSeries(rt, 2, nt, nt, !0);
        for (var it, ot = new rt(5), st = new rt(16), lt = new rt(20); _e--; )
            it = nt.times(nt),
            nt = nt.times(ot.plus(it.times(st.times(it).plus(lt))))
    }
    return rt.precision = $,
    rt.rounding = et,
    finalise(nt, $, et, !0)
}
;
P.hyperbolicTangent = P.tanh = function() {
    var _e, $, et = this, tt = et.constructor;
    return et.isFinite() ? et.isZero() ? new tt(et) : (_e = tt.precision,
    $ = tt.rounding,
    tt.precision = _e + 7,
    tt.rounding = 1,
    divide(et.sinh(), et.cosh(), tt.precision = _e, tt.rounding = $)) : new tt(et.s)
}
;
P.inverseCosine = P.acos = function() {
    var _e = this
      , $ = _e.constructor
      , et = _e.abs().cmp(1)
      , tt = $.precision
      , nt = $.rounding;
    return et !== -1 ? et === 0 ? _e.isNeg() ? getPi($, tt, nt) : new $(0) : new $(NaN) : _e.isZero() ? getPi($, tt + 4, nt).times(.5) : ($.precision = tt + 6,
    $.rounding = 1,
    _e = new $(1).minus(_e).div(_e.plus(1)).sqrt().atan(),
    $.precision = tt,
    $.rounding = nt,
    _e.times(2))
}
;
P.inverseHyperbolicCosine = P.acosh = function() {
    var _e, $, et = this, tt = et.constructor;
    return et.lte(1) ? new tt(et.eq(1) ? 0 : NaN) : et.isFinite() ? (_e = tt.precision,
    $ = tt.rounding,
    tt.precision = _e + Math.max(Math.abs(et.e), et.sd()) + 4,
    tt.rounding = 1,
    external = !1,
    et = et.times(et).minus(1).sqrt().plus(et),
    external = !0,
    tt.precision = _e,
    tt.rounding = $,
    et.ln()) : new tt(et)
}
;
P.inverseHyperbolicSine = P.asinh = function() {
    var _e, $, et = this, tt = et.constructor;
    return !et.isFinite() || et.isZero() ? new tt(et) : (_e = tt.precision,
    $ = tt.rounding,
    tt.precision = _e + 2 * Math.max(Math.abs(et.e), et.sd()) + 6,
    tt.rounding = 1,
    external = !1,
    et = et.times(et).plus(1).sqrt().plus(et),
    external = !0,
    tt.precision = _e,
    tt.rounding = $,
    et.ln())
}
;
P.inverseHyperbolicTangent = P.atanh = function() {
    var _e, $, et, tt, nt = this, rt = nt.constructor;
    return nt.isFinite() ? nt.e >= 0 ? new rt(nt.abs().eq(1) ? nt.s / 0 : nt.isZero() ? nt : NaN) : (_e = rt.precision,
    $ = rt.rounding,
    tt = nt.sd(),
    Math.max(tt, _e) < 2 * -nt.e - 1 ? finalise(new rt(nt), _e, $, !0) : (rt.precision = et = tt - nt.e,
    nt = divide(nt.plus(1), new rt(1).minus(nt), et + _e, 1),
    rt.precision = _e + 4,
    rt.rounding = 1,
    nt = nt.ln(),
    rt.precision = _e,
    rt.rounding = $,
    nt.times(.5))) : new rt(NaN)
}
;
P.inverseSine = P.asin = function() {
    var _e, $, et, tt, nt = this, rt = nt.constructor;
    return nt.isZero() ? new rt(nt) : ($ = nt.abs().cmp(1),
    et = rt.precision,
    tt = rt.rounding,
    $ !== -1 ? $ === 0 ? (_e = getPi(rt, et + 4, tt).times(.5),
    _e.s = nt.s,
    _e) : new rt(NaN) : (rt.precision = et + 6,
    rt.rounding = 1,
    nt = nt.div(new rt(1).minus(nt.times(nt)).sqrt().plus(1)).atan(),
    rt.precision = et,
    rt.rounding = tt,
    nt.times(2)))
}
;
P.inverseTangent = P.atan = function() {
    var _e, $, et, tt, nt, rt, it, ot, st, lt = this, ct = lt.constructor, dt = ct.precision, pt = ct.rounding;
    if (lt.isFinite()) {
        if (lt.isZero())
            return new ct(lt);
        if (lt.abs().eq(1) && dt + 4 <= PI_PRECISION)
            return it = getPi(ct, dt + 4, pt).times(.25),
            it.s = lt.s,
            it
    } else {
        if (!lt.s)
            return new ct(NaN);
        if (dt + 4 <= PI_PRECISION)
            return it = getPi(ct, dt + 4, pt).times(.5),
            it.s = lt.s,
            it
    }
    for (ct.precision = ot = dt + 10,
    ct.rounding = 1,
    et = Math.min(28, ot / LOG_BASE + 2 | 0),
    _e = et; _e; --_e)
        lt = lt.div(lt.times(lt).plus(1).sqrt().plus(1));
    for (external = !1,
    $ = Math.ceil(ot / LOG_BASE),
    tt = 1,
    st = lt.times(lt),
    it = new ct(lt),
    nt = lt; _e !== -1; )
        if (nt = nt.times(st),
        rt = it.minus(nt.div(tt += 2)),
        nt = nt.times(st),
        it = rt.plus(nt.div(tt += 2)),
        it.d[$] !== void 0)
            for (_e = $; it.d[_e] === rt.d[_e] && _e--; )
                ;
    return et && (it = it.times(2 << et - 1)),
    external = !0,
    finalise(it, ct.precision = dt, ct.rounding = pt, !0)
}
;
P.isFinite = function() {
    return !!this.d
}
;
P.isInteger = P.isInt = function() {
    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2
}
;
P.isNaN = function() {
    return !this.s
}
;
P.isNegative = P.isNeg = function() {
    return this.s < 0
}
;
P.isPositive = P.isPos = function() {
    return this.s > 0
}
;
P.isZero = function() {
    return !!this.d && this.d[0] === 0
}
;
P.lessThan = P.lt = function(_e) {
    return this.cmp(_e) < 0
}
;
P.lessThanOrEqualTo = P.lte = function(_e) {
    return this.cmp(_e) < 1
}
;
P.logarithm = P.log = function(_e) {
    var $, et, tt, nt, rt, it, ot, st, lt = this, ct = lt.constructor, dt = ct.precision, pt = ct.rounding, ht = 5;
    if (_e == null)
        _e = new ct(10),
        $ = !0;
    else {
        if (_e = new ct(_e),
        et = _e.d,
        _e.s < 0 || !et || !et[0] || _e.eq(1))
            return new ct(NaN);
        $ = _e.eq(10)
    }
    if (et = lt.d,
    lt.s < 0 || !et || !et[0] || lt.eq(1))
        return new ct(et && !et[0] ? -1 / 0 : lt.s != 1 ? NaN : et ? 0 : 1 / 0);
    if ($)
        if (et.length > 1)
            rt = !0;
        else {
            for (nt = et[0]; nt % 10 === 0; )
                nt /= 10;
            rt = nt !== 1
        }
    if (external = !1,
    ot = dt + ht,
    it = naturalLogarithm(lt, ot),
    tt = $ ? getLn10(ct, ot + 10) : naturalLogarithm(_e, ot),
    st = divide(it, tt, ot, 1),
    checkRoundingDigits(st.d, nt = dt, pt))
        do
            if (ot += 10,
            it = naturalLogarithm(lt, ot),
            tt = $ ? getLn10(ct, ot + 10) : naturalLogarithm(_e, ot),
            st = divide(it, tt, ot, 1),
            !rt) {
                +digitsToString(st.d).slice(nt + 1, nt + 15) + 1 == 1e14 && (st = finalise(st, dt + 1, 0));
                break
            }
        while (checkRoundingDigits(st.d, nt += 10, pt));
    return external = !0,
    finalise(st, dt, pt)
}
;
P.minus = P.sub = function(_e) {
    var $, et, tt, nt, rt, it, ot, st, lt, ct, dt, pt, ht = this, mt = ht.constructor;
    if (_e = new mt(_e),
    !ht.d || !_e.d)
        return !ht.s || !_e.s ? _e = new mt(NaN) : ht.d ? _e.s = -_e.s : _e = new mt(_e.d || ht.s !== _e.s ? ht : NaN),
        _e;
    if (ht.s != _e.s)
        return _e.s = -_e.s,
        ht.plus(_e);
    if (lt = ht.d,
    pt = _e.d,
    ot = mt.precision,
    st = mt.rounding,
    !lt[0] || !pt[0]) {
        if (pt[0])
            _e.s = -_e.s;
        else if (lt[0])
            _e = new mt(ht);
        else
            return new mt(st === 3 ? -0 : 0);
        return external ? finalise(_e, ot, st) : _e
    }
    if (et = mathfloor(_e.e / LOG_BASE),
    ct = mathfloor(ht.e / LOG_BASE),
    lt = lt.slice(),
    rt = ct - et,
    rt) {
        for (dt = rt < 0,
        dt ? ($ = lt,
        rt = -rt,
        it = pt.length) : ($ = pt,
        et = ct,
        it = lt.length),
        tt = Math.max(Math.ceil(ot / LOG_BASE), it) + 2,
        rt > tt && (rt = tt,
        $.length = 1),
        $.reverse(),
        tt = rt; tt--; )
            $.push(0);
        $.reverse()
    } else {
        for (tt = lt.length,
        it = pt.length,
        dt = tt < it,
        dt && (it = tt),
        tt = 0; tt < it; tt++)
            if (lt[tt] != pt[tt]) {
                dt = lt[tt] < pt[tt];
                break
            }
        rt = 0
    }
    for (dt && ($ = lt,
    lt = pt,
    pt = $,
    _e.s = -_e.s),
    it = lt.length,
    tt = pt.length - it; tt > 0; --tt)
        lt[it++] = 0;
    for (tt = pt.length; tt > rt; ) {
        if (lt[--tt] < pt[tt]) {
            for (nt = tt; nt && lt[--nt] === 0; )
                lt[nt] = BASE - 1;
            --lt[nt],
            lt[tt] += BASE
        }
        lt[tt] -= pt[tt]
    }
    for (; lt[--it] === 0; )
        lt.pop();
    for (; lt[0] === 0; lt.shift())
        --et;
    return lt[0] ? (_e.d = lt,
    _e.e = getBase10Exponent(lt, et),
    external ? finalise(_e, ot, st) : _e) : new mt(st === 3 ? -0 : 0)
}
;
P.modulo = P.mod = function(_e) {
    var $, et = this, tt = et.constructor;
    return _e = new tt(_e),
    !et.d || !_e.s || _e.d && !_e.d[0] ? new tt(NaN) : !_e.d || et.d && !et.d[0] ? finalise(new tt(et), tt.precision, tt.rounding) : (external = !1,
    tt.modulo == 9 ? ($ = divide(et, _e.abs(), 0, 3, 1),
    $.s *= _e.s) : $ = divide(et, _e, 0, tt.modulo, 1),
    $ = $.times(_e),
    external = !0,
    et.minus($))
}
;
P.naturalExponential = P.exp = function() {
    return naturalExponential(this)
}
;
P.naturalLogarithm = P.ln = function() {
    return naturalLogarithm(this)
}
;
P.negated = P.neg = function() {
    var _e = new this.constructor(this);
    return _e.s = -_e.s,
    finalise(_e)
}
;
P.plus = P.add = function(_e) {
    var $, et, tt, nt, rt, it, ot, st, lt, ct, dt = this, pt = dt.constructor;
    if (_e = new pt(_e),
    !dt.d || !_e.d)
        return !dt.s || !_e.s ? _e = new pt(NaN) : dt.d || (_e = new pt(_e.d || dt.s === _e.s ? dt : NaN)),
        _e;
    if (dt.s != _e.s)
        return _e.s = -_e.s,
        dt.minus(_e);
    if (lt = dt.d,
    ct = _e.d,
    ot = pt.precision,
    st = pt.rounding,
    !lt[0] || !ct[0])
        return ct[0] || (_e = new pt(dt)),
        external ? finalise(_e, ot, st) : _e;
    if (rt = mathfloor(dt.e / LOG_BASE),
    tt = mathfloor(_e.e / LOG_BASE),
    lt = lt.slice(),
    nt = rt - tt,
    nt) {
        for (nt < 0 ? (et = lt,
        nt = -nt,
        it = ct.length) : (et = ct,
        tt = rt,
        it = lt.length),
        rt = Math.ceil(ot / LOG_BASE),
        it = rt > it ? rt + 1 : it + 1,
        nt > it && (nt = it,
        et.length = 1),
        et.reverse(); nt--; )
            et.push(0);
        et.reverse()
    }
    for (it = lt.length,
    nt = ct.length,
    it - nt < 0 && (nt = it,
    et = ct,
    ct = lt,
    lt = et),
    $ = 0; nt; )
        $ = (lt[--nt] = lt[nt] + ct[nt] + $) / BASE | 0,
        lt[nt] %= BASE;
    for ($ && (lt.unshift($),
    ++tt),
    it = lt.length; lt[--it] == 0; )
        lt.pop();
    return _e.d = lt,
    _e.e = getBase10Exponent(lt, tt),
    external ? finalise(_e, ot, st) : _e
}
;
P.precision = P.sd = function(_e) {
    var $, et = this;
    if (_e !== void 0 && _e !== !!_e && _e !== 1 && _e !== 0)
        throw Error(invalidArgument + _e);
    return et.d ? ($ = getPrecision(et.d),
    _e && et.e + 1 > $ && ($ = et.e + 1)) : $ = NaN,
    $
}
;
P.round = function() {
    var _e = this
      , $ = _e.constructor;
    return finalise(new $(_e), _e.e + 1, $.rounding)
}
;
P.sine = P.sin = function() {
    var _e, $, et = this, tt = et.constructor;
    return et.isFinite() ? et.isZero() ? new tt(et) : (_e = tt.precision,
    $ = tt.rounding,
    tt.precision = _e + Math.max(et.e, et.sd()) + LOG_BASE,
    tt.rounding = 1,
    et = sine(tt, toLessThanHalfPi(tt, et)),
    tt.precision = _e,
    tt.rounding = $,
    finalise(quadrant > 2 ? et.neg() : et, _e, $, !0)) : new tt(NaN)
}
;
P.squareRoot = P.sqrt = function() {
    var _e, $, et, tt, nt, rt, it = this, ot = it.d, st = it.e, lt = it.s, ct = it.constructor;
    if (lt !== 1 || !ot || !ot[0])
        return new ct(!lt || lt < 0 && (!ot || ot[0]) ? NaN : ot ? it : 1 / 0);
    for (external = !1,
    lt = Math.sqrt(+it),
    lt == 0 || lt == 1 / 0 ? ($ = digitsToString(ot),
    ($.length + st) % 2 == 0 && ($ += "0"),
    lt = Math.sqrt($),
    st = mathfloor((st + 1) / 2) - (st < 0 || st % 2),
    lt == 1 / 0 ? $ = "5e" + st : ($ = lt.toExponential(),
    $ = $.slice(0, $.indexOf("e") + 1) + st),
    tt = new ct($)) : tt = new ct(lt.toString()),
    et = (st = ct.precision) + 3; ; )
        if (rt = tt,
        tt = rt.plus(divide(it, rt, et + 2, 1)).times(.5),
        digitsToString(rt.d).slice(0, et) === ($ = digitsToString(tt.d)).slice(0, et))
            if ($ = $.slice(et - 3, et + 1),
            $ == "9999" || !nt && $ == "4999") {
                if (!nt && (finalise(rt, st + 1, 0),
                rt.times(rt).eq(it))) {
                    tt = rt;
                    break
                }
                et += 4,
                nt = 1
            } else {
                (!+$ || !+$.slice(1) && $.charAt(0) == "5") && (finalise(tt, st + 1, 1),
                _e = !tt.times(tt).eq(it));
                break
            }
    return external = !0,
    finalise(tt, st, ct.rounding, _e)
}
;
P.tangent = P.tan = function() {
    var _e, $, et = this, tt = et.constructor;
    return et.isFinite() ? et.isZero() ? new tt(et) : (_e = tt.precision,
    $ = tt.rounding,
    tt.precision = _e + 10,
    tt.rounding = 1,
    et = et.sin(),
    et.s = 1,
    et = divide(et, new tt(1).minus(et.times(et)).sqrt(), _e + 10, 0),
    tt.precision = _e,
    tt.rounding = $,
    finalise(quadrant == 2 || quadrant == 4 ? et.neg() : et, _e, $, !0)) : new tt(NaN)
}
;
P.times = P.mul = function(_e) {
    var $, et, tt, nt, rt, it, ot, st, lt, ct = this, dt = ct.constructor, pt = ct.d, ht = (_e = new dt(_e)).d;
    if (_e.s *= ct.s,
    !pt || !pt[0] || !ht || !ht[0])
        return new dt(!_e.s || pt && !pt[0] && !ht || ht && !ht[0] && !pt ? NaN : !pt || !ht ? _e.s / 0 : _e.s * 0);
    for (et = mathfloor(ct.e / LOG_BASE) + mathfloor(_e.e / LOG_BASE),
    st = pt.length,
    lt = ht.length,
    st < lt && (rt = pt,
    pt = ht,
    ht = rt,
    it = st,
    st = lt,
    lt = it),
    rt = [],
    it = st + lt,
    tt = it; tt--; )
        rt.push(0);
    for (tt = lt; --tt >= 0; ) {
        for ($ = 0,
        nt = st + tt; nt > tt; )
            ot = rt[nt] + ht[tt] * pt[nt - tt - 1] + $,
            rt[nt--] = ot % BASE | 0,
            $ = ot / BASE | 0;
        rt[nt] = (rt[nt] + $) % BASE | 0
    }
    for (; !rt[--it]; )
        rt.pop();
    return $ ? ++et : rt.shift(),
    _e.d = rt,
    _e.e = getBase10Exponent(rt, et),
    external ? finalise(_e, dt.precision, dt.rounding) : _e
}
;
P.toBinary = function(_e, $) {
    return toStringBinary(this, 2, _e, $)
}
;
P.toDecimalPlaces = P.toDP = function(_e, $) {
    var et = this
      , tt = et.constructor;
    return et = new tt(et),
    _e === void 0 ? et : (checkInt32(_e, 0, MAX_DIGITS),
    $ === void 0 ? $ = tt.rounding : checkInt32($, 0, 8),
    finalise(et, _e + et.e + 1, $))
}
;
P.toExponential = function(_e, $) {
    var et, tt = this, nt = tt.constructor;
    return _e === void 0 ? et = finiteToString(tt, !0) : (checkInt32(_e, 0, MAX_DIGITS),
    $ === void 0 ? $ = nt.rounding : checkInt32($, 0, 8),
    tt = finalise(new nt(tt), _e + 1, $),
    et = finiteToString(tt, !0, _e + 1)),
    tt.isNeg() && !tt.isZero() ? "-" + et : et
}
;
P.toFixed = function(_e, $) {
    var et, tt, nt = this, rt = nt.constructor;
    return _e === void 0 ? et = finiteToString(nt) : (checkInt32(_e, 0, MAX_DIGITS),
    $ === void 0 ? $ = rt.rounding : checkInt32($, 0, 8),
    tt = finalise(new rt(nt), _e + nt.e + 1, $),
    et = finiteToString(tt, !1, _e + tt.e + 1)),
    nt.isNeg() && !nt.isZero() ? "-" + et : et
}
;
P.toFraction = function(_e) {
    var $, et, tt, nt, rt, it, ot, st, lt, ct, dt, pt, ht = this, mt = ht.d, yt = ht.constructor;
    if (!mt)
        return new yt(ht);
    if (lt = et = new yt(1),
    tt = st = new yt(0),
    $ = new yt(tt),
    rt = $.e = getPrecision(mt) - ht.e - 1,
    it = rt % LOG_BASE,
    $.d[0] = mathpow(10, it < 0 ? LOG_BASE + it : it),
    _e == null)
        _e = rt > 0 ? $ : lt;
    else {
        if (ot = new yt(_e),
        !ot.isInt() || ot.lt(lt))
            throw Error(invalidArgument + ot);
        _e = ot.gt($) ? rt > 0 ? $ : lt : ot
    }
    for (external = !1,
    ot = new yt(digitsToString(mt)),
    ct = yt.precision,
    yt.precision = rt = mt.length * LOG_BASE * 2; dt = divide(ot, $, 0, 1, 1),
    nt = et.plus(dt.times(tt)),
    nt.cmp(_e) != 1; )
        et = tt,
        tt = nt,
        nt = lt,
        lt = st.plus(dt.times(nt)),
        st = nt,
        nt = $,
        $ = ot.minus(dt.times(nt)),
        ot = nt;
    return nt = divide(_e.minus(et), tt, 0, 1, 1),
    st = st.plus(nt.times(lt)),
    et = et.plus(nt.times(tt)),
    st.s = lt.s = ht.s,
    pt = divide(lt, tt, rt, 1).minus(ht).abs().cmp(divide(st, et, rt, 1).minus(ht).abs()) < 1 ? [lt, tt] : [st, et],
    yt.precision = ct,
    external = !0,
    pt
}
;
P.toHexadecimal = P.toHex = function(_e, $) {
    return toStringBinary(this, 16, _e, $)
}
;
P.toNearest = function(_e, $) {
    var et = this
      , tt = et.constructor;
    if (et = new tt(et),
    _e == null) {
        if (!et.d)
            return et;
        _e = new tt(1),
        $ = tt.rounding
    } else {
        if (_e = new tt(_e),
        $ === void 0 ? $ = tt.rounding : checkInt32($, 0, 8),
        !et.d)
            return _e.s ? et : _e;
        if (!_e.d)
            return _e.s && (_e.s = et.s),
            _e
    }
    return _e.d[0] ? (external = !1,
    et = divide(et, _e, 0, $, 1).times(_e),
    external = !0,
    finalise(et)) : (_e.s = et.s,
    et = _e),
    et
}
;
P.toNumber = function() {
    return +this
}
;
P.toOctal = function(_e, $) {
    return toStringBinary(this, 8, _e, $)
}
;
P.toPower = P.pow = function(_e) {
    var $, et, tt, nt, rt, it, ot = this, st = ot.constructor, lt = +(_e = new st(_e));
    if (!ot.d || !_e.d || !ot.d[0] || !_e.d[0])
        return new st(mathpow(+ot, lt));
    if (ot = new st(ot),
    ot.eq(1))
        return ot;
    if (tt = st.precision,
    rt = st.rounding,
    _e.eq(1))
        return finalise(ot, tt, rt);
    if ($ = mathfloor(_e.e / LOG_BASE),
    $ >= _e.d.length - 1 && (et = lt < 0 ? -lt : lt) <= MAX_SAFE_INTEGER$2)
        return nt = intPow(st, ot, et, tt),
        _e.s < 0 ? new st(1).div(nt) : finalise(nt, tt, rt);
    if (it = ot.s,
    it < 0) {
        if ($ < _e.d.length - 1)
            return new st(NaN);
        if (_e.d[$] & 1 || (it = 1),
        ot.e == 0 && ot.d[0] == 1 && ot.d.length == 1)
            return ot.s = it,
            ot
    }
    return et = mathpow(+ot, lt),
    $ = et == 0 || !isFinite(et) ? mathfloor(lt * (Math.log("0." + digitsToString(ot.d)) / Math.LN10 + ot.e + 1)) : new st(et + "").e,
    $ > st.maxE + 1 || $ < st.minE - 1 ? new st($ > 0 ? it / 0 : 0) : (external = !1,
    st.rounding = ot.s = 1,
    et = Math.min(12, ($ + "").length),
    nt = naturalExponential(_e.times(naturalLogarithm(ot, tt + et)), tt),
    nt.d && (nt = finalise(nt, tt + 5, 1),
    checkRoundingDigits(nt.d, tt, rt) && ($ = tt + 10,
    nt = finalise(naturalExponential(_e.times(naturalLogarithm(ot, $ + et)), $), $ + 5, 1),
    +digitsToString(nt.d).slice(tt + 1, tt + 15) + 1 == 1e14 && (nt = finalise(nt, tt + 1, 0)))),
    nt.s = it,
    external = !0,
    st.rounding = rt,
    finalise(nt, tt, rt))
}
;
P.toPrecision = function(_e, $) {
    var et, tt = this, nt = tt.constructor;
    return _e === void 0 ? et = finiteToString(tt, tt.e <= nt.toExpNeg || tt.e >= nt.toExpPos) : (checkInt32(_e, 1, MAX_DIGITS),
    $ === void 0 ? $ = nt.rounding : checkInt32($, 0, 8),
    tt = finalise(new nt(tt), _e, $),
    et = finiteToString(tt, _e <= tt.e || tt.e <= nt.toExpNeg, _e)),
    tt.isNeg() && !tt.isZero() ? "-" + et : et
}
;
P.toSignificantDigits = P.toSD = function(_e, $) {
    var et = this
      , tt = et.constructor;
    return _e === void 0 ? (_e = tt.precision,
    $ = tt.rounding) : (checkInt32(_e, 1, MAX_DIGITS),
    $ === void 0 ? $ = tt.rounding : checkInt32($, 0, 8)),
    finalise(new tt(et), _e, $)
}
;
P.toString = function() {
    var _e = this
      , $ = _e.constructor
      , et = finiteToString(_e, _e.e <= $.toExpNeg || _e.e >= $.toExpPos);
    return _e.isNeg() && !_e.isZero() ? "-" + et : et
}
;
P.truncated = P.trunc = function() {
    return finalise(new this.constructor(this), this.e + 1, 1)
}
;
P.valueOf = P.toJSON = function() {
    var _e = this
      , $ = _e.constructor
      , et = finiteToString(_e, _e.e <= $.toExpNeg || _e.e >= $.toExpPos);
    return _e.isNeg() ? "-" + et : et
}
;
function digitsToString(_e) {
    var $, et, tt, nt = _e.length - 1, rt = "", it = _e[0];
    if (nt > 0) {
        for (rt += it,
        $ = 1; $ < nt; $++)
            tt = _e[$] + "",
            et = LOG_BASE - tt.length,
            et && (rt += getZeroString(et)),
            rt += tt;
        it = _e[$],
        tt = it + "",
        et = LOG_BASE - tt.length,
        et && (rt += getZeroString(et))
    } else if (it === 0)
        return "0";
    for (; it % 10 === 0; )
        it /= 10;
    return rt + it
}
function checkInt32(_e, $, et) {
    if (_e !== ~~_e || _e < $ || _e > et)
        throw Error(invalidArgument + _e)
}
function checkRoundingDigits(_e, $, et, tt) {
    var nt, rt, it, ot;
    for (rt = _e[0]; rt >= 10; rt /= 10)
        --$;
    return --$ < 0 ? ($ += LOG_BASE,
    nt = 0) : (nt = Math.ceil(($ + 1) / LOG_BASE),
    $ %= LOG_BASE),
    rt = mathpow(10, LOG_BASE - $),
    ot = _e[nt] % rt | 0,
    tt == null ? $ < 3 ? ($ == 0 ? ot = ot / 100 | 0 : $ == 1 && (ot = ot / 10 | 0),
    it = et < 4 && ot == 99999 || et > 3 && ot == 49999 || ot == 5e4 || ot == 0) : it = (et < 4 && ot + 1 == rt || et > 3 && ot + 1 == rt / 2) && (_e[nt + 1] / rt / 100 | 0) == mathpow(10, $ - 2) - 1 || (ot == rt / 2 || ot == 0) && (_e[nt + 1] / rt / 100 | 0) == 0 : $ < 4 ? ($ == 0 ? ot = ot / 1e3 | 0 : $ == 1 ? ot = ot / 100 | 0 : $ == 2 && (ot = ot / 10 | 0),
    it = (tt || et < 4) && ot == 9999 || !tt && et > 3 && ot == 4999) : it = ((tt || et < 4) && ot + 1 == rt || !tt && et > 3 && ot + 1 == rt / 2) && (_e[nt + 1] / rt / 1e3 | 0) == mathpow(10, $ - 3) - 1,
    it
}
function convertBase(_e, $, et) {
    for (var tt, nt = [0], rt, it = 0, ot = _e.length; it < ot; ) {
        for (rt = nt.length; rt--; )
            nt[rt] *= $;
        for (nt[0] += NUMERALS.indexOf(_e.charAt(it++)),
        tt = 0; tt < nt.length; tt++)
            nt[tt] > et - 1 && (nt[tt + 1] === void 0 && (nt[tt + 1] = 0),
            nt[tt + 1] += nt[tt] / et | 0,
            nt[tt] %= et)
    }
    return nt.reverse()
}
function cosine(_e, $) {
    var et, tt, nt;
    if ($.isZero())
        return $;
    tt = $.d.length,
    tt < 32 ? (et = Math.ceil(tt / 3),
    nt = (1 / tinyPow(4, et)).toString()) : (et = 16,
    nt = "2.3283064365386962890625e-10"),
    _e.precision += et,
    $ = taylorSeries(_e, 1, $.times(nt), new _e(1));
    for (var rt = et; rt--; ) {
        var it = $.times($);
        $ = it.times(it).minus(it).times(8).plus(1)
    }
    return _e.precision -= et,
    $
}
var divide = function() {
    function _e(tt, nt, rt) {
        var it, ot = 0, st = tt.length;
        for (tt = tt.slice(); st--; )
            it = tt[st] * nt + ot,
            tt[st] = it % rt | 0,
            ot = it / rt | 0;
        return ot && tt.unshift(ot),
        tt
    }
    function $(tt, nt, rt, it) {
        var ot, st;
        if (rt != it)
            st = rt > it ? 1 : -1;
        else
            for (ot = st = 0; ot < rt; ot++)
                if (tt[ot] != nt[ot]) {
                    st = tt[ot] > nt[ot] ? 1 : -1;
                    break
                }
        return st
    }
    function et(tt, nt, rt, it) {
        for (var ot = 0; rt--; )
            tt[rt] -= ot,
            ot = tt[rt] < nt[rt] ? 1 : 0,
            tt[rt] = ot * it + tt[rt] - nt[rt];
        for (; !tt[0] && tt.length > 1; )
            tt.shift()
    }
    return function(tt, nt, rt, it, ot, st) {
        var lt, ct, dt, pt, ht, mt, yt, Et, _t, wt, St, Ct, Nt, Lt, kt, Ut, Jt, Pt, Xt, rn, zt = tt.constructor, xt = tt.s == nt.s ? 1 : -1, $t = tt.d, Dt = nt.d;
        if (!$t || !$t[0] || !Dt || !Dt[0])
            return new zt(!tt.s || !nt.s || ($t ? Dt && $t[0] == Dt[0] : !Dt) ? NaN : $t && $t[0] == 0 || !Dt ? xt * 0 : xt / 0);
        for (st ? (ht = 1,
        ct = tt.e - nt.e) : (st = BASE,
        ht = LOG_BASE,
        ct = mathfloor(tt.e / ht) - mathfloor(nt.e / ht)),
        Xt = Dt.length,
        Jt = $t.length,
        _t = new zt(xt),
        wt = _t.d = [],
        dt = 0; Dt[dt] == ($t[dt] || 0); dt++)
            ;
        if (Dt[dt] > ($t[dt] || 0) && ct--,
        rt == null ? (Lt = rt = zt.precision,
        it = zt.rounding) : ot ? Lt = rt + (tt.e - nt.e) + 1 : Lt = rt,
        Lt < 0)
            wt.push(1),
            mt = !0;
        else {
            if (Lt = Lt / ht + 2 | 0,
            dt = 0,
            Xt == 1) {
                for (pt = 0,
                Dt = Dt[0],
                Lt++; (dt < Jt || pt) && Lt--; dt++)
                    kt = pt * st + ($t[dt] || 0),
                    wt[dt] = kt / Dt | 0,
                    pt = kt % Dt | 0;
                mt = pt || dt < Jt
            } else {
                for (pt = st / (Dt[0] + 1) | 0,
                pt > 1 && (Dt = _e(Dt, pt, st),
                $t = _e($t, pt, st),
                Xt = Dt.length,
                Jt = $t.length),
                Ut = Xt,
                St = $t.slice(0, Xt),
                Ct = St.length; Ct < Xt; )
                    St[Ct++] = 0;
                rn = Dt.slice(),
                rn.unshift(0),
                Pt = Dt[0],
                Dt[1] >= st / 2 && ++Pt;
                do
                    pt = 0,
                    lt = $(Dt, St, Xt, Ct),
                    lt < 0 ? (Nt = St[0],
                    Xt != Ct && (Nt = Nt * st + (St[1] || 0)),
                    pt = Nt / Pt | 0,
                    pt > 1 ? (pt >= st && (pt = st - 1),
                    yt = _e(Dt, pt, st),
                    Et = yt.length,
                    Ct = St.length,
                    lt = $(yt, St, Et, Ct),
                    lt == 1 && (pt--,
                    et(yt, Xt < Et ? rn : Dt, Et, st))) : (pt == 0 && (lt = pt = 1),
                    yt = Dt.slice()),
                    Et = yt.length,
                    Et < Ct && yt.unshift(0),
                    et(St, yt, Ct, st),
                    lt == -1 && (Ct = St.length,
                    lt = $(Dt, St, Xt, Ct),
                    lt < 1 && (pt++,
                    et(St, Xt < Ct ? rn : Dt, Ct, st))),
                    Ct = St.length) : lt === 0 && (pt++,
                    St = [0]),
                    wt[dt++] = pt,
                    lt && St[0] ? St[Ct++] = $t[Ut] || 0 : (St = [$t[Ut]],
                    Ct = 1);
                while ((Ut++ < Jt || St[0] !== void 0) && Lt--);
                mt = St[0] !== void 0
            }
            wt[0] || wt.shift()
        }
        if (ht == 1)
            _t.e = ct,
            inexact = mt;
        else {
            for (dt = 1,
            pt = wt[0]; pt >= 10; pt /= 10)
                dt++;
            _t.e = dt + ct * ht - 1,
            finalise(_t, ot ? rt + _t.e + 1 : rt, it, mt)
        }
        return _t
    }
}();
function finalise(_e, $, et, tt) {
    var nt, rt, it, ot, st, lt, ct, dt, pt, ht = _e.constructor;
    e: if ($ != null) {
        if (dt = _e.d,
        !dt)
            return _e;
        for (nt = 1,
        ot = dt[0]; ot >= 10; ot /= 10)
            nt++;
        if (rt = $ - nt,
        rt < 0)
            rt += LOG_BASE,
            it = $,
            ct = dt[pt = 0],
            st = ct / mathpow(10, nt - it - 1) % 10 | 0;
        else if (pt = Math.ceil((rt + 1) / LOG_BASE),
        ot = dt.length,
        pt >= ot)
            if (tt) {
                for (; ot++ <= pt; )
                    dt.push(0);
                ct = st = 0,
                nt = 1,
                rt %= LOG_BASE,
                it = rt - LOG_BASE + 1
            } else
                break e;
        else {
            for (ct = ot = dt[pt],
            nt = 1; ot >= 10; ot /= 10)
                nt++;
            rt %= LOG_BASE,
            it = rt - LOG_BASE + nt,
            st = it < 0 ? 0 : ct / mathpow(10, nt - it - 1) % 10 | 0
        }
        if (tt = tt || $ < 0 || dt[pt + 1] !== void 0 || (it < 0 ? ct : ct % mathpow(10, nt - it - 1)),
        lt = et < 4 ? (st || tt) && (et == 0 || et == (_e.s < 0 ? 3 : 2)) : st > 5 || st == 5 && (et == 4 || tt || et == 6 && (rt > 0 ? it > 0 ? ct / mathpow(10, nt - it) : 0 : dt[pt - 1]) % 10 & 1 || et == (_e.s < 0 ? 8 : 7)),
        $ < 1 || !dt[0])
            return dt.length = 0,
            lt ? ($ -= _e.e + 1,
            dt[0] = mathpow(10, (LOG_BASE - $ % LOG_BASE) % LOG_BASE),
            _e.e = -$ || 0) : dt[0] = _e.e = 0,
            _e;
        if (rt == 0 ? (dt.length = pt,
        ot = 1,
        pt--) : (dt.length = pt + 1,
        ot = mathpow(10, LOG_BASE - rt),
        dt[pt] = it > 0 ? (ct / mathpow(10, nt - it) % mathpow(10, it) | 0) * ot : 0),
        lt)
            for (; ; )
                if (pt == 0) {
                    for (rt = 1,
                    it = dt[0]; it >= 10; it /= 10)
                        rt++;
                    for (it = dt[0] += ot,
                    ot = 1; it >= 10; it /= 10)
                        ot++;
                    rt != ot && (_e.e++,
                    dt[0] == BASE && (dt[0] = 1));
                    break
                } else {
                    if (dt[pt] += ot,
                    dt[pt] != BASE)
                        break;
                    dt[pt--] = 0,
                    ot = 1
                }
        for (rt = dt.length; dt[--rt] === 0; )
            dt.pop()
    }
    return external && (_e.e > ht.maxE ? (_e.d = null,
    _e.e = NaN) : _e.e < ht.minE && (_e.e = 0,
    _e.d = [0])),
    _e
}
function finiteToString(_e, $, et) {
    if (!_e.isFinite())
        return nonFiniteToString(_e);
    var tt, nt = _e.e, rt = digitsToString(_e.d), it = rt.length;
    return $ ? (et && (tt = et - it) > 0 ? rt = rt.charAt(0) + "." + rt.slice(1) + getZeroString(tt) : it > 1 && (rt = rt.charAt(0) + "." + rt.slice(1)),
    rt = rt + (_e.e < 0 ? "e" : "e+") + _e.e) : nt < 0 ? (rt = "0." + getZeroString(-nt - 1) + rt,
    et && (tt = et - it) > 0 && (rt += getZeroString(tt))) : nt >= it ? (rt += getZeroString(nt + 1 - it),
    et && (tt = et - nt - 1) > 0 && (rt = rt + "." + getZeroString(tt))) : ((tt = nt + 1) < it && (rt = rt.slice(0, tt) + "." + rt.slice(tt)),
    et && (tt = et - it) > 0 && (nt + 1 === it && (rt += "."),
    rt += getZeroString(tt))),
    rt
}
function getBase10Exponent(_e, $) {
    var et = _e[0];
    for ($ *= LOG_BASE; et >= 10; et /= 10)
        $++;
    return $
}
function getLn10(_e, $, et) {
    if ($ > LN10_PRECISION)
        throw external = !0,
        et && (_e.precision = et),
        Error(precisionLimitExceeded);
    return finalise(new _e(LN10), $, 1, !0)
}
function getPi(_e, $, et) {
    if ($ > PI_PRECISION)
        throw Error(precisionLimitExceeded);
    return finalise(new _e(PI), $, et, !0)
}
function getPrecision(_e) {
    var $ = _e.length - 1
      , et = $ * LOG_BASE + 1;
    if ($ = _e[$],
    $) {
        for (; $ % 10 == 0; $ /= 10)
            et--;
        for ($ = _e[0]; $ >= 10; $ /= 10)
            et++
    }
    return et
}
function getZeroString(_e) {
    for (var $ = ""; _e--; )
        $ += "0";
    return $
}
function intPow(_e, $, et, tt) {
    var nt, rt = new _e(1), it = Math.ceil(tt / LOG_BASE + 4);
    for (external = !1; ; ) {
        if (et % 2 && (rt = rt.times($),
        truncate$1(rt.d, it) && (nt = !0)),
        et = mathfloor(et / 2),
        et === 0) {
            et = rt.d.length - 1,
            nt && rt.d[et] === 0 && ++rt.d[et];
            break
        }
        $ = $.times($),
        truncate$1($.d, it)
    }
    return external = !0,
    rt
}
function isOdd(_e) {
    return _e.d[_e.d.length - 1] & 1
}
function maxOrMin(_e, $, et) {
    for (var tt, nt, rt = new _e($[0]), it = 0; ++it < $.length; ) {
        if (nt = new _e($[it]),
        !nt.s) {
            rt = nt;
            break
        }
        tt = rt.cmp(nt),
        (tt === et || tt === 0 && rt.s === et) && (rt = nt)
    }
    return rt
}
function naturalExponential(_e, $) {
    var et, tt, nt, rt, it, ot, st, lt = 0, ct = 0, dt = 0, pt = _e.constructor, ht = pt.rounding, mt = pt.precision;
    if (!_e.d || !_e.d[0] || _e.e > 17)
        return new pt(_e.d ? _e.d[0] ? _e.s < 0 ? 0 : 1 / 0 : 1 : _e.s ? _e.s < 0 ? 0 : _e : NaN);
    for ($ == null ? (external = !1,
    st = mt) : st = $,
    ot = new pt(.03125); _e.e > -2; )
        _e = _e.times(ot),
        dt += 5;
    for (tt = Math.log(mathpow(2, dt)) / Math.LN10 * 2 + 5 | 0,
    st += tt,
    et = rt = it = new pt(1),
    pt.precision = st; ; ) {
        if (rt = finalise(rt.times(_e), st, 1),
        et = et.times(++ct),
        ot = it.plus(divide(rt, et, st, 1)),
        digitsToString(ot.d).slice(0, st) === digitsToString(it.d).slice(0, st)) {
            for (nt = dt; nt--; )
                it = finalise(it.times(it), st, 1);
            if ($ == null)
                if (lt < 3 && checkRoundingDigits(it.d, st - tt, ht, lt))
                    pt.precision = st += 10,
                    et = rt = ot = new pt(1),
                    ct = 0,
                    lt++;
                else
                    return finalise(it, pt.precision = mt, ht, external = !0);
            else
                return pt.precision = mt,
                it
        }
        it = ot
    }
}
function naturalLogarithm(_e, $) {
    var et, tt, nt, rt, it, ot, st, lt, ct, dt, pt, ht = 1, mt = 10, yt = _e, Et = yt.d, _t = yt.constructor, wt = _t.rounding, St = _t.precision;
    if (yt.s < 0 || !Et || !Et[0] || !yt.e && Et[0] == 1 && Et.length == 1)
        return new _t(Et && !Et[0] ? -1 / 0 : yt.s != 1 ? NaN : Et ? 0 : yt);
    if ($ == null ? (external = !1,
    ct = St) : ct = $,
    _t.precision = ct += mt,
    et = digitsToString(Et),
    tt = et.charAt(0),
    Math.abs(rt = yt.e) < 15e14) {
        for (; tt < 7 && tt != 1 || tt == 1 && et.charAt(1) > 3; )
            yt = yt.times(_e),
            et = digitsToString(yt.d),
            tt = et.charAt(0),
            ht++;
        rt = yt.e,
        tt > 1 ? (yt = new _t("0." + et),
        rt++) : yt = new _t(tt + "." + et.slice(1))
    } else
        return lt = getLn10(_t, ct + 2, St).times(rt + ""),
        yt = naturalLogarithm(new _t(tt + "." + et.slice(1)), ct - mt).plus(lt),
        _t.precision = St,
        $ == null ? finalise(yt, St, wt, external = !0) : yt;
    for (dt = yt,
    st = it = yt = divide(yt.minus(1), yt.plus(1), ct, 1),
    pt = finalise(yt.times(yt), ct, 1),
    nt = 3; ; ) {
        if (it = finalise(it.times(pt), ct, 1),
        lt = st.plus(divide(it, new _t(nt), ct, 1)),
        digitsToString(lt.d).slice(0, ct) === digitsToString(st.d).slice(0, ct))
            if (st = st.times(2),
            rt !== 0 && (st = st.plus(getLn10(_t, ct + 2, St).times(rt + ""))),
            st = divide(st, new _t(ht), ct, 1),
            $ == null)
                if (checkRoundingDigits(st.d, ct - mt, wt, ot))
                    _t.precision = ct += mt,
                    lt = it = yt = divide(dt.minus(1), dt.plus(1), ct, 1),
                    pt = finalise(yt.times(yt), ct, 1),
                    nt = ot = 1;
                else
                    return finalise(st, _t.precision = St, wt, external = !0);
            else
                return _t.precision = St,
                st;
        st = lt,
        nt += 2
    }
}
function nonFiniteToString(_e) {
    return String(_e.s * _e.s / 0)
}
function parseDecimal(_e, $) {
    var et, tt, nt;
    for ((et = $.indexOf(".")) > -1 && ($ = $.replace(".", "")),
    (tt = $.search(/e/i)) > 0 ? (et < 0 && (et = tt),
    et += +$.slice(tt + 1),
    $ = $.substring(0, tt)) : et < 0 && (et = $.length),
    tt = 0; $.charCodeAt(tt) === 48; tt++)
        ;
    for (nt = $.length; $.charCodeAt(nt - 1) === 48; --nt)
        ;
    if ($ = $.slice(tt, nt),
    $) {
        if (nt -= tt,
        _e.e = et = et - tt - 1,
        _e.d = [],
        tt = (et + 1) % LOG_BASE,
        et < 0 && (tt += LOG_BASE),
        tt < nt) {
            for (tt && _e.d.push(+$.slice(0, tt)),
            nt -= LOG_BASE; tt < nt; )
                _e.d.push(+$.slice(tt, tt += LOG_BASE));
            $ = $.slice(tt),
            tt = LOG_BASE - $.length
        } else
            tt -= nt;
        for (; tt--; )
            $ += "0";
        _e.d.push(+$),
        external && (_e.e > _e.constructor.maxE ? (_e.d = null,
        _e.e = NaN) : _e.e < _e.constructor.minE && (_e.e = 0,
        _e.d = [0]))
    } else
        _e.e = 0,
        _e.d = [0];
    return _e
}
function parseOther(_e, $) {
    var et, tt, nt, rt, it, ot, st, lt, ct;
    if ($.indexOf("_") > -1) {
        if ($ = $.replace(/(\d)_(?=\d)/g, "$1"),
        isDecimal.test($))
            return parseDecimal(_e, $)
    } else if ($ === "Infinity" || $ === "NaN")
        return +$ || (_e.s = NaN),
        _e.e = NaN,
        _e.d = null,
        _e;
    if (isHex.test($))
        et = 16,
        $ = $.toLowerCase();
    else if (isBinary.test($))
        et = 2;
    else if (isOctal.test($))
        et = 8;
    else
        throw Error(invalidArgument + $);
    for (rt = $.search(/p/i),
    rt > 0 ? (st = +$.slice(rt + 1),
    $ = $.substring(2, rt)) : $ = $.slice(2),
    rt = $.indexOf("."),
    it = rt >= 0,
    tt = _e.constructor,
    it && ($ = $.replace(".", ""),
    ot = $.length,
    rt = ot - rt,
    nt = intPow(tt, new tt(et), rt, rt * 2)),
    lt = convertBase($, et, BASE),
    ct = lt.length - 1,
    rt = ct; lt[rt] === 0; --rt)
        lt.pop();
    return rt < 0 ? new tt(_e.s * 0) : (_e.e = getBase10Exponent(lt, ct),
    _e.d = lt,
    external = !1,
    it && (_e = divide(_e, nt, ot * 4)),
    st && (_e = _e.times(Math.abs(st) < 54 ? mathpow(2, st) : Decimal.pow(2, st))),
    external = !0,
    _e)
}
function sine(_e, $) {
    var et, tt = $.d.length;
    if (tt < 3)
        return $.isZero() ? $ : taylorSeries(_e, 2, $, $);
    et = 1.4 * Math.sqrt(tt),
    et = et > 16 ? 16 : et | 0,
    $ = $.times(1 / tinyPow(5, et)),
    $ = taylorSeries(_e, 2, $, $);
    for (var nt, rt = new _e(5), it = new _e(16), ot = new _e(20); et--; )
        nt = $.times($),
        $ = $.times(rt.plus(nt.times(it.times(nt).minus(ot))));
    return $
}
function taylorSeries(_e, $, et, tt, nt) {
    var rt, it, ot, st, lt = _e.precision, ct = Math.ceil(lt / LOG_BASE);
    for (external = !1,
    st = et.times(et),
    ot = new _e(tt); ; ) {
        if (it = divide(ot.times(st), new _e($++ * $++), lt, 1),
        ot = nt ? tt.plus(it) : tt.minus(it),
        tt = divide(it.times(st), new _e($++ * $++), lt, 1),
        it = ot.plus(tt),
        it.d[ct] !== void 0) {
            for (rt = ct; it.d[rt] === ot.d[rt] && rt--; )
                ;
            if (rt == -1)
                break
        }
        rt = ot,
        ot = tt,
        tt = it,
        it = rt
    }
    return external = !0,
    it.d.length = ct + 1,
    it
}
function tinyPow(_e, $) {
    for (var et = _e; --$; )
        et *= _e;
    return et
}
function toLessThanHalfPi(_e, $) {
    var et, tt = $.s < 0, nt = getPi(_e, _e.precision, 1), rt = nt.times(.5);
    if ($ = $.abs(),
    $.lte(rt))
        return quadrant = tt ? 4 : 1,
        $;
    if (et = $.divToInt(nt),
    et.isZero())
        quadrant = tt ? 3 : 2;
    else {
        if ($ = $.minus(et.times(nt)),
        $.lte(rt))
            return quadrant = isOdd(et) ? tt ? 2 : 3 : tt ? 4 : 1,
            $;
        quadrant = isOdd(et) ? tt ? 1 : 4 : tt ? 3 : 2
    }
    return $.minus(nt).abs()
}
function toStringBinary(_e, $, et, tt) {
    var nt, rt, it, ot, st, lt, ct, dt, pt, ht = _e.constructor, mt = et !== void 0;
    if (mt ? (checkInt32(et, 1, MAX_DIGITS),
    tt === void 0 ? tt = ht.rounding : checkInt32(tt, 0, 8)) : (et = ht.precision,
    tt = ht.rounding),
    !_e.isFinite())
        ct = nonFiniteToString(_e);
    else {
        for (ct = finiteToString(_e),
        it = ct.indexOf("."),
        mt ? (nt = 2,
        $ == 16 ? et = et * 4 - 3 : $ == 8 && (et = et * 3 - 2)) : nt = $,
        it >= 0 && (ct = ct.replace(".", ""),
        pt = new ht(1),
        pt.e = ct.length - it,
        pt.d = convertBase(finiteToString(pt), 10, nt),
        pt.e = pt.d.length),
        dt = convertBase(ct, 10, nt),
        rt = st = dt.length; dt[--st] == 0; )
            dt.pop();
        if (!dt[0])
            ct = mt ? "0p+0" : "0";
        else {
            if (it < 0 ? rt-- : (_e = new ht(_e),
            _e.d = dt,
            _e.e = rt,
            _e = divide(_e, pt, et, tt, 0, nt),
            dt = _e.d,
            rt = _e.e,
            lt = inexact),
            it = dt[et],
            ot = nt / 2,
            lt = lt || dt[et + 1] !== void 0,
            lt = tt < 4 ? (it !== void 0 || lt) && (tt === 0 || tt === (_e.s < 0 ? 3 : 2)) : it > ot || it === ot && (tt === 4 || lt || tt === 6 && dt[et - 1] & 1 || tt === (_e.s < 0 ? 8 : 7)),
            dt.length = et,
            lt)
                for (; ++dt[--et] > nt - 1; )
                    dt[et] = 0,
                    et || (++rt,
                    dt.unshift(1));
            for (st = dt.length; !dt[st - 1]; --st)
                ;
            for (it = 0,
            ct = ""; it < st; it++)
                ct += NUMERALS.charAt(dt[it]);
            if (mt) {
                if (st > 1)
                    if ($ == 16 || $ == 8) {
                        for (it = $ == 16 ? 4 : 3,
                        --st; st % it; st++)
                            ct += "0";
                        for (dt = convertBase(ct, nt, $),
                        st = dt.length; !dt[st - 1]; --st)
                            ;
                        for (it = 1,
                        ct = "1."; it < st; it++)
                            ct += NUMERALS.charAt(dt[it])
                    } else
                        ct = ct.charAt(0) + "." + ct.slice(1);
                ct = ct + (rt < 0 ? "p" : "p+") + rt
            } else if (rt < 0) {
                for (; ++rt; )
                    ct = "0" + ct;
                ct = "0." + ct
            } else if (++rt > st)
                for (rt -= st; rt--; )
                    ct += "0";
            else
                rt < st && (ct = ct.slice(0, rt) + "." + ct.slice(rt))
        }
        ct = ($ == 16 ? "0x" : $ == 2 ? "0b" : $ == 8 ? "0o" : "") + ct
    }
    return _e.s < 0 ? "-" + ct : ct
}
function truncate$1(_e, $) {
    if (_e.length > $)
        return _e.length = $,
        !0
}
function abs$1(_e) {
    return new this(_e).abs()
}
function acos(_e) {
    return new this(_e).acos()
}
function acosh(_e) {
    return new this(_e).acosh()
}
function add(_e, $) {
    return new this(_e).plus($)
}
function asin(_e) {
    return new this(_e).asin()
}
function asinh(_e) {
    return new this(_e).asinh()
}
function atan(_e) {
    return new this(_e).atan()
}
function atanh(_e) {
    return new this(_e).atanh()
}
function atan2(_e, $) {
    _e = new this(_e),
    $ = new this($);
    var et, tt = this.precision, nt = this.rounding, rt = tt + 4;
    return !_e.s || !$.s ? et = new this(NaN) : !_e.d && !$.d ? (et = getPi(this, rt, 1).times($.s > 0 ? .25 : .75),
    et.s = _e.s) : !$.d || _e.isZero() ? (et = $.s < 0 ? getPi(this, tt, nt) : new this(0),
    et.s = _e.s) : !_e.d || $.isZero() ? (et = getPi(this, rt, 1).times(.5),
    et.s = _e.s) : $.s < 0 ? (this.precision = rt,
    this.rounding = 1,
    et = this.atan(divide(_e, $, rt, 1)),
    $ = getPi(this, rt, 1),
    this.precision = tt,
    this.rounding = nt,
    et = _e.s < 0 ? et.minus($) : et.plus($)) : et = this.atan(divide(_e, $, rt, 1)),
    et
}
function cbrt(_e) {
    return new this(_e).cbrt()
}
function ceil$1(_e) {
    return finalise(_e = new this(_e), _e.e + 1, 2)
}
function clamp(_e, $, et) {
    return new this(_e).clamp($, et)
}
function config(_e) {
    if (!_e || typeof _e != "object")
        throw Error(decimalError + "Object expected");
    var $, et, tt, nt = _e.defaults === !0, rt = ["precision", 1, MAX_DIGITS, "rounding", 0, 8, "toExpNeg", -9e15, 0, "toExpPos", 0, EXP_LIMIT, "maxE", 0, EXP_LIMIT, "minE", -9e15, 0, "modulo", 0, 9];
    for ($ = 0; $ < rt.length; $ += 3)
        if (et = rt[$],
        nt && (this[et] = DEFAULTS[et]),
        (tt = _e[et]) !== void 0)
            if (mathfloor(tt) === tt && tt >= rt[$ + 1] && tt <= rt[$ + 2])
                this[et] = tt;
            else
                throw Error(invalidArgument + et + ": " + tt);
    if (et = "crypto",
    nt && (this[et] = DEFAULTS[et]),
    (tt = _e[et]) !== void 0)
        if (tt === !0 || tt === !1 || tt === 0 || tt === 1)
            if (tt)
                if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                    this[et] = !0;
                else
                    throw Error(cryptoUnavailable);
            else
                this[et] = !1;
        else
            throw Error(invalidArgument + et + ": " + tt);
    return this
}
function cos(_e) {
    return new this(_e).cos()
}
function cosh(_e) {
    return new this(_e).cosh()
}
function clone$3(_e) {
    var $, et, tt;
    function nt(rt) {
        var it, ot, st, lt = this;
        if (!(lt instanceof nt))
            return new nt(rt);
        if (lt.constructor = nt,
        isDecimalInstance(rt)) {
            lt.s = rt.s,
            external ? !rt.d || rt.e > nt.maxE ? (lt.e = NaN,
            lt.d = null) : rt.e < nt.minE ? (lt.e = 0,
            lt.d = [0]) : (lt.e = rt.e,
            lt.d = rt.d.slice()) : (lt.e = rt.e,
            lt.d = rt.d ? rt.d.slice() : rt.d);
            return
        }
        if (st = typeof rt,
        st === "number") {
            if (rt === 0) {
                lt.s = 1 / rt < 0 ? -1 : 1,
                lt.e = 0,
                lt.d = [0];
                return
            }
            if (rt < 0 ? (rt = -rt,
            lt.s = -1) : lt.s = 1,
            rt === ~~rt && rt < 1e7) {
                for (it = 0,
                ot = rt; ot >= 10; ot /= 10)
                    it++;
                external ? it > nt.maxE ? (lt.e = NaN,
                lt.d = null) : it < nt.minE ? (lt.e = 0,
                lt.d = [0]) : (lt.e = it,
                lt.d = [rt]) : (lt.e = it,
                lt.d = [rt]);
                return
            }
            if (rt * 0 !== 0) {
                rt || (lt.s = NaN),
                lt.e = NaN,
                lt.d = null;
                return
            }
            return parseDecimal(lt, rt.toString())
        }
        if (st === "string")
            return (ot = rt.charCodeAt(0)) === 45 ? (rt = rt.slice(1),
            lt.s = -1) : (ot === 43 && (rt = rt.slice(1)),
            lt.s = 1),
            isDecimal.test(rt) ? parseDecimal(lt, rt) : parseOther(lt, rt);
        if (st === "bigint")
            return rt < 0 ? (rt = -rt,
            lt.s = -1) : lt.s = 1,
            parseDecimal(lt, rt.toString());
        throw Error(invalidArgument + rt)
    }
    if (nt.prototype = P,
    nt.ROUND_UP = 0,
    nt.ROUND_DOWN = 1,
    nt.ROUND_CEIL = 2,
    nt.ROUND_FLOOR = 3,
    nt.ROUND_HALF_UP = 4,
    nt.ROUND_HALF_DOWN = 5,
    nt.ROUND_HALF_EVEN = 6,
    nt.ROUND_HALF_CEIL = 7,
    nt.ROUND_HALF_FLOOR = 8,
    nt.EUCLID = 9,
    nt.config = nt.set = config,
    nt.clone = clone$3,
    nt.isDecimal = isDecimalInstance,
    nt.abs = abs$1,
    nt.acos = acos,
    nt.acosh = acosh,
    nt.add = add,
    nt.asin = asin,
    nt.asinh = asinh,
    nt.atan = atan,
    nt.atanh = atanh,
    nt.atan2 = atan2,
    nt.cbrt = cbrt,
    nt.ceil = ceil$1,
    nt.clamp = clamp,
    nt.cos = cos,
    nt.cosh = cosh,
    nt.div = div$1,
    nt.exp = exp,
    nt.floor = floor$2,
    nt.hypot = hypot,
    nt.ln = ln,
    nt.log = log,
    nt.log10 = log10,
    nt.log2 = log2,
    nt.max = max$2,
    nt.min = min$3,
    nt.mod = mod,
    nt.mul = mul,
    nt.pow = pow$1,
    nt.random = random,
    nt.round = round,
    nt.sign = sign,
    nt.sin = sin,
    nt.sinh = sinh,
    nt.sqrt = sqrt,
    nt.sub = sub,
    nt.sum = sum,
    nt.tan = tan,
    nt.tanh = tanh,
    nt.trunc = trunc,
    _e === void 0 && (_e = {}),
    _e && _e.defaults !== !0)
        for (tt = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"],
        $ = 0; $ < tt.length; )
            _e.hasOwnProperty(et = tt[$++]) || (_e[et] = this[et]);
    return nt.config(_e),
    nt
}
function div$1(_e, $) {
    return new this(_e).div($)
}
function exp(_e) {
    return new this(_e).exp()
}
function floor$2(_e) {
    return finalise(_e = new this(_e), _e.e + 1, 3)
}
function hypot() {
    var _e, $, et = new this(0);
    for (external = !1,
    _e = 0; _e < arguments.length; )
        if ($ = new this(arguments[_e++]),
        $.d)
            et.d && (et = et.plus($.times($)));
        else {
            if ($.s)
                return external = !0,
                new this(1 / 0);
            et = $
        }
    return external = !0,
    et.sqrt()
}
function isDecimalInstance(_e) {
    return _e instanceof Decimal || _e && _e.toStringTag === tag || !1
}
function ln(_e) {
    return new this(_e).ln()
}
function log(_e, $) {
    return new this(_e).log($)
}
function log2(_e) {
    return new this(_e).log(2)
}
function log10(_e) {
    return new this(_e).log(10)
}
function max$2() {
    return maxOrMin(this, arguments, -1)
}
function min$3() {
    return maxOrMin(this, arguments, 1)
}
function mod(_e, $) {
    return new this(_e).mod($)
}
function mul(_e, $) {
    return new this(_e).mul($)
}
function pow$1(_e, $) {
    return new this(_e).pow($)
}
function random(_e) {
    var $, et, tt, nt, rt = 0, it = new this(1), ot = [];
    if (_e === void 0 ? _e = this.precision : checkInt32(_e, 1, MAX_DIGITS),
    tt = Math.ceil(_e / LOG_BASE),
    this.crypto)
        if (crypto.getRandomValues)
            for ($ = crypto.getRandomValues(new Uint32Array(tt)); rt < tt; )
                nt = $[rt],
                nt >= 429e7 ? $[rt] = crypto.getRandomValues(new Uint32Array(1))[0] : ot[rt++] = nt % 1e7;
        else if (crypto.randomBytes) {
            for ($ = crypto.randomBytes(tt *= 4); rt < tt; )
                nt = $[rt] + ($[rt + 1] << 8) + ($[rt + 2] << 16) + (($[rt + 3] & 127) << 24),
                nt >= 214e7 ? crypto.randomBytes(4).copy($, rt) : (ot.push(nt % 1e7),
                rt += 4);
            rt = tt / 4
        } else
            throw Error(cryptoUnavailable);
    else
        for (; rt < tt; )
            ot[rt++] = Math.random() * 1e7 | 0;
    for (tt = ot[--rt],
    _e %= LOG_BASE,
    tt && _e && (nt = mathpow(10, LOG_BASE - _e),
    ot[rt] = (tt / nt | 0) * nt); ot[rt] === 0; rt--)
        ot.pop();
    if (rt < 0)
        et = 0,
        ot = [0];
    else {
        for (et = -1; ot[0] === 0; et -= LOG_BASE)
            ot.shift();
        for (tt = 1,
        nt = ot[0]; nt >= 10; nt /= 10)
            tt++;
        tt < LOG_BASE && (et -= LOG_BASE - tt)
    }
    return it.e = et,
    it.d = ot,
    it
}
function round(_e) {
    return finalise(_e = new this(_e), _e.e + 1, this.rounding)
}
function sign(_e) {
    return _e = new this(_e),
    _e.d ? _e.d[0] ? _e.s : 0 * _e.s : _e.s || NaN
}
function sin(_e) {
    return new this(_e).sin()
}
function sinh(_e) {
    return new this(_e).sinh()
}
function sqrt(_e) {
    return new this(_e).sqrt()
}
function sub(_e, $) {
    return new this(_e).sub($)
}
function sum() {
    var _e = 0
      , $ = arguments
      , et = new this($[_e]);
    for (external = !1; et.s && ++_e < $.length; )
        et = et.plus($[_e]);
    return external = !0,
    finalise(et, this.precision, this.rounding)
}
function tan(_e) {
    return new this(_e).tan()
}
function tanh(_e) {
    return new this(_e).tanh()
}
function trunc(_e) {
    return finalise(_e = new this(_e), _e.e + 1, 1)
}
P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
P[Symbol.toStringTag] = "Decimal";
var Decimal = P.constructor = clone$3(DEFAULTS);
LN10 = new Decimal(LN10);
PI = new Decimal(PI);
const formatNativeBalance = (_e, $=4) => Number.isNaN(_e) || !_e ? "" : new Decimal(_e).div(LAMPORTS_PER_SOL).toDecimalPlaces($, Decimal.ROUND_DOWN).toNumber()
  , formatTokenBalance = (_e, $=6) => Number.isNaN(_e) || !_e ? "" : new Decimal(_e).div(Math.pow(10, DEFAULT_TOKEN_DECIMALS)).toDecimalPlaces($, Decimal.ROUND_DOWN).toNumber();
function isNumeric(_e) {
    return _e === "" ? !1 : !Number.isNaN(Number(_e))
}
function checkInputNumberic(_e, $=DEFAULT_PRECISION, et=!1) {
    let tt = "";
    et && (tt = "(\\-|\\+)?");
    const nt = new RegExp(`^${tt}[0-9]{0,${MAX_USER_INTERER - 1}}?(\\.\\d{0,${$}})?$`)
      , rt = new RegExp("^0?(\\.\\d{0," + $ + "})?$");
    return !(!nt.test(_e) && !rt.test(_e))
}
function plus(_e, $) {
    return !isNumeric(_e) || !isNumeric($) ? "0" : new Decimal(_e).plus($).toString()
}
function minus(_e, $) {
    return !isNumeric(_e) || !isNumeric($) ? "0" : new Decimal(_e).minus($).toString()
}
function multipliedBy(_e, $) {
    return !isNumeric(_e) || !isNumeric($) ? "0" : new Decimal(_e).mul($).toString()
}
function div(_e, $) {
    return !isNumeric(_e) || !isNumeric($) ? "0" : new Decimal(_e).div($).toString()
}
function abs(_e) {
    return isNumeric(_e) ? new Decimal(_e).abs().toString() : "0"
}
function isGreaterThan(_e, $) {
    return !isNumeric(_e) || !isNumeric($) ? !1 : new Decimal(_e).greaterThan($)
}
function isGreaterThanOrEqual(_e, $) {
    return !isNumeric(_e) || !isNumeric($) ? !1 : new Decimal(_e).greaterThanOrEqualTo($)
}
function isLessThan(_e, $) {
    return !isNumeric(_e) || !isNumeric($) ? !1 : new Decimal(_e).lessThan($)
}
function isLessThanOrEqualTo(_e, $) {
    return !isNumeric(_e) || !isNumeric($) ? !1 : new Decimal(_e).lessThanOrEqualTo($)
}
function isEqualTo(_e, $) {
    return !isNumeric(_e) || !isNumeric($) ? !1 : new Decimal(_e).equals($)
}
function isZero(_e) {
    if (_e === void 0)
        return !1;
    try {
        return new Decimal(_e).isZero()
    } catch {
        return !1
    }
}
function isPositive(_e) {
    if (_e === void 0 || !isNumeric(_e))
        return !1;
    try {
        return new Decimal(_e).greaterThan(0)
    } catch {
        return !1
    }
}
function isNegative(_e) {
    if (_e === void 0)
        return !1;
    try {
        return new Decimal(_e).isNegative()
    } catch {
        return !1
    }
}
function toDecimalPlaces$1(_e, $=DEFAULT_PRECISION, et=Decimal.ROUND_DOWN) {
    try {
        return new Decimal(_e).toFixed($, et)
    } catch {
        return String(_e || "-")
    }
}
function formatDecimalPlaces(_e, $=DEFAULT_PRECISION) {
    return _e.includes(".") && _e.split(".")[1].length > $ ? toDecimalPlaces$1(_e, $) : _e
}
function translation(_e, $=DEFAULT_PRECISION) {
    let et = Number(_e);
    return !isNaN(et) && String(et).toLowerCase().includes("e") ? et.toFixed($) : _e
}
function getFileSuffix(_e) {
    const $ = _e.lastIndexOf(".");
    return _e.slice($)
}
function getObjectURL(_e) {
    const $ = window;
    let et = null;
    return $.createObjectURL !== void 0 ? et = $.createObjectURL(_e) : $.URL !== void 0 ? et = $.URL.createObjectURL(_e) : $.webkitURL !== void 0 && (et = $.webkitURL.createObjectURL(_e)),
    et
}
function getFullImageUrl(_e) {
    return _e.startsWith("https://") ? _e : _e !== "" ? `https://static.super.exchange/${_e}` : ""
}
function formatLinkUrl(_e) {
    return _e.startsWith("https://") || _e.startsWith("http://") ? _e : _e !== "" ? `https://${_e}` : ""
}
var _isObject = function(_e) {
    return typeof _e == "object" ? _e !== null : typeof _e == "function"
}
  , isObject$d = _isObject
  , _anObject = function(_e) {
    if (!isObject$d(_e))
        throw TypeError(_e + " is not an object!");
    return _e
}
  , _defined = function(_e) {
    if (_e == null)
        throw TypeError("Can't call method on  " + _e);
    return _e
}
  , defined$3 = _defined
  , _toObject = function(_e) {
    return Object(defined$3(_e))
}
  , ceil = Math.ceil
  , floor$1 = Math.floor
  , _toInteger = function(_e) {
    return isNaN(_e = +_e) ? 0 : (_e > 0 ? floor$1 : ceil)(_e)
}
  , toInteger$3 = _toInteger
  , min$2 = Math.min
  , _toLength = function(_e) {
    return _e > 0 ? min$2(toInteger$3(_e), 9007199254740991) : 0
}
  , toInteger$2 = _toInteger
  , defined$2 = _defined
  , _stringAt = function(_e) {
    return function($, et) {
        var tt = String(defined$2($)), nt = toInteger$2(et), rt = tt.length, it, ot;
        return nt < 0 || nt >= rt ? _e ? "" : void 0 : (it = tt.charCodeAt(nt),
        it < 55296 || it > 56319 || nt + 1 === rt || (ot = tt.charCodeAt(nt + 1)) < 56320 || ot > 57343 ? _e ? tt.charAt(nt) : it : _e ? tt.slice(nt, nt + 2) : (it - 55296 << 10) + (ot - 56320) + 65536)
    }
}
  , at = _stringAt(!0)
  , _advanceStringIndex = function(_e, $, et) {
    return $ + (et ? at(_e, $).length : 1)
}
  , toString$3 = {}.toString
  , _cof = function(_e) {
    return toString$3.call(_e).slice(8, -1)
}
  , _wks = {
    exports: {}
}
  , _shared = {
    exports: {}
}
  , _core = {
    exports: {}
}
  , core$4 = _core.exports = {
    version: "2.6.12"
};
typeof __e == "number" && (__e = core$4);
var _coreExports = _core.exports
  , _global = {
    exports: {}
}
  , global$7 = _global.exports = typeof window < "u" && window.Math == Math ? window : typeof self < "u" && self.Math == Math ? self : Function("return this")();
typeof __g == "number" && (__g = global$7);
var _globalExports = _global.exports
  , core$3 = _coreExports
  , global$6 = _globalExports
  , SHARED = "__core-js_shared__"
  , store$1 = global$6[SHARED] || (global$6[SHARED] = {});
(_shared.exports = function(_e, $) {
    return store$1[_e] || (store$1[_e] = $ !== void 0 ? $ : {})
}
)("versions", []).push({
    version: core$3.version,
    mode: "global",
    copyright: " 2020 Denis Pushkarev (zloirock.ru)"
});
var _sharedExports = _shared.exports
  , id$1 = 0
  , px = Math.random()
  , _uid = function(_e) {
    return "Symbol(".concat(_e === void 0 ? "" : _e, ")_", (++id$1 + px).toString(36))
}
  , store = _sharedExports("wks")
  , uid$2 = _uid
  , Symbol$2 = _globalExports.Symbol
  , USE_SYMBOL = typeof Symbol$2 == "function"
  , $exports = _wks.exports = function(_e) {
    return store[_e] || (store[_e] = USE_SYMBOL && Symbol$2[_e] || (USE_SYMBOL ? Symbol$2 : uid$2)("Symbol." + _e))
}
;
$exports.store = store;
var _wksExports = _wks.exports
  , cof$3 = _cof
  , TAG$1 = _wksExports("toStringTag")
  , ARG = cof$3(function() {
    return arguments
}()) == "Arguments"
  , tryGet = function(_e, $) {
    try {
        return _e[$]
    } catch {}
}
  , _classof = function(_e) {
    var $, et, tt;
    return _e === void 0 ? "Undefined" : _e === null ? "Null" : typeof (et = tryGet($ = Object(_e), TAG$1)) == "string" ? et : ARG ? cof$3($) : (tt = cof$3($)) == "Object" && typeof $.callee == "function" ? "Arguments" : tt
}
  , classof$2 = _classof
  , builtinExec = RegExp.prototype.exec
  , _regexpExecAbstract = function(_e, $) {
    var et = _e.exec;
    if (typeof et == "function") {
        var tt = et.call(_e, $);
        if (typeof tt != "object")
            throw new TypeError("RegExp exec method returned something other than an Object or null");
        return tt
    }
    if (classof$2(_e) !== "RegExp")
        throw new TypeError("RegExp#exec called on incompatible receiver");
    return builtinExec.call(_e, $)
}
  , anObject$b = _anObject
  , _flags = function() {
    var _e = anObject$b(this)
      , $ = "";
    return _e.global && ($ += "g"),
    _e.ignoreCase && ($ += "i"),
    _e.multiline && ($ += "m"),
    _e.unicode && ($ += "u"),
    _e.sticky && ($ += "y"),
    $
}
  , regexpFlags = _flags
  , nativeExec = RegExp.prototype.exec
  , nativeReplace = String.prototype.replace
  , patchedExec = nativeExec
  , LAST_INDEX$1 = "lastIndex"
  , UPDATES_LAST_INDEX_WRONG = function() {
    var _e = /a/
      , $ = /b*/g;
    return nativeExec.call(_e, "a"),
    nativeExec.call($, "a"),
    _e[LAST_INDEX$1] !== 0 || $[LAST_INDEX$1] !== 0
}()
  , NPCG_INCLUDED = /()??/.exec("")[1] !== void 0
  , PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;
PATCH && (patchedExec = function($) {
    var et = this, tt, nt, rt, it;
    return NPCG_INCLUDED && (nt = new RegExp("^" + et.source + "$(?!\\s)",regexpFlags.call(et))),
    UPDATES_LAST_INDEX_WRONG && (tt = et[LAST_INDEX$1]),
    rt = nativeExec.call(et, $),
    UPDATES_LAST_INDEX_WRONG && rt && (et[LAST_INDEX$1] = et.global ? rt.index + rt[0].length : tt),
    NPCG_INCLUDED && rt && rt.length > 1 && nativeReplace.call(rt[0], nt, function() {
        for (it = 1; it < arguments.length - 2; it++)
            arguments[it] === void 0 && (rt[it] = void 0)
    }),
    rt
}
);
var _regexpExec = patchedExec, _objectDp = {}, _fails = function(_e) {
    try {
        return !!_e()
    } catch {
        return !0
    }
}, _descriptors = !_fails(function() {
    return Object.defineProperty({}, "a", {
        get: function() {
            return 7
        }
    }).a != 7
}), _domCreate, hasRequired_domCreate;
function require_domCreate() {
    if (hasRequired_domCreate)
        return _domCreate;
    hasRequired_domCreate = 1;
    var _e = _isObject
      , $ = _globalExports.document
      , et = _e($) && _e($.createElement);
    return _domCreate = function(tt) {
        return et ? $.createElement(tt) : {}
    }
    ,
    _domCreate
}
var _ie8DomDefine = !_descriptors && !_fails(function() {
    return Object.defineProperty(require_domCreate()("div"), "a", {
        get: function() {
            return 7
        }
    }).a != 7
})
  , isObject$c = _isObject
  , _toPrimitive = function(_e, $) {
    if (!isObject$c(_e))
        return _e;
    var et, tt;
    if ($ && typeof (et = _e.toString) == "function" && !isObject$c(tt = et.call(_e)) || typeof (et = _e.valueOf) == "function" && !isObject$c(tt = et.call(_e)) || !$ && typeof (et = _e.toString) == "function" && !isObject$c(tt = et.call(_e)))
        return tt;
    throw TypeError("Can't convert object to primitive value")
}
  , anObject$a = _anObject
  , IE8_DOM_DEFINE$1 = _ie8DomDefine
  , toPrimitive$3 = _toPrimitive
  , dP$3 = Object.defineProperty;
_objectDp.f = _descriptors ? Object.defineProperty : function($, et, tt) {
    if (anObject$a($),
    et = toPrimitive$3(et, !0),
    anObject$a(tt),
    IE8_DOM_DEFINE$1)
        try {
            return dP$3($, et, tt)
        } catch {}
    if ("get"in tt || "set"in tt)
        throw TypeError("Accessors not supported!");
    return "value"in tt && ($[et] = tt.value),
    $
}
;
var _propertyDesc = function(_e, $) {
    return {
        enumerable: !(_e & 1),
        configurable: !(_e & 2),
        writable: !(_e & 4),
        value: $
    }
}
  , dP$2 = _objectDp
  , createDesc$3 = _propertyDesc
  , _hide = _descriptors ? function(_e, $, et) {
    return dP$2.f(_e, $, createDesc$3(1, et))
}
: function(_e, $, et) {
    return _e[$] = et,
    _e
}
  , _redefine = {
    exports: {}
}
  , hasOwnProperty$b = {}.hasOwnProperty
  , _has = function(_e, $) {
    return hasOwnProperty$b.call(_e, $)
}
  , _functionToString = _sharedExports("native-function-to-string", Function.toString)
  , global$5 = _globalExports
  , hide$4 = _hide
  , has$6 = _has
  , SRC = _uid("src")
  , $toString$2 = _functionToString
  , TO_STRING$2 = "toString"
  , TPL = ("" + $toString$2).split(TO_STRING$2);
_coreExports.inspectSource = function(_e) {
    return $toString$2.call(_e)
}
;
(_redefine.exports = function(_e, $, et, tt) {
    var nt = typeof et == "function";
    nt && (has$6(et, "name") || hide$4(et, "name", $)),
    _e[$] !== et && (nt && (has$6(et, SRC) || hide$4(et, SRC, _e[$] ? "" + _e[$] : TPL.join(String($)))),
    _e === global$5 ? _e[$] = et : tt ? _e[$] ? _e[$] = et : hide$4(_e, $, et) : (delete _e[$],
    hide$4(_e, $, et)))
}
)(Function.prototype, TO_STRING$2, function() {
    return typeof this == "function" && this[SRC] || $toString$2.call(this)
});
var _redefineExports = _redefine.exports
  , _aFunction = function(_e) {
    if (typeof _e != "function")
        throw TypeError(_e + " is not a function!");
    return _e
}
  , aFunction$3 = _aFunction
  , _ctx = function(_e, $, et) {
    if (aFunction$3(_e),
    $ === void 0)
        return _e;
    switch (et) {
    case 1:
        return function(tt) {
            return _e.call($, tt)
        }
        ;
    case 2:
        return function(tt, nt) {
            return _e.call($, tt, nt)
        }
        ;
    case 3:
        return function(tt, nt, rt) {
            return _e.call($, tt, nt, rt)
        }
    }
    return function() {
        return _e.apply($, arguments)
    }
}
  , global$4 = _globalExports
  , core$2 = _coreExports
  , hide$3 = _hide
  , redefine$4 = _redefineExports
  , ctx$2 = _ctx
  , PROTOTYPE$2 = "prototype"
  , $export$d = function(_e, $, et) {
    var tt = _e & $export$d.F, nt = _e & $export$d.G, rt = _e & $export$d.S, it = _e & $export$d.P, ot = _e & $export$d.B, st = nt ? global$4 : rt ? global$4[$] || (global$4[$] = {}) : (global$4[$] || {})[PROTOTYPE$2], lt = nt ? core$2 : core$2[$] || (core$2[$] = {}), ct = lt[PROTOTYPE$2] || (lt[PROTOTYPE$2] = {}), dt, pt, ht, mt;
    nt && (et = $);
    for (dt in et)
        pt = !tt && st && st[dt] !== void 0,
        ht = (pt ? st : et)[dt],
        mt = ot && pt ? ctx$2(ht, global$4) : it && typeof ht == "function" ? ctx$2(Function.call, ht) : ht,
        st && redefine$4(st, dt, ht, _e & $export$d.U),
        lt[dt] != ht && hide$3(lt, dt, mt),
        it && ct[dt] != ht && (ct[dt] = ht)
};
global$4.core = core$2;
$export$d.F = 1;
$export$d.G = 2;
$export$d.S = 4;
$export$d.P = 8;
$export$d.B = 16;
$export$d.W = 32;
$export$d.U = 64;
$export$d.R = 128;
var _export = $export$d
  , regexpExec$2 = _regexpExec;
_export({}, {
    exec: regexpExec$2
});
var redefine$3 = _redefineExports
  , hide$2 = _hide
  , fails$4 = _fails
  , defined$1 = _defined
  , wks$2 = _wksExports
  , regexpExec$1 = _regexpExec
  , SPECIES$2 = wks$2("species")
  , REPLACE_SUPPORTS_NAMED_GROUPS = !fails$4(function() {
    var _e = /./;
    return _e.exec = function() {
        var $ = [];
        return $.groups = {
            a: "7"
        },
        $
    }
    ,
    "".replace(_e, "$<a>") !== "7"
})
  , SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function() {
    var _e = /(?:)/
      , $ = _e.exec;
    _e.exec = function() {
        return $.apply(this, arguments)
    }
    ;
    var et = "ab".split(_e);
    return et.length === 2 && et[0] === "a" && et[1] === "b"
}()
  , _fixReWks = function(_e, $, et) {
    var tt = wks$2(_e)
      , nt = !fails$4(function() {
        var ct = {};
        return ct[tt] = function() {
            return 7
        }
        ,
        ""[_e](ct) != 7
    })
      , rt = nt ? !fails$4(function() {
        var ct = !1
          , dt = /a/;
        return dt.exec = function() {
            return ct = !0,
            null
        }
        ,
        _e === "split" && (dt.constructor = {},
        dt.constructor[SPECIES$2] = function() {
            return dt
        }
        ),
        dt[tt](""),
        !ct
    }) : void 0;
    if (!nt || !rt || _e === "replace" && !REPLACE_SUPPORTS_NAMED_GROUPS || _e === "split" && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
        var it = /./[tt]
          , ot = et(defined$1, tt, ""[_e], function(dt, pt, ht, mt, yt) {
            return pt.exec === regexpExec$1 ? nt && !yt ? {
                done: !0,
                value: it.call(pt, ht, mt)
            } : {
                done: !0,
                value: dt.call(ht, pt, mt)
            } : {
                done: !1
            }
        })
          , st = ot[0]
          , lt = ot[1];
        redefine$3(String.prototype, _e, st),
        hide$2(RegExp.prototype, tt, $ == 2 ? function(ct, dt) {
            return lt.call(ct, this, dt)
        }
        : function(ct) {
            return lt.call(ct, this)
        }
        )
    }
}
  , anObject$9 = _anObject
  , toObject$7 = _toObject
  , toLength$6 = _toLength
  , toInteger$1 = _toInteger
  , advanceStringIndex$2 = _advanceStringIndex
  , regExpExec$1 = _regexpExecAbstract
  , max$1 = Math.max
  , min$1 = Math.min
  , floor = Math.floor
  , SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g
  , SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g
  , maybeToString = function(_e) {
    return _e === void 0 ? _e : String(_e)
};
_fixReWks("replace", 2, function(_e, $, et, tt) {
    return [function(it, ot) {
        var st = _e(this)
          , lt = it == null ? void 0 : it[$];
        return lt !== void 0 ? lt.call(it, st, ot) : et.call(String(st), it, ot)
    }
    , function(rt, it) {
        var ot = tt(et, rt, this, it);
        if (ot.done)
            return ot.value;
        var st = anObject$9(rt)
          , lt = String(this)
          , ct = typeof it == "function";
        ct || (it = String(it));
        var dt = st.global;
        if (dt) {
            var pt = st.unicode;
            st.lastIndex = 0
        }
        for (var ht = []; ; ) {
            var mt = regExpExec$1(st, lt);
            if (mt === null || (ht.push(mt),
            !dt))
                break;
            var yt = String(mt[0]);
            yt === "" && (st.lastIndex = advanceStringIndex$2(lt, toLength$6(st.lastIndex), pt))
        }
        for (var Et = "", _t = 0, wt = 0; wt < ht.length; wt++) {
            mt = ht[wt];
            for (var St = String(mt[0]), Ct = max$1(min$1(toInteger$1(mt.index), lt.length), 0), Nt = [], Lt = 1; Lt < mt.length; Lt++)
                Nt.push(maybeToString(mt[Lt]));
            var kt = mt.groups;
            if (ct) {
                var Ut = [St].concat(Nt, Ct, lt);
                kt !== void 0 && Ut.push(kt);
                var Jt = String(it.apply(void 0, Ut))
            } else
                Jt = nt(St, lt, Ct, Nt, kt, it);
            Ct >= _t && (Et += lt.slice(_t, Ct) + Jt,
            _t = Ct + St.length)
        }
        return Et + lt.slice(_t)
    }
    ];
    function nt(rt, it, ot, st, lt, ct) {
        var dt = ot + rt.length
          , pt = st.length
          , ht = SUBSTITUTION_SYMBOLS_NO_NAMED;
        return lt !== void 0 && (lt = toObject$7(lt),
        ht = SUBSTITUTION_SYMBOLS),
        et.call(ct, ht, function(mt, yt) {
            var Et;
            switch (yt.charAt(0)) {
            case "$":
                return "$";
            case "&":
                return rt;
            case "`":
                return it.slice(0, ot);
            case "'":
                return it.slice(dt);
            case "<":
                Et = lt[yt.slice(1, -1)];
                break;
            default:
                var _t = +yt;
                if (_t === 0)
                    return mt;
                if (_t > pt) {
                    var wt = floor(_t / 10);
                    return wt === 0 ? mt : wt <= pt ? st[wt - 1] === void 0 ? yt.charAt(1) : st[wt - 1] + yt.charAt(1) : mt
                }
                Et = st[_t - 1]
            }
            return Et === void 0 ? "" : Et
        })
    }
});
var cof$2 = _cof
  , _iobject = Object("z").propertyIsEnumerable(0) ? Object : function(_e) {
    return cof$2(_e) == "String" ? _e.split("") : Object(_e)
}
  , IObject$2 = _iobject
  , defined = _defined
  , _toIobject = function(_e) {
    return IObject$2(defined(_e))
}
  , toInteger = _toInteger
  , max = Math.max
  , min = Math.min
  , _toAbsoluteIndex = function(_e, $) {
    return _e = toInteger(_e),
    _e < 0 ? max(_e + $, 0) : min(_e, $)
}
  , toIObject$6 = _toIobject
  , toLength$5 = _toLength
  , toAbsoluteIndex = _toAbsoluteIndex
  , _arrayIncludes = function(_e) {
    return function($, et, tt) {
        var nt = toIObject$6($), rt = toLength$5(nt.length), it = toAbsoluteIndex(tt, rt), ot;
        if (_e && et != et) {
            for (; rt > it; )
                if (ot = nt[it++],
                ot != ot)
                    return !0
        } else
            for (; rt > it; it++)
                if ((_e || it in nt) && nt[it] === et)
                    return _e || it || 0;
        return !_e && -1
    }
}
  , fails$3 = _fails
  , _strictMethod = function(_e, $) {
    return !!_e && fails$3(function() {
        $ ? _e.call(null, function() {}, 1) : _e.call(null)
    })
}
  , $export$c = _export
  , $indexOf = _arrayIncludes(!1)
  , $native = [].indexOf
  , NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
$export$c($export$c.P + $export$c.F * (NEGATIVE_ZERO || !_strictMethod($native)), "Array", {
    indexOf: function($) {
        return NEGATIVE_ZERO ? $native.apply(this, arguments) || 0 : $indexOf(this, $, arguments[1])
    }
});
var cashtag = /[a-z]{1,6}(?:[._][a-z]{1,2})?/i
  , punct = /\!'#%&'\(\)*\+,\\\-\.\/:;<=>\?@\[\]\^_{|}~\$/
  , _objectGopd = {}
  , _objectPie = {};
_objectPie.f = {}.propertyIsEnumerable;
var pIE$1 = _objectPie
  , createDesc$2 = _propertyDesc
  , toIObject$5 = _toIobject
  , toPrimitive$2 = _toPrimitive
  , has$5 = _has
  , IE8_DOM_DEFINE = _ie8DomDefine
  , gOPD$2 = Object.getOwnPropertyDescriptor;
_objectGopd.f = _descriptors ? gOPD$2 : function($, et) {
    if ($ = toIObject$5($),
    et = toPrimitive$2(et, !0),
    IE8_DOM_DEFINE)
        try {
            return gOPD$2($, et)
        } catch {}
    if (has$5($, et))
        return createDesc$2(!pIE$1.f.call($, et), $[et])
}
;
var isObject$b = _isObject
  , anObject$8 = _anObject
  , check = function(_e, $) {
    if (anObject$8(_e),
    !isObject$b($) && $ !== null)
        throw TypeError($ + ": can't set as prototype!")
}
  , _setProto = {
    set: Object.setPrototypeOf || ("__proto__"in {} ? function(_e, $, et) {
        try {
            et = _ctx(Function.call, _objectGopd.f(Object.prototype, "__proto__").set, 2),
            et(_e, []),
            $ = !(_e instanceof Array)
        } catch {
            $ = !0
        }
        return function(nt, rt) {
            return check(nt, rt),
            $ ? nt.__proto__ = rt : et(nt, rt),
            nt
        }
    }({}, !1) : void 0)
}
  , isObject$a = _isObject
  , setPrototypeOf = _setProto.set
  , _inheritIfRequired = function(_e, $, et) {
    var tt = $.constructor, nt;
    return tt !== et && typeof tt == "function" && (nt = tt.prototype) !== et.prototype && isObject$a(nt) && setPrototypeOf && setPrototypeOf(_e, nt),
    _e
}
  , _objectGopn = {}
  , shared$1 = _sharedExports("keys")
  , uid$1 = _uid
  , _sharedKey = function(_e) {
    return shared$1[_e] || (shared$1[_e] = uid$1(_e))
}
  , has$4 = _has
  , toIObject$4 = _toIobject
  , arrayIndexOf = _arrayIncludes(!1)
  , IE_PROTO$2 = _sharedKey("IE_PROTO")
  , _objectKeysInternal = function(_e, $) {
    var et = toIObject$4(_e), tt = 0, nt = [], rt;
    for (rt in et)
        rt != IE_PROTO$2 && has$4(et, rt) && nt.push(rt);
    for (; $.length > tt; )
        has$4(et, rt = $[tt++]) && (~arrayIndexOf(nt, rt) || nt.push(rt));
    return nt
}
  , _enumBugKeys = "constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")
  , $keys$3 = _objectKeysInternal
  , hiddenKeys = _enumBugKeys.concat("length", "prototype");
_objectGopn.f = Object.getOwnPropertyNames || function($) {
    return $keys$3($, hiddenKeys)
}
;
var isObject$9 = _isObject, cof$1 = _cof, MATCH = _wksExports("match"), _isRegexp = function(_e) {
    var $;
    return isObject$9(_e) && (($ = _e[MATCH]) !== void 0 ? !!$ : cof$1(_e) == "RegExp")
}, _setSpecies, hasRequired_setSpecies;
function require_setSpecies() {
    if (hasRequired_setSpecies)
        return _setSpecies;
    hasRequired_setSpecies = 1;
    var _e = _globalExports
      , $ = _objectDp
      , et = _descriptors
      , tt = _wksExports("species");
    return _setSpecies = function(nt) {
        var rt = _e[nt];
        et && rt && !rt[tt] && $.f(rt, tt, {
            configurable: !0,
            get: function() {
                return this
            }
        })
    }
    ,
    _setSpecies
}
var global$3 = _globalExports
  , inheritIfRequired = _inheritIfRequired
  , dP$1 = _objectDp.f
  , gOPN$3 = _objectGopn.f
  , isRegExp$2 = _isRegexp
  , $flags$1 = _flags
  , $RegExp = global$3.RegExp
  , Base = $RegExp
  , proto$1 = $RegExp.prototype
  , re1 = /a/g
  , re2 = /a/g
  , CORRECT_NEW = new $RegExp(re1) !== re1;
if (_descriptors && (!CORRECT_NEW || _fails(function() {
    return re2[_wksExports("match")] = !1,
    $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, "i") != "/a/i"
}))) {
    $RegExp = function($, et) {
        var tt = this instanceof $RegExp
          , nt = isRegExp$2($)
          , rt = et === void 0;
        return !tt && nt && $.constructor === $RegExp && rt ? $ : inheritIfRequired(CORRECT_NEW ? new Base(nt && !rt ? $.source : $,et) : Base((nt = $ instanceof $RegExp) ? $.source : $, nt && rt ? $flags$1.call($) : et), tt ? this : proto$1, $RegExp)
    }
    ;
    for (var proxy = function(_e) {
        _e in $RegExp || dP$1($RegExp, _e, {
            configurable: !0,
            get: function() {
                return Base[_e]
            },
            set: function($) {
                Base[_e] = $
            }
        })
    }, keys$1 = gOPN$3(Base), i$1 = 0; keys$1.length > i$1; )
        proxy(keys$1[i$1++]);
    proto$1.constructor = $RegExp,
    $RegExp.prototype = proto$1,
    _redefineExports(global$3, "RegExp", $RegExp)
}
require_setSpecies()("RegExp");
function regexSupplant(_e, $, et) {
    return et = et || "",
    typeof _e != "string" && (_e.global && et.indexOf("g") < 0 && (et += "g"),
    _e.ignoreCase && et.indexOf("i") < 0 && (et += "i"),
    _e.multiline && et.indexOf("m") < 0 && (et += "m"),
    _e = _e.source),
    new RegExp(_e.replace(/#\{(\w+)\}/g, function(tt, nt) {
        var rt = $[nt] || "";
        return typeof rt != "string" && (rt = rt.source),
        rt
    }),et)
}
var spacesGroup = /\x09-\x0D\x20\x85\xA0\u1680\u180E\u2000-\u200A\u2028\u2029\u202F\u205F\u3000/;
const spaces = regexSupplant(/[#{spacesGroup}]/, {
    spacesGroup
});
var validCashtag = regexSupplant("(^|#{spaces})(\\$)(#{cashtag})(?=$|\\s|[#{punct}])", {
    cashtag,
    spaces,
    punct
}, "gi");
function extractCashtagsWithIndices(_e) {
    if (!_e || _e.indexOf("$") === -1)
        return [];
    var $ = [];
    return _e.replace(validCashtag, function(et, tt, nt, rt, it, ot) {
        var st = it + tt.length
          , lt = st + rt.length + 1;
        $.push({
            cashtag: rt,
            indices: [st, lt]
        })
    }),
    $
}
var anObject$7 = _anObject
  , toLength$4 = _toLength
  , advanceStringIndex$1 = _advanceStringIndex
  , regExpExec = _regexpExecAbstract;
_fixReWks("match", 1, function(_e, $, et, tt) {
    return [function(rt) {
        var it = _e(this)
          , ot = rt == null ? void 0 : rt[$];
        return ot !== void 0 ? ot.call(rt, it) : new RegExp(rt)[$](String(it))
    }
    , function(nt) {
        var rt = tt(et, nt, this);
        if (rt.done)
            return rt.value;
        var it = anObject$7(nt)
          , ot = String(this);
        if (!it.global)
            return regExpExec(it, ot);
        var st = it.unicode;
        it.lastIndex = 0;
        for (var lt = [], ct = 0, dt; (dt = regExpExec(it, ot)) !== null; ) {
            var pt = String(dt[0]);
            lt[ct] = pt,
            pt === "" && (it.lastIndex = advanceStringIndex$1(ot, toLength$4(it.lastIndex), st)),
            ct++
        }
        return ct === 0 ? null : lt
    }
    ]
});
var hashSigns = /[#]/
  , endHashtagMatch = regexSupplant(/^(?:#{hashSigns}|:\/\/)/, {
    hashSigns
})
  , validCCTLD = regexSupplant(RegExp("(?:(?:||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||zw|zm|za|yt|ye|ws|wf|vu|vn|vi|vg|ve|vc|va|uz|uy|us|um|uk|ug|ua|tz|tw|tv|tt|tr|tp|to|tn|tm|tl|tk|tj|th|tg|tf|td|tc|sz|sy|sx|sv|su|st|ss|sr|so|sn|sm|sl|sk|sj|si|sh|sg|se|sd|sc|sb|sa|rw|ru|rs|ro|re|qa|py|pw|pt|ps|pr|pn|pm|pl|pk|ph|pg|pf|pe|pa|om|nz|nu|nr|np|no|nl|ni|ng|nf|ne|nc|na|mz|my|mx|mw|mv|mu|mt|ms|mr|mq|mp|mo|mn|mm|ml|mk|mh|mg|mf|me|md|mc|ma|ly|lv|lu|lt|ls|lr|lk|li|lc|lb|la|kz|ky|kw|kr|kp|kn|km|ki|kh|kg|ke|jp|jo|jm|je|it|is|ir|iq|io|in|im|il|ie|id|hu|ht|hr|hn|hm|hk|gy|gw|gu|gt|gs|gr|gq|gp|gn|gm|gl|gi|gh|gg|gf|ge|gd|gb|ga|fr|fo|fm|fk|fj|fi|eu|et|es|er|eh|eg|ee|ec|dz|do|dm|dk|dj|de|cz|cy|cx|cw|cv|cu|cr|co|cn|cm|cl|ck|ci|ch|cg|cf|cd|cc|ca|bz|by|bw|bv|bt|bs|br|bq|bo|bn|bm|bl|bj|bi|bh|bg|bf|be|bd|bb|ba|az|ax|aw|au|at|as|ar|aq|ao|an|am|al|ai|ag|af|ae|ad|ac)(?=[^0-9a-zA-Z@+-]|$))"))
  , directionalMarkersGroup = /\u202A-\u202E\u061C\u200E\u200F\u2066\u2067\u2068\u2069/
  , invalidCharsGroup = /\uFFFE\uFEFF\uFFFF/;
function stringSupplant(_e, $) {
    return _e.replace(/#\{(\w+)\}/g, function(et, tt) {
        return $[tt] || ""
    })
}
var invalidDomainChars = stringSupplant("#{punct}#{spacesGroup}#{invalidCharsGroup}#{directionalMarkersGroup}", {
    punct,
    spacesGroup,
    invalidCharsGroup,
    directionalMarkersGroup
})
  , validDomainChars = regexSupplant(/[^#{invalidDomainChars}]/, {
    invalidDomainChars
})
  , validDomainName = regexSupplant(/(?:(?:#{validDomainChars}(?:-|#{validDomainChars})*)?#{validDomainChars}\.)/, {
    validDomainChars
})
  , validGTLD = regexSupplant(RegExp("(?:(?:|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||zuerich|zone|zippo|zip|zero|zara|zappos|yun|youtube|you|yokohama|yoga|yodobashi|yandex|yamaxun|yahoo|yachts|xyz|xxx|xperia|xin|xihuan|xfinity|xerox|xbox|wtf|wtc|wow|world|works|work|woodside|wolterskluwer|wme|winners|wine|windows|win|williamhill|wiki|wien|whoswho|weir|weibo|wedding|wed|website|weber|webcam|weatherchannel|weather|watches|watch|warman|wanggou|wang|walter|walmart|wales|vuelos|voyage|voto|voting|vote|volvo|volkswagen|vodka|vlaanderen|vivo|viva|vistaprint|vista|vision|visa|virgin|vip|vin|villas|viking|vig|video|viajes|vet|versicherung|vermgensberatung|vermgensberater|verisign|ventures|vegas|vanguard|vana|vacations|ups|uol|uno|university|unicom|uconnect|ubs|ubank|tvs|tushu|tunes|tui|tube|trv|trust|travelersinsurance|travelers|travelchannel|travel|training|trading|trade|toys|toyota|town|tours|total|toshiba|toray|top|tools|tokyo|today|tmall|tkmaxx|tjx|tjmaxx|tirol|tires|tips|tiffany|tienda|tickets|tiaa|theatre|theater|thd|teva|tennis|temasek|telefonica|telecity|tel|technology|tech|team|tdk|tci|taxi|tax|tattoo|tatar|tatamotors|target|taobao|talk|taipei|tab|systems|symantec|sydney|swiss|swiftcover|swatch|suzuki|surgery|surf|support|supply|supplies|sucks|style|study|studio|stream|store|storage|stockholm|stcgroup|stc|statoil|statefarm|statebank|starhub|star|staples|stada|srt|srl|spreadbetting|spot|sport|spiegel|space|soy|sony|song|solutions|solar|sohu|software|softbank|social|soccer|sncf|smile|smart|sling|skype|sky|skin|ski|site|singles|sina|silk|shriram|showtime|show|shouji|shopping|shop|shoes|shiksha|shia|shell|shaw|sharp|shangrila|sfr|sexy|sex|sew|seven|ses|services|sener|select|seek|security|secure|seat|search|scot|scor|scjohnson|science|schwarz|schule|school|scholarships|schmidt|schaeffler|scb|sca|sbs|sbi|saxo|save|sas|sarl|sapo|sap|sanofi|sandvikcoromant|sandvik|samsung|samsclub|salon|sale|sakura|safety|safe|saarland|ryukyu|rwe|run|ruhr|rugby|rsvp|room|rogers|rodeo|rocks|rocher|rmit|rip|rio|ril|rightathome|ricoh|richardli|rich|rexroth|reviews|review|restaurant|rest|republican|report|repair|rentals|rent|ren|reliance|reit|reisen|reise|rehab|redumbrella|redstone|red|recipes|realty|realtor|realestate|read|raid|radio|racing|qvc|quest|quebec|qpon|pwc|pub|prudential|pru|protection|property|properties|promo|progressive|prof|productions|prod|pro|prime|press|praxi|pramerica|post|porn|politie|poker|pohl|pnc|plus|plumbing|playstation|play|place|pizza|pioneer|pink|ping|pin|pid|pictures|pictet|pics|piaget|physio|photos|photography|photo|phone|philips|phd|pharmacy|pfizer|pet|pccw|pay|passagens|party|parts|partners|pars|paris|panerai|panasonic|pamperedchef|page|ovh|ott|otsuka|osaka|origins|orientexpress|organic|org|orange|oracle|open|ooo|onyourside|online|onl|ong|one|omega|ollo|oldnavy|olayangroup|olayan|okinawa|office|off|observer|obi|nyc|ntt|nrw|nra|nowtv|nowruz|now|norton|northwesternmutual|nokia|nissay|nissan|ninja|nikon|nike|nico|nhk|ngo|nfl|nexus|nextdirect|next|news|newholland|new|neustar|network|netflix|netbank|net|nec|nba|navy|natura|nationwide|name|nagoya|nadex|nab|mutuelle|mutual|museum|mtr|mtpc|mtn|msd|movistar|movie|mov|motorcycles|moto|moscow|mortgage|mormon|mopar|montblanc|monster|money|monash|mom|moi|moe|moda|mobily|mobile|mobi|mma|mls|mlb|mitsubishi|mit|mint|mini|mil|microsoft|miami|metlife|merckmsd|meo|menu|men|memorial|meme|melbourne|meet|media|med|mckinsey|mcdonalds|mcd|mba|mattel|maserati|marshalls|marriott|markets|marketing|market|map|mango|management|man|makeup|maison|maif|madrid|macys|luxury|luxe|lupin|lundbeck|ltda|ltd|lplfinancial|lpl|love|lotto|lotte|london|lol|loft|locus|locker|loans|loan|llp|llc|lixil|living|live|lipsy|link|linde|lincoln|limo|limited|lilly|like|lighting|lifestyle|lifeinsurance|life|lidl|liaison|lgbt|lexus|lego|legal|lefrak|leclerc|lease|lds|lawyer|law|latrobe|latino|lat|lasalle|lanxess|landrover|land|lancome|lancia|lancaster|lamer|lamborghini|ladbrokes|lacaixa|kyoto|kuokgroup|kred|krd|kpn|kpmg|kosher|komatsu|koeln|kiwi|kitchen|kindle|kinder|kim|kia|kfh|kerryproperties|kerrylogistics|kerryhotels|kddi|kaufen|juniper|juegos|jprs|jpmorgan|joy|jot|joburg|jobs|jnj|jmp|jll|jlc|jio|jewelry|jetzt|jeep|jcp|jcb|java|jaguar|iwc|iveco|itv|itau|istanbul|ist|ismaili|iselect|irish|ipiranga|investments|intuit|international|intel|int|insure|insurance|institute|ink|ing|info|infiniti|industries|inc|immobilien|immo|imdb|imamat|ikano|iinet|ifm|ieee|icu|ice|icbc|ibm|hyundai|hyatt|hughes|htc|hsbc|how|house|hotmail|hotels|hoteles|hot|hosting|host|hospital|horse|honeywell|honda|homesense|homes|homegoods|homedepot|holiday|holdings|hockey|hkt|hiv|hitachi|hisamitsu|hiphop|hgtv|hermes|here|helsinki|help|healthcare|health|hdfcbank|hdfc|hbo|haus|hangout|hamburg|hair|guru|guitars|guide|guge|gucci|guardian|group|grocery|gripe|green|gratis|graphics|grainger|gov|got|gop|google|goog|goodyear|goodhands|goo|golf|goldpoint|gold|godaddy|gmx|gmo|gmbh|gmail|globo|global|gle|glass|glade|giving|gives|gifts|gift|ggee|george|genting|gent|gea|gdn|gbiz|gay|garden|gap|games|game|gallup|gallo|gallery|gal|fyi|futbol|furniture|fund|fun|fujixerox|fujitsu|ftr|frontier|frontdoor|frogans|frl|fresenius|free|fox|foundation|forum|forsale|forex|ford|football|foodnetwork|food|foo|fly|flsmidth|flowers|florist|flir|flights|flickr|fitness|fit|fishing|fish|firmdale|firestone|fire|financial|finance|final|film|fido|fidelity|fiat|ferrero|ferrari|feedback|fedex|fast|fashion|farmers|farm|fans|fan|family|faith|fairwinds|fail|fage|extraspace|express|exposed|expert|exchange|everbank|events|eus|eurovision|etisalat|esurance|estate|esq|erni|ericsson|equipment|epson|epost|enterprises|engineering|engineer|energy|emerck|email|education|edu|edeka|eco|eat|earth|dvr|dvag|durban|dupont|duns|dunlop|duck|dubai|dtv|drive|download|dot|doosan|domains|doha|dog|dodge|doctor|docs|dnp|diy|dish|discover|discount|directory|direct|digital|diet|diamonds|dhl|dev|design|desi|dentist|dental|democrat|delta|deloitte|dell|delivery|degree|deals|dealer|deal|dds|dclk|day|datsun|dating|date|data|dance|dad|dabur|cyou|cymru|cuisinella|csc|cruises|cruise|crs|crown|cricket|creditunion|creditcard|credit|cpa|courses|coupons|coupon|country|corsica|coop|cool|cookingchannel|cooking|contractors|contact|consulting|construction|condos|comsec|computer|compare|company|community|commbank|comcast|com|cologne|college|coffee|codes|coach|clubmed|club|cloud|clothing|clinique|clinic|click|cleaning|claims|cityeats|city|citic|citi|citadel|cisco|circle|cipriani|church|chrysler|chrome|christmas|chloe|chintai|cheap|chat|chase|charity|channel|chanel|cfd|cfa|cern|ceo|center|ceb|cbs|cbre|cbn|cba|catholic|catering|cat|casino|cash|caseih|case|casa|cartier|cars|careers|career|care|cards|caravan|car|capitalone|capital|capetown|canon|cancerresearch|camp|camera|cam|calvinklein|call|cal|cafe|cab|bzh|buzz|buy|business|builders|build|bugatti|budapest|brussels|brother|broker|broadway|bridgestone|bradesco|box|boutique|bot|boston|bostik|bosch|boots|booking|book|boo|bond|bom|bofa|boehringer|boats|bnpparibas|bnl|bmw|bms|blue|bloomberg|blog|blockbuster|blanco|blackfriday|black|biz|bio|bingo|bing|bike|bid|bible|bharti|bet|bestbuy|best|berlin|bentley|beer|beauty|beats|bcn|bcg|bbva|bbt|bbc|bayern|bauhaus|basketball|baseball|bargains|barefoot|barclays|barclaycard|barcelona|bar|bank|band|bananarepublic|banamex|baidu|baby|azure|axa|aws|avianca|autos|auto|author|auspost|audio|audible|audi|auction|attorney|athleta|associates|asia|asda|arte|art|arpa|army|archi|aramco|arab|aquarelle|apple|app|apartments|aol|anz|anquan|android|analytics|amsterdam|amica|amfam|amex|americanfamily|americanexpress|alstom|alsace|ally|allstate|allfinanz|alipay|alibaba|alfaromeo|akdn|airtel|airforce|airbus|aigo|aig|agency|agakhan|africa|afl|afamilycompany|aetna|aero|aeg|adult|ads|adac|actor|active|aco|accountants|accountant|accenture|academy|abudhabi|abogado|able|abc|abbvie|abbott|abb|abarth|aarp|aaa|onion)(?=[^0-9a-zA-Z@+-]|$))"))
  , validPunycode = /(?:xn--[\-0-9a-z]+)/
  , validSubdomain = regexSupplant(/(?:(?:#{validDomainChars}(?:[_-]|#{validDomainChars})*)?#{validDomainChars}\.)/, {
    validDomainChars
})
  , validDomain = regexSupplant(/(?:#{validSubdomain}*#{validDomainName}(?:#{validGTLD}|#{validCCTLD}|#{validPunycode}))/, {
    validDomainName,
    validSubdomain,
    validGTLD,
    validCCTLD,
    validPunycode
})
  , validPortNumber = /[0-9]+/
  , cyrillicLettersAndMarks = /\u0400-\u04FF/
  , latinAccentChars = /\xC0-\xD6\xD8-\xF6\xF8-\xFF\u0100-\u024F\u0253\u0254\u0256\u0257\u0259\u025B\u0263\u0268\u026F\u0272\u0289\u028B\u02BB\u0300-\u036F\u1E00-\u1EFF/
  , validGeneralUrlPathChars = regexSupplant(/[a-z#{cyrillicLettersAndMarks}0-9!\*';:=\+,\.\$\/%#\[\]\-\u2013_~@\|&#{latinAccentChars}]/i, {
    cyrillicLettersAndMarks,
    latinAccentChars
})
  , validUrlBalancedParens = regexSupplant("\\((?:#{validGeneralUrlPathChars}+|(?:#{validGeneralUrlPathChars}*\\(#{validGeneralUrlPathChars}+\\)#{validGeneralUrlPathChars}*))\\)", {
    validGeneralUrlPathChars
}, "i")
  , validUrlPathEndingChars = regexSupplant(/[\+\-a-z#{cyrillicLettersAndMarks}0-9=_#\/#{latinAccentChars}]|(?:#{validUrlBalancedParens})/i, {
    cyrillicLettersAndMarks,
    latinAccentChars,
    validUrlBalancedParens
})
  , validUrlPath = regexSupplant("(?:(?:#{validGeneralUrlPathChars}*(?:#{validUrlBalancedParens}#{validGeneralUrlPathChars}*)*#{validUrlPathEndingChars})|(?:@#{validGeneralUrlPathChars}+/))", {
    validGeneralUrlPathChars,
    validUrlBalancedParens,
    validUrlPathEndingChars
}, "i")
  , validUrlPrecedingChars = regexSupplant(/(?:[^A-Za-z0-9@$##{invalidCharsGroup}]|[#{directionalMarkersGroup}]|^)/, {
    invalidCharsGroup,
    directionalMarkersGroup
})
  , validUrlQueryChars = /[a-z0-9!?\*'@\(\);:&=\+\$\/%#\[\]\-_\.,~|]/i
  , validUrlQueryEndingChars = /[a-z0-9\-_&=#\/]/i
  , extractUrl = regexSupplant("((#{validUrlPrecedingChars})((https?:\\/\\/)?(#{validDomain})(?::(#{validPortNumber}))?(\\/#{validUrlPath}*)?(\\?#{validUrlQueryChars}*#{validUrlQueryEndingChars})?))", {
    validUrlPrecedingChars,
    validDomain,
    validPortNumber,
    validUrlPath,
    validUrlQueryChars,
    validUrlQueryEndingChars
}, "gi")
  , invalidUrlWithoutProtocolPrecedingChars = /[-_.\/]$/
  , anObject$6 = _anObject
  , aFunction$2 = _aFunction
  , SPECIES$1 = _wksExports("species")
  , _speciesConstructor = function(_e, $) {
    var et = anObject$6(_e).constructor, tt;
    return et === void 0 || (tt = anObject$6(et)[SPECIES$1]) == null ? $ : aFunction$2(tt)
}
  , isRegExp$1 = _isRegexp
  , anObject$5 = _anObject
  , speciesConstructor$1 = _speciesConstructor
  , advanceStringIndex = _advanceStringIndex
  , toLength$3 = _toLength
  , callRegExpExec = _regexpExecAbstract
  , regexpExec = _regexpExec
  , fails$2 = _fails
  , $min = Math.min
  , $push = [].push
  , $SPLIT = "split"
  , LENGTH = "length"
  , LAST_INDEX = "lastIndex"
  , MAX_UINT32 = 4294967295
  , SUPPORTS_Y = !fails$2(function() {
    RegExp(MAX_UINT32, "y")
});
_fixReWks("split", 2, function(_e, $, et, tt) {
    var nt;
    return "abbc"[$SPLIT](/(b)*/)[1] == "c" || "test"[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || "ab"[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || "."[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || "."[$SPLIT](/()()/)[LENGTH] > 1 || ""[$SPLIT](/.?/)[LENGTH] ? nt = function(rt, it) {
        var ot = String(this);
        if (rt === void 0 && it === 0)
            return [];
        if (!isRegExp$1(rt))
            return et.call(ot, rt, it);
        for (var st = [], lt = (rt.ignoreCase ? "i" : "") + (rt.multiline ? "m" : "") + (rt.unicode ? "u" : "") + (rt.sticky ? "y" : ""), ct = 0, dt = it === void 0 ? MAX_UINT32 : it >>> 0, pt = new RegExp(rt.source,lt + "g"), ht, mt, yt; (ht = regexpExec.call(pt, ot)) && (mt = pt[LAST_INDEX],
        !(mt > ct && (st.push(ot.slice(ct, ht.index)),
        ht[LENGTH] > 1 && ht.index < ot[LENGTH] && $push.apply(st, ht.slice(1)),
        yt = ht[0][LENGTH],
        ct = mt,
        st[LENGTH] >= dt))); )
            pt[LAST_INDEX] === ht.index && pt[LAST_INDEX]++;
        return ct === ot[LENGTH] ? (yt || !pt.test("")) && st.push("") : st.push(ot.slice(ct)),
        st[LENGTH] > dt ? st.slice(0, dt) : st
    }
    : "0"[$SPLIT](void 0, 0)[LENGTH] ? nt = function(rt, it) {
        return rt === void 0 && it === 0 ? [] : et.call(this, rt, it)
    }
    : nt = et,
    [function(it, ot) {
        var st = _e(this)
          , lt = it == null ? void 0 : it[$];
        return lt !== void 0 ? lt.call(it, st, ot) : nt.call(String(st), it, ot)
    }
    , function(rt, it) {
        var ot = tt(nt, rt, this, it, nt !== et);
        if (ot.done)
            return ot.value;
        var st = anObject$5(rt)
          , lt = String(this)
          , ct = speciesConstructor$1(st, RegExp)
          , dt = st.unicode
          , pt = (st.ignoreCase ? "i" : "") + (st.multiline ? "m" : "") + (st.unicode ? "u" : "") + (SUPPORTS_Y ? "y" : "g")
          , ht = new ct(SUPPORTS_Y ? st : "^(?:" + st.source + ")",pt)
          , mt = it === void 0 ? MAX_UINT32 : it >>> 0;
        if (mt === 0)
            return [];
        if (lt.length === 0)
            return callRegExpExec(ht, lt) === null ? [lt] : [];
        for (var yt = 0, Et = 0, _t = []; Et < lt.length; ) {
            ht.lastIndex = SUPPORTS_Y ? Et : 0;
            var wt = callRegExpExec(ht, SUPPORTS_Y ? lt : lt.slice(Et)), St;
            if (wt === null || (St = $min(toLength$3(ht.lastIndex + (SUPPORTS_Y ? 0 : Et)), lt.length)) === yt)
                Et = advanceStringIndex(lt, Et, dt);
            else {
                if (_t.push(lt.slice(yt, Et)),
                _t.length === mt)
                    return _t;
                for (var Ct = 1; Ct <= wt.length - 1; Ct++)
                    if (_t.push(wt[Ct]),
                    _t.length === mt)
                        return _t;
                Et = yt = St
            }
        }
        return _t.push(lt.slice(yt)),
        _t
    }
    ]
});
var punycode = {
    exports: {}
};
/*! https://mths.be/punycode v1.4.1 by @mathias */
punycode.exports;
(function(_e, $) {
    (function(et) {
        var tt = $ && !$.nodeType && $
          , nt = _e && !_e.nodeType && _e
          , rt = typeof globalThis == "object" && globalThis;
        (rt.global === rt || rt.window === rt || rt.self === rt) && (et = rt);
        var it, ot = 2147483647, st = 36, lt = 1, ct = 26, dt = 38, pt = 700, ht = 72, mt = 128, yt = "-", Et = /^xn--/, _t = /[^\x20-\x7E]/, wt = /[\x2E\u3002\uFF0E\uFF61]/g, St = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        }, Ct = st - lt, Nt = Math.floor, Lt = String.fromCharCode, kt;
        function Ut(qt) {
            throw new RangeError(St[qt])
        }
        function Jt(qt, Wt) {
            for (var Mt = qt.length, Yt = []; Mt--; )
                Yt[Mt] = Wt(qt[Mt]);
            return Yt
        }
        function Pt(qt, Wt) {
            var Mt = qt.split("@")
              , Yt = "";
            Mt.length > 1 && (Yt = Mt[0] + "@",
            qt = Mt[1]),
            qt = qt.replace(wt, ".");
            var un = qt.split(".")
              , hn = Jt(un, Wt).join(".");
            return Yt + hn
        }
        function Xt(qt) {
            for (var Wt = [], Mt = 0, Yt = qt.length, un, hn; Mt < Yt; )
                un = qt.charCodeAt(Mt++),
                un >= 55296 && un <= 56319 && Mt < Yt ? (hn = qt.charCodeAt(Mt++),
                (hn & 64512) == 56320 ? Wt.push(((un & 1023) << 10) + (hn & 1023) + 65536) : (Wt.push(un),
                Mt--)) : Wt.push(un);
            return Wt
        }
        function rn(qt) {
            return Jt(qt, function(Wt) {
                var Mt = "";
                return Wt > 65535 && (Wt -= 65536,
                Mt += Lt(Wt >>> 10 & 1023 | 55296),
                Wt = 56320 | Wt & 1023),
                Mt += Lt(Wt),
                Mt
            }).join("")
        }
        function zt(qt) {
            return qt - 48 < 10 ? qt - 22 : qt - 65 < 26 ? qt - 65 : qt - 97 < 26 ? qt - 97 : st
        }
        function xt(qt, Wt) {
            return qt + 22 + 75 * (qt < 26) - ((Wt != 0) << 5)
        }
        function $t(qt, Wt, Mt) {
            var Yt = 0;
            for (qt = Mt ? Nt(qt / pt) : qt >> 1,
            qt += Nt(qt / Wt); qt > Ct * ct >> 1; Yt += st)
                qt = Nt(qt / Ct);
            return Nt(Yt + (Ct + 1) * qt / (qt + dt))
        }
        function Dt(qt) {
            var Wt = [], Mt = qt.length, Yt, un = 0, hn = mt, _n = ht, kn, Dn, jn, Bn, Un, Hn, cr, Gn, Mn;
            for (kn = qt.lastIndexOf(yt),
            kn < 0 && (kn = 0),
            Dn = 0; Dn < kn; ++Dn)
                qt.charCodeAt(Dn) >= 128 && Ut("not-basic"),
                Wt.push(qt.charCodeAt(Dn));
            for (jn = kn > 0 ? kn + 1 : 0; jn < Mt; ) {
                for (Bn = un,
                Un = 1,
                Hn = st; jn >= Mt && Ut("invalid-input"),
                cr = zt(qt.charCodeAt(jn++)),
                (cr >= st || cr > Nt((ot - un) / Un)) && Ut("overflow"),
                un += cr * Un,
                Gn = Hn <= _n ? lt : Hn >= _n + ct ? ct : Hn - _n,
                !(cr < Gn); Hn += st)
                    Mn = st - Gn,
                    Un > Nt(ot / Mn) && Ut("overflow"),
                    Un *= Mn;
                Yt = Wt.length + 1,
                _n = $t(un - Bn, Yt, Bn == 0),
                Nt(un / Yt) > ot - hn && Ut("overflow"),
                hn += Nt(un / Yt),
                un %= Yt,
                Wt.splice(un++, 0, hn)
            }
            return rn(Wt)
        }
        function jt(qt) {
            var Wt, Mt, Yt, un, hn, _n, kn, Dn, jn, Bn, Un, Hn = [], cr, Gn, Mn, rr;
            for (qt = Xt(qt),
            cr = qt.length,
            Wt = mt,
            Mt = 0,
            hn = ht,
            _n = 0; _n < cr; ++_n)
                Un = qt[_n],
                Un < 128 && Hn.push(Lt(Un));
            for (Yt = un = Hn.length,
            un && Hn.push(yt); Yt < cr; ) {
                for (kn = ot,
                _n = 0; _n < cr; ++_n)
                    Un = qt[_n],
                    Un >= Wt && Un < kn && (kn = Un);
                for (Gn = Yt + 1,
                kn - Wt > Nt((ot - Mt) / Gn) && Ut("overflow"),
                Mt += (kn - Wt) * Gn,
                Wt = kn,
                _n = 0; _n < cr; ++_n)
                    if (Un = qt[_n],
                    Un < Wt && ++Mt > ot && Ut("overflow"),
                    Un == Wt) {
                        for (Dn = Mt,
                        jn = st; Bn = jn <= hn ? lt : jn >= hn + ct ? ct : jn - hn,
                        !(Dn < Bn); jn += st)
                            rr = Dn - Bn,
                            Mn = st - Bn,
                            Hn.push(Lt(xt(Bn + rr % Mn, 0))),
                            Dn = Nt(rr / Mn);
                        Hn.push(Lt(xt(Dn, 0))),
                        hn = $t(Mt, Gn, Yt == un),
                        Mt = 0,
                        ++Yt
                    }
                ++Mt,
                ++Wt
            }
            return Hn.join("")
        }
        function Ft(qt) {
            return Pt(qt, function(Wt) {
                return Et.test(Wt) ? Dt(Wt.slice(4).toLowerCase()) : Wt
            })
        }
        function Ht(qt) {
            return Pt(qt, function(Wt) {
                return _t.test(Wt) ? "xn--" + jt(Wt) : Wt
            })
        }
        if (it = {
            version: "1.4.1",
            ucs2: {
                decode: Xt,
                encode: rn
            },
            decode: Dt,
            encode: jt,
            toASCII: Ht,
            toUnicode: Ft
        },
        tt && nt)
            if (_e.exports == tt)
                nt.exports = it;
            else
                for (kt in it)
                    it.hasOwnProperty(kt) && (tt[kt] = it[kt]);
        else
            et.punycode = it
    }
    )(commonjsGlobal$1)
}
)(punycode, punycode.exports);
var punycodeExports = punycode.exports;
const require$$0 = getDefaultExportFromCjs$2(punycodeExports);
var validAsciiDomain = regexSupplant(/(?:(?:[\-a-z0-9#{latinAccentChars}]+)\.)+(?:#{validGTLD}|#{validCCTLD}|#{validPunycode})/gi, {
    latinAccentChars,
    validGTLD,
    validCCTLD,
    validPunycode
})
  , MAX_DOMAIN_LABEL_LENGTH = 63
  , PUNYCODE_ENCODED_DOMAIN_PREFIX = "xn--"
  , idna = {
    toAscii: function($) {
        if (!($.substring(0, 4) === PUNYCODE_ENCODED_DOMAIN_PREFIX && !$.match(validAsciiDomain))) {
            for (var et = $.split("."), tt = 0; tt < et.length; tt++) {
                var nt = et[tt]
                  , rt = require$$0.toASCII(nt);
                if (rt.length < 1 || rt.length > MAX_DOMAIN_LABEL_LENGTH)
                    return
            }
            return et.join(".")
        }
    }
}
  , validTcoUrl = regexSupplant(/^https?:\/\/t\.co\/([a-z0-9]+)(?:\?#{validUrlQueryChars}*#{validUrlQueryEndingChars})?/, {
    validUrlQueryChars,
    validUrlQueryEndingChars
}, "i")
  , DEFAULT_PROTOCOL = "https://"
  , DEFAULT_PROTOCOL_OPTIONS = {
    extractUrlsWithoutProtocol: !0
}
  , MAX_URL_LENGTH = 4096
  , MAX_TCO_SLUG_LENGTH = 40
  , extractUrlsWithIndices = function($) {
    var et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : DEFAULT_PROTOCOL_OPTIONS;
    if (!$ || (et.extractUrlsWithoutProtocol ? !$.match(/\./) : !$.match(/:/)))
        return [];
    for (var tt = [], nt = function() {
        var ot = RegExp.$2
          , st = RegExp.$3
          , lt = RegExp.$4
          , ct = RegExp.$5
          , dt = RegExp.$7
          , pt = extractUrl.lastIndex
          , ht = pt - st.length;
        if (!isValidUrl$1(st, lt || DEFAULT_PROTOCOL, ct))
            return "continue";
        if (lt) {
            if (st.match(validTcoUrl)) {
                var Et = RegExp.$1;
                if (Et && Et.length > MAX_TCO_SLUG_LENGTH)
                    return "continue";
                st = RegExp.lastMatch,
                pt = ht + st.length
            }
            tt.push({
                url: st,
                indices: [ht, pt]
            })
        } else {
            if (!et.extractUrlsWithoutProtocol || ot.match(invalidUrlWithoutProtocolPrecedingChars))
                return "continue";
            var mt = null
              , yt = 0;
            if (ct.replace(validAsciiDomain, function(_t) {
                var wt = ct.indexOf(_t, yt);
                yt = wt + _t.length,
                mt = {
                    url: _t,
                    indices: [ht + wt, ht + yt]
                },
                tt.push(mt)
            }),
            mt == null)
                return "continue";
            dt && (mt.url = st.replace(ct, mt.url),
            mt.indices[1] = pt)
        }
    }; extractUrl.exec($); )
        var rt = nt();
    return tt
}
  , isValidUrl$1 = function($, et, tt) {
    var nt = $.length
      , rt = idna.toAscii(tt);
    return !rt || !rt.length ? !1 : (nt = nt + rt.length - tt.length,
    et.length + nt <= MAX_URL_LENGTH)
}
  , $export$b = _export
  , aFunction$1 = _aFunction
  , toObject$6 = _toObject
  , fails$1 = _fails
  , $sort = [].sort
  , test$1 = [1, 2, 3];
$export$b($export$b.P + $export$b.F * (fails$1(function() {
    test$1.sort(void 0)
}) || !fails$1(function() {
    test$1.sort(null)
}) || !_strictMethod($sort)), "Array", {
    sort: function($) {
        return $ === void 0 ? $sort.call(toObject$6(this)) : $sort.call(toObject$6(this), aFunction$1($))
    }
});
function removeOverlappingEntities(_e) {
    _e.sort(function(tt, nt) {
        return tt.indices[0] - nt.indices[0]
    });
    for (var $ = _e[0], et = 1; et < _e.length; et++)
        $.indices[1] > _e[et].indices[0] ? (_e.splice(et, 1),
        et--) : $ = _e[et]
}
var astralLetterAndMarks = /\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\uddfd\ude80-\ude9c\udea0-\uded0\udee0\udf00-\udf1f\udf30-\udf40\udf42-\udf49\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf]|\ud801[\udc00-\udc9d\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe\uddbf\ude00-\ude03\ude05\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude33\ude38-\ude3a\ude3f\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee6\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48]|\ud804[\udc00-\udc46\udc7f-\udcba\udcd0-\udce8\udd00-\udd34\udd50-\udd73\udd76\udd80-\uddc4\uddda\ude00-\ude11\ude13-\ude37\udeb0-\udeea\udf01-\udf03\udf05-\udf0c\udf0f\udf10\udf13-\udf28\udf2a-\udf30\udf32\udf33\udf35-\udf39\udf3c-\udf44\udf47\udf48\udf4b-\udf4d\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]|\ud805[\udc80-\udcc5\udcc7\udd80-\uddb5\uddb8-\uddc0\ude00-\ude40\ude44\ude80-\udeb7]|\ud806[\udca0-\udcdf\udcff\udec0-\udef8]|\ud808[\udc00-\udf98]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udef0-\udef4\udf00-\udf36\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud81b[\udf00-\udf44\udf50-\udf7e\udf8f-\udf9f]|\ud82c[\udc00\udc01]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9d\udc9e]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e\udc9f\udca2\udca5\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud83a[\udc00-\udcc4\udcd0-\udcd6]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d]|\ud87e[\udc00-\ude1d]|\udb40[\udd00-\uddef]/
  , bmpLetterAndMarks = /A-Za-z\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u052f\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u05d0-\u05ea\u05f0-\u05f2\u0610-\u061a\u0620-\u065f\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06ef\u06fa-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07ca-\u07f5\u07fa\u0800-\u082d\u0840-\u085b\u08a0-\u08b2\u08e4-\u0963\u0971-\u0983\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7\u09c8\u09cb-\u09ce\u09d7\u09dc\u09dd\u09df-\u09e3\u09f0\u09f1\u0a01-\u0a03\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a70-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0b01-\u0b03\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5c\u0b5d\u0b5f-\u0b63\u0b71\u0b82\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0c00-\u0c03\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c58\u0c59\u0c60-\u0c63\u0c81-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0cde\u0ce0-\u0ce3\u0cf1\u0cf2\u0d01-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d57\u0d60-\u0d63\u0d7a-\u0d7f\u0d82\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb9\u0ebb-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0edc-\u0edf\u0f00\u0f18\u0f19\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u103f\u1050-\u108f\u109a-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16f1-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772\u1773\u1780-\u17d3\u17d7\u17dc\u17dd\u180b-\u180d\u1820-\u1877\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f\u1aa7\u1ab0-\u1abe\u1b00-\u1b4b\u1b6b-\u1b73\u1b80-\u1baf\u1bba-\u1bf3\u1c00-\u1c37\u1c4d-\u1c4f\u1c5a-\u1c7d\u1cd0-\u1cd2\u1cd4-\u1cf6\u1cf8\u1cf9\u1d00-\u1df5\u1dfc-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u20d0-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2183\u2184\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u2e2f\u3005\u3006\u302a-\u302f\u3031-\u3035\u303b\u303c\u3041-\u3096\u3099\u309a\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua672\ua674-\ua67d\ua67f-\ua69d\ua69f-\ua6e5\ua6f0\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua7ad\ua7b0\ua7b1\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c4\ua8e0-\ua8f7\ua8fb\ua90a-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf\ua9e0-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab5f\uab64\uab65\uabc0-\uabea\uabec\uabed\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf870-\uf87f\uf882\uf884-\uf89f\uf8b8\uf8c1-\uf8d6\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2d\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc/
  , nonBmpCodePairs = /[\uD800-\uDBFF][\uDC00-\uDFFF]/gm
  , hashtagAlpha = regexSupplant(/(?:[#{bmpLetterAndMarks}]|(?=#{nonBmpCodePairs})(?:#{astralLetterAndMarks}))/, {
    bmpLetterAndMarks,
    nonBmpCodePairs,
    astralLetterAndMarks
})
  , astralNumerals = /\ud801[\udca0-\udca9]|\ud804[\udc66-\udc6f\udcf0-\udcf9\udd36-\udd3f\uddd0-\uddd9\udef0-\udef9]|\ud805[\udcd0-\udcd9\ude50-\ude59\udec0-\udec9]|\ud806[\udce0-\udce9]|\ud81a[\ude60-\ude69\udf50-\udf59]|\ud835[\udfce-\udfff]/
  , bmpNumerals = /0-9\u0660-\u0669\u06f0-\u06f9\u07c0-\u07c9\u0966-\u096f\u09e6-\u09ef\u0a66-\u0a6f\u0ae6-\u0aef\u0b66-\u0b6f\u0be6-\u0bef\u0c66-\u0c6f\u0ce6-\u0cef\u0d66-\u0d6f\u0de6-\u0def\u0e50-\u0e59\u0ed0-\u0ed9\u0f20-\u0f29\u1040-\u1049\u1090-\u1099\u17e0-\u17e9\u1810-\u1819\u1946-\u194f\u19d0-\u19d9\u1a80-\u1a89\u1a90-\u1a99\u1b50-\u1b59\u1bb0-\u1bb9\u1c40-\u1c49\u1c50-\u1c59\ua620-\ua629\ua8d0-\ua8d9\ua900-\ua909\ua9d0-\ua9d9\ua9f0-\ua9f9\uaa50-\uaa59\uabf0-\uabf9\uff10-\uff19/
  , hashtagSpecialChars = /_\u200c\u200d\ua67e\u05be\u05f3\u05f4\uff5e\u301c\u309b\u309c\u30a0\u30fb\u3003\u0f0b\u0f0c\xb7/
  , hashtagAlphaNumeric = regexSupplant(/(?:[#{bmpLetterAndMarks}#{bmpNumerals}#{hashtagSpecialChars}]|(?=#{nonBmpCodePairs})(?:#{astralLetterAndMarks}|#{astralNumerals}))/, {
    bmpLetterAndMarks,
    bmpNumerals,
    hashtagSpecialChars,
    nonBmpCodePairs,
    astralLetterAndMarks,
    astralNumerals
})
  , codePoint = /(?:[^\uD800-\uDFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF])/
  , hashtagBoundary = regexSupplant(/(?:^|\uFE0E|\uFE0F|$|(?!#{hashtagAlphaNumeric}|&)#{codePoint})/, {
    codePoint,
    hashtagAlphaNumeric
})
  , validHashtag = regexSupplant(/(#{hashtagBoundary})(#{hashSigns})(?!\uFE0F|\u20E3)(#{hashtagAlphaNumeric}*#{hashtagAlpha}#{hashtagAlphaNumeric}*)/gi, {
    hashtagBoundary,
    hashSigns,
    hashtagAlphaNumeric,
    hashtagAlpha
})
  , extractHashtagsWithIndices = function($, et) {
    if (et || (et = {
        checkUrlOverlap: !0
    }),
    !$ || !$.match(hashSigns))
        return [];
    var tt = [];
    if ($.replace(validHashtag, function(ot, st, lt, ct, dt, pt) {
        var ht = pt.slice(dt + ot.length);
        if (!ht.match(endHashtagMatch)) {
            var mt = dt + st.length
              , yt = mt + ct.length + 1;
            tt.push({
                hashtag: ct,
                indices: [mt, yt]
            })
        }
    }),
    et.checkUrlOverlap) {
        var nt = extractUrlsWithIndices($);
        if (nt.length > 0) {
            var rt = tt.concat(nt);
            removeOverlappingEntities(rt),
            tt = [];
            for (var it = 0; it < rt.length; it++)
                rt[it].hashtag && tt.push(rt[it])
        }
    }
    return tt
}
  , atSigns = /[@]/
  , endMentionMatch = regexSupplant(/^(?:#{atSigns}|[#{latinAccentChars}]|:\/\/)/, {
    atSigns,
    latinAccentChars
})
  , validMentionPrecedingChars = /(?:^|[^a-zA-Z0-9_!#$%&*@]|(?:^|[^a-zA-Z0-9_+~.-])(?:rt|RT|rT|Rt):?)/
  , validMentionOrList = regexSupplant("(#{validMentionPrecedingChars})(#{atSigns})([a-zA-Z0-9_]{1,20})(/[a-zA-Z][a-zA-Z0-9_-]{0,24})?", {
    validMentionPrecedingChars,
    atSigns
}, "g");
function extractMentionsOrListsWithIndices(_e) {
    if (!_e || !_e.match(atSigns))
        return [];
    var $ = [];
    return _e.replace(validMentionOrList, function(et, tt, nt, rt, it, ot, st) {
        var lt = st.slice(ot + et.length);
        if (!lt.match(endMentionMatch)) {
            it = it || "";
            var ct = ot + tt.length
              , dt = ct + rt.length + it.length + 1;
            $.push({
                screenName: rt,
                listSlug: it,
                indices: [ct, dt]
            })
        }
    }),
    $
}
function extractEntitiesWithIndices(_e, $) {
    var et = extractUrlsWithIndices(_e, $).concat(extractMentionsOrListsWithIndices(_e)).concat(extractHashtagsWithIndices(_e, {
        checkUrlOverlap: !1
    })).concat(extractCashtagsWithIndices(_e));
    return et.length == 0 ? [] : (removeOverlappingEntities(et),
    et)
}
function clone$2(_e) {
    var $ = {};
    for (var et in _e)
        _e.hasOwnProperty(et) && ($[et] = _e[et]);
    return $
}
var BOOLEAN_ATTRIBUTES$1 = {
    disabled: !0,
    readonly: !0,
    multiple: !0,
    checked: !0
}
  , OPTIONS_NOT_ATTRIBUTES = {
    urlClass: !0,
    listClass: !0,
    usernameClass: !0,
    hashtagClass: !0,
    cashtagClass: !0,
    usernameUrlBase: !0,
    listUrlBase: !0,
    hashtagUrlBase: !0,
    cashtagUrlBase: !0,
    usernameUrlBlock: !0,
    listUrlBlock: !0,
    hashtagUrlBlock: !0,
    linkUrlBlock: !0,
    usernameIncludeSymbol: !0,
    suppressLists: !0,
    suppressNoFollow: !0,
    targetBlank: !0,
    suppressDataScreenName: !0,
    urlEntities: !0,
    symbolTag: !0,
    textWithSymbolTag: !0,
    urlTarget: !0,
    invisibleTagAttrs: !0,
    linkAttributeBlock: !0,
    linkTextBlock: !0,
    htmlEscapeNonEntities: !0
};
function extractHtmlAttrsFromOptions(_e) {
    var $ = {};
    for (var et in _e) {
        var tt = _e[et];
        OPTIONS_NOT_ATTRIBUTES[et] || (BOOLEAN_ATTRIBUTES$1[et] && (tt = tt ? et : null),
        tt != null && ($[et] = tt))
    }
    return $
}
var HTML_ENTITIES = {
    "&": "&amp;",
    ">": "&gt;",
    "<": "&lt;",
    '"': "&quot;",
    "'": "&#39;"
};
function htmlEscape(_e) {
    return _e && _e.replace(/[&"'><]/g, function($) {
        return HTML_ENTITIES[$]
    })
}
_descriptors && /./g.flags != "g" && _objectDp.f(RegExp.prototype, "flags", {
    configurable: !0,
    get: _flags
});
var anObject$4 = _anObject
  , $flags = _flags
  , DESCRIPTORS$1 = _descriptors
  , TO_STRING$1 = "toString"
  , $toString$1 = /./[TO_STRING$1]
  , define = function(_e) {
    _redefineExports(RegExp.prototype, TO_STRING$1, _e, !0)
};
_fails(function() {
    return $toString$1.call({
        source: "a",
        flags: "b"
    }) != "/a/b"
}) ? define(function() {
    var $ = anObject$4(this);
    return "/".concat($.source, "/", "flags"in $ ? $.flags : !DESCRIPTORS$1 && $ instanceof RegExp ? $flags.call($) : void 0)
}) : $toString$1.name != TO_STRING$1 && define(function() {
    return $toString$1.call(this)
});
var DateProto = Date.prototype
  , INVALID_DATE = "Invalid Date"
  , TO_STRING = "toString"
  , $toString = DateProto[TO_STRING]
  , getTime = DateProto.getTime;
new Date(NaN) + "" != INVALID_DATE && _redefineExports(DateProto, TO_STRING, function() {
    var $ = getTime.call(this);
    return $ === $ ? $toString.call(this) : INVALID_DATE
});
var classof$1 = _classof
  , test = {};
test[_wksExports("toStringTag")] = "z";
test + "" != "[object z]" && _redefineExports(Object.prototype, "toString", function() {
    return "[object " + classof$1(this) + "]"
}, !0);
var BOOLEAN_ATTRIBUTES = {
    disabled: !0,
    readonly: !0,
    multiple: !0,
    checked: !0
};
function tagAttrs(_e) {
    var $ = "";
    for (var et in _e) {
        var tt = _e[et];
        BOOLEAN_ATTRIBUTES[et] && (tt = tt ? et : null),
        tt != null && ($ += " ".concat(htmlEscape(et), '="').concat(htmlEscape(tt.toString()), '"'))
    }
    return $
}
function linkToText(_e, $, et, tt) {
    tt.suppressNoFollow || (et.rel = "nofollow"),
    tt.linkAttributeBlock && tt.linkAttributeBlock(_e, et),
    tt.linkTextBlock && ($ = tt.linkTextBlock(_e, $));
    var nt = {
        text: $,
        attr: tagAttrs(et)
    };
    return stringSupplant("<a#{attr}>#{text}</a>", nt)
}
function linkToTextWithSymbol(_e, $, et, tt, nt) {
    var rt = nt.symbolTag ? "<".concat(nt.symbolTag, ">").concat($, "</").concat(nt.symbolTag, ">") : $;
    et = htmlEscape(et);
    var it = nt.textWithSymbolTag ? "<".concat(nt.textWithSymbolTag, ">").concat(et, "</").concat(nt.textWithSymbolTag, ">") : et;
    return nt.usernameIncludeSymbol || !$.match(atSigns) ? linkToText(_e, rt + it, tt, nt) : rt + linkToText(_e, it, tt, nt)
}
function linkToCashtag(_e, $, et) {
    var tt = htmlEscape(_e.cashtag)
      , nt = clone$2(et.htmlAttrs || {});
    return nt.href = et.cashtagUrlBase + tt,
    nt.title = "$".concat(tt),
    nt.class = et.cashtagClass,
    et.targetBlank && (nt.target = "_blank"),
    linkToTextWithSymbol(_e, "$", tt, nt, et)
}
var rtlChars = /[\u0600-\u06FF]|[\u0750-\u077F]|[\u0590-\u05FF]|[\uFE70-\uFEFF]/gm;
function linkToHashtag(_e, $, et) {
    var tt = $.substring(_e.indices[0], _e.indices[0] + 1)
      , nt = htmlEscape(_e.hashtag)
      , rt = clone$2(et.htmlAttrs || {});
    return rt.href = et.hashtagUrlBase + nt,
    rt.title = "#".concat(nt),
    rt.class = et.hashtagClass,
    nt.charAt(0).match(rtlChars) && (rt.class += " rtl"),
    et.targetBlank && (rt.target = "_blank"),
    linkToTextWithSymbol(_e, tt, nt, rt, et)
}
function linkTextWithEntity(_e, $) {
    var et = _e.display_url
      , tt = _e.expanded_url
      , nt = et.replace(//g, "");
    if (tt.indexOf(nt) != -1) {
        var rt = tt.indexOf(nt)
          , it = {
            displayUrlSansEllipses: nt,
            beforeDisplayUrl: tt.substr(0, rt),
            afterDisplayUrl: tt.substr(rt + nt.length),
            precedingEllipsis: et.match(/^/) ? "" : "",
            followingEllipsis: et.match(/$/) ? "" : ""
        };
        for (var ot in it)
            it.hasOwnProperty(ot) && (it[ot] = htmlEscape(it[ot]));
        return it.invisible = $.invisibleTagAttrs,
        stringSupplant("<span class='tco-ellipsis'>#{precedingEllipsis}<span #{invisible}>&nbsp;</span></span><span #{invisible}>#{beforeDisplayUrl}</span><span class='js-display-url'>#{displayUrlSansEllipses}</span><span #{invisible}>#{afterDisplayUrl}</span><span class='tco-ellipsis'><span #{invisible}>&nbsp;</span>#{followingEllipsis}</span>", it)
    }
    return et
}
var urlHasProtocol = /^https?:\/\//i;
function linkToUrl(_e, $, et) {
    var tt = _e.url
      , nt = tt
      , rt = htmlEscape(nt)
      , it = et.urlEntities && et.urlEntities[tt] || _e;
    it.display_url && (rt = linkTextWithEntity(it, et));
    var ot = clone$2(et.htmlAttrs || {});
    return tt.match(urlHasProtocol) || (tt = "http://".concat(tt)),
    ot.href = tt,
    et.targetBlank && (ot.target = "_blank"),
    et.urlClass && (ot.class = et.urlClass),
    et.urlTarget && (ot.target = et.urlTarget),
    !et.title && it.display_url && (ot.title = it.expanded_url),
    linkToText(_e, rt, ot, et)
}
function linkToMentionAndList(_e, $, et) {
    var tt = $.substring(_e.indices[0], _e.indices[0] + 1)
      , nt = htmlEscape(_e.screenName)
      , rt = htmlEscape(_e.listSlug)
      , it = _e.listSlug && !et.suppressLists
      , ot = clone$2(et.htmlAttrs || {});
    return ot.class = it ? et.listClass : et.usernameClass,
    ot.href = it ? et.listUrlBase + nt + rt : et.usernameUrlBase + nt,
    !it && !et.suppressDataScreenName && (ot["data-screen-name"] = nt),
    et.targetBlank && (ot.target = "_blank"),
    linkToTextWithSymbol(_e, tt, it ? nt + rt : nt, ot, et)
}
var DEFAULT_LIST_CLASS = "tweet-url list-slug"
  , DEFAULT_USERNAME_CLASS = "tweet-url username"
  , DEFAULT_HASHTAG_CLASS = "tweet-url hashtag"
  , DEFAULT_CASHTAG_CLASS = "tweet-url cashtag";
function autoLinkEntities(_e, $, tt) {
    var tt = clone$2(tt || {});
    tt.hashtagClass = tt.hashtagClass || DEFAULT_HASHTAG_CLASS,
    tt.hashtagUrlBase = tt.hashtagUrlBase || "https://twitter.com/search?q=%23",
    tt.cashtagClass = tt.cashtagClass || DEFAULT_CASHTAG_CLASS,
    tt.cashtagUrlBase = tt.cashtagUrlBase || "https://twitter.com/search?q=%24",
    tt.listClass = tt.listClass || DEFAULT_LIST_CLASS,
    tt.usernameClass = tt.usernameClass || DEFAULT_USERNAME_CLASS,
    tt.usernameUrlBase = tt.usernameUrlBase || "https://twitter.com/",
    tt.listUrlBase = tt.listUrlBase || "https://twitter.com/",
    tt.htmlAttrs = extractHtmlAttrsFromOptions(tt),
    tt.invisibleTagAttrs = tt.invisibleTagAttrs || "style='position:absolute;left:-9999px;'";
    var nt, rt, it;
    if (tt.urlEntities) {
        for (nt = {},
        rt = 0,
        it = tt.urlEntities.length; rt < it; rt++)
            nt[tt.urlEntities[rt].url] = tt.urlEntities[rt];
        tt.urlEntities = nt
    }
    var ot = ""
      , st = 0;
    $.sort(function(dt, pt) {
        return dt.indices[0] - pt.indices[0]
    });
    for (var lt = tt.htmlEscapeNonEntities ? htmlEscape : function(dt) {
        return dt
    }
    , rt = 0; rt < $.length; rt++) {
        var ct = $[rt];
        ot += lt(_e.substring(st, ct.indices[0])),
        ct.url ? ot += linkToUrl(ct, _e, tt) : ct.hashtag ? ot += linkToHashtag(ct, _e, tt) : ct.screenName ? ot += linkToMentionAndList(ct, _e, tt) : ct.cashtag && (ot += linkToCashtag(ct, _e, tt)),
        st = ct.indices[1]
    }
    return ot += lt(_e.substring(st, _e.length)),
    ot
}
function autoLink(_e, $) {
    var et = extractEntitiesWithIndices(_e, {
        extractUrlsWithoutProtocol: !1
    });
    return autoLinkEntities(_e, et, $)
}
function autoLinkCashtags(_e, $) {
    var et = extractCashtagsWithIndices(_e);
    return autoLinkEntities(_e, et, $)
}
function autoLinkHashtags(_e, $) {
    var et = extractHashtagsWithIndices(_e);
    return autoLinkEntities(_e, et, $)
}
function autoLinkUrlsCustom(_e, $) {
    var et = extractUrlsWithIndices(_e, {
        extractUrlsWithoutProtocol: !1
    });
    return autoLinkEntities(_e, et, $)
}
function autoLinkUsernamesOrLists(_e, $) {
    var et = extractMentionsOrListsWithIndices(_e);
    return autoLinkEntities(_e, et, $)
}
var convertUnicodeIndices$1 = function($, et, tt) {
    if (et.length !== 0) {
        var nt = 0
          , rt = 0;
        et.sort(function(ct, dt) {
            return ct.indices[0] - dt.indices[0]
        });
        for (var it = 0, ot = et[0]; nt < $.length; ) {
            if (ot.indices[0] === (tt ? nt : rt)) {
                var st = ot.indices[1] - ot.indices[0];
                if (ot.indices[0] = tt ? rt : nt,
                ot.indices[1] = ot.indices[0] + st,
                it++,
                it === et.length)
                    break;
                ot = et[it]
            }
            var lt = $.charCodeAt(nt);
            lt >= 55296 && lt <= 56319 && nt < $.length - 1 && (lt = $.charCodeAt(nt + 1),
            lt >= 56320 && lt <= 57343 && nt++),
            rt++,
            nt++
        }
    }
};
function modifyIndicesFromUnicodeToUTF16(_e, $) {
    convertUnicodeIndices$1(_e, $, !1)
}
function autoLinkWithJSON(_e, $, et) {
    if ($.user_mentions)
        for (var tt = 0; tt < $.user_mentions.length; tt++)
            $.user_mentions[tt].screenName = $.user_mentions[tt].screen_name;
    if ($.hashtags)
        for (var tt = 0; tt < $.hashtags.length; tt++)
            $.hashtags[tt].hashtag = $.hashtags[tt].text;
    if ($.symbols)
        for (var tt = 0; tt < $.symbols.length; tt++)
            $.symbols[tt].cashtag = $.symbols[tt].text;
    var nt = [];
    for (var rt in $)
        nt = nt.concat($[rt]);
    return modifyIndicesFromUnicodeToUTF16(_e, nt),
    autoLinkEntities(_e, nt, et)
}
const configs = {
    version1: {
        version: 1,
        maxWeightedTweetLength: 140,
        scale: 1,
        defaultWeight: 1,
        transformedURLLength: 23,
        ranges: []
    },
    version2: {
        version: 2,
        maxWeightedTweetLength: 280,
        scale: 100,
        defaultWeight: 200,
        transformedURLLength: 23,
        ranges: [{
            start: 0,
            end: 4351,
            weight: 100
        }, {
            start: 8192,
            end: 8205,
            weight: 100
        }, {
            start: 8208,
            end: 8223,
            weight: 100
        }, {
            start: 8242,
            end: 8247,
            weight: 100
        }]
    },
    version3: {
        version: 3,
        maxWeightedTweetLength: 280,
        scale: 100,
        defaultWeight: 200,
        emojiParsingEnabled: !0,
        transformedURLLength: 23,
        ranges: [{
            start: 0,
            end: 4351,
            weight: 100
        }, {
            start: 8192,
            end: 8205,
            weight: 100
        }, {
            start: 8208,
            end: 8223,
            weight: 100
        }, {
            start: 8242,
            end: 8247,
            weight: 100
        }]
    },
    defaults: {
        version: 3,
        maxWeightedTweetLength: 280,
        scale: 100,
        defaultWeight: 200,
        emojiParsingEnabled: !0,
        transformedURLLength: 23,
        ranges: [{
            start: 0,
            end: 4351,
            weight: 100
        }, {
            start: 8192,
            end: 8205,
            weight: 100
        }, {
            start: 8208,
            end: 8223,
            weight: 100
        }, {
            start: 8242,
            end: 8247,
            weight: 100
        }]
    }
};
function convertUnicodeIndices(_e, $, et) {
    if ($.length != 0) {
        var tt = 0
          , nt = 0;
        $.sort(function(lt, ct) {
            return lt.indices[0] - ct.indices[0]
        });
        for (var rt = 0, it = $[0]; tt < _e.length; ) {
            if (it.indices[0] == (et ? tt : nt)) {
                var ot = it.indices[1] - it.indices[0];
                if (it.indices[0] = et ? nt : tt,
                it.indices[1] = it.indices[0] + ot,
                rt++,
                rt == $.length)
                    break;
                it = $[rt]
            }
            var st = _e.charCodeAt(tt);
            st >= 55296 && st <= 56319 && tt < _e.length - 1 && (st = _e.charCodeAt(tt + 1),
            st >= 56320 && st <= 57343 && tt++),
            nt++,
            tt++
        }
    }
}
function extractCashtags(_e) {
    for (var $ = [], et = extractCashtagsWithIndices(_e), tt = 0; tt < et.length; tt++)
        $.push(et[tt].cashtag);
    return $
}
function extractHashtags(_e) {
    for (var $ = [], et = extractHashtagsWithIndices(_e), tt = 0; tt < et.length; tt++)
        $.push(et[tt].hashtag);
    return $
}
function extractMentionsWithIndices(_e) {
    for (var $ = [], et, tt = extractMentionsOrListsWithIndices(_e), nt = 0; nt < tt.length; nt++)
        et = tt[nt],
        et.listSlug === "" && $.push({
            screenName: et.screenName,
            indices: et.indices
        });
    return $
}
function extractMentions(_e) {
    for (var $ = [], et = extractMentionsWithIndices(_e), tt = 0; tt < et.length; tt++) {
        var nt = et[tt].screenName;
        $.push(nt)
    }
    return $
}
var validReply = regexSupplant(/^(?:#{spaces})*#{atSigns}([a-zA-Z0-9_]{1,20})/, {
    atSigns,
    spaces
});
function extractReplies(_e) {
    if (!_e)
        return null;
    var $ = _e.match(validReply);
    return !$ || RegExp.rightContext.match(endMentionMatch) ? null : $[1]
}
function extractUrls(_e, $) {
    for (var et = [], tt = extractUrlsWithIndices(_e, $), nt = 0; nt < tt.length; nt++)
        et.push(tt[nt].url);
    return et
}
var cof = _cof
  , _isArray = Array.isArray || function($) {
    return cof($) == "Array"
}
  , $export$a = _export;
$export$a($export$a.S, "Array", {
    isArray: _isArray
});
var getCharacterWeight = function($, et) {
    var tt = et.defaultWeight
      , nt = et.ranges
      , rt = tt
      , it = $.charCodeAt(0);
    if (Array.isArray(nt))
        for (var ot = 0, st = nt.length; ot < st; ot++) {
            var lt = nt[ot];
            if (it >= lt.start && it <= lt.end) {
                rt = lt.weight;
                break
            }
        }
    return rt
};
function modifyIndicesFromUTF16ToUnicode(_e, $) {
    convertUnicodeIndices$1(_e, $, !0)
}
var aFunction = _aFunction
  , toObject$5 = _toObject
  , IObject$1 = _iobject
  , toLength$2 = _toLength
  , _arrayReduce = function(_e, $, et, tt, nt) {
    aFunction($);
    var rt = toObject$5(_e)
      , it = IObject$1(rt)
      , ot = toLength$2(rt.length)
      , st = nt ? ot - 1 : 0
      , lt = nt ? -1 : 1;
    if (et < 2)
        for (; ; ) {
            if (st in it) {
                tt = it[st],
                st += lt;
                break
            }
            if (st += lt,
            nt ? st < 0 : ot <= st)
                throw TypeError("Reduce of empty array with no initial value")
        }
    for (; nt ? st >= 0 : ot > st; st += lt)
        st in it && (tt = $(tt, it[st], st, rt));
    return tt
}
  , $export$9 = _export
  , $reduce = _arrayReduce;
$export$9($export$9.P + $export$9.F * !_strictMethod([].reduce, !0), "Array", {
    reduce: function($) {
        return $reduce(this, $, arguments.length, arguments[1], !1)
    }
});
var UNSCOPABLES = _wksExports("unscopables")
  , ArrayProto$1 = Array.prototype;
ArrayProto$1[UNSCOPABLES] == null && _hide(ArrayProto$1, UNSCOPABLES, {});
var _addToUnscopables = function(_e) {
    ArrayProto$1[UNSCOPABLES][_e] = !0
}, _iterStep = function(_e, $) {
    return {
        value: $,
        done: !!_e
    }
}, _iterators = {}, $keys$2 = _objectKeysInternal, enumBugKeys$1 = _enumBugKeys, _objectKeys = Object.keys || function($) {
    return $keys$2($, enumBugKeys$1)
}
, _objectDps, hasRequired_objectDps;
function require_objectDps() {
    if (hasRequired_objectDps)
        return _objectDps;
    hasRequired_objectDps = 1;
    var _e = _objectDp
      , $ = _anObject
      , et = _objectKeys;
    return _objectDps = _descriptors ? Object.defineProperties : function(nt, rt) {
        $(nt);
        for (var it = et(rt), ot = it.length, st = 0, lt; ot > st; )
            _e.f(nt, lt = it[st++], rt[lt]);
        return nt
    }
    ,
    _objectDps
}
var _html, hasRequired_html;
function require_html() {
    if (hasRequired_html)
        return _html;
    hasRequired_html = 1;
    var _e = _globalExports.document;
    return _html = _e && _e.documentElement,
    _html
}
var anObject$3 = _anObject
  , dPs = require_objectDps()
  , enumBugKeys = _enumBugKeys
  , IE_PROTO$1 = _sharedKey("IE_PROTO")
  , Empty = function() {}
  , PROTOTYPE$1 = "prototype"
  , createDict = function() {
    var _e = require_domCreate()("iframe"), $ = enumBugKeys.length, et = "<", tt = ">", nt;
    for (_e.style.display = "none",
    require_html().appendChild(_e),
    _e.src = "javascript:",
    nt = _e.contentWindow.document,
    nt.open(),
    nt.write(et + "script" + tt + "document.F=Object" + et + "/script" + tt),
    nt.close(),
    createDict = nt.F; $--; )
        delete createDict[PROTOTYPE$1][enumBugKeys[$]];
    return createDict()
}
  , _objectCreate = Object.create || function($, et) {
    var tt;
    return $ !== null ? (Empty[PROTOTYPE$1] = anObject$3($),
    tt = new Empty,
    Empty[PROTOTYPE$1] = null,
    tt[IE_PROTO$1] = $) : tt = createDict(),
    et === void 0 ? tt : dPs(tt, et)
}
  , def = _objectDp.f
  , has$3 = _has
  , TAG = _wksExports("toStringTag")
  , _setToStringTag = function(_e, $, et) {
    _e && !has$3(_e = et ? _e : _e.prototype, TAG) && def(_e, TAG, {
        configurable: !0,
        value: $
    })
}
  , create = _objectCreate
  , descriptor = _propertyDesc
  , setToStringTag$2 = _setToStringTag
  , IteratorPrototype = {};
_hide(IteratorPrototype, _wksExports("iterator"), function() {
    return this
});
var _iterCreate = function(_e, $, et) {
    _e.prototype = create(IteratorPrototype, {
        next: descriptor(1, et)
    }),
    setToStringTag$2(_e, $ + " Iterator")
}
  , has$2 = _has
  , toObject$4 = _toObject
  , IE_PROTO = _sharedKey("IE_PROTO")
  , ObjectProto$1 = Object.prototype
  , _objectGpo = Object.getPrototypeOf || function(_e) {
    return _e = toObject$4(_e),
    has$2(_e, IE_PROTO) ? _e[IE_PROTO] : typeof _e.constructor == "function" && _e instanceof _e.constructor ? _e.constructor.prototype : _e instanceof Object ? ObjectProto$1 : null
}
  , $export$8 = _export
  , redefine$2 = _redefineExports
  , hide$1 = _hide
  , Iterators$4 = _iterators
  , $iterCreate = _iterCreate
  , setToStringTag$1 = _setToStringTag
  , getPrototypeOf = _objectGpo
  , ITERATOR$3 = _wksExports("iterator")
  , BUGGY = !([].keys && "next"in [].keys())
  , FF_ITERATOR = "@@iterator"
  , KEYS = "keys"
  , VALUES = "values"
  , returnThis = function() {
    return this
}
  , _iterDefine = function(_e, $, et, tt, nt, rt, it) {
    $iterCreate(et, $, tt);
    var ot = function(St) {
        if (!BUGGY && St in dt)
            return dt[St];
        switch (St) {
        case KEYS:
            return function() {
                return new et(this,St)
            }
            ;
        case VALUES:
            return function() {
                return new et(this,St)
            }
        }
        return function() {
            return new et(this,St)
        }
    }, st = $ + " Iterator", lt = nt == VALUES, ct = !1, dt = _e.prototype, pt = dt[ITERATOR$3] || dt[FF_ITERATOR] || nt && dt[nt], ht = pt || ot(nt), mt = nt ? lt ? ot("entries") : ht : void 0, yt = $ == "Array" && dt.entries || pt, Et, _t, wt;
    if (yt && (wt = getPrototypeOf(yt.call(new _e)),
    wt !== Object.prototype && wt.next && (setToStringTag$1(wt, st, !0),
    typeof wt[ITERATOR$3] != "function" && hide$1(wt, ITERATOR$3, returnThis))),
    lt && pt && pt.name !== VALUES && (ct = !0,
    ht = function() {
        return pt.call(this)
    }
    ),
    (BUGGY || ct || !dt[ITERATOR$3]) && hide$1(dt, ITERATOR$3, ht),
    Iterators$4[$] = ht,
    Iterators$4[st] = returnThis,
    nt)
        if (Et = {
            values: lt ? ht : ot(VALUES),
            keys: rt ? ht : ot(KEYS),
            entries: mt
        },
        it)
            for (_t in Et)
                _t in dt || redefine$2(dt, _t, Et[_t]);
        else
            $export$8($export$8.P + $export$8.F * (BUGGY || ct), $, Et);
    return Et
}
  , addToUnscopables = _addToUnscopables
  , step = _iterStep
  , Iterators$3 = _iterators
  , toIObject$3 = _toIobject
  , es6_array_iterator = _iterDefine(Array, "Array", function(_e, $) {
    this._t = toIObject$3(_e),
    this._i = 0,
    this._k = $
}, function() {
    var _e = this._t
      , $ = this._k
      , et = this._i++;
    return !_e || et >= _e.length ? (this._t = void 0,
    step(1)) : $ == "keys" ? step(0, et) : $ == "values" ? step(0, _e[et]) : step(0, [et, _e[et]])
}, "values");
Iterators$3.Arguments = Iterators$3.Array;
addToUnscopables("keys");
addToUnscopables("values");
addToUnscopables("entries");
var $iterators = es6_array_iterator
  , getKeys$1 = _objectKeys
  , redefine$1 = _redefineExports
  , global$2 = _globalExports
  , hide = _hide
  , Iterators$2 = _iterators
  , wks$1 = _wksExports
  , ITERATOR$2 = wks$1("iterator")
  , TO_STRING_TAG = wks$1("toStringTag")
  , ArrayValues = Iterators$2.Array
  , DOMIterables = {
    CSSRuleList: !0,
    CSSStyleDeclaration: !1,
    CSSValueList: !1,
    ClientRectList: !1,
    DOMRectList: !1,
    DOMStringList: !1,
    DOMTokenList: !0,
    DataTransferItemList: !1,
    FileList: !1,
    HTMLAllCollection: !1,
    HTMLCollection: !1,
    HTMLFormElement: !1,
    HTMLSelectElement: !1,
    MediaList: !0,
    MimeTypeArray: !1,
    NamedNodeMap: !1,
    NodeList: !0,
    PaintRequestList: !1,
    Plugin: !1,
    PluginArray: !1,
    SVGLengthList: !1,
    SVGNumberList: !1,
    SVGPathSegList: !1,
    SVGPointList: !1,
    SVGStringList: !1,
    SVGTransformList: !1,
    SourceBufferList: !1,
    StyleSheetList: !0,
    TextTrackCueList: !1,
    TextTrackList: !1,
    TouchList: !1
};
for (var collections = getKeys$1(DOMIterables), i = 0; i < collections.length; i++) {
    var NAME = collections[i], explicit = DOMIterables[NAME], Collection = global$2[NAME], proto = Collection && Collection.prototype, key;
    if (proto && (proto[ITERATOR$2] || hide(proto, ITERATOR$2, ArrayValues),
    proto[TO_STRING_TAG] || hide(proto, TO_STRING_TAG, NAME),
    Iterators$2[NAME] = ArrayValues,
    explicit))
        for (key in $iterators)
            proto[key] || redefine$1(proto, key, $iterators[key], !0)
}
var $export$7 = _export
  , core$1 = _coreExports
  , fails = _fails
  , _objectSap = function(_e, $) {
    var et = (core$1.Object || {})[_e] || Object[_e]
      , tt = {};
    tt[_e] = $(et),
    $export$7($export$7.S + $export$7.F * fails(function() {
        et(1)
    }), "Object", tt)
}
  , toObject$3 = _toObject
  , $keys$1 = _objectKeys;
_objectSap("keys", function() {
    return function($) {
        return $keys$1(toObject$3($))
    }
});
var invalidChars = regexSupplant(/[#{invalidCharsGroup}]/, {
    invalidCharsGroup
});
function hasInvalidCharacters(_e) {
    return invalidChars.test(_e)
}
var dist = {}
  , regex = {};
Object.defineProperty(regex, "__esModule", {
    value: !0
});
regex.default = /(?:\ud83d[\udc68\udc69])(?:\ud83c[\udffb-\udfff])?\u200d(?:\u2695\ufe0f|\u2696\ufe0f|\u2708\ufe0f|\ud83c[\udf3e\udf73\udf93\udfa4\udfa8\udfeb\udfed]|\ud83d[\udcbb\udcbc\udd27\udd2c\ude80\ude92]|\ud83e[\uddb0-\uddb3])|(?:\ud83c[\udfcb\udfcc]|\ud83d[\udd74\udd75]|\u26f9)((?:\ud83c[\udffb-\udfff]|\ufe0f)\u200d[\u2640\u2642]\ufe0f)|(?:\ud83c[\udfc3\udfc4\udfca]|\ud83d[\udc6e\udc71\udc73\udc77\udc81\udc82\udc86\udc87\ude45-\ude47\ude4b\ude4d\ude4e\udea3\udeb4-\udeb6]|\ud83e[\udd26\udd35\udd37-\udd39\udd3d\udd3e\uddb8\uddb9\uddd6-\udddd])(?:\ud83c[\udffb-\udfff])?\u200d[\u2640\u2642]\ufe0f|(?:\ud83d\udc68\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d\udc68|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d\udc8b\u200d\ud83d[\udc68\udc69]|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\u2764\ufe0f\u200d\ud83d\udc68|\ud83d\udc68\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc68\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc68\u200d\ud83d[\udc66\udc67]|\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d[\udc68\udc69]|\ud83d\udc69\u200d\ud83d\udc66\u200d\ud83d\udc66|\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83c\udff3\ufe0f\u200d\ud83c\udf08|\ud83c\udff4\u200d\u2620\ufe0f|\ud83d\udc41\u200d\ud83d\udde8|\ud83d\udc68\u200d\ud83d[\udc66\udc67]|\ud83d\udc69\u200d\ud83d[\udc66\udc67]|\ud83d\udc6f\u200d\u2640\ufe0f|\ud83d\udc6f\u200d\u2642\ufe0f|\ud83e\udd3c\u200d\u2640\ufe0f|\ud83e\udd3c\u200d\u2642\ufe0f|\ud83e\uddde\u200d\u2640\ufe0f|\ud83e\uddde\u200d\u2642\ufe0f|\ud83e\udddf\u200d\u2640\ufe0f|\ud83e\udddf\u200d\u2642\ufe0f)|[#*0-9]\ufe0f?\u20e3|(?:[\u2122\u265f]\ufe0f)|(?:\ud83c[\udc04\udd70\udd71\udd7e\udd7f\ude02\ude1a\ude2f\ude37\udf21\udf24-\udf2c\udf36\udf7d\udf96\udf97\udf99-\udf9b\udf9e\udf9f\udfcd\udfce\udfd4-\udfdf\udff3\udff5\udff7]|\ud83d[\udc3f\udc41\udcfd\udd49\udd4a\udd6f\udd70\udd73\udd76-\udd79\udd87\udd8a-\udd8d\udda5\udda8\uddb1\uddb2\uddbc\uddc2-\uddc4\uddd1-\uddd3\udddc-\uddde\udde1\udde3\udde8\uddef\uddf3\uddfa\udecb\udecd-\udecf\udee0-\udee5\udee9\udef0\udef3]|[\u203c\u2049\u2139\u2194-\u2199\u21a9\u21aa\u231a\u231b\u2328\u23cf\u23ed-\u23ef\u23f1\u23f2\u23f8-\u23fa\u24c2\u25aa\u25ab\u25b6\u25c0\u25fb-\u25fe\u2600-\u2604\u260e\u2611\u2614\u2615\u2618\u2620\u2622\u2623\u2626\u262a\u262e\u262f\u2638-\u263a\u2640\u2642\u2648-\u2653\u2660\u2663\u2665\u2666\u2668\u267b\u267f\u2692-\u2697\u2699\u269b\u269c\u26a0\u26a1\u26aa\u26ab\u26b0\u26b1\u26bd\u26be\u26c4\u26c5\u26c8\u26cf\u26d1\u26d3\u26d4\u26e9\u26ea\u26f0-\u26f5\u26f8\u26fa\u26fd\u2702\u2708\u2709\u270f\u2712\u2714\u2716\u271d\u2721\u2733\u2734\u2744\u2747\u2757\u2763\u2764\u27a1\u2934\u2935\u2b05-\u2b07\u2b1b\u2b1c\u2b50\u2b55\u3030\u303d\u3297\u3299])(?:\ufe0f|(?!\ufe0e))|(?:(?:\ud83c[\udfcb\udfcc]|\ud83d[\udd74\udd75\udd90]|[\u261d\u26f7\u26f9\u270c\u270d])(?:\ufe0f|(?!\ufe0e))|(?:\ud83c[\udf85\udfc2-\udfc4\udfc7\udfca]|\ud83d[\udc42\udc43\udc46-\udc50\udc66-\udc69\udc6e\udc70-\udc78\udc7c\udc81-\udc83\udc85-\udc87\udcaa\udd7a\udd95\udd96\ude45-\ude47\ude4b-\ude4f\udea3\udeb4-\udeb6\udec0\udecc]|\ud83e[\udd18-\udd1c\udd1e\udd1f\udd26\udd30-\udd39\udd3d\udd3e\uddb5\uddb6\uddb8\uddb9\uddd1-\udddd]|[\u270a\u270b]))(?:\ud83c[\udffb-\udfff])?|(?:\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc65\udb40\udc6e\udb40\udc67\udb40\udc7f|\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc73\udb40\udc63\udb40\udc74\udb40\udc7f|\ud83c\udff4\udb40\udc67\udb40\udc62\udb40\udc77\udb40\udc6c\udb40\udc73\udb40\udc7f|\ud83c\udde6\ud83c[\udde8-\uddec\uddee\uddf1\uddf2\uddf4\uddf6-\uddfa\uddfc\uddfd\uddff]|\ud83c\udde7\ud83c[\udde6\udde7\udde9-\uddef\uddf1-\uddf4\uddf6-\uddf9\uddfb\uddfc\uddfe\uddff]|\ud83c\udde8\ud83c[\udde6\udde8\udde9\uddeb-\uddee\uddf0-\uddf5\uddf7\uddfa-\uddff]|\ud83c\udde9\ud83c[\uddea\uddec\uddef\uddf0\uddf2\uddf4\uddff]|\ud83c\uddea\ud83c[\udde6\udde8\uddea\uddec\udded\uddf7-\uddfa]|\ud83c\uddeb\ud83c[\uddee-\uddf0\uddf2\uddf4\uddf7]|\ud83c\uddec\ud83c[\udde6\udde7\udde9-\uddee\uddf1-\uddf3\uddf5-\uddfa\uddfc\uddfe]|\ud83c\udded\ud83c[\uddf0\uddf2\uddf3\uddf7\uddf9\uddfa]|\ud83c\uddee\ud83c[\udde8-\uddea\uddf1-\uddf4\uddf6-\uddf9]|\ud83c\uddef\ud83c[\uddea\uddf2\uddf4\uddf5]|\ud83c\uddf0\ud83c[\uddea\uddec-\uddee\uddf2\uddf3\uddf5\uddf7\uddfc\uddfe\uddff]|\ud83c\uddf1\ud83c[\udde6-\udde8\uddee\uddf0\uddf7-\uddfb\uddfe]|\ud83c\uddf2\ud83c[\udde6\udde8-\udded\uddf0-\uddff]|\ud83c\uddf3\ud83c[\udde6\udde8\uddea-\uddec\uddee\uddf1\uddf4\uddf5\uddf7\uddfa\uddff]|\ud83c\uddf4\ud83c\uddf2|\ud83c\uddf5\ud83c[\udde6\uddea-\udded\uddf0-\uddf3\uddf7-\uddf9\uddfc\uddfe]|\ud83c\uddf6\ud83c\udde6|\ud83c\uddf7\ud83c[\uddea\uddf4\uddf8\uddfa\uddfc]|\ud83c\uddf8\ud83c[\udde6-\uddea\uddec-\uddf4\uddf7-\uddf9\uddfb\uddfd-\uddff]|\ud83c\uddf9\ud83c[\udde6\udde8\udde9\uddeb-\udded\uddef-\uddf4\uddf7\uddf9\uddfb\uddfc\uddff]|\ud83c\uddfa\ud83c[\udde6\uddec\uddf2\uddf3\uddf8\uddfe\uddff]|\ud83c\uddfb\ud83c[\udde6\udde8\uddea\uddec\uddee\uddf3\uddfa]|\ud83c\uddfc\ud83c[\uddeb\uddf8]|\ud83c\uddfd\ud83c\uddf0|\ud83c\uddfe\ud83c[\uddea\uddf9]|\ud83c\uddff\ud83c[\udde6\uddf2\uddfc]|\ud83c[\udccf\udd8e\udd91-\udd9a\udde6-\uddff\ude01\ude32-\ude36\ude38-\ude3a\ude50\ude51\udf00-\udf20\udf2d-\udf35\udf37-\udf7c\udf7e-\udf84\udf86-\udf93\udfa0-\udfc1\udfc5\udfc6\udfc8\udfc9\udfcf-\udfd3\udfe0-\udff0\udff4\udff8-\udfff]|\ud83d[\udc00-\udc3e\udc40\udc44\udc45\udc51-\udc65\udc6a-\udc6d\udc6f\udc79-\udc7b\udc7d-\udc80\udc84\udc88-\udca9\udcab-\udcfc\udcff-\udd3d\udd4b-\udd4e\udd50-\udd67\udda4\uddfb-\ude44\ude48-\ude4a\ude80-\udea2\udea4-\udeb3\udeb7-\udebf\udec1-\udec5\uded0-\uded2\udeeb\udeec\udef4-\udef9]|\ud83e[\udd10-\udd17\udd1d\udd20-\udd25\udd27-\udd2f\udd3a\udd3c\udd40-\udd45\udd47-\udd70\udd73-\udd76\udd7a\udd7c-\udda2\uddb4\uddb7\uddc0-\uddc2\uddd0\uddde-\uddff]|[\u23e9-\u23ec\u23f0\u23f3\u267e\u26ce\u2705\u2728\u274c\u274e\u2753-\u2755\u2795-\u2797\u27b0\u27bf\ue50a])|\ufe0f/g;
Object.defineProperty(dist, "__esModule", {
    value: !0
});
dist.TypeName = void 0;
var parse_1 = dist.parse = parse;
dist.toCodePoints = toCodePoints;
var _regex = regex
  , _regex2 = _interopRequireDefault(_regex);
function _interopRequireDefault(_e) {
    return _e && _e.__esModule ? _e : {
        default: _e
    }
}
var TypeName = dist.TypeName = "emoji";
function parse(_e, $) {
    var et = $ && $.assetType ? $.assetType : "svg"
      , tt = $ && $.buildUrl ? $.buildUrl : function(st, lt) {
        return lt === "png" ? "https://twemoji.maxcdn.com/2/72x72/" + st + ".png" : "https://twemoji.maxcdn.com/2/svg/" + st + ".svg"
    }
      , nt = [];
    for (_regex2.default.lastIndex = 0; ; ) {
        var rt = _regex2.default.exec(_e);
        if (!rt)
            break;
        var it = rt[0]
          , ot = toCodePoints(removeVS16s(it)).join("-");
        nt.push({
            url: ot ? tt(ot, et) : "",
            indices: [rt.index, _regex2.default.lastIndex],
            text: it,
            type: TypeName
        })
    }
    return nt
}
var vs16RegExp = /\uFE0F/g
  , zeroWidthJoiner = ""
  , removeVS16s = function($) {
    return $.indexOf(zeroWidthJoiner) < 0 ? $.replace(vs16RegExp, "") : $
};
function toCodePoints(_e) {
    for (var $ = [], et = 0, tt = 0, nt = 0; nt < _e.length; )
        et = _e.charCodeAt(nt++),
        tt ? ($.push((65536 + (tt - 55296 << 10) + (et - 56320)).toString(16)),
        tt = 0) : et > 55296 && et <= 56319 ? tt = et : $.push(et.toString(16));
    return $
}
var urlHasHttps = /^https:\/\//i
  , parseTweet = function() {
    for (var $ = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : configs.defaults, tt = Object.keys(et).length ? et : configs.defaults, nt = tt.defaultWeight, rt = tt.emojiParsingEnabled, it = tt.scale, ot = tt.maxWeightedTweetLength, st = tt.transformedURLLength, lt = typeof String.prototype.normalize == "function" ? $.normalize() : $, ct = transformEntitiesToHash(extractUrlsWithIndices(lt)), dt = rt ? transformEntitiesToHash(parse_1(lt)) : [], pt = lt.length, ht = 0, mt = 0, yt = !0, Et = 0; Et < pt; Et++) {
        if (ct[Et]) {
            var _t = ct[Et]
              , wt = _t.url;
            _t.indices,
            ht += st * it,
            Et += wt.length - 1
        } else if (rt && dt[Et]) {
            var St = dt[Et]
              , Ct = St.text;
            St.indices,
            ht += nt,
            Et += Ct.length - 1
        } else
            Et += isSurrogatePair(lt, Et) ? 1 : 0,
            ht += getCharacterWeight(lt.charAt(Et), tt);
        yt && (yt = !hasInvalidCharacters(lt.substring(Et, Et + 1))),
        yt && ht <= ot * it && (mt = Et)
    }
    ht = ht / it,
    yt = yt && ht > 0 && ht <= ot;
    var Nt = Math.floor(ht / ot * 1e3)
      , Lt = $.length - lt.length;
    return mt += Lt,
    {
        weightedLength: ht,
        valid: yt,
        permillage: Nt,
        validRangeStart: 0,
        validRangeEnd: mt,
        displayRangeStart: 0,
        displayRangeEnd: $.length > 0 ? $.length - 1 : 0
    }
}
  , transformEntitiesToHash = function($) {
    return $.reduce(function(et, tt) {
        return et[tt.indices[0]] = tt,
        et
    }, {})
}
  , isSurrogatePair = function($, et) {
    if (et < $.length - 1) {
        var tt = $.charCodeAt(et)
          , nt = $.charCodeAt(et + 1);
        return 55296 <= tt && tt <= 56319 && 56320 <= nt && nt <= 57343
    }
    return !1
}
  , getTweetLength = function($) {
    var et = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : configs.defaults;
    return parseTweet($, et).weightedLength
};
function getUnicodeTextLength(_e) {
    return _e.replace(nonBmpCodePairs, " ").length
}
function splitTags(_e) {
    for (var $ = _e.split("<"), et, tt = [], nt, rt = 0; rt < $.length; rt += 1)
        if (nt = $[rt],
        !nt)
            tt.push("");
        else {
            et = nt.split(">");
            for (var it = 0; it < et.length; it += 1)
                tt.push(et[it])
        }
    return tt
}
function hitHighlight(_e, $, et) {
    var tt = "em";
    if ($ = $ || [],
    et = et || {},
    $.length === 0)
        return _e;
    var nt = et.tag || tt, rt = ["<".concat(nt, ">"), "</".concat(nt, ">")], it = splitTags(_e), ot, st, lt = "", ct = 0, dt = it[0], pt = 0, ht = 0, mt = !1, yt = dt, Et = [], _t, wt, St, Ct, Nt;
    for (ot = 0; ot < $.length; ot += 1)
        for (st = 0; st < $[ot].length; st += 1)
            Et.push($[ot][st]);
    for (_t = 0; _t < Et.length; _t += 1) {
        for (wt = Et[_t],
        St = rt[_t % 2],
        Ct = !1; dt != null && wt >= pt + dt.length; )
            lt += yt.slice(ht),
            mt && wt === pt + yt.length && (lt += St,
            Ct = !0),
            it[ct + 1] && (lt += "<".concat(it[ct + 1], ">")),
            pt += yt.length,
            ht = 0,
            ct += 2,
            dt = it[ct],
            yt = dt,
            mt = !1;
        !Ct && dt != null ? (Nt = wt - pt,
        lt += yt.slice(ht, Nt) + St,
        ht = Nt,
        _t % 2 === 0 ? mt = !0 : mt = !1) : Ct || (Ct = !0,
        lt += St)
    }
    if (dt != null)
        for (ht < yt.length && (lt += yt.slice(ht)),
        _t = ct + 1; _t < it.length; _t += 1)
            lt += _t % 2 === 0 ? it[_t] : "<".concat(it[_t], ">");
    return lt
}
var $export$6 = _export;
$export$6($export$6.S + $export$6.F * !_descriptors, "Object", {
    defineProperty: _objectDp.f
});
var $export$5 = _export;
$export$5($export$5.S + $export$5.F * !_descriptors, "Object", {
    defineProperties: require_objectDps()
});
var _objectGops = {};
_objectGops.f = Object.getOwnPropertySymbols;
var gOPN$2 = _objectGopn
  , gOPS$1 = _objectGops
  , anObject$2 = _anObject
  , Reflect$1 = _globalExports.Reflect
  , _ownKeys = Reflect$1 && Reflect$1.ownKeys || function($) {
    var et = gOPN$2.f(anObject$2($))
      , tt = gOPS$1.f;
    return tt ? et.concat(tt($)) : et
}
  , $defineProperty$1 = _objectDp
  , createDesc$1 = _propertyDesc
  , _createProperty = function(_e, $, et) {
    $ in _e ? $defineProperty$1.f(_e, $, createDesc$1(0, et)) : _e[$] = et
}
  , $export$4 = _export
  , ownKeys$1 = _ownKeys
  , toIObject$2 = _toIobject
  , gOPD$1 = _objectGopd
  , createProperty$1 = _createProperty;
$export$4($export$4.S, "Object", {
    getOwnPropertyDescriptors: function($) {
        for (var et = toIObject$2($), tt = gOPD$1.f, nt = ownKeys$1(et), rt = {}, it = 0, ot, st; nt.length > it; )
            st = tt(et, ot = nt[it++]),
            st !== void 0 && createProperty$1(rt, ot, st);
        return rt
    }
});
var isObject$8 = _isObject
  , isArray$3 = _isArray
  , SPECIES = _wksExports("species")
  , _arraySpeciesConstructor = function(_e) {
    var $;
    return isArray$3(_e) && ($ = _e.constructor,
    typeof $ == "function" && ($ === Array || isArray$3($.prototype)) && ($ = void 0),
    isObject$8($) && ($ = $[SPECIES],
    $ === null && ($ = void 0))),
    $ === void 0 ? Array : $
}
  , speciesConstructor = _arraySpeciesConstructor
  , _arraySpeciesCreate = function(_e, $) {
    return new (speciesConstructor(_e))($)
}
  , ctx$1 = _ctx
  , IObject = _iobject
  , toObject$2 = _toObject
  , toLength$1 = _toLength
  , asc = _arraySpeciesCreate
  , _arrayMethods = function(_e, $) {
    var et = _e == 1
      , tt = _e == 2
      , nt = _e == 3
      , rt = _e == 4
      , it = _e == 6
      , ot = _e == 5 || it
      , st = $ || asc;
    return function(lt, ct, dt) {
        for (var pt = toObject$2(lt), ht = IObject(pt), mt = ctx$1(ct, dt, 3), yt = toLength$1(ht.length), Et = 0, _t = et ? st(lt, yt) : tt ? st(lt, 0) : void 0, wt, St; yt > Et; Et++)
            if ((ot || Et in ht) && (wt = ht[Et],
            St = mt(wt, Et, pt),
            _e)) {
                if (et)
                    _t[Et] = St;
                else if (St)
                    switch (_e) {
                    case 3:
                        return !0;
                    case 5:
                        return wt;
                    case 6:
                        return Et;
                    case 2:
                        _t.push(wt)
                    }
                else if (rt)
                    return !1
            }
        return it ? -1 : nt || rt ? rt : _t
    }
}
  , $export$3 = _export
  , $forEach = _arrayMethods(0)
  , STRICT = _strictMethod([].forEach, !0);
$export$3($export$3.P + $export$3.F * !STRICT, "Array", {
    forEach: function($) {
        return $forEach(this, $, arguments[1])
    }
});
var $export$2 = _export
  , $filter = _arrayMethods(2);
$export$2($export$2.P + $export$2.F * !_strictMethod([].filter, !0), "Array", {
    filter: function($) {
        return $filter(this, $, arguments[1])
    }
});
var _meta = {
    exports: {}
}
  , META$1 = _uid("meta")
  , isObject$7 = _isObject
  , has$1 = _has
  , setDesc = _objectDp.f
  , id = 0
  , isExtensible = Object.isExtensible || function() {
    return !0
}
  , FREEZE = !_fails(function() {
    return isExtensible(Object.preventExtensions({}))
})
  , setMeta = function(_e) {
    setDesc(_e, META$1, {
        value: {
            i: "O" + ++id,
            w: {}
        }
    })
}
  , fastKey = function(_e, $) {
    if (!isObject$7(_e))
        return typeof _e == "symbol" ? _e : (typeof _e == "string" ? "S" : "P") + _e;
    if (!has$1(_e, META$1)) {
        if (!isExtensible(_e))
            return "F";
        if (!$)
            return "E";
        setMeta(_e)
    }
    return _e[META$1].i
}
  , getWeak = function(_e, $) {
    if (!has$1(_e, META$1)) {
        if (!isExtensible(_e))
            return !0;
        if (!$)
            return !1;
        setMeta(_e)
    }
    return _e[META$1].w
}
  , onFreeze = function(_e) {
    return FREEZE && meta.NEED && isExtensible(_e) && !has$1(_e, META$1) && setMeta(_e),
    _e
}
  , meta = _meta.exports = {
    KEY: META$1,
    NEED: !1,
    fastKey,
    getWeak,
    onFreeze
}
  , _metaExports = _meta.exports
  , _wksExt = {};
_wksExt.f = _wksExports;
var global$1 = _globalExports
  , core = _coreExports
  , wksExt$1 = _wksExt
  , defineProperty$1 = _objectDp.f
  , _wksDefine = function(_e) {
    var $ = core.Symbol || (core.Symbol = global$1.Symbol || {});
    _e.charAt(0) != "_" && !(_e in $) && defineProperty$1($, _e, {
        value: wksExt$1.f(_e)
    })
}
  , getKeys = _objectKeys
  , gOPS = _objectGops
  , pIE = _objectPie
  , _enumKeys = function(_e) {
    var $ = getKeys(_e)
      , et = gOPS.f;
    if (et)
        for (var tt = et(_e), nt = pIE.f, rt = 0, it; tt.length > rt; )
            nt.call(_e, it = tt[rt++]) && $.push(it);
    return $
}
  , _objectGopnExt = {}
  , toIObject$1 = _toIobject
  , gOPN$1 = _objectGopn.f
  , toString$2 = {}.toString
  , windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : []
  , getWindowNames = function(_e) {
    try {
        return gOPN$1(_e)
    } catch {
        return windowNames.slice()
    }
};
_objectGopnExt.f = function($) {
    return windowNames && toString$2.call($) == "[object Window]" ? getWindowNames($) : gOPN$1(toIObject$1($))
}
;
var global = _globalExports
  , has = _has
  , DESCRIPTORS = _descriptors
  , $export$1 = _export
  , redefine = _redefineExports
  , META = _metaExports.KEY
  , $fails = _fails
  , shared = _sharedExports
  , setToStringTag = _setToStringTag
  , uid = _uid
  , wks = _wksExports
  , wksExt = _wksExt
  , wksDefine = _wksDefine
  , enumKeys = _enumKeys
  , isArray$2 = _isArray
  , anObject$1 = _anObject
  , isObject$6 = _isObject
  , toObject$1 = _toObject
  , toIObject = _toIobject
  , toPrimitive$1 = _toPrimitive
  , createDesc = _propertyDesc
  , _create = _objectCreate
  , gOPNExt = _objectGopnExt
  , $GOPD = _objectGopd
  , $GOPS = _objectGops
  , $DP = _objectDp
  , $keys = _objectKeys
  , gOPD = $GOPD.f
  , dP = $DP.f
  , gOPN = gOPNExt.f
  , $Symbol = global.Symbol
  , $JSON = global.JSON
  , _stringify = $JSON && $JSON.stringify
  , PROTOTYPE = "prototype"
  , HIDDEN = wks("_hidden")
  , TO_PRIMITIVE = wks("toPrimitive")
  , isEnum = {}.propertyIsEnumerable
  , SymbolRegistry = shared("symbol-registry")
  , AllSymbols = shared("symbols")
  , OPSymbols = shared("op-symbols")
  , ObjectProto = Object[PROTOTYPE]
  , USE_NATIVE = typeof $Symbol == "function" && !!$GOPS.f
  , QObject = global.QObject
  , setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild
  , setSymbolDesc = DESCRIPTORS && $fails(function() {
    return _create(dP({}, "a", {
        get: function() {
            return dP(this, "a", {
                value: 7
            }).a
        }
    })).a != 7
}) ? function(_e, $, et) {
    var tt = gOPD(ObjectProto, $);
    tt && delete ObjectProto[$],
    dP(_e, $, et),
    tt && _e !== ObjectProto && dP(ObjectProto, $, tt)
}
: dP
  , wrap$1 = function(_e) {
    var $ = AllSymbols[_e] = _create($Symbol[PROTOTYPE]);
    return $._k = _e,
    $
}
  , isSymbol$1 = USE_NATIVE && typeof $Symbol.iterator == "symbol" ? function(_e) {
    return typeof _e == "symbol"
}
: function(_e) {
    return _e instanceof $Symbol
}
  , $defineProperty = function($, et, tt) {
    return $ === ObjectProto && $defineProperty(OPSymbols, et, tt),
    anObject$1($),
    et = toPrimitive$1(et, !0),
    anObject$1(tt),
    has(AllSymbols, et) ? (tt.enumerable ? (has($, HIDDEN) && $[HIDDEN][et] && ($[HIDDEN][et] = !1),
    tt = _create(tt, {
        enumerable: createDesc(0, !1)
    })) : (has($, HIDDEN) || dP($, HIDDEN, createDesc(1, {})),
    $[HIDDEN][et] = !0),
    setSymbolDesc($, et, tt)) : dP($, et, tt)
}
  , $defineProperties = function($, et) {
    anObject$1($);
    for (var tt = enumKeys(et = toIObject(et)), nt = 0, rt = tt.length, it; rt > nt; )
        $defineProperty($, it = tt[nt++], et[it]);
    return $
}
  , $create = function($, et) {
    return et === void 0 ? _create($) : $defineProperties(_create($), et)
}
  , $propertyIsEnumerable = function($) {
    var et = isEnum.call(this, $ = toPrimitive$1($, !0));
    return this === ObjectProto && has(AllSymbols, $) && !has(OPSymbols, $) ? !1 : et || !has(this, $) || !has(AllSymbols, $) || has(this, HIDDEN) && this[HIDDEN][$] ? et : !0
}
  , $getOwnPropertyDescriptor = function($, et) {
    if ($ = toIObject($),
    et = toPrimitive$1(et, !0),
    !($ === ObjectProto && has(AllSymbols, et) && !has(OPSymbols, et))) {
        var tt = gOPD($, et);
        return tt && has(AllSymbols, et) && !(has($, HIDDEN) && $[HIDDEN][et]) && (tt.enumerable = !0),
        tt
    }
}
  , $getOwnPropertyNames = function($) {
    for (var et = gOPN(toIObject($)), tt = [], nt = 0, rt; et.length > nt; )
        !has(AllSymbols, rt = et[nt++]) && rt != HIDDEN && rt != META && tt.push(rt);
    return tt
}
  , $getOwnPropertySymbols = function($) {
    for (var et = $ === ObjectProto, tt = gOPN(et ? OPSymbols : toIObject($)), nt = [], rt = 0, it; tt.length > rt; )
        has(AllSymbols, it = tt[rt++]) && (!et || has(ObjectProto, it)) && nt.push(AllSymbols[it]);
    return nt
};
USE_NATIVE || ($Symbol = function() {
    if (this instanceof $Symbol)
        throw TypeError("Symbol is not a constructor!");
    var $ = uid(arguments.length > 0 ? arguments[0] : void 0)
      , et = function(tt) {
        this === ObjectProto && et.call(OPSymbols, tt),
        has(this, HIDDEN) && has(this[HIDDEN], $) && (this[HIDDEN][$] = !1),
        setSymbolDesc(this, $, createDesc(1, tt))
    };
    return DESCRIPTORS && setter && setSymbolDesc(ObjectProto, $, {
        configurable: !0,
        set: et
    }),
    wrap$1($)
}
,
redefine($Symbol[PROTOTYPE], "toString", function() {
    return this._k
}),
$GOPD.f = $getOwnPropertyDescriptor,
$DP.f = $defineProperty,
_objectGopn.f = gOPNExt.f = $getOwnPropertyNames,
_objectPie.f = $propertyIsEnumerable,
$GOPS.f = $getOwnPropertySymbols,
DESCRIPTORS && redefine(ObjectProto, "propertyIsEnumerable", $propertyIsEnumerable, !0),
wksExt.f = function(_e) {
    return wrap$1(wks(_e))
}
);
$export$1($export$1.G + $export$1.W + $export$1.F * !USE_NATIVE, {
    Symbol: $Symbol
});
for (var es6Symbols = "hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","), j = 0; es6Symbols.length > j; )
    wks(es6Symbols[j++]);
for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k; )
    wksDefine(wellKnownSymbols[k++]);
$export$1($export$1.S + $export$1.F * !USE_NATIVE, "Symbol", {
    for: function(_e) {
        return has(SymbolRegistry, _e += "") ? SymbolRegistry[_e] : SymbolRegistry[_e] = $Symbol(_e)
    },
    keyFor: function($) {
        if (!isSymbol$1($))
            throw TypeError($ + " is not a symbol!");
        for (var et in SymbolRegistry)
            if (SymbolRegistry[et] === $)
                return et
    },
    useSetter: function() {
        setter = !0
    },
    useSimple: function() {
        setter = !1
    }
});
$export$1($export$1.S + $export$1.F * !USE_NATIVE, "Object", {
    create: $create,
    defineProperty: $defineProperty,
    defineProperties: $defineProperties,
    getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
    getOwnPropertyNames: $getOwnPropertyNames,
    getOwnPropertySymbols: $getOwnPropertySymbols
});
var FAILS_ON_PRIMITIVES = $fails(function() {
    $GOPS.f(1)
});
$export$1($export$1.S + $export$1.F * FAILS_ON_PRIMITIVES, "Object", {
    getOwnPropertySymbols: function($) {
        return $GOPS.f(toObject$1($))
    }
});
$JSON && $export$1($export$1.S + $export$1.F * (!USE_NATIVE || $fails(function() {
    var _e = $Symbol();
    return _stringify([_e]) != "[null]" || _stringify({
        a: _e
    }) != "{}" || _stringify(Object(_e)) != "{}"
})), "JSON", {
    stringify: function($) {
        for (var et = [$], tt = 1, nt, rt; arguments.length > tt; )
            et.push(arguments[tt++]);
        if (rt = nt = et[1],
        !(!isObject$6(nt) && $ === void 0 || isSymbol$1($)))
            return isArray$2(nt) || (nt = function(it, ot) {
                if (typeof rt == "function" && (ot = rt.call(this, it, ot)),
                !isSymbol$1(ot))
                    return ot
            }
            ),
            et[1] = nt,
            _stringify.apply($JSON, et)
    }
});
$Symbol[PROTOTYPE][TO_PRIMITIVE] || _hide($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
setToStringTag($Symbol, "Symbol");
setToStringTag(Math, "Math", !0);
setToStringTag(global.JSON, "JSON", !0);
function _typeof(_e) {
    "@babel/helpers - typeof";
    return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function($) {
        return typeof $
    }
    : function($) {
        return $ && typeof Symbol == "function" && $.constructor === Symbol && $ !== Symbol.prototype ? "symbol" : typeof $
    }
    ,
    _typeof(_e)
}
function toPrimitive(_e, $) {
    if (_typeof(_e) != "object" || !_e)
        return _e;
    var et = _e[Symbol.toPrimitive];
    if (et !== void 0) {
        var tt = et.call(_e, $);
        if (_typeof(tt) != "object")
            return tt;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return ($ === "string" ? String : Number)(_e)
}
function toPropertyKey(_e) {
    var $ = toPrimitive(_e, "string");
    return _typeof($) == "symbol" ? $ : $ + ""
}
function _defineProperty(_e, $, et) {
    return ($ = toPropertyKey($))in _e ? Object.defineProperty(_e, $, {
        value: et,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : _e[$] = et,
    _e
}
function ownKeys(_e, $) {
    var et = Object.keys(_e);
    if (Object.getOwnPropertySymbols) {
        var tt = Object.getOwnPropertySymbols(_e);
        $ && (tt = tt.filter(function(nt) {
            return Object.getOwnPropertyDescriptor(_e, nt).enumerable
        })),
        et.push.apply(et, tt)
    }
    return et
}
function _objectSpread(_e) {
    for (var $ = 1; $ < arguments.length; $++) {
        var et = arguments[$] != null ? arguments[$] : {};
        $ % 2 ? ownKeys(et, !0).forEach(function(tt) {
            _defineProperty(_e, tt, et[tt])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(_e, Object.getOwnPropertyDescriptors(et)) : ownKeys(et).forEach(function(tt) {
            Object.defineProperty(_e, tt, Object.getOwnPropertyDescriptor(et, tt))
        })
    }
    return _e
}
function isInvalidTweet(_e) {
    var $ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : configs.defaults;
    if (!_e)
        return "empty";
    var et = _objectSpread({}, configs.defaults, {}, $)
      , tt = et.maxWeightedTweetLength;
    return getTweetLength(_e, et) > tt ? "too_long" : hasInvalidCharacters(_e) ? "invalid_characters" : !1
}
function isValidHashtag(_e) {
    if (!_e)
        return !1;
    var $ = extractHashtags(_e);
    return $.length === 1 && $[0] === _e.slice(1)
}
var VALID_LIST_RE = regexSupplant(/^#{validMentionOrList}$/, {
    validMentionOrList
});
function isValidList(_e) {
    var $ = _e.match(VALID_LIST_RE);
    return !!($ && $[1] == "" && $[4])
}
function isValidTweetText(_e, $) {
    return !isInvalidTweet(_e, $)
}
var validateUrlUnreserved = /[a-z\u0400-\u04FF0-9\-._~]/i
  , validateUrlPctEncoded = /(?:%[0-9a-f]{2})/i
  , validateUrlSubDelims = /[!$&'()*+,;=]/i
  , validateUrlUserinfo = regexSupplant("(?:#{validateUrlUnreserved}|#{validateUrlPctEncoded}|#{validateUrlSubDelims}|:)*", {
    validateUrlUnreserved,
    validateUrlPctEncoded,
    validateUrlSubDelims
}, "i")
  , validateUrlDomainSegment = /(?:[a-z0-9](?:[a-z0-9\-]*[a-z0-9])?)/i
  , validateUrlDomainTld = /(?:[a-z](?:[a-z0-9\-]*[a-z0-9])?)/i
  , validateUrlSubDomainSegment = /(?:[a-z0-9](?:[a-z0-9_\-]*[a-z0-9])?)/i
  , validateUrlDomain = regexSupplant(/(?:(?:#{validateUrlSubDomainSegment}\.)*(?:#{validateUrlDomainSegment}\.)#{validateUrlDomainTld})/i, {
    validateUrlSubDomainSegment,
    validateUrlDomainSegment,
    validateUrlDomainTld
})
  , validateUrlDecOctet = /(?:[0-9]|(?:[1-9][0-9])|(?:1[0-9]{2})|(?:2[0-4][0-9])|(?:25[0-5]))/i
  , validateUrlIpv4 = regexSupplant(/(?:#{validateUrlDecOctet}(?:\.#{validateUrlDecOctet}){3})/i, {
    validateUrlDecOctet
})
  , validateUrlIpv6 = /(?:\[[a-f0-9:\.]+\])/i
  , validateUrlIp = regexSupplant("(?:#{validateUrlIpv4}|#{validateUrlIpv6})", {
    validateUrlIpv4,
    validateUrlIpv6
}, "i")
  , validateUrlHost = regexSupplant("(?:#{validateUrlIp}|#{validateUrlDomain})", {
    validateUrlIp,
    validateUrlDomain
}, "i")
  , validateUrlPort = /[0-9]{1,5}/
  , validateUrlAuthority = regexSupplant("(?:(#{validateUrlUserinfo})@)?(#{validateUrlHost})(?::(#{validateUrlPort}))?", {
    validateUrlUserinfo,
    validateUrlHost,
    validateUrlPort
}, "i")
  , validateUrlPchar = regexSupplant("(?:#{validateUrlUnreserved}|#{validateUrlPctEncoded}|#{validateUrlSubDelims}|[:|@])", {
    validateUrlUnreserved,
    validateUrlPctEncoded,
    validateUrlSubDelims
}, "i")
  , validateUrlFragment = regexSupplant(/(#{validateUrlPchar}|\/|\?)*/i, {
    validateUrlPchar
})
  , validateUrlPath = regexSupplant(/(\/#{validateUrlPchar}*)*/i, {
    validateUrlPchar
})
  , validateUrlQuery = regexSupplant(/(#{validateUrlPchar}|\/|\?)*/i, {
    validateUrlPchar
})
  , validateUrlScheme = /(?:[a-z][a-z0-9+\-.]*)/i
  , validateUrlUnencoded = regexSupplant("^(?:([^:/?#]+):\\/\\/)?([^/?#]*)([^?#]*)(?:\\?([^#]*))?(?:#(.*))?$", "i")
  , validateUrlUnicodeSubDomainSegment = /(?:(?:[a-z0-9]|[^\u0000-\u007f])(?:(?:[a-z0-9_\-]|[^\u0000-\u007f])*(?:[a-z0-9]|[^\u0000-\u007f]))?)/i
  , validateUrlUnicodeDomainSegment = /(?:(?:[a-z0-9]|[^\u0000-\u007f])(?:(?:[a-z0-9\-]|[^\u0000-\u007f])*(?:[a-z0-9]|[^\u0000-\u007f]))?)/i
  , validateUrlUnicodeDomainTld = /(?:(?:[a-z]|[^\u0000-\u007f])(?:(?:[a-z0-9\-]|[^\u0000-\u007f])*(?:[a-z0-9]|[^\u0000-\u007f]))?)/i
  , validateUrlUnicodeDomain = regexSupplant(/(?:(?:#{validateUrlUnicodeSubDomainSegment}\.)*(?:#{validateUrlUnicodeDomainSegment}\.)#{validateUrlUnicodeDomainTld})/i, {
    validateUrlUnicodeSubDomainSegment,
    validateUrlUnicodeDomainSegment,
    validateUrlUnicodeDomainTld
})
  , validateUrlUnicodeHost = regexSupplant("(?:#{validateUrlIp}|#{validateUrlUnicodeDomain})", {
    validateUrlIp,
    validateUrlUnicodeDomain
}, "i")
  , validateUrlUnicodeAuthority = regexSupplant("(?:(#{validateUrlUserinfo})@)?(#{validateUrlUnicodeHost})(?::(#{validateUrlPort}))?", {
    validateUrlUserinfo,
    validateUrlUnicodeHost,
    validateUrlPort
}, "i");
function isValidMatch(_e, $, et) {
    return et ? !_e || _e.match($) && RegExp["$&"] === _e : typeof _e == "string" && _e.match($) && RegExp["$&"] === _e
}
function isValidUrl(_e, $, et) {
    if ($ == null && ($ = !0),
    et == null && (et = !0),
    !_e)
        return !1;
    var tt = _e.match(validateUrlUnencoded);
    if (!tt || tt[0] !== _e)
        return !1;
    var nt = tt[1]
      , rt = tt[2]
      , it = tt[3]
      , ot = tt[4]
      , st = tt[5];
    return (!et || isValidMatch(nt, validateUrlScheme) && nt.match(/^https?$/i)) && isValidMatch(it, validateUrlPath) && isValidMatch(ot, validateUrlQuery, !0) && isValidMatch(st, validateUrlFragment, !0) ? $ && isValidMatch(rt, validateUrlUnicodeAuthority) || !$ && isValidMatch(rt, validateUrlAuthority) : !1
}
function isValidUsername(_e) {
    if (!_e)
        return !1;
    var $ = extractMentions(_e);
    return $.length === 1 && $[0] === _e.slice(1)
}
const regexen = {
    astralLetterAndMarks,
    astralNumerals,
    atSigns,
    bmpLetterAndMarks,
    bmpNumerals,
    cashtag,
    codePoint,
    cyrillicLettersAndMarks,
    endHashtagMatch,
    endMentionMatch,
    extractUrl,
    hashSigns,
    hashtagAlpha,
    hashtagAlphaNumeric,
    hashtagBoundary,
    hashtagSpecialChars,
    invalidChars,
    invalidCharsGroup,
    invalidDomainChars,
    invalidUrlWithoutProtocolPrecedingChars,
    latinAccentChars,
    nonBmpCodePairs,
    punct,
    rtlChars,
    spaces,
    spacesGroup,
    urlHasHttps,
    urlHasProtocol,
    validAsciiDomain,
    validateUrlAuthority,
    validateUrlDecOctet,
    validateUrlDomain,
    validateUrlDomainSegment,
    validateUrlDomainTld,
    validateUrlFragment,
    validateUrlHost,
    validateUrlIp,
    validateUrlIpv4,
    validateUrlIpv6,
    validateUrlPath,
    validateUrlPchar,
    validateUrlPctEncoded,
    validateUrlPort,
    validateUrlQuery,
    validateUrlScheme,
    validateUrlSubDelims,
    validateUrlSubDomainSegment,
    validateUrlUnencoded,
    validateUrlUnicodeAuthority,
    validateUrlUnicodeDomain,
    validateUrlUnicodeDomainSegment,
    validateUrlUnicodeDomainTld,
    validateUrlUnicodeHost,
    validateUrlUnicodeSubDomainSegment,
    validateUrlUnreserved,
    validateUrlUserinfo,
    validCashtag,
    validCCTLD,
    validDomain,
    validDomainChars,
    validDomainName,
    validGeneralUrlPathChars,
    validGTLD,
    validHashtag,
    validMentionOrList,
    validMentionPrecedingChars,
    validPortNumber,
    validPunycode,
    validReply,
    validSubdomain,
    validTcoUrl,
    validUrlBalancedParens,
    validUrlPath,
    validUrlPathEndingChars,
    validUrlPrecedingChars,
    validUrlQueryChars,
    validUrlQueryEndingChars
};
var $at = _stringAt(!0);
_iterDefine(String, "String", function(_e) {
    this._t = String(_e),
    this._i = 0
}, function() {
    var _e = this._t, $ = this._i, et;
    return $ >= _e.length ? {
        value: void 0,
        done: !0
    } : (et = $at(_e, $),
    this._i += et.length,
    {
        value: et,
        done: !1
    })
});
var anObject = _anObject, _iterCall = function(_e, $, et, tt) {
    try {
        return tt ? $(anObject(et)[0], et[1]) : $(et)
    } catch (rt) {
        var nt = _e.return;
        throw nt !== void 0 && anObject(nt.call(_e)),
        rt
    }
}, Iterators$1 = _iterators, ITERATOR$1 = _wksExports("iterator"), ArrayProto = Array.prototype, _isArrayIter = function(_e) {
    return _e !== void 0 && (Iterators$1.Array === _e || ArrayProto[ITERATOR$1] === _e)
}, classof = _classof, ITERATOR = _wksExports("iterator"), Iterators = _iterators, core_getIteratorMethod = _coreExports.getIteratorMethod = function(_e) {
    if (_e != null)
        return _e[ITERATOR] || _e["@@iterator"] || Iterators[classof(_e)]
}
, _iterDetect, hasRequired_iterDetect;
function require_iterDetect() {
    if (hasRequired_iterDetect)
        return _iterDetect;
    hasRequired_iterDetect = 1;
    var _e = _wksExports("iterator")
      , $ = !1;
    try {
        var et = [7][_e]();
        et.return = function() {
            $ = !0
        }
        ,
        Array.from(et, function() {
            throw 2
        })
    } catch {}
    return _iterDetect = function(tt, nt) {
        if (!nt && !$)
            return !1;
        var rt = !1;
        try {
            var it = [7]
              , ot = it[_e]();
            ot.next = function() {
                return {
                    done: rt = !0
                }
            }
            ,
            it[_e] = function() {
                return ot
            }
            ,
            tt(it)
        } catch {}
        return rt
    }
    ,
    _iterDetect
}
var ctx = _ctx
  , $export = _export
  , toObject = _toObject
  , call = _iterCall
  , isArrayIter = _isArrayIter
  , toLength = _toLength
  , createProperty = _createProperty
  , getIterFn = core_getIteratorMethod;
$export($export.S + $export.F * !require_iterDetect()(function(_e) {
    Array.from(_e)
}), "Array", {
    from: function($) {
        var et = toObject($), tt = typeof this == "function" ? this : Array, nt = arguments.length, rt = nt > 1 ? arguments[1] : void 0, it = rt !== void 0, ot = 0, st = getIterFn(et), lt, ct, dt, pt;
        if (it && (rt = ctx(rt, nt > 2 ? arguments[2] : void 0, 2)),
        st != null && !(tt == Array && isArrayIter(st)))
            for (pt = st.call(et),
            ct = new tt; !(dt = pt.next()).done; ot++)
                createProperty(ct, ot, it ? call(pt, rt, [dt.value, ot], !0) : dt.value);
        else
            for (lt = toLength(et.length),
            ct = new tt(lt); lt > ot; ot++)
                createProperty(ct, ot, it ? rt(et[ot], ot) : et[ot]);
        return ct.length = ot,
        ct
    }
});
function standardizeIndices(_e, $, et) {
    var tt = getUnicodeTextLength(_e)
      , nt = _e.length - tt;
    if (nt > 0) {
        var rt = Array.from(_e)
          , it = $ === 0 ? "" : rt.slice(0, $).join("")
          , ot = rt.slice($, et).join("");
        return [it.length, it.length + ot.length]
    }
    return [$, et]
}
const twitterText = {
    autoLink,
    autoLinkCashtags,
    autoLinkEntities,
    autoLinkHashtags,
    autoLinkUrlsCustom,
    autoLinkUsernamesOrLists,
    autoLinkWithJSON,
    configs,
    convertUnicodeIndices,
    extractCashtags,
    extractCashtagsWithIndices,
    extractEntitiesWithIndices,
    extractHashtags,
    extractHashtagsWithIndices,
    extractHtmlAttrsFromOptions,
    extractMentions,
    extractMentionsOrListsWithIndices,
    extractMentionsWithIndices,
    extractReplies,
    extractUrls,
    extractUrlsWithIndices,
    getTweetLength,
    getUnicodeTextLength,
    hasInvalidCharacters,
    hitHighlight,
    htmlEscape,
    isInvalidTweet,
    isValidHashtag,
    isValidList,
    isValidTweetText,
    isValidUrl,
    isValidUsername,
    linkTextWithEntity,
    linkToCashtag,
    linkToHashtag,
    linkToMentionAndList,
    linkToText,
    linkToTextWithSymbol,
    linkToUrl,
    modifyIndicesFromUTF16ToUnicode,
    modifyIndicesFromUnicodeToUTF16,
    regexen,
    removeOverlappingEntities,
    parseTweet,
    splitTags,
    standardizeIndices,
    tagAttrs
}
  , getStringCharactersLength = _e => _e ? twitterText.parseTweet(_e).weightedLength : 0
  , AVATAR_SIZE_FOR_AWS = 100;
function getThumbnailPicUrl(_e, $=Dom_Size.MEDIA_PIC_SIZE) {
    if (!_e)
        return "";
    if (getFileSuffix(_e),
    _e.includes("blob") || _e.includes("base64"))
        return _e;
    const et = Decimal.max($ * 2, AVATAR_SIZE_FOR_AWS).toNumber();
    return `${_e}?w=${et}&h=${et}`
}
function toDecimalPlaces(_e, $=DEFAULT_PRECISION, et=Decimal.ROUND_DOWN) {
    try {
        return new Decimal(_e).toFixed($, et)
    } catch {
        return String(_e || "-")
    }
}
function isEmptyAmount(_e, $=DEFAULT_PRECISION) {
    return new Decimal(_e).mul(Decimal.pow(10, $)).trunc().isZero()
}
const formatNumber = (_e="", $=2, et=!1) => {
    if (_e === "")
        return "-";
    if (isEqualTo(_e, "0"))
        return "0";
    try {
        const tt = toDecimalPlaces(_e, $, et ? Decimal.ROUND_HALF_EVEN : Decimal.ROUND_DOWN);
        let nt = new Decimal(tt).toFixed();
        const rt = nt.indexOf(".");
        rt >= 0 && (nt = nt);
        const it = new Decimal(_e)
          , ot = new Decimal(1).dividedBy(new Decimal(10).pow($));
        return !isNegative(it) && it.lessThan(ot) ? nt = `<${ot.toFixed($)}` : nt = `${it.toDecimalPlaces($).toFixed()}`,
        it.toNumber() > 1 ? nt.replace(/\d(?=(?:\d{3})+(?:\.|$))/g, (st, lt) => rt < 0 || lt < rt ? `${st},` : st) : nt
    } catch {
        return "-"
    }
}
  , toNearestValue = (_e="", $=2) => {
    if (_e === "")
        return "-";
    if (isEqualTo(_e, "0"))
        return "0";
    try {
        const et = new Decimal(_e).toNearest(NEAREST_VALUE).toNumber();
        return isGreaterThan(new Decimal(1).div(new Decimal(10).pow($)), _e) ? `<${new Decimal(1).div(new Decimal(10).pow($)).toFixed($)}` : formatNumber(et, $)
    } catch {
        return "-"
    }
}
;
function toUsd(_e, $=2, et=Decimal.ROUND_DOWN) {
    try {
        if (isEmptyAmount(_e))
            return "$0.00";
        const nt = new Decimal(_e)
          , rt = div(1, Decimal.pow(10, $));
        return nt.gte(0) && nt.lt(rt) ? `<$${rt}` : nt.gt(`-${rt}`) && nt.lt(0) ? `<-$${rt}` : isPositive(nt) ? `$${formatNumber(nt.toFixed($, et), $)}` : `-$${formatNumber(nt.abs().toFixed($, et), $)}`
    } catch {
        return String(_e || "-")
    }
}
function formatUnits(_e, $) {
    if (!isNumeric(_e))
        return "0";
    try {
        return new Decimal(toDecimalPlaces(_e, 0)).div(10 ** $).toFixed()
    } catch {
        return "0"
    }
}
function amountFormatter(_e, $=2) {
    let et = "";
    try {
        const tt = new Decimal(_e).abs();
        if (tt.isZero())
            return "0";
        const nt = new Decimal(_e)
          , rt = new Decimal(1).dividedBy(new Decimal(10).pow($));
        if (new Decimal(nt).abs().lessThan(rt))
            return `${rt.toFixed($)}`;
        const it = [{
            value: 1,
            symbol: ""
        }, {
            value: 1e3,
            symbol: "K"
        }, {
            value: 1e6,
            symbol: "M"
        }, {
            value: 1e9,
            symbol: "B"
        }, {
            value: 1e12,
            symbol: "T"
        }, {
            value: 1e15,
            symbol: "P"
        }, {
            value: 1e18,
            symbol: "E"
        }];
        let ot;
        for (ot = it.length - 1; ot > 0 && !tt.gte(it[ot].value); ot--)
            ;
        const st = tt.div(it[ot].value).toFixed($) + it[ot].symbol;
        return isNegative(_e) ? `-${st}` : st
    } catch {
        et = "-"
    }
    return et
}
function shortenAddress(_e, $=4) {
    return _e ? `${_e.substring(0, $ + 2)}...${_e.slice(-4)}` : ""
}
function DefaultAvatar(_e) {
    const {size: $=24} = _e;
    return jsxRuntimeExports.jsxs("svg", {
        width: $,
        height: $,
        viewBox: "0 0 512 512",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [jsxRuntimeExports.jsx("rect", {
            width: "512",
            height: "512",
            rx: "256",
            fill: "#202020"
        }), jsxRuntimeExports.jsx("path", {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M332.055 303.334C357.84 290.855 374.354 277.349 374.354 255.365C374.354 211.34 316.936 200.217 285.834 194.384C266.094 190.682 206.585 186.187 206.585 162.41C206.585 138.633 242.007 134.801 259.108 134.801C286.741 134.801 314.748 147.818 319.591 176.562L370.253 169.643C365.198 114.037 307.628 94.6074 259.176 94.6074C209.974 94.6074 156.477 112.532 153.051 165.335C153.051 184.335 158.019 194.072 170.239 206.974C143.65 219.372 137.646 236.249 137.646 255.053C140.104 299.725 187.884 305.493 219.33 311.134C235.551 314.044 338.607 332.533 285.834 362.586C256.972 379.022 196.908 376.738 190.916 336.093L140.104 341.365C145.615 394.407 196.117 417.39 244.173 417.39C294.51 417.39 356.93 396.914 356.93 344.487C356.93 325.805 347.18 312.691 332.055 303.334ZM218.044 219.126C261.911 230.927 323.536 232.756 323.536 259.586C323.536 272.363 303.884 279.523 283.518 284.586C256.122 277.881 187.482 279.673 183.588 245.25C182.187 232.87 194.894 226.631 218.044 219.126Z",
            fill: "white"
        })]
    })
}
function UserAvatar(_e) {
    const {src: $, size: et, userId: tt, ...nt} = _e;
    return jsxRuntimeExports.jsx(Avatar$1, {
        src: getThumbnailPicUrl($, et * 2),
        sx: {
            width: et,
            height: et
        },
        ...nt,
        children: jsxRuntimeExports.jsx(DefaultAvatar$2, {
            size: et,
            userId: tt
        })
    })
}
function TokenAvatar(_e) {
    const {src: $, size: et, symbol: tt, isBase64: nt=!1, ...rt} = _e
      , [it,ot] = reactExports.useState("")
      , st = lt => {
        let ct = new Image;
        ct.setAttribute("crossOrigin", "anonymous"),
        ct.onload = function() {
            let dt = document.createElement("canvas");
            dt.width = ct.width,
            dt.height = ct.height,
            dt.getContext("2d").drawImage(ct, 0, 0, ct.width, ct.height);
            let ht = dt.toDataURL("image/png");
            ot(ht)
        }
        ,
        ct.src = lt
    }
    ;
    return reactExports.useEffect( () => {
        nt && st(getThumbnailPicUrl($, et))
    }
    , [nt]),
    jsxRuntimeExports.jsx(Avatar$1, {
        src: tt === "SOL" ? $ : tt === PLATFORM_TOKEN ? "" : nt ? it : getThumbnailPicUrl($, et),
        sx: {
            width: et,
            height: et,
            backgroundColor: "transparent"
        },
        ...rt,
        children: tt === PLATFORM_TOKEN ? jsxRuntimeExports.jsx(DefaultAvatar, {
            size: et
        }) : jsxRuntimeExports.jsx(DefaultAvatar$1, {
            size: et
        })
    })
}
function useAppBreakpoints() {
    const _e = useTheme()
      , $ = useMediaQuery(_e.breakpoints.down("md"))
      , et = useMediaQuery(_e.breakpoints.up("md"))
      , tt = useMediaQuery(_e.breakpoints.down("lg"))
      , nt = useMediaQuery(_e.breakpoints.up("lg"))
      , rt = useMediaQuery(_e.breakpoints.down("xl"))
      , it = useMediaQuery(_e.breakpoints.up("xl"));
    return {
        isMatchMobile: $,
        isMatchPad: et && tt,
        isMatchPc: nt,
        isUpMd: et,
        isUpXl: it,
        isDownXl: rt,
        isDownLg: tt,
        isUpLg: nt
    }
}
const StyledTabs = styled(_e => {
    const {size: $, ...et} = _e;
    return jsxRuntimeExports.jsx(Tabs, {
        ...et,
        TabIndicatorProps: {
            children: jsxRuntimeExports.jsx("div", {
                className: "MuiTabs-indicatorSpan"
            })
        }
    })
}
)( ({theme: _e, type: $="normal"}) => (useAppBreakpoints(),
{
    position: "relative",
    borderBottom: `1px solid ${_e.palette.divider}`,
    padding: "2px 0 0",
    "& .MuiTabs-indicator": {
        display: "none",
        bottom: "-1px",
        justifyContent: "center",
        backgroundColor: "transparent"
    },
    "& .MuiTabs-indicatorSpan": {
        width: "100% !important",
        height: "2px",
        backgroundColor: _e.palette.primary.main,
        boxShadow: "0px 2px 4px 0px #98FF7880"
    },
    "& .MuiTab-root": {
        marginRight: "20px",
        fontWeight: 400,
        color: _e.custom.textColorL2,
        "&.Mui-selected": {
            color: _e.palette.primary.main,
            backgroundColor: _e.palette.background.default,
            fontWeight: 800,
            borderRadius: "32px"
        }
    },
    "& .MuiSvgIcon-root": {
        fontSize: 20
    },
    "& .MuiButtonBase-root": {
        minWidth: "auto"
    }
}))
  , StyledTab = styled(Tab)( () => ({
    position: "relative",
    textTransform: "none",
    fontWeight: 400,
    minWidth: "auto",
    fontSize: "14px",
    padding: "12px 0",
    "&.Mui-focusVisible": {
        backgroundColor: "rgba(100, 95, 228, 0.32)"
    },
    "@media screen and (max-width: 768px)": {
        minWidth: "auto"
    }
}));
create$1()(persist(_e => ({
    notificationSetting: {},
    setNotificationSetting: $ => _e({
        notificationSetting: $
    }),
    isReadAll: !1,
    setIsReadAll: $ => _e({
        isReadAll: $
    }),
    unread: {},
    setUnread: $ => _e({
        unread: $
    })
}), {
    name: "notification"
}));
var classnames = {
    exports: {}
};
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(_e) {
    (function() {
        var $ = {}.hasOwnProperty;
        function et() {
            for (var rt = "", it = 0; it < arguments.length; it++) {
                var ot = arguments[it];
                ot && (rt = nt(rt, tt(ot)))
            }
            return rt
        }
        function tt(rt) {
            if (typeof rt == "string" || typeof rt == "number")
                return rt;
            if (typeof rt != "object")
                return "";
            if (Array.isArray(rt))
                return et.apply(null, rt);
            if (rt.toString !== Object.prototype.toString && !rt.toString.toString().includes("[native code]"))
                return rt.toString();
            var it = "";
            for (var ot in rt)
                $.call(rt, ot) && rt[ot] && (it = nt(it, ot));
            return it
        }
        function nt(rt, it) {
            return it ? rt ? rt + " " + it : rt + it : rt
        }
        _e.exports ? (et.default = et,
        _e.exports = et) : window.classNames = et
    }
    )()
}
)(classnames);
var classnamesExports = classnames.exports;
const cn = getDefaultExportFromCjs$2(classnamesExports);
function Loading({size: _e=16, color: $}) {
    const et = useTheme();
    return jsxRuntimeExports.jsx(Box, {
        component: "span",
        className: "inline-block leading-none",
        children: jsxRuntimeExports.jsx(CircularProgress, {
            disableShrink: !0,
            size: _e,
            sx: {
                color: $ || et.palette.text.primary,
                fontWeight: 700
            }
        })
    })
}
function LoadingForSection({size: _e="medium"}) {
    return jsxRuntimeExports.jsx("span", {
        className: cn("loader-section", _e)
    })
}
function SectionLoadingContainer({loading: _e, children: $, ...et}) {
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: _e === !0 ? jsxRuntimeExports.jsx(Box, {
            className: "flex items-center justify-center",
            ...et,
            sx: {
                height: Dom_Size.SECTION_LOADING
            },
            children: jsxRuntimeExports.jsx(LoadingForSection, {})
        }) : jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
            children: $
        })
    })
}
class InfiniteScroll extends reactExports.Component {
    constructor($) {
        super($),
        this.scrollListener = this.scrollListener.bind(this),
        this.eventListenerOptions = this.eventListenerOptions.bind(this),
        this.mousewheelListener = this.mousewheelListener.bind(this)
    }
    componentDidMount() {
        this.pageLoaded = this.props.pageStart,
        this.options = this.eventListenerOptions(),
        this.attachScrollListener()
    }
    componentDidUpdate() {
        if (this.props.isReverse && this.loadMore) {
            const $ = this.getParentElement(this.scrollComponent);
            $.scrollTop = $.scrollHeight - this.beforeScrollHeight + this.beforeScrollTop,
            this.loadMore = !1
        }
        this.attachScrollListener()
    }
    componentWillUnmount() {
        this.detachScrollListener(),
        this.detachMousewheelListener()
    }
    isPassiveSupported() {
        let $ = !1;
        const et = {
            get passive() {
                $ = !0
            }
        };
        try {
            document.addEventListener("test", null, et),
            document.removeEventListener("test", null, et)
        } catch {}
        return $
    }
    eventListenerOptions() {
        let $ = this.props.useCapture;
        return this.isPassiveSupported() ? $ = {
            useCapture: this.props.useCapture,
            passive: !0
        } : $ = {
            passive: !1
        },
        $
    }
    setDefaultLoader($) {
        this.defaultLoader = $
    }
    detachMousewheelListener() {
        let $ = window;
        this.props.useWindow === !1 && ($ = this.scrollComponent.parentNode),
        $.removeEventListener("mousewheel", this.mousewheelListener, this.options ? this.options : this.props.useCapture)
    }
    detachScrollListener() {
        let $ = window;
        this.props.useWindow === !1 && ($ = this.getParentElement(this.scrollComponent)),
        $.removeEventListener("scroll", this.scrollListener, this.options ? this.options : this.props.useCapture),
        $.removeEventListener("resize", this.scrollListener, this.options ? this.options : this.props.useCapture)
    }
    getParentElement($) {
        const et = this.props.getScrollParent && this.props.getScrollParent();
        return et ?? ($ && $.parentNode)
    }
    filterProps($) {
        return $
    }
    attachScrollListener() {
        const $ = this.getParentElement(this.scrollComponent);
        if (!this.props.hasMore || !$)
            return;
        let et = window;
        this.props.useWindow === !1 && (et = $),
        et.addEventListener("mousewheel", this.mousewheelListener, this.options ? this.options : this.props.useCapture),
        et.addEventListener("scroll", this.scrollListener, this.options ? this.options : this.props.useCapture),
        et.addEventListener("resize", this.scrollListener, this.options ? this.options : this.props.useCapture),
        this.props.initialLoad && this.scrollListener()
    }
    mousewheelListener($) {
        $.deltaY === 1 && !this.isPassiveSupported() && $.preventDefault()
    }
    scrollListener() {
        const $ = this.scrollComponent
          , et = window
          , tt = this.getParentElement($);
        let nt;
        if (this.props.useWindow) {
            const rt = document.documentElement || document.body.parentNode || document.body
              , it = et.pageYOffset !== void 0 ? et.pageYOffset : rt.scrollTop;
            this.props.isReverse ? nt = it : nt = this.calculateOffset($, it)
        } else
            this.props.isReverse ? nt = tt.scrollTop : nt = $.scrollHeight - tt.scrollTop - tt.clientHeight;
        nt < Number(this.props.threshold) && $ && $.offsetParent !== null && (this.detachScrollListener(),
        this.beforeScrollHeight = tt.scrollHeight,
        this.beforeScrollTop = tt.scrollTop,
        typeof this.props.loadMore == "function" && (this.props.loadMore(this.pageLoaded += 1),
        this.loadMore = !0))
    }
    calculateOffset($, et) {
        return $ ? this.calculateTopPosition($) + ($.offsetHeight - et - window.innerHeight) : 0
    }
    calculateTopPosition($) {
        return $ ? $.offsetTop + this.calculateTopPosition($.offsetParent) : 0
    }
    render() {
        const $ = this.filterProps(this.props)
          , {children: et, element: tt, hasMore: nt, initialLoad: rt, isReverse: it, loader: ot, loadMore: st, pageStart: lt, ref: ct, threshold: dt, useCapture: pt, useWindow: ht, getScrollParent: mt, ...yt} = $;
        yt.ref = _t => {
            this.scrollComponent = _t,
            ct && ct(_t)
        }
        ;
        const Et = [et];
        return nt && (ot ? it ? Et.unshift(ot) : Et.push(ot) : this.defaultLoader && (it ? Et.unshift(this.defaultLoader) : Et.push(this.defaultLoader))),
        React.createElement(tt, yt, Et)
    }
}
Br(InfiniteScroll, "propTypes", {
    children: PropTypes.node.isRequired,
    element: PropTypes.node,
    hasMore: PropTypes.bool,
    initialLoad: PropTypes.bool,
    isReverse: PropTypes.bool,
    loader: PropTypes.node,
    loadMore: PropTypes.func.isRequired,
    pageStart: PropTypes.number,
    ref: PropTypes.func,
    getScrollParent: PropTypes.func,
    threshold: PropTypes.number,
    useCapture: PropTypes.bool,
    useWindow: PropTypes.bool
}),
Br(InfiniteScroll, "defaultProps", {
    element: "div",
    hasMore: !1,
    initialLoad: !0,
    pageStart: 0,
    ref: null,
    threshold: 250,
    useWindow: !0,
    isReverse: !1,
    useCapture: !1,
    loader: null,
    getScrollParent: null
});
styled(Divider)( ({theme: _e, type: $, level: et}) => ({
    borderColor: et === "l1" ? _e.custom.dividerColorL1 : _e.palette.divider,
    borderStyle: $ ?? ""
}));
const NoDataSay = React.memo( ({children: _e, height: $=Dom_Size.SECTION_LOADING, ...et}) => jsxRuntimeExports.jsx(Box, {
    className: "flex items-center justify-center",
    sx: {
        minHeight: $
    },
    children: jsxRuntimeExports.jsx(Box, {
        className: "flex flex-col  justify-center items-center",
        children: jsxRuntimeExports.jsx(Text, {
            variant: "h6",
            className: "leading-4 mt-2",
            children: _e ?? jsxRuntimeExports.jsx(Trans, {
                id: "4SBV0R"
            })
        })
    })
}));
function SearchSvg$1(_e) {
    return jsxRuntimeExports.jsx("svg", {
        width: "24",
        height: "24",
        viewBox: "0 0 24 24",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ..._e,
        children: jsxRuntimeExports.jsx("path", {
            d: "M21 21L16.65 16.65M11 6C13.7614 6 16 8.23858 16 11M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z",
            stroke: "#9CA3AF",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        })
    })
}
function CloseIcon(_e) {
    const $ = useTheme()
      , {fill: et=$.palette.text.secondary, size: tt=32} = _e;
    return jsxRuntimeExports.jsx(SvgIcon, {
        ..._e,
        children: jsxRuntimeExports.jsx("svg", {
            width: tt,
            height: tt,
            viewBox: "0 0 32 33",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg",
            children: jsxRuntimeExports.jsx("path", {
                d: "M24 8.5L8 24.5M8 8.5L24 24.5",
                stroke: et,
                strokeWidth: "2.66667",
                strokeLinecap: "round",
                strokeLinejoin: "round"
            })
        })
    })
}
function useSearchPostAndUser(_e, $) {
    const [et,tt] = reactExports.useState([])
      , [nt,rt] = reactExports.useState([])
      , [it,ot] = reactExports.useState(null)
      , [st,lt] = reactExports.useState("")
      , [ct,dt] = reactExports.useState(!1)
      , [pt,ht] = reactExports.useState(!1)
      , {data: mt, loading: yt, fetching: Et, execute: _t, refresh: wt, request: St} = postSearch({
        cursor: "",
        limit: DEFAULT_PAGE_LIMIT,
        param: $,
        search_type: _e
    }, !0);
    return useUpdateEffect( () => {
        if (!pt && mt && mt.code === API_Code.Success) {
            const {posts: Nt, users: Lt, tickers: kt} = mt.data;
            if (_e === SearchType.POSTS) {
                const Ut = Nt.map(Jt => ({
                    ...Jt
                }));
                tt(st === "" ? Ut : lodashExports.uniqBy([...et, ...Ut], "post_id"))
            } else
                _e === SearchType.USERS ? rt([...nt, ...Lt]) : ot(kt);
            lt(mt.data.cursor),
            dt(mt.data.has_more)
        }
    }
    , [mt]),
    {
        cursor: st,
        hasMore: ct,
        postList: et,
        userList: nt,
        tickerList: it,
        loading: yt,
        fetching: Et,
        execute: _t,
        refresh: wt,
        request: St,
        reset: () => {
            lt(""),
            dt(!1),
            tt([]),
            rt([]),
            ot(null),
            ht(!1)
        }
    }
}
function Search({onSelect: _e}) {
    const {theme: $} = useStore$1()
      , et = useNavigate()
      , {param: tt=""} = useParams()
      , nt = useLocation()
      , [rt,it] = reactExports.useState(tt)
      , [ot,st] = reactExports.useState("")
      , [lt,ct] = reactExports.useState(!1);
    useDebounce( () => {
        st(rt)
    }
    , DEBOUNCE_TIME_OUT, [rt]);
    const {loading: dt, tickerList: pt, execute: ht, refresh: mt, reset: yt} = useSearchPostAndUser(SearchType.TICKERS, ot)
      , Et = useTheme()
      , {isMatchMobile: _t, isMatchPc: wt} = useAppBreakpoints();
    useUpdateEffect( () => {
        if (ot.trim() !== "") {
            if (!pt) {
                ht(),
                ct(!0);
                return
            }
            ct(!0),
            mt({
                cursor: "",
                limit: DEFAULT_PAGE_LIMIT,
                param: ot,
                search_type: SearchType.TICKERS
            })
        }
    }
    , [ot]);
    const St = kt => {
        _e == null || _e(kt),
        et(`/${kt.market.token_symbol}`),
        ct(!1)
    }
      , Ct = () => {
        ct(!1)
    }
      , Nt = () => {
        it(""),
        ct(!1),
        yt()
    }
      , Lt = kt => {
        const Ut = kt.target.value;
        if (Ut.trim() === "") {
            it(""),
            ct(!1),
            yt();
            return
        }
        Ut.trim().length <= 44 ? it(Ut) : it(Ut.slice(0, 44))
    }
    ;
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: jsxRuntimeExports.jsx(ClickAwayListener, {
            onClickAway: Ct,
            children: jsxRuntimeExports.jsxs(Box, {
                className: "relative",
                children: [jsxRuntimeExports.jsx(OutlinedInput, {
                    value: rt,
                    onChange: Lt,
                    type: "text",
                    placeholder: i18n._({
                        id: "pLSc6a"
                    }),
                    fullWidth: !0,
                    sx: {
                        height: nt.pathname === "/landing" ? "56px" : "44px",
                        "& .MuiOutlinedInput-input": {
                            paddingLeft: "8px"
                        }
                    },
                    startAdornment: jsxRuntimeExports.jsx(SearchSvg$1, {}),
                    endAdornment: rt ? jsxRuntimeExports.jsx(IconButton, {
                        className: "size-6",
                        onClick: Nt,
                        children: jsxRuntimeExports.jsx(CloseIcon, {
                            className: "size-5"
                        })
                    }) : null
                }), lt && jsxRuntimeExports.jsx(Paper, {
                    className: "absolute top-[110%] left-0 z-10 overflow-auto px-0",
                    sx: {
                        boxShadow: "none",
                        width: nt.pathname === "/landing" && wt ? "50%" : "100%",
                        height: wt ? "260px" : "calc(100vh - 108px)",
                        backgroundColor: $ === App_Theme.light ? Et.palette.primary.contrastText : Et.palette.background.paper
                    },
                    children: jsxRuntimeExports.jsx(SectionLoadingContainer, {
                        loading: dt || !pt,
                        children: pt && pt.length > 0 ? jsxRuntimeExports.jsx(MenuList, {
                            children: pt.map( (kt, Ut) => {
                                var Jt;
                                return jsxRuntimeExports.jsxs(MenuItem, {
                                    className: "flex items-center space-x-3 sm:space-x-1 w-full sm:px-0",
                                    onClick: () => St(kt),
                                    children: [jsxRuntimeExports.jsx(TokenAvatar, {
                                        symbol: (Jt = kt.market) == null ? void 0 : Jt.token_symbol,
                                        src: kt.market_metadata.image_url,
                                        size: _t ? 24 : 30
                                    }), jsxRuntimeExports.jsxs("div", {
                                        className: "flex-1 truncate",
                                        children: [jsxRuntimeExports.jsx(Typography, {
                                            fontWeight: 700,
                                            children: kt.market.token_symbol
                                        }), jsxRuntimeExports.jsx(Typography, {
                                            color: "text.secondary",
                                            variant: "body2",
                                            noWrap: !0,
                                            children: kt.market.token_name
                                        })]
                                    })]
                                }, Ut)
                            }
                            )
                        }) : jsxRuntimeExports.jsx(Box, {
                            className: "min-h-[260px] w-full flex justify-center items-center",
                            children: jsxRuntimeExports.jsx(Typography, {
                                variant: "body1",
                                className: "text-center",
                                children: jsxRuntimeExports.jsx(Trans, {
                                    id: "4SBV0R"
                                })
                            })
                        })
                    })
                })]
            })
        })
    })
}
function CommonButton({children: _e, className: $, componentVariant: et, ...tt}) {
    const nt = useTheme();
    return et === "short" ? jsxRuntimeExports.jsx(Button, {
        variant: "contained",
        className: `px-6 py-1.5 font-bold ${$}`,
        ...tt,
        sx: {
            backgroundColor: nt.palette.error.main,
            color: nt.palette.common.white,
            "&:hover": {
                backgroundColor: lighten(nt.palette.error.main, .2)
            },
            "&:disabled": {
                opacity: nt.palette.action.disabledOpacity,
                background: nt.palette.error.main
            }
        },
        children: _e
    }) : et === "outlined" ? jsxRuntimeExports.jsx(Button, {
        variant: "outlined",
        color: "secondary",
        className: $,
        ...tt,
        sx: {
            border: `1px solid ${nt.palette.divider}`,
            color: nt.palette.text.primary,
            "&:hover": {
                border: `1px solid ${nt.custom.dividerColorL1}`,
                background: alpha(nt.palette.text.primary, .06)
            }
        },
        children: _e
    }) : et === "secondary" ? jsxRuntimeExports.jsx(Button, {
        variant: "contained",
        color: "secondary",
        className: $,
        size: "large",
        sx: {
            transition: "0.5s",
            backgroundColor: alpha(nt.palette.text.primary, .06),
            color: nt.palette.text.secondary,
            "&:disabled": {
                color: nt.palette.common.black,
                background: nt.palette.primary.main,
                opacity: .5,
                cursor: "not-allowed"
            }
        },
        ...tt,
        children: _e
    }) : jsxRuntimeExports.jsx(Button, {
        variant: "contained",
        color: "primary",
        className: $,
        size: "large",
        sx: {
            transition: "0.5s",
            "&:hover": {
                background: alpha(nt.palette.primary.main, .8)
            },
            "&:disabled": {
                color: nt.palette.common.black,
                background: nt.palette.primary.main,
                opacity: .5,
                cursor: "not-allowed"
            }
        },
        ...tt,
        children: _e
    })
}
const Dialog = _e => {
    const {title: $, titleAlign: et="start", children: tt, open: nt, onClose: rt, maxWidth: it, width: ot, height: st, disabled: lt, confirmLabel: ct="Confirm", onConfirm: dt, cancelLabel: pt="Cancel", onCancel: ht, size: mt, loading: yt, zIndex: Et, ..._t} = _e
      , {isMatchMobile: wt} = useAppBreakpoints()
      , St = Lt => {
        Lt.stopPropagation(),
        dt && dt()
    }
      , Ct = Lt => {
        Lt.stopPropagation(),
        ht && ht()
    }
      , Nt = Lt => {
        Lt.stopPropagation(),
        rt()
    }
    ;
    return jsxRuntimeExports.jsxs(Dialog$1, {
        open: nt,
        onClose: rt,
        maxWidth: it,
        fullScreen: wt,
        className: "m-auto",
        sx: {
            "& >.MuiDialog-container": {
                overflow: "hidden"
            },
            "& .MuiPaper-root": {
                width: mt === "large" ? wt ? "100%" : ot || "auto" : wt ? "100%" : ot,
                borderBottomLeftRadius: wt ? "0" : "inheirt",
                borderBottomRightRadius: wt ? "0" : "inheirt"
            },
            "& .MuiDialog-paper": {
                minHeight: st
            },
            zIndex: wt && Et ? Et : 1300
        },
        children: [jsxRuntimeExports.jsx(DialogTitle, {
            className: "pt-[24px] pb-[16px] px-8",
            children: jsxRuntimeExports.jsxs(Box, {
                className: "flex items-center",
                children: [jsxRuntimeExports.jsx(Text, {
                    className: "text-[20px] leading-5 flex-1 -mt-1",
                    fontWeight: 500,
                    children: jsxRuntimeExports.jsx(Box, {
                        className: `flex justify-${et}`,
                        children: $
                    })
                }), jsxRuntimeExports.jsx(IconButton, {
                    onClick: Nt,
                    className: "-mr-2",
                    children: jsxRuntimeExports.jsx(CloseIcon, {
                        size: 60
                    })
                })]
            })
        }), jsxRuntimeExports.jsx(DialogContent, {
            ..._t,
            children: tt
        }), (dt || ht) && jsxRuntimeExports.jsxs(DialogActions, {
            className: "px-8 pt-0 sm:px-3",
            children: [!ht && jsxRuntimeExports.jsx(CommonButton, {
                componentVariant: "confirm",
                className: "font-bold h-[50px]",
                fullWidth: !0,
                onClick: St,
                disabled: lt,
                startIcon: yt ? jsxRuntimeExports.jsx(Loading, {}) : null,
                children: ct
            }), ht && jsxRuntimeExports.jsxs("div", {
                className: "flex flex-1 space-x-3",
                children: [jsxRuntimeExports.jsx(CommonButton, {
                    fullWidth: !0,
                    componentVariant: "outlined",
                    className: "h-[50px]",
                    onClick: Ct,
                    children: pt
                }), jsxRuntimeExports.jsx(CommonButton, {
                    fullWidth: !0,
                    variant: "contained",
                    className: "h-[50px]",
                    disabled: lt,
                    onClick: St,
                    startIcon: yt ? jsxRuntimeExports.jsx(Loading, {}) : null,
                    children: ct
                })]
            })]
        })]
    })
}
  , Logo = "data:image/svg+xml,%3csvg%20width='86'%20height='116'%20viewBox='0%200%2086%20116'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M70.3325%2075.011C79.5989%2070.5263%2085.5335%2065.6729%2085.5335%2057.7723C85.5335%2041.9508%2064.899%2037.9535%2053.7216%2035.8572C46.6276%2034.5268%2025.2416%2032.9114%2025.2416%2024.3665C25.2416%2015.8216%2037.9714%2014.4447%2044.117%2014.4447C54.0477%2014.4447%2064.1127%2019.1227%2065.853%2029.4524L84.0596%2026.9658C82.243%206.98234%2061.554%200%2044.1413%200C26.4595%200%207.23417%206.44171%206.00274%2025.4176C6.00274%2032.2458%207.78818%2035.7452%2012.1798%2040.3816C2.62433%2044.8374%200.466797%2050.9024%200.466797%2057.6603C1.35003%2073.7143%2018.5209%2075.7869%2029.8217%2077.8142C35.6513%2078.86%2072.6869%2085.5046%2053.7216%2096.3047C43.3494%20102.211%2021.7638%20101.391%2019.6104%2086.7838L1.35003%2088.6786C3.33053%20107.741%2021.4796%20116%2038.7498%20116C56.8397%20116%2079.2717%20108.641%2079.2717%2089.8006C79.2717%2083.0867%2075.7678%2078.3738%2070.3325%2075.011ZM29.3596%2044.749C45.1245%2048.99%2067.2708%2049.6472%2067.2708%2059.2892C67.2708%2063.8811%2060.2082%2066.4541%2052.8892%2068.2735C43.0441%2065.8638%2018.3766%2066.5078%2016.9769%2054.1371C16.4735%2049.6882%2021.0402%2047.4459%2029.3596%2044.749Z'%20fill='white'/%3e%3c/svg%3e";
styled("div")`
  width: 100vw;
  min-height: 100vh;
  box-sizing: border-box;
  overflow: hidden;
`;
function ExplorerLink({path: _e, label: $, className: et}) {
    const {getExplorerUrl: tt} = useCluster();
    return jsxRuntimeExports.jsx("a", {
        href: tt(_e),
        target: "_blank",
        rel: "noopener noreferrer",
        className: et || "link font-mono",
        children: $
    })
}
const solIcon = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%20512%20512'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3ccircle%20cx='256'%20cy='256'%20r='256'%20fill='%23202020'/%3e%3cg%20clip-path='url(%23clip0_2604_8669)'%3e%3cpath%20d='M389.532%20326.489L343.975%20374.674C342.993%20375.732%20341.8%20376.574%20340.472%20377.146C339.143%20377.719%20337.709%20378.01%20336.261%20378H120.304C119.274%20377.994%20118.268%20377.695%20117.405%20377.138C116.542%20376.58%20115.859%20375.788%20115.437%20374.855C115.023%20373.925%20114.896%20372.893%20115.073%20371.891C115.254%20370.884%20115.721%20369.949%20116.419%20369.198L161.921%20321.012C162.902%20319.954%20164.096%20319.111%20165.424%20318.539C166.753%20317.966%20168.187%20317.676%20169.635%20317.687H385.593C386.628%20317.659%20387.648%20317.937%20388.523%20318.486C389.399%20319.036%20390.09%20319.831%20390.509%20320.772C390.929%20321.712%20391.057%20322.755%20390.878%20323.768C390.699%20324.782%20390.221%20325.719%20389.504%20326.462L389.532%20326.489ZM343.966%20229.431C342.968%20228.394%20341.771%20227.566%20340.447%20226.995C339.122%20226.424%20337.696%20226.121%20336.252%20226.105H120.304C119.273%20226.111%20118.266%20226.412%20117.403%20226.971C116.54%20227.531%20115.858%20228.325%20115.437%20229.259C115.023%20230.19%20114.896%20231.221%20115.073%20232.223C115.255%20233.236%20115.719%20234.148%20116.419%20234.907L161.921%20283.12C162.895%20284.159%20164.105%20285%20165.414%20285.56C166.752%20286.138%20168.171%20286.419%20169.635%20286.446H385.593C386.617%20286.448%20387.619%20286.151%20388.475%20285.592C389.331%20285.033%20390.002%20284.236%20390.405%20283.301C390.82%20282.371%20390.948%20281.34%20390.773%20280.338C390.599%20279.335%20390.128%20278.407%20389.423%20277.671L343.939%20229.458L343.966%20229.431ZM120.294%20194.819H336.252C337.703%20194.811%20339.138%20194.517%20340.473%20193.952C341.81%20193.373%20342.993%20192.56%20343.966%20191.493L389.541%20143.308C390.067%20142.75%20390.463%20142.084%20390.702%20141.357C390.941%20140.63%20391.017%20139.861%20390.924%20139.102C390.831%20138.343%20390.572%20137.613%20390.165%20136.964C389.758%20136.316%20389.213%20135.763%20388.567%20135.346C387.692%20134.789%20386.668%20134.506%20385.629%20134.533H169.635C168.198%20134.533%20166.752%20134.84%20165.414%20135.392C164.088%20135.96%20162.898%20136.801%20161.921%20137.859L116.419%20186.044C115.723%20186.79%20115.26%20187.721%20115.086%20188.724C114.911%20189.726%20115.033%20190.757%20115.437%20191.692C115.858%20192.624%20116.54%20193.415%20117.401%20193.972C118.263%20194.53%20119.267%20194.83%20120.294%20194.837V194.819Z'%20fill='url(%23paint0_linear_2604_8669)'/%3e%3c/g%3e%3cdefs%3e%3clinearGradient%20id='paint0_linear_2604_8669'%20x1='138.297'%20y1='383.802'%20x2='361.294'%20y2='128.955'%20gradientUnits='userSpaceOnUse'%3e%3cstop%20offset='0.08'%20stop-color='%239945FF'/%3e%3cstop%20offset='0.3'%20stop-color='%238752F3'/%3e%3cstop%20offset='0.5'%20stop-color='%235497D5'/%3e%3cstop%20offset='0.6'%20stop-color='%2343B4CA'/%3e%3cstop%20offset='0.72'%20stop-color='%2328E0B9'/%3e%3cstop%20offset='0.97'%20stop-color='%2319FB9B'/%3e%3c/linearGradient%3e%3cclipPath%20id='clip0_2604_8669'%3e%3crect%20width='282'%20height='244'%20fill='white'%20transform='translate(115%20134)'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";
function useCheckLogin() {
    const {connected: _e} = useWallet()
      , {token: $} = useStore$1()
      , et = "Wallet not connected"
      , tt = reactExports.useCallback( () => !$ || !_e ? (Vt.error(et),
    !1) : !0, [$, _e]);
    return {
        message: et,
        isLogin: !!$ && _e,
        onCheckLogin: tt,
        onToggleLogin: () => {
            Vt.error(et)
        }
    }
}
function CreateButton({isUserInfo: _e=!1, handleOpenCreate: $}) {
    const {isMatchMobile: et} = useAppBreakpoints()
      , tt = () => {
        $({
            meta: !0,
            buy: !1
        })
    }
    ;
    return jsxRuntimeExports.jsx(Box, {
        children: _e ? jsxRuntimeExports.jsx(Button, {
            className: "h-[44px]",
            variant: "outlined",
            color: "secondary",
            onClick: tt,
            fullWidth: !0,
            children: jsxRuntimeExports.jsx(Trans, {
                id: "gvAbMv"
            })
        }) : jsxRuntimeExports.jsx(Button, {
            className: "h-[44px] sm:h-[30px]",
            variant: "outlined",
            size: et ? "small" : "medium",
            onClick: tt,
            children: jsxRuntimeExports.jsx(Trans, {
                id: "hYgDIe"
            })
        })
    })
}
function UserInfoBox({handleOpenCreate: _e}) {
    const $ = useTheme()
      , {isLogin: et} = useCheckLogin()
      , {publicKey: tt} = useWallet()
      , {nativeBalance: nt} = useStore$1()
      , {logout: rt} = useLogin()
      , [it,ot] = React.useState(null)
      , {setOpen: st} = useWalletDialog()
      , lt = St => {
        ot(St.currentTarget)
    }
      , ct = () => {
        ot(null)
    }
      , dt = !!it
      , pt = dt ? "simple-popover" : void 0
      , [ht,mt] = useCopyClipboard()
      , yt = St => {
        mt(St)
    }
      , {isMatchMobile: Et, isMatchPc: _t} = useAppBreakpoints()
      , wt = St => {
        _e(St),
        ot(null)
    }
    ;
    return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, {
        children: [et && jsxRuntimeExports.jsx(Box, {
            className: "flex items-center",
            children: jsxRuntimeExports.jsx(Button, {
                className: "h-[44px] sm:h-[30px]",
                "aria-describedby": pt,
                size: Et ? "small" : "medium",
                onClick: lt,
                children: jsxRuntimeExports.jsxs(Box, {
                    className: "flex items-center space-x-2",
                    children: [_t && jsxRuntimeExports.jsxs(Box, {
                        className: "flex items-center",
                        children: [jsxRuntimeExports.jsx("img", {
                            src: solIcon
                        }), jsxRuntimeExports.jsxs(Text, {
                            color: "text.primary",
                            children: [formatNumber(formatNativeBalance(nt)), " SOL"]
                        })]
                    }), jsxRuntimeExports.jsxs("div", {
                        className: "flex items-center",
                        children: [jsxRuntimeExports.jsx(Text, {
                            level: "l2",
                            children: shortenAddress(tt && tt.toBase58())
                        }), dt ? jsxRuntimeExports.jsx(ArrowDropUpIcon, {
                            sx: {
                                color: $.palette.text.primary
                            }
                        }) : jsxRuntimeExports.jsx(ExpandMoreIcon, {
                            sx: {
                                color: $.palette.text.primary
                            }
                        })]
                    })]
                })
            })
        }), jsxRuntimeExports.jsx(Popover, {
            id: pt,
            open: dt,
            anchorEl: it,
            onClose: ct,
            anchorOrigin: {
                vertical: "bottom",
                horizontal: "right"
            },
            transformOrigin: {
                vertical: "top",
                horizontal: "right"
            },
            children: et && jsxRuntimeExports.jsxs(Box, {
                className: "p-4 space-y-4 w-[332px]",
                children: [Et && jsxRuntimeExports.jsx(CreateButton, {
                    isUserInfo: !0,
                    handleOpenCreate: wt
                }), jsxRuntimeExports.jsx(Button, {
                    className: "h-[44px]",
                    variant: "outlined",
                    color: "secondary",
                    onClick: () => yt(tt && tt.toBase58()),
                    fullWidth: !0,
                    children: ht ? jsxRuntimeExports.jsx(Trans, {
                        id: "6V3Ea3"
                    }) : jsxRuntimeExports.jsx(Trans, {
                        id: "zXagFp"
                    })
                }), jsxRuntimeExports.jsx(Button, {
                    className: "h-[44px]",
                    variant: "outlined",
                    color: "secondary",
                    onClick: () => {
                        rt(),
                        st(!0),
                        ot(null)
                    }
                    ,
                    fullWidth: !0,
                    children: jsxRuntimeExports.jsx(Trans, {
                        id: "3A/mG4"
                    })
                }), jsxRuntimeExports.jsx(Button, {
                    className: "h-[44px]",
                    variant: "outlined",
                    color: "secondary",
                    onClick: () => {
                        rt(),
                        ot(null)
                    }
                    ,
                    fullWidth: !0,
                    children: jsxRuntimeExports.jsx(Trans, {
                        id: "+K0AvT"
                    })
                })]
            })
        })]
    })
}
function Nav() {
    const {isMatchMobile: _e} = useAppBreakpoints()
      , $ = useTheme()
      , {pathname: et} = useLocation()
      , [tt,nt,rt,it] = reactExports.useMemo( () => [et === "/", et === "/portfolio", et === "/points", et === "/SUPER"], [et]);
    return jsxRuntimeExports.jsx(Box, {
        className: "px-3 flex items-center",
        sx: {
            height: Dom_Size.HEIGHT_NAV_MOBILE,
            borderBottom: _e ? `1px solid ${$.palette.divider}` : "0 none"
        },
        children: jsxRuntimeExports.jsxs("ul", {
            className: "flex items-center space-x-8 md:space-x-5 sm:space-x-5",
            children: [jsxRuntimeExports.jsx("li", {
                children: jsxRuntimeExports.jsx(NavLink, {
                    to: "/",
                    end: !0,
                    children: jsxRuntimeExports.jsx(Text, {
                        variant: "h6",
                        color: tt ? "primary" : "text.secondary",
                        fontWeight: 500,
                        children: jsxRuntimeExports.jsx(Trans, {
                            id: "AHWd74"
                        })
                    })
                })
            }), jsxRuntimeExports.jsx("li", {
                children: jsxRuntimeExports.jsx(NavLink, {
                    to: "/portfolio",
                    end: !0,
                    children: jsxRuntimeExports.jsx(Text, {
                        variant: "h6",
                        color: nt ? "primary" : "text.secondary",
                        fontWeight: 500,
                        children: jsxRuntimeExports.jsx(Trans, {
                            id: "mXGEjA"
                        })
                    })
                })
            }), jsxRuntimeExports.jsx("li", {
                children: jsxRuntimeExports.jsx(NavLink, {
                    to: "/points",
                    children: jsxRuntimeExports.jsx(Text, {
                        variant: "h6",
                        color: rt ? "primary" : "text.secondary",
                        fontWeight: 500,
                        children: jsxRuntimeExports.jsx(Trans, {
                            id: "WJUXN9"
                        })
                    })
                })
            }), jsxRuntimeExports.jsx("li", {
                children: jsxRuntimeExports.jsx(NavLink, {
                    to: "/SUPER",
                    children: jsxRuntimeExports.jsx(Text, {
                        variant: "h6",
                        color: it ? "primary" : "text.secondary",
                        fontWeight: 500,
                        children: jsxRuntimeExports.jsx(Trans, {
                            id: "cEAtfR"
                        })
                    })
                })
            })]
        })
    })
}
const LanguagePopover = reactExports.forwardRef(function() {
    const {activeLocale: $, setActiveLocale: et} = useStore$1()
      , [tt,nt] = reactExports.useState(!1)
      , [rt,it] = reactExports.useState(null)
      , ot = useTheme()
      , st = ct => {
        et(ct),
        dayjs.locale($.toLowerCase()),
        nt(!1)
    }
      , lt = ct => {
        nt(!0),
        ct && (ct != null && ct.currentTarget) && it(ct.currentTarget)
    }
    ;
    return reactExports.useEffect( () => {
        $ && dayjs.locale($.toLowerCase())
    }
    , [$]),
    jsxRuntimeExports.jsxs(Box, {
        sx: {
            borderRadius: "4px",
            "&:hover": {
                textDecoration: "none",
                backgroundColor: ot.palette.action.hover
            }
        },
        children: [jsxRuntimeExports.jsx(Box, {
            className: "flex cursor-pointer justify-between",
            onClick: lt,
            children: jsxRuntimeExports.jsxs("svg", {
                width: "20",
                height: "20",
                viewBox: "0 0 20 20",
                fill: "none",
                xmlns: "http://www.w3.org/2000/svg",
                children: [jsxRuntimeExports.jsx("g", {
                    clipPath: "url(#clip0_16159_30046)",
                    children: jsxRuntimeExports.jsx("path", {
                        d: "M10.0002 0.833496C15.0628 0.833496 19.1668 4.93749 19.1668 10.0002C19.1668 15.0628 15.0628 19.1668 10.0002 19.1668C4.93749 19.1668 0.833496 15.0628 0.833496 10.0002C0.833496 4.93749 4.93749 0.833496 10.0002 0.833496ZM13.0393 10.7641H6.96103C7.12985 14.6633 8.56902 17.6391 10.0002 17.6391C11.4309 17.6391 12.8705 14.6633 13.0393 10.7641ZM5.43173 10.7641L2.39909 10.7644C2.67943 13.5855 4.49443 15.9551 6.9977 17.0264C6.09746 15.4914 5.52836 13.2604 5.43173 10.7644V10.7641ZM17.6012 10.7644H14.5686C14.472 13.2608 13.9029 15.4914 13.0026 17.026C15.5059 15.9554 17.3209 13.5855 17.6012 10.7644ZM6.99808 2.97429L6.91329 3.01096C4.45318 4.09874 2.676 6.44693 2.39947 9.23627H5.43211C5.52874 6.73989 6.09784 4.50895 6.99808 2.97429ZM10.0002 2.36127L9.94287 2.3628C8.5312 2.44072 7.12794 5.38933 6.96103 9.23627H13.0393C12.8705 5.33739 11.4313 2.36127 10.0002 2.36127ZM13.0026 2.97391L13.0588 3.07131C13.9266 4.60214 14.4739 6.79183 14.5682 9.23627H17.6009C17.3209 6.41485 15.5055 4.04527 13.0022 2.97391H13.0026Z",
                        fill: ot.palette.text.primary,
                        fillOpacity: "0.9"
                    })
                }), jsxRuntimeExports.jsx("defs", {
                    children: jsxRuntimeExports.jsx("clipPath", {
                        id: "clip0_16159_30046",
                        children: jsxRuntimeExports.jsx("rect", {
                            width: "20",
                            height: "20",
                            fill: ot.palette.text.primary
                        })
                    })
                })]
            })
        }), jsxRuntimeExports.jsx(Popover, {
            open: !!rt && tt,
            anchorEl: rt,
            className: "translate-y-3 transform",
            onClose: () => nt(!1),
            anchorOrigin: {
                vertical: "bottom",
                horizontal: "center"
            },
            transformOrigin: {
                vertical: "top",
                horizontal: "center"
            },
            children: jsxRuntimeExports.jsx(MenuList, {
                children: LOCALES.map(ct => jsxRuntimeExports.jsxs(MenuItem, {
                    className: "flex cursor-pointer items-center justify-between py-2",
                    component: "div",
                    onClick: () => st(ct.key),
                    children: [jsxRuntimeExports.jsx(Box, {
                        className: "flex items-center justify-center text-sm  pl-2",
                        children: jsxRuntimeExports.jsx(Typography, {
                            variant: "inherit",
                            color: ct.key === $ ? "text.primary" : "text.secondary",
                            children: ct.name
                        })
                    }), jsxRuntimeExports.jsx(DoneRoundedIcon, {
                        fontSize: "small",
                        className: cn("mr-1 font-bold", {
                            "opacity-0": ct.key !== $
                        }),
                        sx: {
                            color: ot.palette.primary.main
                        }
                    })]
                }, ct.key))
            })
        })]
    })
});
function ___$insertStyle(_e) {
    if (!_e || typeof window > "u")
        return;
    const $ = document.createElement("style");
    return $.setAttribute("type", "text/css"),
    $.innerHTML = _e,
    document.head.appendChild($),
    _e
}
var __assign$1 = function() {
    return __assign$1 = Object.assign || function($) {
        for (var et, tt = 1, nt = arguments.length; tt < nt; tt++) {
            et = arguments[tt];
            for (var rt in et)
                Object.prototype.hasOwnProperty.call(et, rt) && ($[rt] = et[rt])
        }
        return $
    }
    ,
    __assign$1.apply(this, arguments)
};
function __rest(_e, $) {
    var et = {};
    for (var tt in _e)
        Object.prototype.hasOwnProperty.call(_e, tt) && $.indexOf(tt) < 0 && (et[tt] = _e[tt]);
    if (_e != null && typeof Object.getOwnPropertySymbols == "function")
        for (var nt = 0, tt = Object.getOwnPropertySymbols(_e); nt < tt.length; nt++)
            $.indexOf(tt[nt]) < 0 && Object.prototype.propertyIsEnumerable.call(_e, tt[nt]) && (et[tt[nt]] = _e[tt[nt]]);
    return et
}
function __awaiter$1(_e, $, et, tt) {
    function nt(rt) {
        return rt instanceof et ? rt : new et(function(it) {
            it(rt)
        }
        )
    }
    return new (et || (et = Promise))(function(rt, it) {
        function ot(ct) {
            try {
                lt(tt.next(ct))
            } catch (dt) {
                it(dt)
            }
        }
        function st(ct) {
            try {
                lt(tt.throw(ct))
            } catch (dt) {
                it(dt)
            }
        }
        function lt(ct) {
            ct.done ? rt(ct.value) : nt(ct.value).then(ot, st)
        }
        lt((tt = tt.apply(_e, [])).next())
    }
    )
}
function __generator$1(_e, $) {
    var et = {
        label: 0,
        sent: function() {
            if (rt[0] & 1)
                throw rt[1];
            return rt[1]
        },
        trys: [],
        ops: []
    }, tt, nt, rt, it;
    return it = {
        next: ot(0),
        throw: ot(1),
        return: ot(2)
    },
    typeof Symbol == "function" && (it[Symbol.iterator] = function() {
        return this
    }
    ),
    it;
    function ot(lt) {
        return function(ct) {
            return st([lt, ct])
        }
    }
    function st(lt) {
        if (tt)
            throw new TypeError("Generator is already executing.");
        for (; it && (it = 0,
        lt[0] && (et = 0)),
        et; )
            try {
                if (tt = 1,
                nt && (rt = lt[0] & 2 ? nt.return : lt[0] ? nt.throw || ((rt = nt.return) && rt.call(nt),
                0) : nt.next) && !(rt = rt.call(nt, lt[1])).done)
                    return rt;
                switch (nt = 0,
                rt && (lt = [lt[0] & 2, rt.value]),
                lt[0]) {
                case 0:
                case 1:
                    rt = lt;
                    break;
                case 4:
                    return et.label++,
                    {
                        value: lt[1],
                        done: !1
                    };
                case 5:
                    et.label++,
                    nt = lt[1],
                    lt = [0];
                    continue;
                case 7:
                    lt = et.ops.pop(),
                    et.trys.pop();
                    continue;
                default:
                    if (rt = et.trys,
                    !(rt = rt.length > 0 && rt[rt.length - 1]) && (lt[0] === 6 || lt[0] === 2)) {
                        et = 0;
                        continue
                    }
                    if (lt[0] === 3 && (!rt || lt[1] > rt[0] && lt[1] < rt[3])) {
                        et.label = lt[1];
                        break
                    }
                    if (lt[0] === 6 && et.label < rt[1]) {
                        et.label = rt[1],
                        rt = lt;
                        break
                    }
                    if (rt && et.label < rt[2]) {
                        et.label = rt[2],
                        et.ops.push(lt);
                        break
                    }
                    rt[2] && et.ops.pop(),
                    et.trys.pop();
                    continue
                }
                lt = $.call(_e, et)
            } catch (ct) {
                lt = [6, ct],
                nt = 0
            } finally {
                tt = rt = 0
            }
        if (lt[0] & 5)
            throw lt[1];
        return {
            value: lt[0] ? lt[1] : void 0,
            done: !0
        }
    }
}
var readAsDataURL = function(_e, $, et) {
    return new Promise(function(tt, nt) {
        try {
            var rt = new FileReader;
            rt.onprogress = function() {
                $ == null || $()
            }
            ,
            rt.onerror = function() {
                et == null || et()
            }
            ,
            rt.onload = function() {
                tt(rt.result)
            }
            ,
            rt.readAsDataURL(_e)
        } catch {
            nt(void 0)
        }
    }
    )
};
function getImageOrientation(_e) {
    return new Promise(function($, et) {
        if (!_e || _e.length === 0) {
            et("landscape");
            return
        }
        try {
            var tt = new Image;
            tt.src = _e,
            tt.onerror = function(nt) {
                et("landscape")
            }
            ,
            tt.onload = function() {
                var nt = tt.width
                  , rt = tt.height;
                nt > rt ? $("landscape") : $("portrait")
            }
        } catch {
            et("landscape")
        }
    }
    )
}
var FileIdGenerator = function() {
    function _e() {}
    return _e.getNextId = function() {
        return _e.nextId++,
        _e.nextId
    }
    ,
    _e.nextId = 0,
    _e
}()
  , addClassName = function(_e, $) {
    return "".concat(_e, " ").concat($)
};
function mergeProps(_e, $) {
    return _e ? __assign$1(__assign$1({}, $), _e) : $
}
var InputHidden = function(_e) {
    var $ = _e.onChange
      , et = _e.inputRef
      , tt = _e.accept
      , nt = _e.multiple;
    return reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("input", {
        "aria-label": "fui-hidden-input",
        style: {
            display: "none"
        },
        ref: et,
        onChange: $,
        type: "file",
        accept: tt,
        multiple: nt
    }))
};
___$insertStyle(`.files-ui-dropzone-children-container {
  width: 100%;
  flex-grow: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  flex-wrap: wrap;
  padding: 5px 0;
}`);
function handleClickUtil(_e) {
    _e.preventDefault(),
    _e.stopPropagation()
}
___$insertStyle(`.filesui-disabled-root {
  position: absolute;
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.38);
}`);
___$insertStyle(`@import url(https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900);
.fui-dropzone-root {
  width: 100%;
  min-width: 150px;
  min-height: 180px;
  position: relative;
  display: flex;
  flex-direction: column;
  gap: 0 8px;
  text-rendering: optimizeLegibility;
  font-size: 1.5em;
  font-family: "Poppins", sans-serif;
  text-align: center;
  font-weight: 400;
  letter-spacing: 0.02857em;
  box-sizing: border-box;
  word-break: normal;
  /*  &.fui-dropzone-border {
    box-sizing: border-box;

    border: 1px dashed #0c2358;
    border-radius: 10px;
    &.fui-hide-border {
      border: none;
    }
  } */
}
@media (max-width: 600px) {
  .fui-dropzone-root {
    font-size: 1.3em;
  }
}
.fui-dropzone-root.clickable {
  cursor: pointer;
}

.files-ui-header {
  min-height: 23px;
  /*  height: 22px;
  position: absolute;
  top: 0;
  */
  cursor: text;
  display: flex;
  width: 100%;
  flex-direction: row;
  align-items: center;
  justify-content: flex-end;
  font-family: inherit;
  font-size: 1rem;
}
@media (max-width: 960px) {
  .files-ui-header {
    font-size: 0.8rem;
  }
}

.files-ui-footer {
  /*   border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px; */
  box-sizing: border-box;
  cursor: text;
  /* height: 23px;
  position: absolute;
  bottom: 0;
  left: 0; */
  width: 100%;
  /* display: flex;
  flex-direction: column;
  align-items: flex-start;
  justify-content: center; */
  font-family: inherit;
  padding-left: 10px;
  font-size: 1rem;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 1; /* number of lines to show */
  line-clamp: 1;
  -webkit-box-orient: vertical;
  text-align: left;
}
@media (max-width: 960px) {
  .files-ui-footer {
    padding-left: 1px;
    font-size: 0.9rem;
  }
}`);
___$insertStyle(`.filesui-base-ripple-absolute {
  position: absolute;
  display: none;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
  box-sizing: border-box;
  border-radius: 8px;
  overflow: hidden;
}
.filesui-base-ripple-absolute .filesui-base-ripple-relative {
  width: 100%;
  height: 100%;
  position: relative;
  overflow: hidden;
  display: flex;
  justify-content: center;
  align-items: center;
  box-sizing: border-box;
}
.filesui-base-ripple-absolute .filesui-base-ripple-relative span.ripple {
  position: absolute;
  border-radius: 50%;
  transform: scale(0);
  animation: ripple 500ms linear;
  background-color: rgba(255, 255, 255, 0.7);
}
@keyframes ripple {
  to {
    transform: scale(4);
    opacity: 0;
  }
}`);
var parseSize = function(_e) {
    if (typeof _e == "number")
        return _e;
    switch (_e) {
    case "micro":
        return 8;
    case "small":
        return 15;
    case "semi-medium":
        return 18;
    case "medium":
        return 25;
    case "large":
        return 28;
    case "extra-large":
        return 32;
    default:
        return 24
    }
}
  , Clear = function(_e) {
    var $ = _e.size
      , et = _e.color
      , tt = _e.colorFill
      , nt = _e.onClick
      , rt = _e.style
      , it = _e.className
      , ot = parseSize($)
      , st = rt || {};
    return reactExports.createElement("svg", {
        className: it || "",
        style: nt ? __assign$1({
            cursor: "pointer"
        }, st) : st,
        xmlns: "http://www.w3.org/2000/svg",
        height: "".concat(ot, "px"),
        viewBox: "0 0 24 24",
        width: "".concat(ot, "px"),
        fill: et || "#000000",
        onClick: function(lt) {
            handleClickUtil(lt),
            nt == null || nt(lt)
        }
    }, reactExports.createElement("path", {
        d: "M0 0h24v24H0V0z",
        fill: tt || "none"
    }), reactExports.createElement("path", {
        d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"
    }))
};
___$insertStyle(`@keyframes filesui-rotate-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}
.filesui-rotate {
  cursor: default;
}

@media (prefers-reduced-motion: no-preference) {
  .filesui-rotate {
    animation: filesui-rotate-spin infinite 2s linear;
  }
}`);
var DynamiCSS;
(function(_e) {
    function $(it) {
        var ot = "";
        if (typeof window > "u" || typeof it > "u" || it === null)
            return "";
        if (document.getElementById(it.id))
            return it.id;
        ot = it.id;
        var st = document.createElement("style");
        st.id = ot,
        st.setAttribute("type", "text/css");
        var lt = toRawStyleSheet(it.sheetRules || []) + it.raw || "";
        st.textContent = lt;
        var ct = document.head.appendChild(st);
        return ct ? ot : ""
    }
    _e.insertStyleSheet = $;
    function et(it, ot) {
        var st = "";
        if (typeof window > "u" || typeof it > "u" || it === null || ot === null)
            return "";
        var lt = document.getElementById(it);
        return lt ? (lt.textContent = toRawStyleSheet(ot),
        st) : ""
    }
    _e.editStyleSheet = et;
    function tt(it) {
        var ot = "";
        if (!it)
            return "";
        var st = document.getElementById(it);
        return st && (document.head.removeChild(st),
        ot = it),
        ot
    }
    _e.removeStyleSheet = tt;
    function nt(it) {
        if (typeof it > "u" || it === null)
            return !1;
        var ot = document.getElementById(it);
        return !!ot
    }
    _e.existStyleSheet = nt;
    function rt(it) {
        return typeof it > "u" || it === null ? null : it
    }
    _e.makeStyleSheet = rt
}
)(DynamiCSS || (DynamiCSS = {}));
function isUpper(_e) {
    return _e ? !/[a-z]/.test(_e) && /[A-Z]/.test(_e) : !1
}
function fromUpperCaseToHyphen(_e) {
    for (var $ = "", et = " ", tt = !1, nt = 0; nt < _e.length; nt++) {
        var rt = _e[nt];
        if (isUpper(rt)) {
            et = rt,
            tt = !0;
            break
        }
    }
    if (tt) {
        var it = _e.split(et);
        $ = "".concat(it[0], "-").concat(et.toLowerCase()).concat(it[1])
    } else
        $ = _e;
    return $
}
function isPseudo(_e) {
    return _e ? _e.includes(":") : !1
}
function makeRawRuleLabel(_e) {
    var $ = ""
      , et = _e.trim().split(" ");
    if (et.length > 1) {
        for (var tt = 0; tt < et.length; tt++)
            $ += ".".concat(et[tt]);
        $ += `{
`
    } else
        $ += ".".concat(_e, `{
`);
    return $
}
function toRawStyleSheet(_e) {
    if (typeof _e > "u" || _e === null)
        return "";
    for (var $ = "", et = [], tt = 0; tt < _e.length; tt++) {
        var nt = _e[tt]
          , rt = "";
        rt += makeRawRuleLabel(nt.className);
        for (var it = Object.keys(nt.rules), ot = 0; ot < it.length; ot++) {
            var st = it[ot]
              , lt = fromUpperCaseToHyphen(st);
            if (isPseudo(lt)) {
                var ct = nt.className + lt;
                et.push({
                    className: ct,
                    rules: nt.rules[lt]
                })
            } else {
                var dt = nt.rules[st];
                rt += "	".concat(lt, " : ").concat(dt, `;
`)
            }
        }
        rt += `}
`,
        $ += rt
    }
    for (var pt = 0; pt < et.length; pt++) {
        var rt = ""
          , nt = et[pt]
          , it = Object.keys(nt.rules);
        rt += ".".concat(nt.className, `{
`);
        for (var ot = 0; ot < it.length; ot++) {
            var st = it[ot]
              , lt = fromUpperCaseToHyphen(st)
              , dt = nt.rules[st];
            rt += "	".concat(lt, " : ").concat(dt, `;
`)
        }
        rt += `}
`,
        $ += rt
    }
    return $
}
___$insertStyle(`@import url(https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900);
.material-button-root {
  border: 0;
  cursor: pointer;
  display: inline-flex;
  outline: 0;
  position: relative;
  align-items: center;
  vertical-align: middle;
  justify-content: center;
  text-decoration: none;
  text-transform: none;
  color: white;
}

.material-button {
  transition: background-color 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms, box-shadow 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms, border 250ms cubic-bezier(0.4, 0, 0.2, 1) 0ms;
  overflow: hidden;
  min-width: 64px;
  box-sizing: border-box;
  border-radius: 4px;
  font-family: "Poppins", sans-serif;
  font-size: 0.875rem;
  font-weight: 400;
  line-height: 1.75;
  letter-spacing: 0.02857em;
}

.material-button.uppercase {
  text-transform: uppercase;
}

.material-button.lowercase {
  text-transform: lowercase;
}

.material-button.capitalize {
  text-transform: capitalize;
}

.material-button.contained {
  padding: 6px 16px;
  box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);
}

.material-button.outlined {
  padding: 5px 15px;
}

.material-button.text {
  padding: 5px 15px;
}

.material-button-root.contained:hover {
  box-shadow: 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12);
}

.material-button span.material-button-label {
  width: 100%;
  display: inherit;
  align-items: inherit;
  justify-content: inherit;
}

span.ripple {
  position: absolute;
  border-radius: 50%;
  transform: scale(0);
  animation: ripple 500ms linear;
  background-color: rgba(255, 255, 255, 0.7);
}

@keyframes ripple {
  to {
    transform: scale(4);
    opacity: 0;
  }
}
.material-button-root.disabled {
  box-shadow: none;
  cursor: default;
  pointer-events: none;
  background-color: rgba(0, 0, 0, 0.12);
  color: rgba(0, 0, 0, 0.26);
  padding: 6px 16px;
}
.material-button-root.disabled.darkmode {
  background-color: rgba(255, 255, 255, 0.12);
  color: rgba(255, 255, 255, 0.3);
}

/* @media screen and (max-width: 600px) {
  .material-button {
    min-width: 30px;
    font-size: 0.78rem;
    line-height: 1.5;
    letter-spacing: 0.025em;
  }
  .material-button.contained {
    padding: 4px 13px;
  }
  .material-button.outlined {
    padding: 4px 12px;
  }
}
 */`);
React.createContext({});
___$insertStyle(`.files-ui-buttons-container {
  width: 100%;
  box-sizing: border-box;
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  align-items: center;
  justify-content: flex-end;
  box-sizing: border-box;
  gap: 10px;
}
.files-ui-buttons-container.top {
  padding-bottom: 10px;
}
.files-ui-buttons-container.bottom {
  padding-top: 10px;
}`);
var defaultAvatarProps = {
    variant: "square",
    alt: "avatar",
    emptyLabel: "Agregar foto",
    changeLabel: "Cambiar foto",
    loadingLabel: "Loading...",
    readOnly: !1,
    smartImgFit: "center"
};
___$insertStyle(`@import url(https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900);
.fui-avatar-main-container {
  width: 200px;
  height: 200px;
  position: relative;
  background-color: transparent;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: rgba(128, 128, 128, 0.486);
  border-radius: 10px;
  font-family: "Poppins", sans-serif;
}
.fui-avatar-main-container.square {
  border-radius: 0px;
}
.fui-avatar-main-container.circle {
  border-radius: 50%;
}
.fui-avatar-main-container .fui-avatar-image {
  background-repeat: no-repeat;
  background-size: cover;
  background-position: center;
}
.fui-avatar-main-container:hover .fui-avatar-label.hide {
  display: flex;
}
.fui-avatar-main-container .fui-avatar-label {
  margin: 0;
  overflow: hidden;
  background-color: rgba(128, 128, 128, 0.486);
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  color: white;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  flex-direction: column;
}
.fui-avatar-main-container .fui-avatar-label.hide {
  display: none;
}
.fui-avatar-main-container .fui-avatar-label:hover {
  background-color: rgba(71, 71, 71, 0.74);
  display: flex;
  cursor: pointer;
}`);
var useAvatarStyle = function(_e, $) {
    var et = reactExports.useState("")
      , tt = et[0]
      , nt = et[1]
      , rt = reactExports.useState(!1)
      , it = rt[0]
      , ot = rt[1]
      , st = reactExports.useState(void 0)
      , lt = st[0]
      , ct = st[1]
      , dt = function(pt, ht) {
        var mt = ht ? "-".concat(pt) : "-default"
          , yt = DynamiCSS.makeStyleSheet({
            id: "fui-avatar-styles" + mt,
            sheetRules: [{
                className: "fui-avatar-border" + mt,
                rules: {
                    borderRadius: "".concat(ht || "6px", " !important")
                }
            }]
        });
        return yt
    };
    return reactExports.useEffect(function() {
        return function() {
            it && DynamiCSS.removeStyleSheet(tt),
            nt(""),
            ot(!1)
        }
    }, []),
    reactExports.useEffect(function() {
        var pt = ""
          , ht = dt(_e, $);
        !$ && !it ? DynamiCSS.existStyleSheet("fui-avatar-styles-default") ? (ot(!0),
        nt("fui-avatar-styles-default")) : (pt = DynamiCSS.insertStyleSheet(ht),
        nt(pt),
        pt !== "" && ot(!0)) : it ? DynamiCSS.editStyleSheet(tt, ht.sheetRules || []) : (pt = DynamiCSS.insertStyleSheet(ht),
        nt(pt),
        pt !== "" && ot(!0)),
        ct("fui-avatar-border-" + _e)
    }, [$]),
    lt
}
  , BasePreparingLoader = function(_e) {
    var $ = _e.size
      , et = _e.color
      , tt = _e.style
      , nt = _e.radius
      , rt = _e.x
      , it = _e.y
      , ot = _e.width
      , st = nt || 46
      , lt = rt || 50
      , ct = it || 50
      , dt = parseSize($)
      , pt = tt || {};
    return reactExports.createElement("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        xmlnsXlink: "http://www.w3.org/1999/xlink",
        width: "".concat(dt, "px"),
        height: "".concat(dt, "px"),
        style: pt,
        viewBox: "0 0 100 100",
        preserveAspectRatio: "xMidYMid"
    }, reactExports.createElement("circle", {
        cx: "".concat(lt),
        cy: "".concat(ct),
        r: "".concat(st),
        fill: "none",
        stroke: et || "#14ff00",
        strokeWidth: "".concat(ot || 8, "px"),
        strokeDasharray: "164.93361431346415 100.97787143782138"
    }, reactExports.createElement("animateTransform", {
        attributeName: "transform",
        type: "rotate",
        repeatCount: "indefinite",
        dur: "1s",
        values: "0 ".concat(lt, " ").concat(lt, ";360 ").concat(lt, " ").concat(lt),
        keyTimes: "0;1"
    })))
};
___$insertStyle(`.files-ui-loader-container {
  background-color: rgba(0, 0, 0, 0.41);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  position: relative;
}
.files-ui-loader-container.clickable {
  cursor: pointer;
}
.files-ui-loader-container:hover {
  background-color: rgba(0, 0, 0, 0.61);
}`);
var LoaderContainer = function(_e) {
    var $ = _e.children
      , et = _e.className
      , tt = _e.style
      , nt = _e.size
      , rt = _e.onClick
      , it = nt ? parseSize(nt) : void 0
      , ot = rt ? "files-ui-loader-container clickable" : "files-ui-loader-container"
      , st = function() {
        rt == null || rt()
    };
    return reactExports.createElement("div", {
        onClick: st,
        className: et ? "".concat(ot, " ").concat(et) : ot,
        style: __assign$1(__assign$1({}, tt), {
            height: it,
            width: it
        })
    }, $)
}
  , InfiniteLoader = function(_e) {
    var $ = _e.onClick
      , et = _e.size;
    return reactExports.createElement(LoaderContainer, {
        onClick: $,
        size: et
    }, reactExports.createElement(reactExports.Fragment, null, reactExports.createElement(BasePreparingLoader, {
        size: et
    }), reactExports.createElement("div", {
        style: {
            position: "absolute",
            width: "100%",
            height: "100%",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
        }
    }, $ && reactExports.createElement(Clear, {
        color: "rgba(255,255,255,0.75)",
        size: 45,
        onClick: $
    }))))
};
___$insertStyle(`.files-ui-layer {
  position: absolute;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
}`);
var Layer = function(_e) {
    var $ = _e.style
      , et = _e.className
      , tt = _e.children
      , nt = _e.visible
      , rt = __rest(_e, ["style", "className", "children", "visible"])
      , it = addClassName(et || "", "files-ui-layer");
    return nt ? reactExports.createElement("div", __assign$1({
        className: it,
        style: $
    }, rt), tt) : reactExports.createElement(reactExports.Fragment, null)
}
  , ImagePreviewDefaultProps = {
    alt: "image-preview",
    smartImgFit: "orientation"
};
___$insertStyle(`.fui-image-preview {
  position: relative;
  border-radius: 10px;
}`);
var ImagePreview = function(_e) {
    var $ = mergeProps(_e, ImagePreviewDefaultProps)
      , et = $.src
      , tt = $.alt
      , nt = $.width
      , rt = $.height
      , it = $.onError
      , ot = $.smartImgFit
      , st = $.style
      , lt = $.className
      , ct = reactExports.useState([void 0, void 0])
      , dt = ct[0]
      , pt = dt[0]
      , ht = dt[1]
      , mt = ct[1]
      , yt = reactExports.useState(void 0)
      , Et = yt[0]
      , _t = yt[1]
      , wt = function(Nt) {
        return __awaiter$1(void 0, void 0, void 0, function() {
            var Lt;
            return __generator$1(this, function(kt) {
                switch (kt.label) {
                case 0:
                    return [4, readAsDataURL(Nt)];
                case 1:
                    return Lt = kt.sent(),
                    St(Lt),
                    [2]
                }
            })
        })
    }
      , St = function(Nt) {
        return __awaiter$1(void 0, void 0, void 0, function() {
            var Lt, kt, Ut;
            return __generator$1(this, function(Jt) {
                switch (Jt.label) {
                case 0:
                    return Nt === "" || !Nt ? [2] : (Lt = void 0,
                    kt = void 0,
                    ot ? [3, 1] : (kt = "100%",
                    [3, 4]));
                case 1:
                    return Jt.trys.push([1, 3, , 4]),
                    [4, getImageOrientation(Nt)];
                case 2:
                    return Ut = Jt.sent(),
                    Ut === "landscape" ? ot === "orientation" ? (Lt = void 0,
                    kt = "100%") : (Lt = "100%",
                    kt = void 0) : ot === "center" ? (Lt = void 0,
                    kt = "100%") : (Lt = "100%",
                    kt = void 0),
                    [3, 4];
                case 3:
                    return Jt.sent(),
                    it == null || it(),
                    [3, 4];
                case 4:
                    return rt && (Lt = rt),
                    nt && (kt = nt),
                    mt([Lt, kt]),
                    _t(Nt),
                    [2]
                }
            })
        })
    };
    reactExports.useEffect(function() {
        if (et)
            if (typeof et == "string")
                St(et);
            else {
                var Nt = et.type ? et.type.split("/")[0] : "octet";
                Nt === "image" ? wt(et) : it == null || it()
            }
    }, [et]);
    var Ct = function(Nt) {
        it == null || it()
    };
    return reactExports.createElement(reactExports.Fragment, null, et && Et && (pt || ht) && reactExports.createElement("img", {
        style: st || {},
        onClick: function(Nt) {
            Nt.preventDefault()
        },
        width: ht,
        height: pt,
        src: Et,
        alt: tt,
        className: lt,
        onError: Ct
    }))
}
  , Avatar = function(_e) {
    var $ = mergeProps(_e, defaultAvatarProps)
      , et = $.readOnly
      , tt = $.src
      , nt = $.alt
      , rt = $.accept
      , it = $.onChange
      , ot = $.emptyLabel
      , st = $.changeLabel
      , lt = $.variant
      , ct = $.borderRadius
      , dt = $.loadingLabel
      , pt = $.isLoading
      , ht = $.onError
      , mt = $.smartImgFit
      , yt = $.style
      , Et = __rest($, ["readOnly", "src", "alt", "accept", "onChange", "emptyLabel", "changeLabel", "variant", "borderRadius", "loadingLabel", "isLoading", "onError", "smartImgFit", "style"])
      , _t = reactExports.useRef(null)
      , wt = reactExports.useMemo(function() {
        return FileIdGenerator.getNextId() + ""
    }, [])
      , St = useAvatarStyle(wt.replace(":", "").replace(":", ""), ct)
      , Ct = function() {
        var kt;
        (kt = _t.current) === null || kt === void 0 || kt.click()
    }
      , Nt = function(kt) {
        for (var Ut = kt.target.files, Jt = [], Pt = 0, Xt = void 0; Xt = Ut[Pt]; Pt++)
            Jt.push(Xt);
        it == null || it(Jt[0])
    }
      , Lt = function(kt) {
        ht == null || ht(kt)
    };
    return St ? reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("div", __assign$1({
        className: "fui-avatar-main-container".concat(lt === "circle" ? " circle" : "", " ").concat(St),
        style: yt
    }, Et), pt ? reactExports.createElement(Layer, {
        visible: !0
    }, reactExports.createElement("div", {
        className: "fui-avatar-label"
    }, reactExports.createElement(InfiniteLoader, {
        size: 50
    }), dt)) : tt ? reactExports.createElement(ImagePreview, {
        className: "fui-avatar-image",
        src: tt,
        alt: nt,
        onError: Lt,
        smartImgFit: mt
    }) : reactExports.createElement("div", {
        className: "fui-avatar-label"
    }, ot), !et && reactExports.createElement(reactExports.Fragment, null, !pt && reactExports.createElement("div", {
        className: "fui-avatar-label hide",
        onClick: Ct
    }, tt ? st : ot), reactExports.createElement(InputHidden, {
        multiple: !1,
        accept: rt || "image/*",
        onChange: Nt,
        inputRef: _t
    })))) : reactExports.createElement(reactExports.Fragment, null)
};
___$insertStyle(`@import url(https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900);
.files-ui-file-card-main-container {
  border-radius: 8px;
  color: rgba(0, 0, 0, 0.858);
  display: flex;
  flex-direction: row;
  align-items: center;
  min-height: 100px;
  box-sizing: border-box;
  position: relative;
  font-size: 15px;
  font-weight: 400;
  width: 320px;
  font-family: "Poppins", sans-serif;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container {
  border-radius: 8px;
  overflow: hidden;
  width: 320px;
  box-sizing: border-box;
  height: 100px;
  box-sizing: border-box;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-main-layer {
  box-sizing: border-box;
  position: absolute;
  left: 0;
  right: 0;
  width: 100%;
  height: 100%;
  display: flex;
  box-sizing: border-box;
  align-items: center;
  justify-content: space-between;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-main-layer .file-card-icon-plus-data {
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 5px;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-main-layer .file-card-icon-plus-data .file-card-icon-container {
  width: 100px;
  height: 100px;
  overflow: hidden;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-main-layer .file-card-icon-plus-data .file-card-icon-container .file-card-icon-layer {
  box-sizing: border-box;
  position: absolute;
  width: 100px;
  height: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
  box-sizing: border-box;
  overflow: hidden;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-main-layer .file-card-icon-plus-data .file-card-icon-container .file-card-icon-layer img {
  background-repeat: no-repeat;
  background-size: cover;
  background-position: center;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-main-layer .file-card-icon-plus-data .file-card-icon-container .file-card-icon-layer.blur img {
  filter: blur(4px);
  width: 200%;
  height: 200%;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-main-layer .file-card-icon-plus-data .file-card-icon-container .file-card-status-layer {
  display: flex;
  align-items: flex-end;
  justify-content: flex-start;
  padding: 5px;
  box-sizing: border-box;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-main-layer .file-card-icon-plus-data .file-card-data {
  padding-right: 10px;
  box-sizing: border-box;
  line-height: 19px;
  font-weight: 500;
  width: calc(100% - 100px);
  word-break: break-all;
  color: black;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  justify-content: center;
  height: 100%;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-main-layer .file-card-icon-plus-data .file-card-data.dark-mode {
  color: rgba(255, 255, 255, 0.7);
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-main-layer .file-card-icon-plus-data .file-card-data .file-card-size {
  font-weight: 400;
  font-size: 0.9rem;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-main-layer .file-card-icon-plus-data .file-card-data .file-card-name {
  font-size: 1rem;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 1; /* number of lines to show */
  line-clamp: 1;
  -webkit-box-orient: vertical;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-main-layer .file-card-icon-plus-data .file-card-data .file-card-name.not-allowed {
  background-color: rgba(180, 16, 16, 0.7);
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-upload-layer-container {
  cursor: default;
  display: flex;
  box-sizing: border-box;
  background: linear-gradient(to right, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.35), rgba(0, 0, 0, 0.625), rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.9));
  color: rgba(255, 255, 255, 0.8);
  font-weight: 500;
  font-size: 1em;
  position: relative;
  overflow: hidden;
  align-items: center;
  justify-content: flex-end;
  height: 100%;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-info-layer-container {
  cursor: default;
  display: flex;
  box-sizing: border-box;
  background: linear-gradient(to right, rgba(0, 0, 0, 0.2), rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.75), rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.9));
  color: rgba(255, 255, 255, 0.8);
  font-weight: 500;
  font-size: 1em;
  overflow: hidden;
  align-items: center;
  justify-content: flex-end;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-info-layer-container .file-card-file-info {
  width: calc(100% - 100px);
  height: 100px;
  text-align: left;
  scrollbar-width: thin;
  overflow: auto;
  scrollbar-color: rgba(100, 108, 127, 0.662745098) transparent;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-info-layer-container .file-card-file-info::-webkit-scrollbar {
  width: 9px;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-info-layer-container .file-card-file-info::-webkit-scrollbar-track {
  background: transparent;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-info-layer-container .file-card-file-info::-webkit-scrollbar-thumb {
  background-color: rgba(100, 108, 127, 0.662745098);
  border-radius: 20px;
  border: transparent;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-info-layer-container .file-card-file-info .files-ui-file-card-info-layer-header {
  display: flex;
  width: 100%;
  flex-direction: row;
  align-items: center;
  justify-content: flex-end;
  /*  position: absolute;
  top: 5;
  right: 5; */
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-info-layer-container .file-card-file-info .heading {
  font-weight: 600;
  padding: 0 5px;
}
.files-ui-file-card-main-container .files-ui-file-card-main-layer-container .file-card-info-layer-container .file-card-file-info .label {
  padding: 0 5px;
  font-weight: 399;
}
.files-ui-file-card-main-container.clickable {
  cursor: pointer;
}

/* .files-ui-file-icon {
  font-size: 0.7rem;
  min-width: 19px;
  min-height: 19px;
  margin: 0;
  padding: 2px 2px;
  border-radius: 50%;
  background-color: rgba(32, 33, 36, 0.65);
  word-break: break-word;
  box-sizing: content-box;
  &:hover {
    background-color: rgba(32, 33, 36, 0.85);
  }
  &.dark-mode {
    background-color: rgba(154, 160, 166, 0.65);
    &:hover {
      background-color: rgba(154, 160, 166, 0.85);
    }
  }
} */`);
___$insertStyle(`.files-ui-file-icon {
  font-size: 0.7rem;
  min-width: 19px;
  min-height: 19px;
  margin: 0;
  padding: 2px 2px;
  border-radius: 50%;
  background-color: rgba(32, 33, 36, 0.65);
  word-break: break-word;
  box-sizing: content-box;
}
.files-ui-file-icon:hover {
  background-color: rgba(32, 33, 36, 0.85);
}
.files-ui-file-icon.dark-mode {
  background-color: rgba(154, 160, 166, 0.65);
}
.files-ui-file-icon.dark-mode:hover {
  background-color: rgba(154, 160, 166, 0.85);
}`);
___$insertStyle(`.files-ui-file-card-main-container.dark-mode {
  color: rgba(255, 255, 255, 0.7);
  background-color: #121212;
}
.files-ui-file-card-main-container.dark-mode.elevation-0 {
  background-image: linear-gradient(rgba(255, 255, 255, 0), rgba(255, 255, 255, 0));
}
.files-ui-file-card-main-container.dark-mode.elevation-1 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.05), rgba(255, 255, 255, 0.05));
}
.files-ui-file-card-main-container.dark-mode.elevation-2 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.07), rgba(255, 255, 255, 0.07));
}
.files-ui-file-card-main-container.dark-mode.elevation-3 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.08), rgba(255, 255, 255, 0.08));
}
.files-ui-file-card-main-container.dark-mode.elevation-4 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.09), rgba(255, 255, 255, 0.09));
}
.files-ui-file-card-main-container.dark-mode.elevation-5 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.1));
}
.files-ui-file-card-main-container.dark-mode.elevation-6 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.11), rgba(255, 255, 255, 0.11));
}
.files-ui-file-card-main-container.dark-mode.elevation-7 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.11), rgba(255, 255, 255, 0.11));
}
.files-ui-file-card-main-container.dark-mode.elevation-8 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.12));
}
.files-ui-file-card-main-container.dark-mode.elevation-9 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.12));
}
.files-ui-file-card-main-container.dark-mode.elevation-10 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.13), rgba(255, 255, 255, 0.13));
}
.files-ui-file-card-main-container.dark-mode.elevation-11 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.13), rgba(255, 255, 255, 0.13));
}
.files-ui-file-card-main-container.dark-mode.elevation-12 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.14), rgba(255, 255, 255, 0.14));
}
.files-ui-file-card-main-container.dark-mode.elevation-13 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.14), rgba(255, 255, 255, 0.14));
}
.files-ui-file-card-main-container.dark-mode.elevation-14 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.14), rgba(255, 255, 255, 0.14));
}
.files-ui-file-card-main-container.dark-mode.elevation-15 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.14), rgba(255, 255, 255, 0.14));
}
.files-ui-file-card-main-container.dark-mode.elevation-16 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.13), rgba(255, 255, 255, 0.15));
}
.files-ui-file-card-main-container.dark-mode.elevation-17 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.13), rgba(255, 255, 255, 0.15));
}
.files-ui-file-card-main-container.dark-mode.elevation-18 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.13), rgba(255, 255, 255, 0.15));
}
.files-ui-file-card-main-container.dark-mode.elevation-19 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0.15));
}
.files-ui-file-card-main-container.dark-mode.elevation-20 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.16));
}
.files-ui-file-card-main-container.dark-mode.elevation-21 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.16));
}
.files-ui-file-card-main-container.dark-mode.elevation-22 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.16));
}
.files-ui-file-card-main-container.dark-mode.elevation-23 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.16));
}
.files-ui-file-card-main-container.dark-mode.elevation-24 {
  background-image: linear-gradient(rgba(255, 255, 255, 0.16), rgba(255, 255, 255, 0.16));
}
.files-ui-file-card-main-container.elevation-0 {
  box-shadow: none;
}
.files-ui-file-card-main-container.elevation-1 {
  box-shadow: 0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14), 0px 1px 3px 0px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-2 {
  box-shadow: 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-3 {
  box-shadow: 0px 3px 3px -2px rgba(0, 0, 0, 0.2), 0px 3px 4px 0px rgba(0, 0, 0, 0.14), 0px 1px 8px 0px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-4 {
  box-shadow: 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-5 {
  box-shadow: 0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 5px 8px 0px rgba(0, 0, 0, 0.14), 0px 1px 14px 0px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-6 {
  box-shadow: 0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-7 {
  box-shadow: 0px 4px 5px -2px rgba(0, 0, 0, 0.2), 0px 7px 10px 1px rgba(0, 0, 0, 0.14), 0px 2px 16px 1px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-8 {
  box-shadow: 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-9 {
  box-shadow: 0px 5px 6px -3px rgba(0, 0, 0, 0.2), 0px 9px 12px 1px rgba(0, 0, 0, 0.14), 0px 3px 16px 2px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-10 {
  box-shadow: 0px 6px 6px -3px rgba(0, 0, 0, 0.2), 0px 10px 14px 1px rgba(0, 0, 0, 0.14), 0px 4px 18px 3px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-11 {
  box-shadow: 0px 6px 7px -4px rgba(0, 0, 0, 0.2), 0px 11px 15px 1px rgba(0, 0, 0, 0.14), 0px 4px 20px 3px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-12 {
  box-shadow: 0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-13 {
  box-shadow: 0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 13px 19px 2px rgba(0, 0, 0, 0.14), 0px 5px 24px 4px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-14 {
  box-shadow: 0px 7px 9px -4px rgba(0, 0, 0, 0.2), 0px 14px 21px 2px rgba(0, 0, 0, 0.14), 0px 5px 26px 4px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-15 {
  box-shadow: 0px 8px 9px -5px rgba(0, 0, 0, 0.2), 0px 15px 22px 2px rgba(0, 0, 0, 0.14), 0px 6px 28px 5px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-16 {
  box-shadow: 0px 8px 10px -5px rgba(0, 0, 0, 0.2), 0px 16px 24px 2px rgba(0, 0, 0, 0.14), 0px 6px 30px 5px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-17 {
  box-shadow: 0px 8px 11px -5px rgba(0, 0, 0, 0.2), 0px 17px 26px 2px rgba(0, 0, 0, 0.14), 0px 6px 32px 5px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-18 {
  box-shadow: 0px 9px 11px -5px rgba(0, 0, 0, 0.2), 0px 18px 28px 2px rgba(0, 0, 0, 0.14), 0px 7px 34px 6px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-19 {
  box-shadow: 0px 9px 12px -6px rgba(0, 0, 0, 0.2), 0px 19px 29px 2px rgba(0, 0, 0, 0.14), 0px 7px 36px 6px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-20 {
  box-shadow: 0px 10px 13px -6px rgba(0, 0, 0, 0.2), 0px 20px 31px 3px rgba(0, 0, 0, 0.14), 0px 8px 38px 7px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-21 {
  box-shadow: 0px 10px 13px -6px rgba(0, 0, 0, 0.2), 0px 21px 33px 3px rgba(0, 0, 0, 0.14), 0px 8px 40px 7px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-22 {
  box-shadow: 0px 10px 14px -6px rgba(0, 0, 0, 0.2), 0px 22px 35px 3px rgba(0, 0, 0, 0.14), 0px 8px 42px 7px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-23 {
  box-shadow: 0px 11px 14px -7px rgba(0, 0, 0, 0.2), 0px 23px 36px 3px rgba(0, 0, 0, 0.14), 0px 9px 44px 8px rgba(0, 0, 0, 0.12);
}
.files-ui-file-card-main-container.elevation-24 {
  box-shadow: 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12);
}`);
___$insertStyle(`.file-card-right-layer-header {
  margin-top: 3px;
  margin-right: 3px;
  position: absolute;
  top: 0;
  right: 0;
  left: unset;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 2px;
}

.file-card-right-layer-footer {
  margin-bottom: 3px;
  margin-right: 3px;
  left: unset;
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: flex-end;
  gap: 2px;
  bottom: 0;
  right: 0;
}`);
___$insertStyle(`text.files-ui-text-dynamic-loader {
  text-anchor: middle;
  font-size: 1em;
  fill: aliceblue;
}`);
___$insertStyle(`.lds-colorbar {
  background-color: rgba(255, 255, 255, 0.8);
  border-radius: 4px;
}
.lds-colorbar .files-ui-text-default-loader {
  font-size: 1.5rem;
  font-weight: 400;
  text-anchor: middle;
}`);
___$insertStyle(`.files-ui-file-card-upload-layer {
  width: 100px;
  height: 100%;
  color: rgba(255, 255, 255, 0.8);
  font-weight: 500;
  font-size: 1em;
  position: relative;
  overflow: hidden;
}
.files-ui-file-card-upload-layer .elevation-list-card {
  transition: all 1.5s ease;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}
.files-ui-file-card-upload-layer .elevation-list-card .elevation-item-card {
  width: 100%;
  height: 100px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  padding: 0 10px;
  box-sizing: border-box;
}
.files-ui-file-card-upload-layer .elevation-list-card .elevation-item-card span {
  text-align: center;
  word-break: break-word;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2; /* number of lines to show */
  line-clamp: 2;
  -webkit-box-orient: vertical;
}`);
___$insertStyle(`.files-ui-tooltip {
  cursor: default;
  position: relative;
}
.files-ui-tooltip:hover {
  z-index: 2;
}
.files-ui-tooltip:hover .files-ui-tooltiptext {
  visibility: visible;
  opacity: 1;
  z-index: 2;
}
.files-ui-tooltip.card:hover {
  z-index: 2;
}
.files-ui-tooltip.card:hover .files-ui-tooltiptext {
  visibility: visible;
  opacity: 1;
  z-index: 2;
}
.files-ui-tooltip.card .files-ui-tooltiptext {
  box-sizing: border-box;
  font-family: "Poppins", sans-serif;
  font-size: 0.8rem;
  font-weight: 400;
  visibility: hidden;
  width: 200px;
  color: #fff;
  text-align: center;
  border-radius: 6px;
  padding: 2px 2px;
  position: absolute;
  z-index: 2;
  left: calc(50% - 100px);
  left: 0;
  margin-top: 5px;
  top: 100%;
  opacity: 0;
  transition: opacity 1s;
}
.files-ui-tooltip.card .files-ui-tooltiptext.not-valid-error {
  background: linear-gradient(to top, #c62828, #d32f2f);
}
.files-ui-tooltip.card .files-ui-tooltiptext.not-valid-error::after {
  border-color: transparent transparent #d32f2f transparent;
}
.files-ui-tooltip.card .files-ui-tooltiptext.success {
  background: linear-gradient(to top, #1b5e20, #2e7d32);
}
.files-ui-tooltip.card .files-ui-tooltiptext.success::after {
  border-color: transparent transparent #2e7d32 transparent;
}
.files-ui-tooltip.card .files-ui-tooltiptext::after {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
}
.files-ui-tooltip .files-ui-tooltiptext {
  box-sizing: border-box;
  font-family: "Poppins", sans-serif;
  font-size: 0.8rem;
  font-weight: 400;
  visibility: hidden;
  width: 132px;
  color: #fff;
  text-align: center;
  border-radius: 6px;
  padding: 2px 2px;
  position: absolute;
  z-index: 2;
  left: 0;
  opacity: 0;
  transition: opacity 1s;
}
.files-ui-tooltip .files-ui-tooltiptext.not-valid-error {
  background: linear-gradient(to top, #c62828, #d32f2f);
}
.files-ui-tooltip .files-ui-tooltiptext.not-valid-error::after {
  border-color: transparent transparent #d32f2f transparent;
}
.files-ui-tooltip .files-ui-tooltiptext.success {
  background: linear-gradient(to top, #1b5e20, #2e7d32);
}
.files-ui-tooltip .files-ui-tooltiptext.success::after {
  border-color: transparent transparent #2e7d32 transparent;
}
.files-ui-tooltip .files-ui-tooltiptext::after {
  content: "";
  position: absolute;
  bottom: 100%;
  left: 50%;
  margin-left: -5px;
  border-width: 5px;
  border-style: solid;
}`);
___$insertStyle(`@import url(https://fonts.googleapis.com/css?family=Poppins:300,400,500,600,700,900);
.files-ui-file-mosaic-main-container {
  width: 132px;
  box-sizing: border-box;
  font-family: "Poppins", sans-serif;
  font-size: 15px;
  font-weight: 400;
  word-break: break-word;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container {
  width: 132px;
  height: 132px;
  border-radius: 8px;
  box-sizing: border-box;
  overflow: hidden;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-image-layer {
  position: absolute;
  left: 0;
  right: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-image-layer img {
  background-repeat: no-repeat;
  background-size: cover;
  background-position: center;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-image-layer.blur img {
  filter: blur(4px);
  width: 200%;
  height: 200%;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-main-layer {
  position: absolute;
  left: 0;
  right: 0;
  width: 100%;
  height: 100%;
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-direction: column;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-main-layer .file-mosaic-main-layer-header {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: flex-end;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-main-layer .file-mosaic-main-layer-footer {
  width: 100%;
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  flex-direction: row;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-main-layer .file-mosaic-main-layer-footer .file-mosaic-footer-right {
  display: flex;
  align-items: center;
  flex-direction: row;
  flex-grow: 1;
  align-items: flex-end;
  justify-content: flex-end;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-main-layer .file-mosaic-main-layer-footer .file-mosaic-footer-left {
  display: flex;
  align-items: center;
  flex-direction: column;
  flex-grow: 1;
  align-items: flex-start;
  justify-content: center;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-info-layer {
  position: absolute;
  left: 0;
  right: 0;
  text-align: left;
  scrollbar-width: thin;
  line-height: 1.5;
  letter-spacing: 0.02857em;
  font-family: "Poppins", sans-serif;
  width: inherit;
  background-color: rgba(0, 0, 0, 0.85);
  word-break: break-word;
  height: 100%;
  width: 100%;
  font-size: 0.8rem;
  transition: all 0.5s ease 0s;
  overflow: auto;
  color: white;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-info-layer::-webkit-scrollbar {
  width: 9px;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-info-layer::-webkit-scrollbar-track {
  background: transparent;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-info-layer::-webkit-scrollbar-thumb {
  background-color: rgba(100, 108, 127, 0.662745098);
  border-radius: 20px;
  border: transparent;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-info-layer .files-ui-file-mosaic-info-layer-header {
  display: flex;
  width: 100%;
  flex-direction: row;
  align-items: center;
  justify-content: space-between;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-info-layer .heading {
  font-weight: 600;
  padding: 0 5px;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-icon-layer-container .files-ui-file-mosaic-info-layer .label {
  padding: 0 5px;
  font-weight: 399;
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-file-name {
  margin-top: 1px;
  height: 31px;
  text-align: center;
  width: 100%;
  color: black;
  font-size: 0.95em;
  box-sizing: border-box;
  line-height: 15px;
  font-weight: 400;
  letter-spacing: 0.07rem;
  word-break: break-all;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2; /* number of lines to show */
  line-clamp: 2;
  -webkit-box-orient: vertical;
  /*  display: flex;
   align-items: center;
   justify-content: center; */
}
.files-ui-file-mosaic-main-container .files-ui-file-mosaic-file-name.dark-mode {
  color: rgba(255, 255, 255, 0.7);
}
.files-ui-file-mosaic-main-container.clickable {
  cursor: pointer;
}

/* .files-ui-file-icon {
  font-size: 0.7rem;
  min-width: 19px;
  min-height: 19px;
  margin: 0;
  padding: 2px 2px;
  border-radius: 50%;
  background-color: rgba(32, 33, 36, 0.65);
  word-break: break-word;
  box-sizing: content-box;
  &:hover {
    background-color: rgba(32, 33, 36, 0.85);
  }
  &.dark-mode {
    background-color: rgba(154, 160, 166, 0.65);
    &:hover {
      background-color: rgba(154, 160, 166, 0.85);
    }
  }
}
 */`);
___$insertStyle(`.files-ui-layer-container {
  position: relative;
}`);
___$insertStyle(`.files-ui-file-mosaic-upload-layer {
  width: 100%;
  height: 100%;
  background-color: rgba(0, 0, 0, 0.65);
  color: rgba(255, 255, 255, 0.8);
  font-weight: 500;
  font-size: 1em;
  position: relative;
  overflow: hidden;
}
.files-ui-file-mosaic-upload-layer .elevation-list {
  transition: all 1.5s ease;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}
.files-ui-file-mosaic-upload-layer .elevation-list .elevation-item {
  width: 100%;
  height: 132px;
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  padding: 0 10px;
  box-sizing: border-box;
}
.files-ui-file-mosaic-upload-layer .elevation-list .elevation-item span {
  text-align: center;
  word-break: break-word;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2; /* number of lines to show */
  line-clamp: 2;
  -webkit-box-orient: vertical;
}`);
___$insertStyle(`.files-ui-file-item-status-container {
  text-align: center;
  font-size: 0.8rem;
  background-color: rgba(255, 255, 255, 0.8);
  display: flex;
  align-items: center;
  flex-direction: row;
  border-radius: 4px;
  padding: 0.5px;
  font-weight: 400;
}
.files-ui-file-item-status-container.file-status-error {
  color: #f44336;
}
.files-ui-file-item-status-container.file-status-ok {
  color: #5c7a1f;
}
.files-ui-file-item-status-container.file-status-loading {
  position: relative;
  display: flex;
  color: #8b6b10;
  align-items: center;
  justify-content: center;
  flex-direction: column;
  background-color: rgba(255, 255, 255, 0.7);
}
.files-ui-file-item-status-container.file-status-loading.percentage {
  padding: 7px 4px 2px 5px;
}
.files-ui-file-item-status-container.file-status-loading .abort-button {
  position: absolute;
  right: -2px;
  top: -2px;
}
.files-ui-file-item-status-container.file-status-loading .uploading-text.up {
  margin-bottom: -22px;
}
.files-ui-file-item-status-container.file-status-loading .uploading-text.down {
  margin-top: -20px;
}
.files-ui-file-item-status-container.file-status-loading .uploading-text p.percentage {
  font-weight: 500;
}`);
___$insertStyle(`.filesui-file-item-size {
  box-sizing: border-box;
  font-size: 0.7rem;
  border: 0.5px solid wheat;
  text-align: center;
  color: rgba(255, 255, 255, 0.89);
  padding: 2px 1.5px;
  border-radius: 7px;
  background-color: rgba(32, 33, 36, 0.75);
  min-width: 45px;
  word-break: break-word;
  font-family: inherit;
}
.filesui-file-item-size:hover {
  background-color: rgba(32, 33, 36, 0.85);
  color: rgba(255, 255, 255, 0.97);
}`);
___$insertStyle(`.fui-fullscreen-container {
  position: fixed;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  height: 100vh;
  top: 0;
  left: 0;
  background: rgba(0, 0, 0, 0.734);
  transform: translate(100%);
  transition: transform 0.2s ease-in-out;
  margin: 0 !important;
  z-index: 4000;
  box-sizing: border-box;
}
.fui-fullscreen-container.show-fs {
  transform: translate(0);
}

.fui-fullscreen-relative-container {
  position: relative;
  width: 90%;
  height: 90%;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  /*   @media (max-width: 600px) {
    width: 80%;
    height: auto;
  }*/
}
.fui-fullscreen-relative-container img {
  height: 100%;
  width: auto;
}
.fui-fullscreen-relative-container video {
  height: 100%;
  width: auto;
}
@media (max-width: 960px) {
  .fui-fullscreen-relative-container {
    height: 90%;
    width: 100%;
  }
  .fui-fullscreen-relative-container video {
    height: auto;
    width: 100%;
  }
  .fui-fullscreen-relative-container img {
    height: auto;
    width: 100%;
  }
}

.button-full-screen {
  position: absolute;
  top: 0;
  right: 0;
}`);
function DeleteIcon(_e) {
    const {fill: $, size: et=18} = _e;
    return jsxRuntimeExports.jsxs("svg", {
        width: et,
        height: et,
        viewBox: "0 0 21 21",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: [jsxRuntimeExports.jsx("g", {
            clipPath: "url(#clip0_18944_48608)",
            children: jsxRuntimeExports.jsx("path", {
                d: "M7.72578 8.17496V15.675C7.72762 15.7305 7.71793 15.7859 7.69732 15.8375C7.67672 15.8892 7.64564 15.936 7.60606 15.9751C7.56647 16.0141 7.51923 16.0445 7.4673 16.0644C7.41538 16.0843 7.3599 16.0933 7.30435 16.0907H6.45864C6.40297 16.0933 6.34736 16.0843 6.29534 16.0643C6.24332 16.0443 6.196 16.0138 6.1564 15.9746C6.11679 15.9354 6.08574 15.8884 6.06523 15.8365C6.04471 15.7847 6.03517 15.7292 6.03721 15.6735V8.17353C6.03538 8.11795 6.04507 8.0626 6.06567 8.01095C6.08628 7.9593 6.11735 7.91248 6.15694 7.87343C6.19652 7.83438 6.24377 7.80395 6.29569 7.78405C6.34761 7.76415 6.40309 7.75522 6.45864 7.75781H7.3015C7.35717 7.75521 7.41277 7.76418 7.4648 7.78416C7.51682 7.80415 7.56413 7.83471 7.60374 7.87391C7.64335 7.91312 7.67439 7.96012 7.69491 8.01193C7.71542 8.06375 7.72496 8.11926 7.72293 8.17496H7.72435H7.72578ZM11.1029 8.17496V15.675C11.1048 15.7307 11.095 15.7861 11.0744 15.8379C11.0537 15.8896 11.0225 15.9365 10.9827 15.9756C10.943 16.0147 10.8956 16.0451 10.8435 16.0649C10.7914 16.0847 10.7357 16.0935 10.6801 16.0907H9.83721C9.78154 16.0933 9.72594 16.0843 9.67391 16.0643C9.62189 16.0443 9.57458 16.0138 9.53497 15.9746C9.49536 15.9354 9.46432 15.8884 9.4438 15.8365C9.42329 15.7847 9.41374 15.7292 9.41578 15.6735V8.17353C9.41395 8.11795 9.42364 8.0626 9.44424 8.01095C9.46485 7.9593 9.49592 7.91248 9.53551 7.87343C9.5751 7.83438 9.62234 7.80395 9.67426 7.78405C9.72618 7.76415 9.78167 7.75522 9.83721 7.75781H10.6801C10.7357 7.75521 10.7913 7.76418 10.8434 7.78416C10.8954 7.80415 10.9427 7.83471 10.9823 7.87391C11.0219 7.91312 11.053 7.96012 11.0735 8.01193C11.094 8.06375 11.1035 8.11926 11.1015 8.17496H11.1029ZM14.4801 8.17496V15.675C14.4819 15.7307 14.4722 15.7861 14.4515 15.8379C14.4308 15.8896 14.3996 15.9365 14.3599 15.9756C14.3201 16.0147 14.2727 16.0451 14.2206 16.0649C14.1685 16.0847 14.1129 16.0935 14.0572 16.0907H13.2144C13.1587 16.0933 13.1031 16.0843 13.0511 16.0643C12.999 16.0443 12.9517 16.0138 12.9121 15.9746C12.8725 15.9354 12.8415 15.8884 12.8209 15.8365C12.8004 15.7847 12.7909 15.7292 12.7929 15.6735L12.7915 8.17353C12.7897 8.11795 12.7994 8.0626 12.82 8.01095C12.8406 7.9593 12.8716 7.91248 12.9112 7.87343C12.9508 7.83438 12.9981 7.80395 13.05 7.78405C13.1019 7.76415 13.1574 7.75522 13.2129 7.75781H14.0572C14.1129 7.75521 14.1685 7.76418 14.2205 7.78416C14.2725 7.80415 14.3198 7.83471 14.3595 7.87391C14.3991 7.91312 14.4301 7.96012 14.4506 8.01193C14.4711 8.06375 14.4807 8.11926 14.4786 8.17496H14.4801ZM16.1672 17.6021V5.25781H4.35007V17.6007C4.34666 17.9169 4.44591 18.2257 4.63293 18.4807C4.69864 18.555 4.74578 18.5907 4.7715 18.5907H15.7458C15.7715 18.5907 15.8172 18.555 15.8844 18.4807C16.0716 18.2262 16.1713 17.918 16.1686 17.6021H16.1672ZM7.30435 3.59067H13.2129L12.5801 2.06781C12.5255 1.99415 12.4456 1.94326 12.3558 1.92496H8.17435C8.08452 1.94326 8.00464 1.99415 7.95007 2.06781L7.30435 3.59067ZM19.5444 4.00781V4.84067C19.5464 4.89636 19.5368 4.95187 19.5163 5.00369C19.4958 5.05551 19.4648 5.10251 19.4252 5.14171C19.3856 5.18092 19.3382 5.21148 19.2862 5.23146C19.2342 5.25145 19.1786 5.26042 19.1229 5.25781H17.8558V17.6007C17.8558 18.3221 17.6501 18.9435 17.2358 19.4707C16.8215 19.995 16.3258 20.2578 15.7458 20.2578H4.7715C4.1915 20.2578 3.69435 20.0035 3.2815 19.4964C2.86721 18.9878 2.6615 18.3735 2.6615 17.6535V5.25781H1.39435C1.33868 5.26042 1.28308 5.25145 1.23105 5.23146C1.17903 5.21148 1.13172 5.18092 1.09211 5.14171C1.0525 5.10251 1.02146 5.05551 1.00094 5.00369C0.980429 4.95187 0.970888 4.89636 0.972926 4.84067V4.00781C0.970888 3.95212 0.980429 3.89661 1.00094 3.84479C1.02146 3.79297 1.0525 3.74598 1.09211 3.70677C1.13172 3.66757 1.17903 3.637 1.23105 3.61702C1.28308 3.59704 1.33868 3.58806 1.39435 3.59067H5.47007L6.39435 1.41638C6.52578 1.09496 6.76293 0.822098 7.10578 0.596384C7.44864 0.37067 7.79721 0.257812 8.14864 0.257812H12.3686C12.7201 0.257812 13.0686 0.37067 13.4115 0.596384C13.7544 0.822098 13.9915 1.09638 14.1229 1.41638L15.0472 3.59067H19.1229C19.1786 3.58806 19.2342 3.59704 19.2862 3.61702C19.3382 3.637 19.3856 3.66757 19.4252 3.70677C19.4648 3.74598 19.4958 3.79297 19.5163 3.84479C19.5368 3.89661 19.5464 3.95212 19.5444 4.00781Z",
                fill: $
            })
        }), jsxRuntimeExports.jsx("defs", {
            children: jsxRuntimeExports.jsx("clipPath", {
                id: "clip0_18944_48608",
                children: jsxRuntimeExports.jsx("rect", {
                    width: "20px",
                    height: "20px",
                    fill: "white",
                    transform: "translate(0.257812 0.257812)"
                })
            })
        })]
    })
}
const LoadingPng = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAaKSURBVHgB7Z3LixxVFMa/ifGFrwERFUEbRPGBJgjiRrBx50KycONGMgEfoEjiUhAcXAuJf8FEd66iS1cz2egqJFEwCzHdYlCzSaIxcSaT6eN3cqtIdU1V163bXdVVNecHh9vVVdN97/3qnPuoe3sAwzAMwzAMwzAMwzAMw2gHC2gZInI7k1tod+ohbXeUqo1oW7TN6PXGwsKCoEU0WhBW/q1M7qM9QLsbToRdcJUem1b8ddwUI/k6FucabYO2ToGuocE0ThCKcBuTR2k92j1w3rCVYyP4iZK+/iqcOP+hYTRGEAqhXvAU7Qk4EdKVnFfRRceTxNTPU3EuU5wtNIC5C0Ihekxepj2C/EorquiR53tpb0oK/C/t73kLMzdBKMQdTF6n7YGrlKLKz/KYrHPJz/ERJ/3eZdolCnMdc2AuglCMV5m8RtP2oswdnxZkkkhZnzXp75PntAOgolxCzdQqSNROvEN7EvkVGBqKfITMa4PyzmsY+5PCbKImahOEYjzH5APa/dheGYLsBryooq/ANcrJa7SrvBt+HuYj9DptSFHWUQO1CEIx3mDyLop7QCNkd1319e+0X2jnaH/BhZT1nO/TwaOOW+6iPUx7kLaIsDCnpmOXM/y+DVRM5YKwct5mcgDj3hCPpNPhIl0hP9NO0H5gZVzFFDAfKtBDtGcwLs4W/MKmesk5VEylgrAS3mfyHrILOGlMcZr2NSvgDCqA+dKw+Sztcfh7ynnm50dUTGWCsNCHmHyI8TAxKWTosXrDVyz4T6gB5lFnAl6AG4xuYfIg8zfm6zQqZjcqgAVVr/gYxb2a2FM0FHzGAp9EjfD7dMxxnPk9z/RFuDYnL89/oAZm7iEs3PNMvsd2AdJ3XZx+R/skqpy5wXzfy+Ql2tPYHrpO1OEdykwFiaZBVuEmB/PajeTx5yzoF2gQLEPctuigVT3nV+axFu+YOSzMMRlnRNuibdLWaVdo/9Au0t6EUR2s4CXJZpQhzlswqkNDFW0gfuyHUS2s5BVPMZZhVEvkHT6swKgeVvRRDzEG4npgRpUkvGNUIMgSjOrx9A4LVXUhbjxRRA9G9Uj+uMO8Ywp2IZx9qeOsFYJfwqgHD++odea2KwR5CCu773FZoyYN20JoyNrncc0ajNKEPqDaO+GctiWnOWU9hFGaUA/JEiRu1PUZy3EYQZQWhO2HrthYTL+N8YddazCCCPGQ2DuS3dyF1HtDGEGECBJ7R9IjJPXeEEYQ0wiSZOzZ/DwWKXeFEEEeKzg/hBHMNFMnRgWECKLhqVU7W6tEe520w7QL0ZTRgPYp6oJftlwwh3UWOwSZvLjjMOpAiqfdL2KHIMUP6BbLfmYVbchiSEbaRlTGoiVNe1GSEEFOeVzTQ/fppY5n0q6GCOIzxih9Z7SQXuo4a520z807RmlBolncSaLonbIH3adfcD5oF29oG5KnfDzJ2Ef3eaXgfGnvUEIFSe6VyJpk3NPlhl3cSpqisFyrIN8kXmfFTn1vCd2l73HNt6gLcaPTojVZq+goLNvJgrLXP5OhFS7F9NExWKa9HuU+hkCmGRj6rLk6iO7hU6b6wlWM+IUtpYeOIH5bLy5gCoI9JOpjZ3lJOn52aTnpssc19XtHTHTHFG1FUPpoOeK3lnn+EUFc414kykBaPC4R/z2U848G4tfrUIJ7HvNG/PdQ9tAEmJEjnhmu70najNA8e5atOW2l+Pe4lNZsi9a85pQhHaIH0rTeJDN0aEKGWyfKBDGyWEITke2j91EbRSkpRnPbRin3iw5K49oU8W8zlLPS9IEvM9iXcqw0oVDi2sFjHvlNen07nozKeHtSVChlIHOMw+JuooGU4xDahBSv38piRWr0FnEhdlXyb5Q8ltFGAkWJhaksHIjziLLhqd1ixEwhiqIPgvbLDLxGXBtxUPye4+SxjIqp64eUNd5Os7Tyxr5FuK1ya3Ar7Id5qzrEzZv14J576wqYPqZfmvQRv+8IKqbOnxrXCtE+ew+z4xK2L0ny2XJXhiHtAMVYQ9cQ14iuyOzwbYRDWZWd8Fst4p4tDKS56Lxcu7q10yLOW456VM4o53VV6F6Pzi8Wz0VmG8amEWxVOrhKJhi5KcxAZk+eUBqa1CN6MPIR18b4DNx8Kz4twmr0HY0LTY3/T5/iwoiaLm7WrnPZLq12i09FpitCTjV523Yb//WqChILo6bbtOONqJoOo0tVgKHtmTcMwzAMwzAMwzAMwzCMavgf9n5VDefVHgwAAAAASUVORK5CYII=";
function LoadingUploadContainer({loading: _e, children: $, size: et=50, circle: tt=!1, disabled: nt}) {
    return jsxRuntimeExports.jsxs("div", {
        className: "relative",
        children: [$, _e && jsxRuntimeExports.jsx("div", {
            className: `w-full h-full absolute top-0 left-0 bg-black bg-opacity-40 flex justify-center items-center ${tt ? "rounded-full" : "rounded-xl"}`,
            children: jsxRuntimeExports.jsx("div", {
                className: "inline-block animate-spin infinite",
                children: jsxRuntimeExports.jsx("img", {
                    src: LoadingPng,
                    alt: "",
                    width: et,
                    height: et
                })
            })
        }), nt || null]
    })
}
function UploadImage({initAvatarPath: _e="", type: $="avatar", setAvatarPath: et, setUploadError: tt, width: nt=128, height: rt=128, disabled: it}) {
    const ot = useTheme()
      , {onCheckLogin: st} = useCheckLogin()
      , [lt,ct] = reactExports.useState(null)
      , {clearUserInfo: dt} = useStore$1()
      , {data: pt, loading: ht, request: mt} = userGenerateUploadUrls({
        requestBody: {
            files_suffix: []
        }
    }, !0)
      , [{loading: yt},Et] = useAxios$1("", {
        manual: !0
    });
    reactExports.useEffect( () => {
        if (pt) {
            if ((pt == null ? void 0 : pt.code) === 200 && pt.data.upload_files) {
                const [St] = pt.data.upload_files
                  , {form_data: Ct} = St
                  , Nt = new FormData;
                Object.keys(Ct || {}).forEach(Lt => {
                    Ct !== void 0 && Nt.append(Lt, Ct[Lt])
                }
                ),
                Nt.append("file", lt),
                Et({
                    url: St.upload_url,
                    method: "POST",
                    data: Nt
                }).then( () => {
                    et(St.file_path)
                }
                ).catch(Lt => {
                    Vt.error(Lt.message)
                }
                )
            }
            (pt == null ? void 0 : pt.code) !== 200 && (tt(pt == null ? void 0 : pt.msg),
            ct(null)),
            (pt == null ? void 0 : pt.code) === 401 && dt()
        }
    }
    , [pt]);
    const _t = St => {
        if (tt(""),
        !lodashExports.isUndefined(St)) {
            if (St.size > 5 * 1024 * 1024) {
                tt(i18n._({
                    id: "pe2Eus"
                })),
                ct(null);
                return
            }
            if (st()) {
                ct(St);
                const Ct = getFileSuffix(St.name);
                mt({
                    requestBody: {
                        files_suffix: [Ct],
                        type: $ === "token" ? "CREATE_TICKER" : "NORMAL"
                    }
                })
            }
        }
    }
      , wt = St => {
        St.stopPropagation(),
        ct(null),
        et("")
    }
    ;
    return jsxRuntimeExports.jsxs(LoadingUploadContainer, {
        loading: ht || yt,
        circle: $ === "avatar",
        disabled: it,
        children: [($ === "token" || $ === "banner") && jsxRuntimeExports.jsx(Avatar, {
            accept: "image/*",
            src: lt || _e,
            changeLabel: jsxRuntimeExports.jsxs(Box, {
                children: [jsxRuntimeExports.jsx(PanoramaIcon, {
                    fontSize: "large"
                }), jsxRuntimeExports.jsx(IconButton, {
                    className: "absolute right-1 top-1",
                    onClick: wt,
                    children: jsxRuntimeExports.jsx(DeleteIcon, {
                        fill: "red"
                    })
                })]
            }),
            style: {
                width: nt,
                height: rt,
                borderRadius: "0px",
                border: `1px dashed ${ot.custom.dividerColorL1}`
            },
            emptyLabel: jsxRuntimeExports.jsxs(Stack$5, {
                className: "relative flex flex-col justify-center items-center overflow-hidden",
                sx: {
                    width: nt,
                    height: rt,
                    backgroundColor: ot.custom.cardBg
                },
                children: [jsxRuntimeExports.jsx(PanoramaIcon, {
                    fontSize: "large",
                    sx: {
                        color: ot.palette.text.primary
                    }
                }), jsxRuntimeExports.jsx(Text, {
                    fontWeight: 500,
                    sx: {
                        color: ot.palette.text.primary
                    },
                    children: jsxRuntimeExports.jsx(Trans, {
                        id: "+Xjyeo"
                    })
                })]
            }),
            smartImgFit: "orientation",
            onChange: _t
        }), $ === "avatar" && jsxRuntimeExports.jsx(Avatar, {
            src: lt || _e,
            changeLabel: jsxRuntimeExports.jsx(CameraAltIcon, {
                className: "size-8"
            }),
            variant: "circle",
            style: {
                width: "112px",
                height: "112px"
            },
            emptyLabel: jsxRuntimeExports.jsx(CameraAltIcon, {
                className: "size-8"
            }),
            onChange: _t
        })]
    })
}
function FormField(_e) {
    const {errorMsg: $, ...et} = _e;
    return jsxRuntimeExports.jsxs(FormControl, {
        className: "w-full",
        children: [jsxRuntimeExports.jsx(OutlinedInput, {
            ...et
        }), _e != null && _e.error && $ ? jsxRuntimeExports.jsx(Typography, {
            component: "span",
            variant: "body2",
            color: "error.main",
            children: $
        }) : null]
    })
}
var isMergeableObject = function($) {
    return isNonNullObject($) && !isSpecial($)
};
function isNonNullObject(_e) {
    return !!_e && typeof _e == "object"
}
function isSpecial(_e) {
    var $ = Object.prototype.toString.call(_e);
    return $ === "[object RegExp]" || $ === "[object Date]" || isReactElement(_e)
}
var canUseSymbol = typeof Symbol == "function" && Symbol.for
  , REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for("react.element") : 60103;
function isReactElement(_e) {
    return _e.$$typeof === REACT_ELEMENT_TYPE
}
function emptyTarget(_e) {
    return Array.isArray(_e) ? [] : {}
}
function cloneUnlessOtherwiseSpecified(_e, $) {
    return $.clone !== !1 && $.isMergeableObject(_e) ? deepmerge(emptyTarget(_e), _e, $) : _e
}
function defaultArrayMerge(_e, $, et) {
    return _e.concat($).map(function(tt) {
        return cloneUnlessOtherwiseSpecified(tt, et)
    })
}
function mergeObject(_e, $, et) {
    var tt = {};
    return et.isMergeableObject(_e) && Object.keys(_e).forEach(function(nt) {
        tt[nt] = cloneUnlessOtherwiseSpecified(_e[nt], et)
    }),
    Object.keys($).forEach(function(nt) {
        !et.isMergeableObject($[nt]) || !_e[nt] ? tt[nt] = cloneUnlessOtherwiseSpecified($[nt], et) : tt[nt] = deepmerge(_e[nt], $[nt], et)
    }),
    tt
}
function deepmerge(_e, $, et) {
    et = et || {},
    et.arrayMerge = et.arrayMerge || defaultArrayMerge,
    et.isMergeableObject = et.isMergeableObject || isMergeableObject;
    var tt = Array.isArray($)
      , nt = Array.isArray(_e)
      , rt = tt === nt;
    return rt ? tt ? et.arrayMerge(_e, $, et) : mergeObject(_e, $, et) : cloneUnlessOtherwiseSpecified($, et)
}
deepmerge.all = function($, et) {
    if (!Array.isArray($))
        throw new Error("first argument should be an array");
    return $.reduce(function(tt, nt) {
        return deepmerge(tt, nt, et)
    }, {})
}
;
var deepmerge_1 = deepmerge
  , freeGlobal = typeof globalThis == "object" && globalThis && globalThis.Object === Object && globalThis
  , freeSelf = typeof self == "object" && self && self.Object === Object && self
  , root = freeGlobal || freeSelf || Function("return this")()
  , Symbol$1 = root.Symbol
  , objectProto$d = Object.prototype
  , hasOwnProperty$a = objectProto$d.hasOwnProperty
  , nativeObjectToString$1 = objectProto$d.toString
  , symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag(_e) {
    var $ = hasOwnProperty$a.call(_e, symToStringTag$1)
      , et = _e[symToStringTag$1];
    try {
        _e[symToStringTag$1] = void 0;
        var tt = !0
    } catch {}
    var nt = nativeObjectToString$1.call(_e);
    return tt && ($ ? _e[symToStringTag$1] = et : delete _e[symToStringTag$1]),
    nt
}
var objectProto$c = Object.prototype
  , nativeObjectToString = objectProto$c.toString;
function objectToString$1(_e) {
    return nativeObjectToString.call(_e)
}
var nullTag = "[object Null]"
  , undefinedTag = "[object Undefined]"
  , symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
function baseGetTag(_e) {
    return _e == null ? _e === void 0 ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(_e) ? getRawTag(_e) : objectToString$1(_e)
}
function overArg(_e, $) {
    return function(et) {
        return _e($(et))
    }
}
var getPrototype = overArg(Object.getPrototypeOf, Object);
function isObjectLike(_e) {
    return _e != null && typeof _e == "object"
}
var objectTag$3 = "[object Object]"
  , funcProto$2 = Function.prototype
  , objectProto$b = Object.prototype
  , funcToString$2 = funcProto$2.toString
  , hasOwnProperty$9 = objectProto$b.hasOwnProperty
  , objectCtorString = funcToString$2.call(Object);
function isPlainObject$1(_e) {
    if (!isObjectLike(_e) || baseGetTag(_e) != objectTag$3)
        return !1;
    var $ = getPrototype(_e);
    if ($ === null)
        return !0;
    var et = hasOwnProperty$9.call($, "constructor") && $.constructor;
    return typeof et == "function" && et instanceof et && funcToString$2.call(et) == objectCtorString
}
function listCacheClear() {
    this.__data__ = [],
    this.size = 0
}
function eq(_e, $) {
    return _e === $ || _e !== _e && $ !== $
}
function assocIndexOf(_e, $) {
    for (var et = _e.length; et--; )
        if (eq(_e[et][0], $))
            return et;
    return -1
}
var arrayProto = Array.prototype
  , splice = arrayProto.splice;
function listCacheDelete(_e) {
    var $ = this.__data__
      , et = assocIndexOf($, _e);
    if (et < 0)
        return !1;
    var tt = $.length - 1;
    return et == tt ? $.pop() : splice.call($, et, 1),
    --this.size,
    !0
}
function listCacheGet(_e) {
    var $ = this.__data__
      , et = assocIndexOf($, _e);
    return et < 0 ? void 0 : $[et][1]
}
function listCacheHas(_e) {
    return assocIndexOf(this.__data__, _e) > -1
}
function listCacheSet(_e, $) {
    var et = this.__data__
      , tt = assocIndexOf(et, _e);
    return tt < 0 ? (++this.size,
    et.push([_e, $])) : et[tt][1] = $,
    this
}
function ListCache(_e) {
    var $ = -1
      , et = _e == null ? 0 : _e.length;
    for (this.clear(); ++$ < et; ) {
        var tt = _e[$];
        this.set(tt[0], tt[1])
    }
}
ListCache.prototype.clear = listCacheClear;
ListCache.prototype.delete = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;
function stackClear() {
    this.__data__ = new ListCache,
    this.size = 0
}
function stackDelete(_e) {
    var $ = this.__data__
      , et = $.delete(_e);
    return this.size = $.size,
    et
}
function stackGet(_e) {
    return this.__data__.get(_e)
}
function stackHas(_e) {
    return this.__data__.has(_e)
}
function isObject$5(_e) {
    var $ = typeof _e;
    return _e != null && ($ == "object" || $ == "function")
}
var asyncTag = "[object AsyncFunction]"
  , funcTag$2 = "[object Function]"
  , genTag$1 = "[object GeneratorFunction]"
  , proxyTag = "[object Proxy]";
function isFunction$1(_e) {
    if (!isObject$5(_e))
        return !1;
    var $ = baseGetTag(_e);
    return $ == funcTag$2 || $ == genTag$1 || $ == asyncTag || $ == proxyTag
}
var coreJsData = root["__core-js_shared__"]
  , maskSrcKey = function() {
    var _e = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return _e ? "Symbol(src)_1." + _e : ""
}();
function isMasked(_e) {
    return !!maskSrcKey && maskSrcKey in _e
}
var funcProto$1 = Function.prototype
  , funcToString$1 = funcProto$1.toString;
function toSource(_e) {
    if (_e != null) {
        try {
            return funcToString$1.call(_e)
        } catch {}
        try {
            return _e + ""
        } catch {}
    }
    return ""
}
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g
  , reIsHostCtor = /^\[object .+?Constructor\]$/
  , funcProto = Function.prototype
  , objectProto$a = Object.prototype
  , funcToString = funcProto.toString
  , hasOwnProperty$8 = objectProto$a.hasOwnProperty
  , reIsNative = RegExp("^" + funcToString.call(hasOwnProperty$8).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
function baseIsNative(_e) {
    if (!isObject$5(_e) || isMasked(_e))
        return !1;
    var $ = isFunction$1(_e) ? reIsNative : reIsHostCtor;
    return $.test(toSource(_e))
}
function getValue(_e, $) {
    return _e == null ? void 0 : _e[$]
}
function getNative(_e, $) {
    var et = getValue(_e, $);
    return baseIsNative(et) ? et : void 0
}
var Map$1 = getNative(root, "Map")
  , nativeCreate = getNative(Object, "create");
function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {},
    this.size = 0
}
function hashDelete(_e) {
    var $ = this.has(_e) && delete this.__data__[_e];
    return this.size -= $ ? 1 : 0,
    $
}
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__"
  , objectProto$9 = Object.prototype
  , hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashGet(_e) {
    var $ = this.__data__;
    if (nativeCreate) {
        var et = $[_e];
        return et === HASH_UNDEFINED$1 ? void 0 : et
    }
    return hasOwnProperty$7.call($, _e) ? $[_e] : void 0
}
var objectProto$8 = Object.prototype
  , hasOwnProperty$6 = objectProto$8.hasOwnProperty;
function hashHas(_e) {
    var $ = this.__data__;
    return nativeCreate ? $[_e] !== void 0 : hasOwnProperty$6.call($, _e)
}
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function hashSet(_e, $) {
    var et = this.__data__;
    return this.size += this.has(_e) ? 0 : 1,
    et[_e] = nativeCreate && $ === void 0 ? HASH_UNDEFINED : $,
    this
}
function Hash(_e) {
    var $ = -1
      , et = _e == null ? 0 : _e.length;
    for (this.clear(); ++$ < et; ) {
        var tt = _e[$];
        this.set(tt[0], tt[1])
    }
}
Hash.prototype.clear = hashClear;
Hash.prototype.delete = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;
function mapCacheClear() {
    this.size = 0,
    this.__data__ = {
        hash: new Hash,
        map: new (Map$1 || ListCache),
        string: new Hash
    }
}
function isKeyable(_e) {
    var $ = typeof _e;
    return $ == "string" || $ == "number" || $ == "symbol" || $ == "boolean" ? _e !== "__proto__" : _e === null
}
function getMapData(_e, $) {
    var et = _e.__data__;
    return isKeyable($) ? et[typeof $ == "string" ? "string" : "hash"] : et.map
}
function mapCacheDelete(_e) {
    var $ = getMapData(this, _e).delete(_e);
    return this.size -= $ ? 1 : 0,
    $
}
function mapCacheGet(_e) {
    return getMapData(this, _e).get(_e)
}
function mapCacheHas(_e) {
    return getMapData(this, _e).has(_e)
}
function mapCacheSet(_e, $) {
    var et = getMapData(this, _e)
      , tt = et.size;
    return et.set(_e, $),
    this.size += et.size == tt ? 0 : 1,
    this
}
function MapCache(_e) {
    var $ = -1
      , et = _e == null ? 0 : _e.length;
    for (this.clear(); ++$ < et; ) {
        var tt = _e[$];
        this.set(tt[0], tt[1])
    }
}
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype.delete = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;
var LARGE_ARRAY_SIZE = 200;
function stackSet(_e, $) {
    var et = this.__data__;
    if (et instanceof ListCache) {
        var tt = et.__data__;
        if (!Map$1 || tt.length < LARGE_ARRAY_SIZE - 1)
            return tt.push([_e, $]),
            this.size = ++et.size,
            this;
        et = this.__data__ = new MapCache(tt)
    }
    return et.set(_e, $),
    this.size = et.size,
    this
}
function Stack(_e) {
    var $ = this.__data__ = new ListCache(_e);
    this.size = $.size
}
Stack.prototype.clear = stackClear;
Stack.prototype.delete = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;
function arrayEach(_e, $) {
    for (var et = -1, tt = _e == null ? 0 : _e.length; ++et < tt && $(_e[et], et, _e) !== !1; )
        ;
    return _e
}
var defineProperty = function() {
    try {
        var _e = getNative(Object, "defineProperty");
        return _e({}, "", {}),
        _e
    } catch {}
}();
function baseAssignValue(_e, $, et) {
    $ == "__proto__" && defineProperty ? defineProperty(_e, $, {
        configurable: !0,
        enumerable: !0,
        value: et,
        writable: !0
    }) : _e[$] = et
}
var objectProto$7 = Object.prototype
  , hasOwnProperty$5 = objectProto$7.hasOwnProperty;
function assignValue(_e, $, et) {
    var tt = _e[$];
    (!(hasOwnProperty$5.call(_e, $) && eq(tt, et)) || et === void 0 && !($ in _e)) && baseAssignValue(_e, $, et)
}
function copyObject(_e, $, et, tt) {
    var nt = !et;
    et || (et = {});
    for (var rt = -1, it = $.length; ++rt < it; ) {
        var ot = $[rt]
          , st = void 0;
        st === void 0 && (st = _e[ot]),
        nt ? baseAssignValue(et, ot, st) : assignValue(et, ot, st)
    }
    return et
}
function baseTimes(_e, $) {
    for (var et = -1, tt = Array(_e); ++et < _e; )
        tt[et] = $(et);
    return tt
}
var argsTag$2 = "[object Arguments]";
function baseIsArguments(_e) {
    return isObjectLike(_e) && baseGetTag(_e) == argsTag$2
}
var objectProto$6 = Object.prototype
  , hasOwnProperty$4 = objectProto$6.hasOwnProperty
  , propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable
  , isArguments = baseIsArguments(function() {
    return arguments
}()) ? baseIsArguments : function(_e) {
    return isObjectLike(_e) && hasOwnProperty$4.call(_e, "callee") && !propertyIsEnumerable$1.call(_e, "callee")
}
  , isArray$1 = Array.isArray;
function stubFalse() {
    return !1
}
var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports
  , freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module
  , moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2
  , Buffer$1 = moduleExports$2 ? root.Buffer : void 0
  , nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0
  , isBuffer = nativeIsBuffer || stubFalse
  , MAX_SAFE_INTEGER$1 = 9007199254740991
  , reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(_e, $) {
    var et = typeof _e;
    return $ = $ ?? MAX_SAFE_INTEGER$1,
    !!$ && (et == "number" || et != "symbol" && reIsUint.test(_e)) && _e > -1 && _e % 1 == 0 && _e < $
}
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(_e) {
    return typeof _e == "number" && _e > -1 && _e % 1 == 0 && _e <= MAX_SAFE_INTEGER
}
var argsTag$1 = "[object Arguments]"
  , arrayTag$1 = "[object Array]"
  , boolTag$2 = "[object Boolean]"
  , dateTag$2 = "[object Date]"
  , errorTag$1 = "[object Error]"
  , funcTag$1 = "[object Function]"
  , mapTag$4 = "[object Map]"
  , numberTag$2 = "[object Number]"
  , objectTag$2 = "[object Object]"
  , regexpTag$2 = "[object RegExp]"
  , setTag$4 = "[object Set]"
  , stringTag$2 = "[object String]"
  , weakMapTag$2 = "[object WeakMap]"
  , arrayBufferTag$2 = "[object ArrayBuffer]"
  , dataViewTag$3 = "[object DataView]"
  , float32Tag$2 = "[object Float32Array]"
  , float64Tag$2 = "[object Float64Array]"
  , int8Tag$2 = "[object Int8Array]"
  , int16Tag$2 = "[object Int16Array]"
  , int32Tag$2 = "[object Int32Array]"
  , uint8Tag$2 = "[object Uint8Array]"
  , uint8ClampedTag$2 = "[object Uint8ClampedArray]"
  , uint16Tag$2 = "[object Uint16Array]"
  , uint32Tag$2 = "[object Uint32Array]"
  , typedArrayTags = {};
typedArrayTags[float32Tag$2] = typedArrayTags[float64Tag$2] = typedArrayTags[int8Tag$2] = typedArrayTags[int16Tag$2] = typedArrayTags[int32Tag$2] = typedArrayTags[uint8Tag$2] = typedArrayTags[uint8ClampedTag$2] = typedArrayTags[uint16Tag$2] = typedArrayTags[uint32Tag$2] = !0;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$2] = typedArrayTags[boolTag$2] = typedArrayTags[dataViewTag$3] = typedArrayTags[dateTag$2] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag$1] = typedArrayTags[mapTag$4] = typedArrayTags[numberTag$2] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$2] = typedArrayTags[setTag$4] = typedArrayTags[stringTag$2] = typedArrayTags[weakMapTag$2] = !1;
function baseIsTypedArray(_e) {
    return isObjectLike(_e) && isLength(_e.length) && !!typedArrayTags[baseGetTag(_e)]
}
function baseUnary(_e) {
    return function($) {
        return _e($)
    }
}
var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports
  , freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module
  , moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1
  , freeProcess = moduleExports$1 && freeGlobal.process
  , nodeUtil = function() {
    try {
        var _e = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
        return _e || freeProcess && freeProcess.binding && freeProcess.binding("util")
    } catch {}
}()
  , nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray
  , isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray
  , objectProto$5 = Object.prototype
  , hasOwnProperty$3 = objectProto$5.hasOwnProperty;
function arrayLikeKeys(_e, $) {
    var et = isArray$1(_e)
      , tt = !et && isArguments(_e)
      , nt = !et && !tt && isBuffer(_e)
      , rt = !et && !tt && !nt && isTypedArray(_e)
      , it = et || tt || nt || rt
      , ot = it ? baseTimes(_e.length, String) : []
      , st = ot.length;
    for (var lt in _e)
        ($ || hasOwnProperty$3.call(_e, lt)) && !(it && (lt == "length" || nt && (lt == "offset" || lt == "parent") || rt && (lt == "buffer" || lt == "byteLength" || lt == "byteOffset") || isIndex(lt, st))) && ot.push(lt);
    return ot
}
var objectProto$4 = Object.prototype;
function isPrototype(_e) {
    var $ = _e && _e.constructor
      , et = typeof $ == "function" && $.prototype || objectProto$4;
    return _e === et
}
var nativeKeys = overArg(Object.keys, Object)
  , objectProto$3 = Object.prototype
  , hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function baseKeys(_e) {
    if (!isPrototype(_e))
        return nativeKeys(_e);
    var $ = [];
    for (var et in Object(_e))
        hasOwnProperty$2.call(_e, et) && et != "constructor" && $.push(et);
    return $
}
function isArrayLike(_e) {
    return _e != null && isLength(_e.length) && !isFunction$1(_e)
}
function keys(_e) {
    return isArrayLike(_e) ? arrayLikeKeys(_e) : baseKeys(_e)
}
function baseAssign(_e, $) {
    return _e && copyObject($, keys($), _e)
}
function nativeKeysIn(_e) {
    var $ = [];
    if (_e != null)
        for (var et in Object(_e))
            $.push(et);
    return $
}
var objectProto$2 = Object.prototype
  , hasOwnProperty$1 = objectProto$2.hasOwnProperty;
function baseKeysIn(_e) {
    if (!isObject$5(_e))
        return nativeKeysIn(_e);
    var $ = isPrototype(_e)
      , et = [];
    for (var tt in _e)
        tt == "constructor" && ($ || !hasOwnProperty$1.call(_e, tt)) || et.push(tt);
    return et
}
function keysIn(_e) {
    return isArrayLike(_e) ? arrayLikeKeys(_e, !0) : baseKeysIn(_e)
}
function baseAssignIn(_e, $) {
    return _e && copyObject($, keysIn($), _e)
}
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports
  , freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module
  , moduleExports = freeModule && freeModule.exports === freeExports
  , Buffer = moduleExports ? root.Buffer : void 0
  , allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
function cloneBuffer(_e, $) {
    if ($)
        return _e.slice();
    var et = _e.length
      , tt = allocUnsafe ? allocUnsafe(et) : new _e.constructor(et);
    return _e.copy(tt),
    tt
}
function copyArray(_e, $) {
    var et = -1
      , tt = _e.length;
    for ($ || ($ = Array(tt)); ++et < tt; )
        $[et] = _e[et];
    return $
}
function arrayFilter(_e, $) {
    for (var et = -1, tt = _e == null ? 0 : _e.length, nt = 0, rt = []; ++et < tt; ) {
        var it = _e[et];
        $(it, et, _e) && (rt[nt++] = it)
    }
    return rt
}
function stubArray() {
    return []
}
var objectProto$1 = Object.prototype
  , propertyIsEnumerable = objectProto$1.propertyIsEnumerable
  , nativeGetSymbols$1 = Object.getOwnPropertySymbols
  , getSymbols = nativeGetSymbols$1 ? function(_e) {
    return _e == null ? [] : (_e = Object(_e),
    arrayFilter(nativeGetSymbols$1(_e), function($) {
        return propertyIsEnumerable.call(_e, $)
    }))
}
: stubArray;
function copySymbols(_e, $) {
    return copyObject(_e, getSymbols(_e), $)
}
function arrayPush(_e, $) {
    for (var et = -1, tt = $.length, nt = _e.length; ++et < tt; )
        _e[nt + et] = $[et];
    return _e
}
var nativeGetSymbols = Object.getOwnPropertySymbols
  , getSymbolsIn = nativeGetSymbols ? function(_e) {
    for (var $ = []; _e; )
        arrayPush($, getSymbols(_e)),
        _e = getPrototype(_e);
    return $
}
: stubArray;
function copySymbolsIn(_e, $) {
    return copyObject(_e, getSymbolsIn(_e), $)
}
function baseGetAllKeys(_e, $, et) {
    var tt = $(_e);
    return isArray$1(_e) ? tt : arrayPush(tt, et(_e))
}
function getAllKeys(_e) {
    return baseGetAllKeys(_e, keys, getSymbols)
}
function getAllKeysIn(_e) {
    return baseGetAllKeys(_e, keysIn, getSymbolsIn)
}
var DataView$1 = getNative(root, "DataView")
  , Promise$1 = getNative(root, "Promise")
  , Set$1 = getNative(root, "Set")
  , WeakMap$1 = getNative(root, "WeakMap")
  , mapTag$3 = "[object Map]"
  , objectTag$1 = "[object Object]"
  , promiseTag = "[object Promise]"
  , setTag$3 = "[object Set]"
  , weakMapTag$1 = "[object WeakMap]"
  , dataViewTag$2 = "[object DataView]"
  , dataViewCtorString = toSource(DataView$1)
  , mapCtorString = toSource(Map$1)
  , promiseCtorString = toSource(Promise$1)
  , setCtorString = toSource(Set$1)
  , weakMapCtorString = toSource(WeakMap$1)
  , getTag = baseGetTag;
(DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag$2 || Map$1 && getTag(new Map$1) != mapTag$3 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1) != setTag$3 || WeakMap$1 && getTag(new WeakMap$1) != weakMapTag$1) && (getTag = function(_e) {
    var $ = baseGetTag(_e)
      , et = $ == objectTag$1 ? _e.constructor : void 0
      , tt = et ? toSource(et) : "";
    if (tt)
        switch (tt) {
        case dataViewCtorString:
            return dataViewTag$2;
        case mapCtorString:
            return mapTag$3;
        case promiseCtorString:
            return promiseTag;
        case setCtorString:
            return setTag$3;
        case weakMapCtorString:
            return weakMapTag$1
        }
    return $
}
);
var objectProto = Object.prototype
  , hasOwnProperty = objectProto.hasOwnProperty;
function initCloneArray(_e) {
    var $ = _e.length
      , et = new _e.constructor($);
    return $ && typeof _e[0] == "string" && hasOwnProperty.call(_e, "index") && (et.index = _e.index,
    et.input = _e.input),
    et
}
var Uint8Array$1 = root.Uint8Array;
function cloneArrayBuffer(_e) {
    var $ = new _e.constructor(_e.byteLength);
    return new Uint8Array$1($).set(new Uint8Array$1(_e)),
    $
}
function cloneDataView(_e, $) {
    var et = $ ? cloneArrayBuffer(_e.buffer) : _e.buffer;
    return new _e.constructor(et,_e.byteOffset,_e.byteLength)
}
var reFlags = /\w*$/;
function cloneRegExp(_e) {
    var $ = new _e.constructor(_e.source,reFlags.exec(_e));
    return $.lastIndex = _e.lastIndex,
    $
}
var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0
  , symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
function cloneSymbol(_e) {
    return symbolValueOf ? Object(symbolValueOf.call(_e)) : {}
}
function cloneTypedArray(_e, $) {
    var et = $ ? cloneArrayBuffer(_e.buffer) : _e.buffer;
    return new _e.constructor(et,_e.byteOffset,_e.length)
}
var boolTag$1 = "[object Boolean]"
  , dateTag$1 = "[object Date]"
  , mapTag$2 = "[object Map]"
  , numberTag$1 = "[object Number]"
  , regexpTag$1 = "[object RegExp]"
  , setTag$2 = "[object Set]"
  , stringTag$1 = "[object String]"
  , symbolTag$2 = "[object Symbol]"
  , arrayBufferTag$1 = "[object ArrayBuffer]"
  , dataViewTag$1 = "[object DataView]"
  , float32Tag$1 = "[object Float32Array]"
  , float64Tag$1 = "[object Float64Array]"
  , int8Tag$1 = "[object Int8Array]"
  , int16Tag$1 = "[object Int16Array]"
  , int32Tag$1 = "[object Int32Array]"
  , uint8Tag$1 = "[object Uint8Array]"
  , uint8ClampedTag$1 = "[object Uint8ClampedArray]"
  , uint16Tag$1 = "[object Uint16Array]"
  , uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(_e, $, et) {
    var tt = _e.constructor;
    switch ($) {
    case arrayBufferTag$1:
        return cloneArrayBuffer(_e);
    case boolTag$1:
    case dateTag$1:
        return new tt(+_e);
    case dataViewTag$1:
        return cloneDataView(_e, et);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
        return cloneTypedArray(_e, et);
    case mapTag$2:
        return new tt;
    case numberTag$1:
    case stringTag$1:
        return new tt(_e);
    case regexpTag$1:
        return cloneRegExp(_e);
    case setTag$2:
        return new tt;
    case symbolTag$2:
        return cloneSymbol(_e)
    }
}
var objectCreate = Object.create
  , baseCreate = function() {
    function _e() {}
    return function($) {
        if (!isObject$5($))
            return {};
        if (objectCreate)
            return objectCreate($);
        _e.prototype = $;
        var et = new _e;
        return _e.prototype = void 0,
        et
    }
}();
function initCloneObject(_e) {
    return typeof _e.constructor == "function" && !isPrototype(_e) ? baseCreate(getPrototype(_e)) : {}
}
var mapTag$1 = "[object Map]";
function baseIsMap(_e) {
    return isObjectLike(_e) && getTag(_e) == mapTag$1
}
var nodeIsMap = nodeUtil && nodeUtil.isMap
  , isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap
  , setTag$1 = "[object Set]";
function baseIsSet(_e) {
    return isObjectLike(_e) && getTag(_e) == setTag$1
}
var nodeIsSet = nodeUtil && nodeUtil.isSet
  , isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet
  , CLONE_DEEP_FLAG$1 = 1
  , CLONE_FLAT_FLAG = 2
  , CLONE_SYMBOLS_FLAG$2 = 4
  , argsTag = "[object Arguments]"
  , arrayTag = "[object Array]"
  , boolTag = "[object Boolean]"
  , dateTag = "[object Date]"
  , errorTag = "[object Error]"
  , funcTag = "[object Function]"
  , genTag = "[object GeneratorFunction]"
  , mapTag = "[object Map]"
  , numberTag = "[object Number]"
  , objectTag = "[object Object]"
  , regexpTag = "[object RegExp]"
  , setTag = "[object Set]"
  , stringTag = "[object String]"
  , symbolTag$1 = "[object Symbol]"
  , weakMapTag = "[object WeakMap]"
  , arrayBufferTag = "[object ArrayBuffer]"
  , dataViewTag = "[object DataView]"
  , float32Tag = "[object Float32Array]"
  , float64Tag = "[object Float64Array]"
  , int8Tag = "[object Int8Array]"
  , int16Tag = "[object Int16Array]"
  , int32Tag = "[object Int32Array]"
  , uint8Tag = "[object Uint8Array]"
  , uint8ClampedTag = "[object Uint8ClampedArray]"
  , uint16Tag = "[object Uint16Array]"
  , uint32Tag = "[object Uint32Array]"
  , cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag$1] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0;
cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
function baseClone(_e, $, et, tt, nt, rt) {
    var it, ot = $ & CLONE_DEEP_FLAG$1, st = $ & CLONE_FLAT_FLAG, lt = $ & CLONE_SYMBOLS_FLAG$2;
    if (it !== void 0)
        return it;
    if (!isObject$5(_e))
        return _e;
    var ct = isArray$1(_e);
    if (ct) {
        if (it = initCloneArray(_e),
        !ot)
            return copyArray(_e, it)
    } else {
        var dt = getTag(_e)
          , pt = dt == funcTag || dt == genTag;
        if (isBuffer(_e))
            return cloneBuffer(_e, ot);
        if (dt == objectTag || dt == argsTag || pt && !nt) {
            if (it = st || pt ? {} : initCloneObject(_e),
            !ot)
                return st ? copySymbolsIn(_e, baseAssignIn(it, _e)) : copySymbols(_e, baseAssign(it, _e))
        } else {
            if (!cloneableTags[dt])
                return nt ? _e : {};
            it = initCloneByTag(_e, dt, ot)
        }
    }
    rt || (rt = new Stack);
    var ht = rt.get(_e);
    if (ht)
        return ht;
    rt.set(_e, it),
    isSet(_e) ? _e.forEach(function(Et) {
        it.add(baseClone(Et, $, et, Et, _e, rt))
    }) : isMap(_e) && _e.forEach(function(Et, _t) {
        it.set(_t, baseClone(Et, $, et, _t, _e, rt))
    });
    var mt = lt ? st ? getAllKeysIn : getAllKeys : st ? keysIn : keys
      , yt = ct ? void 0 : mt(_e);
    return arrayEach(yt || _e, function(Et, _t) {
        yt && (_t = Et,
        Et = _e[_t]),
        assignValue(it, _t, baseClone(Et, $, et, _t, _e, rt))
    }),
    it
}
var CLONE_DEEP_FLAG = 1
  , CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(_e) {
    return baseClone(_e, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG$1)
}
var isArray = Array.isArray
  , keyList = Object.keys
  , hasProp$1 = Object.prototype.hasOwnProperty
  , hasElementType = typeof Element < "u";
function equal(_e, $) {
    if (_e === $)
        return !0;
    if (_e && $ && typeof _e == "object" && typeof $ == "object") {
        var et = isArray(_e), tt = isArray($), nt, rt, it;
        if (et && tt) {
            if (rt = _e.length,
            rt != $.length)
                return !1;
            for (nt = rt; nt-- !== 0; )
                if (!equal(_e[nt], $[nt]))
                    return !1;
            return !0
        }
        if (et != tt)
            return !1;
        var ot = _e instanceof Date
          , st = $ instanceof Date;
        if (ot != st)
            return !1;
        if (ot && st)
            return _e.getTime() == $.getTime();
        var lt = _e instanceof RegExp
          , ct = $ instanceof RegExp;
        if (lt != ct)
            return !1;
        if (lt && ct)
            return _e.toString() == $.toString();
        var dt = keyList(_e);
        if (rt = dt.length,
        rt !== keyList($).length)
            return !1;
        for (nt = rt; nt-- !== 0; )
            if (!hasProp$1.call($, dt[nt]))
                return !1;
        if (hasElementType && _e instanceof Element && $ instanceof Element)
            return _e === $;
        for (nt = rt; nt-- !== 0; )
            if (it = dt[nt],
            !(it === "_owner" && _e.$$typeof) && !equal(_e[it], $[it]))
                return !1;
        return !0
    }
    return _e !== _e && $ !== $
}
var reactFastCompare = function($, et) {
    try {
        return equal($, et)
    } catch (tt) {
        if (tt.message && tt.message.match(/stack|recursion/i) || tt.number === -2146828260)
            return !1;
        throw tt
    }
};
const isEqual = getDefaultExportFromCjs$2(reactFastCompare);
var CLONE_SYMBOLS_FLAG = 4;
function clone$1(_e) {
    return baseClone(_e, CLONE_SYMBOLS_FLAG)
}
function arrayMap(_e, $) {
    for (var et = -1, tt = _e == null ? 0 : _e.length, nt = Array(tt); ++et < tt; )
        nt[et] = $(_e[et], et, _e);
    return nt
}
var symbolTag = "[object Symbol]";
function isSymbol(_e) {
    return typeof _e == "symbol" || isObjectLike(_e) && baseGetTag(_e) == symbolTag
}
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(_e, $) {
    if (typeof _e != "function" || $ != null && typeof $ != "function")
        throw new TypeError(FUNC_ERROR_TEXT);
    var et = function() {
        var tt = arguments
          , nt = $ ? $.apply(this, tt) : tt[0]
          , rt = et.cache;
        if (rt.has(nt))
            return rt.get(nt);
        var it = _e.apply(this, tt);
        return et.cache = rt.set(nt, it) || rt,
        it
    };
    return et.cache = new (memoize.Cache || MapCache),
    et
}
memoize.Cache = MapCache;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(_e) {
    var $ = memoize(_e, function(tt) {
        return et.size === MAX_MEMOIZE_SIZE && et.clear(),
        tt
    })
      , et = $.cache;
    return $
}
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g
  , reEscapeChar = /\\(\\)?/g
  , stringToPath = memoizeCapped(function(_e) {
    var $ = [];
    return _e.charCodeAt(0) === 46 && $.push(""),
    _e.replace(rePropName, function(et, tt, nt, rt) {
        $.push(nt ? rt.replace(reEscapeChar, "$1") : tt || et)
    }),
    $
});
function toKey(_e) {
    if (typeof _e == "string" || isSymbol(_e))
        return _e;
    var $ = _e + "";
    return $ == "0" && 1 / _e == -1 / 0 ? "-0" : $
}
var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0
  , symbolToString$1 = symbolProto ? symbolProto.toString : void 0;
function baseToString(_e) {
    if (typeof _e == "string")
        return _e;
    if (isArray$1(_e))
        return arrayMap(_e, baseToString) + "";
    if (isSymbol(_e))
        return symbolToString$1 ? symbolToString$1.call(_e) : "";
    var $ = _e + "";
    return $ == "0" && 1 / _e == -1 / 0 ? "-0" : $
}
function toString$1(_e) {
    return _e == null ? "" : baseToString(_e)
}
function toPath(_e) {
    return isArray$1(_e) ? arrayMap(_e, toKey) : isSymbol(_e) ? [_e] : copyArray(stringToPath(toString$1(_e)))
}
function _extends$1() {
    return _extends$1 = Object.assign || function(_e) {
        for (var $ = 1; $ < arguments.length; $++) {
            var et = arguments[$];
            for (var tt in et)
                Object.prototype.hasOwnProperty.call(et, tt) && (_e[tt] = et[tt])
        }
        return _e
    }
    ,
    _extends$1.apply(this, arguments)
}
function _objectWithoutPropertiesLoose(_e, $) {
    if (_e == null)
        return {};
    var et = {}, tt = Object.keys(_e), nt, rt;
    for (rt = 0; rt < tt.length; rt++)
        nt = tt[rt],
        !($.indexOf(nt) >= 0) && (et[nt] = _e[nt]);
    return et
}
var FormikContext = reactExports.createContext(void 0);
FormikContext.displayName = "FormikContext";
FormikContext.Provider;
FormikContext.Consumer;
function useFormikContext() {
    var _e = reactExports.useContext(FormikContext);
    return _e
}
var isFunction = function($) {
    return typeof $ == "function"
}
  , isObject$4 = function($) {
    return $ !== null && typeof $ == "object"
}
  , isInteger = function($) {
    return String(Math.floor(Number($))) === $
}
  , isString$1 = function($) {
    return Object.prototype.toString.call($) === "[object String]"
}
  , isPromise = function($) {
    return isObject$4($) && isFunction($.then)
};
function getIn$1(_e, $, et, tt) {
    tt === void 0 && (tt = 0);
    for (var nt = toPath($); _e && tt < nt.length; )
        _e = _e[nt[tt++]];
    return tt !== nt.length && !_e || _e === void 0 ? et : _e
}
function setIn(_e, $, et) {
    for (var tt = clone$1(_e), nt = tt, rt = 0, it = toPath($); rt < it.length - 1; rt++) {
        var ot = it[rt]
          , st = getIn$1(_e, it.slice(0, rt + 1));
        if (st && (isObject$4(st) || Array.isArray(st)))
            nt = nt[ot] = clone$1(st);
        else {
            var lt = it[rt + 1];
            nt = nt[ot] = isInteger(lt) && Number(lt) >= 0 ? [] : {}
        }
    }
    return (rt === 0 ? _e : nt)[it[rt]] === et ? _e : (et === void 0 ? delete nt[it[rt]] : nt[it[rt]] = et,
    rt === 0 && et === void 0 && delete tt[it[rt]],
    tt)
}
function setNestedObjectValues(_e, $, et, tt) {
    et === void 0 && (et = new WeakMap),
    tt === void 0 && (tt = {});
    for (var nt = 0, rt = Object.keys(_e); nt < rt.length; nt++) {
        var it = rt[nt]
          , ot = _e[it];
        isObject$4(ot) ? et.get(ot) || (et.set(ot, !0),
        tt[it] = Array.isArray(ot) ? [] : {},
        setNestedObjectValues(ot, $, et, tt[it])) : tt[it] = $
    }
    return tt
}
function formikReducer(_e, $) {
    switch ($.type) {
    case "SET_VALUES":
        return _extends$1({}, _e, {
            values: $.payload
        });
    case "SET_TOUCHED":
        return _extends$1({}, _e, {
            touched: $.payload
        });
    case "SET_ERRORS":
        return isEqual(_e.errors, $.payload) ? _e : _extends$1({}, _e, {
            errors: $.payload
        });
    case "SET_STATUS":
        return _extends$1({}, _e, {
            status: $.payload
        });
    case "SET_ISSUBMITTING":
        return _extends$1({}, _e, {
            isSubmitting: $.payload
        });
    case "SET_ISVALIDATING":
        return _extends$1({}, _e, {
            isValidating: $.payload
        });
    case "SET_FIELD_VALUE":
        return _extends$1({}, _e, {
            values: setIn(_e.values, $.payload.field, $.payload.value)
        });
    case "SET_FIELD_TOUCHED":
        return _extends$1({}, _e, {
            touched: setIn(_e.touched, $.payload.field, $.payload.value)
        });
    case "SET_FIELD_ERROR":
        return _extends$1({}, _e, {
            errors: setIn(_e.errors, $.payload.field, $.payload.value)
        });
    case "RESET_FORM":
        return _extends$1({}, _e, $.payload);
    case "SET_FORMIK_STATE":
        return $.payload(_e);
    case "SUBMIT_ATTEMPT":
        return _extends$1({}, _e, {
            touched: setNestedObjectValues(_e.values, !0),
            isSubmitting: !0,
            submitCount: _e.submitCount + 1
        });
    case "SUBMIT_FAILURE":
        return _extends$1({}, _e, {
            isSubmitting: !1
        });
    case "SUBMIT_SUCCESS":
        return _extends$1({}, _e, {
            isSubmitting: !1
        });
    default:
        return _e
    }
}
var emptyErrors = {}
  , emptyTouched = {};
function useFormik(_e) {
    var $ = _e.validateOnChange
      , et = $ === void 0 ? !0 : $
      , tt = _e.validateOnBlur
      , nt = tt === void 0 ? !0 : tt
      , rt = _e.validateOnMount
      , it = rt === void 0 ? !1 : rt
      , ot = _e.isInitialValid
      , st = _e.enableReinitialize
      , lt = st === void 0 ? !1 : st
      , ct = _e.onSubmit
      , dt = _objectWithoutPropertiesLoose(_e, ["validateOnChange", "validateOnBlur", "validateOnMount", "isInitialValid", "enableReinitialize", "onSubmit"])
      , pt = _extends$1({
        validateOnChange: et,
        validateOnBlur: nt,
        validateOnMount: it,
        onSubmit: ct
    }, dt)
      , ht = reactExports.useRef(pt.initialValues)
      , mt = reactExports.useRef(pt.initialErrors || emptyErrors)
      , yt = reactExports.useRef(pt.initialTouched || emptyTouched)
      , Et = reactExports.useRef(pt.initialStatus)
      , _t = reactExports.useRef(!1)
      , wt = reactExports.useRef({});
    reactExports.useEffect(function() {
        return _t.current = !0,
        function() {
            _t.current = !1
        }
    }, []);
    var St = reactExports.useState(0)
      , Ct = St[1]
      , Nt = reactExports.useRef({
        values: cloneDeep(pt.initialValues),
        errors: cloneDeep(pt.initialErrors) || emptyErrors,
        touched: cloneDeep(pt.initialTouched) || emptyTouched,
        status: cloneDeep(pt.initialStatus),
        isSubmitting: !1,
        isValidating: !1,
        submitCount: 0
    })
      , Lt = Nt.current
      , kt = reactExports.useCallback(function(Rn) {
        var Vn = Nt.current;
        Nt.current = formikReducer(Vn, Rn),
        Vn !== Nt.current && Ct(function(qn) {
            return qn + 1
        })
    }, [])
      , Ut = reactExports.useCallback(function(Rn, Vn) {
        return new Promise(function(qn, dr) {
            var or = pt.validate(Rn, Vn);
            or == null ? qn(emptyErrors) : isPromise(or) ? or.then(function(ir) {
                qn(ir || emptyErrors)
            }, function(ir) {
                dr(ir)
            }) : qn(or)
        }
        )
    }, [pt.validate])
      , Jt = reactExports.useCallback(function(Rn, Vn) {
        var qn = pt.validationSchema
          , dr = isFunction(qn) ? qn(Vn) : qn
          , or = Vn && dr.validateAt ? dr.validateAt(Vn, Rn) : validateYupSchema(Rn, dr);
        return new Promise(function(ir, Cr) {
            or.then(function() {
                ir(emptyErrors)
            }, function(br) {
                br.name === "ValidationError" ? ir(yupToFormErrors(br)) : Cr(br)
            })
        }
        )
    }, [pt.validationSchema])
      , Pt = reactExports.useCallback(function(Rn, Vn) {
        return new Promise(function(qn) {
            return qn(wt.current[Rn].validate(Vn))
        }
        )
    }, [])
      , Xt = reactExports.useCallback(function(Rn) {
        var Vn = Object.keys(wt.current).filter(function(dr) {
            return isFunction(wt.current[dr].validate)
        })
          , qn = Vn.length > 0 ? Vn.map(function(dr) {
            return Pt(dr, getIn$1(Rn, dr))
        }) : [Promise.resolve("DO_NOT_DELETE_YOU_WILL_BE_FIRED")];
        return Promise.all(qn).then(function(dr) {
            return dr.reduce(function(or, ir, Cr) {
                return ir === "DO_NOT_DELETE_YOU_WILL_BE_FIRED" || ir && (or = setIn(or, Vn[Cr], ir)),
                or
            }, {})
        })
    }, [Pt])
      , rn = reactExports.useCallback(function(Rn) {
        return Promise.all([Xt(Rn), pt.validationSchema ? Jt(Rn) : {}, pt.validate ? Ut(Rn) : {}]).then(function(Vn) {
            var qn = Vn[0]
              , dr = Vn[1]
              , or = Vn[2]
              , ir = deepmerge_1.all([qn, dr, or], {
                arrayMerge
            });
            return ir
        })
    }, [pt.validate, pt.validationSchema, Xt, Ut, Jt])
      , zt = useEventCallback(function(Rn) {
        return Rn === void 0 && (Rn = Lt.values),
        kt({
            type: "SET_ISVALIDATING",
            payload: !0
        }),
        rn(Rn).then(function(Vn) {
            return _t.current && (kt({
                type: "SET_ISVALIDATING",
                payload: !1
            }),
            kt({
                type: "SET_ERRORS",
                payload: Vn
            })),
            Vn
        })
    });
    reactExports.useEffect(function() {
        it && _t.current === !0 && isEqual(ht.current, pt.initialValues) && zt(ht.current)
    }, [it, zt]);
    var xt = reactExports.useCallback(function(Rn) {
        var Vn = Rn && Rn.values ? Rn.values : ht.current
          , qn = Rn && Rn.errors ? Rn.errors : mt.current ? mt.current : pt.initialErrors || {}
          , dr = Rn && Rn.touched ? Rn.touched : yt.current ? yt.current : pt.initialTouched || {}
          , or = Rn && Rn.status ? Rn.status : Et.current ? Et.current : pt.initialStatus;
        ht.current = Vn,
        mt.current = qn,
        yt.current = dr,
        Et.current = or;
        var ir = function() {
            kt({
                type: "RESET_FORM",
                payload: {
                    isSubmitting: !!Rn && !!Rn.isSubmitting,
                    errors: qn,
                    touched: dr,
                    status: or,
                    values: Vn,
                    isValidating: !!Rn && !!Rn.isValidating,
                    submitCount: Rn && Rn.submitCount && typeof Rn.submitCount == "number" ? Rn.submitCount : 0
                }
            })
        };
        if (pt.onReset) {
            var Cr = pt.onReset(Lt.values, cr);
            isPromise(Cr) ? Cr.then(ir) : ir()
        } else
            ir()
    }, [pt.initialErrors, pt.initialStatus, pt.initialTouched, pt.onReset]);
    reactExports.useEffect(function() {
        _t.current === !0 && !isEqual(ht.current, pt.initialValues) && lt && (ht.current = pt.initialValues,
        xt(),
        it && zt(ht.current))
    }, [lt, pt.initialValues, xt, it, zt]),
    reactExports.useEffect(function() {
        lt && _t.current === !0 && !isEqual(mt.current, pt.initialErrors) && (mt.current = pt.initialErrors || emptyErrors,
        kt({
            type: "SET_ERRORS",
            payload: pt.initialErrors || emptyErrors
        }))
    }, [lt, pt.initialErrors]),
    reactExports.useEffect(function() {
        lt && _t.current === !0 && !isEqual(yt.current, pt.initialTouched) && (yt.current = pt.initialTouched || emptyTouched,
        kt({
            type: "SET_TOUCHED",
            payload: pt.initialTouched || emptyTouched
        }))
    }, [lt, pt.initialTouched]),
    reactExports.useEffect(function() {
        lt && _t.current === !0 && !isEqual(Et.current, pt.initialStatus) && (Et.current = pt.initialStatus,
        kt({
            type: "SET_STATUS",
            payload: pt.initialStatus
        }))
    }, [lt, pt.initialStatus, pt.initialTouched]);
    var $t = useEventCallback(function(Rn) {
        if (wt.current[Rn] && isFunction(wt.current[Rn].validate)) {
            var Vn = getIn$1(Lt.values, Rn)
              , qn = wt.current[Rn].validate(Vn);
            return isPromise(qn) ? (kt({
                type: "SET_ISVALIDATING",
                payload: !0
            }),
            qn.then(function(dr) {
                return dr
            }).then(function(dr) {
                kt({
                    type: "SET_FIELD_ERROR",
                    payload: {
                        field: Rn,
                        value: dr
                    }
                }),
                kt({
                    type: "SET_ISVALIDATING",
                    payload: !1
                })
            })) : (kt({
                type: "SET_FIELD_ERROR",
                payload: {
                    field: Rn,
                    value: qn
                }
            }),
            Promise.resolve(qn))
        } else if (pt.validationSchema)
            return kt({
                type: "SET_ISVALIDATING",
                payload: !0
            }),
            Jt(Lt.values, Rn).then(function(dr) {
                return dr
            }).then(function(dr) {
                kt({
                    type: "SET_FIELD_ERROR",
                    payload: {
                        field: Rn,
                        value: getIn$1(dr, Rn)
                    }
                }),
                kt({
                    type: "SET_ISVALIDATING",
                    payload: !1
                })
            });
        return Promise.resolve()
    })
      , Dt = reactExports.useCallback(function(Rn, Vn) {
        var qn = Vn.validate;
        wt.current[Rn] = {
            validate: qn
        }
    }, [])
      , jt = reactExports.useCallback(function(Rn) {
        delete wt.current[Rn]
    }, [])
      , Ft = useEventCallback(function(Rn, Vn) {
        kt({
            type: "SET_TOUCHED",
            payload: Rn
        });
        var qn = Vn === void 0 ? nt : Vn;
        return qn ? zt(Lt.values) : Promise.resolve()
    })
      , Ht = reactExports.useCallback(function(Rn) {
        kt({
            type: "SET_ERRORS",
            payload: Rn
        })
    }, [])
      , qt = useEventCallback(function(Rn, Vn) {
        var qn = isFunction(Rn) ? Rn(Lt.values) : Rn;
        kt({
            type: "SET_VALUES",
            payload: qn
        });
        var dr = Vn === void 0 ? et : Vn;
        return dr ? zt(qn) : Promise.resolve()
    })
      , Wt = reactExports.useCallback(function(Rn, Vn) {
        kt({
            type: "SET_FIELD_ERROR",
            payload: {
                field: Rn,
                value: Vn
            }
        })
    }, [])
      , Mt = useEventCallback(function(Rn, Vn, qn) {
        kt({
            type: "SET_FIELD_VALUE",
            payload: {
                field: Rn,
                value: Vn
            }
        });
        var dr = qn === void 0 ? et : qn;
        return dr ? zt(setIn(Lt.values, Rn, Vn)) : Promise.resolve()
    })
      , Yt = reactExports.useCallback(function(Rn, Vn) {
        var qn = Vn, dr = Rn, or;
        if (!isString$1(Rn)) {
            Rn.persist && Rn.persist();
            var ir = Rn.target ? Rn.target : Rn.currentTarget
              , Cr = ir.type
              , br = ir.name
              , an = ir.id
              , Kt = ir.value
              , Gt = ir.checked;
            ir.outerHTML;
            var fn = ir.options
              , En = ir.multiple;
            qn = Vn || br || an,
            dr = /number|range/.test(Cr) ? (or = parseFloat(Kt),
            isNaN(or) ? "" : or) : /checkbox/.test(Cr) ? getValueForCheckbox(getIn$1(Lt.values, qn), Gt, Kt) : fn && En ? getSelectedValues(fn) : Kt
        }
        qn && Mt(qn, dr)
    }, [Mt, Lt.values])
      , un = useEventCallback(function(Rn) {
        if (isString$1(Rn))
            return function(Vn) {
                return Yt(Vn, Rn)
            }
            ;
        Yt(Rn)
    })
      , hn = useEventCallback(function(Rn, Vn, qn) {
        Vn === void 0 && (Vn = !0),
        kt({
            type: "SET_FIELD_TOUCHED",
            payload: {
                field: Rn,
                value: Vn
            }
        });
        var dr = qn === void 0 ? nt : qn;
        return dr ? zt(Lt.values) : Promise.resolve()
    })
      , _n = reactExports.useCallback(function(Rn, Vn) {
        Rn.persist && Rn.persist();
        var qn = Rn.target
          , dr = qn.name
          , or = qn.id;
        qn.outerHTML;
        var ir = Vn || dr || or;
        hn(ir, !0)
    }, [hn])
      , kn = useEventCallback(function(Rn) {
        if (isString$1(Rn))
            return function(Vn) {
                return _n(Vn, Rn)
            }
            ;
        _n(Rn)
    })
      , Dn = reactExports.useCallback(function(Rn) {
        isFunction(Rn) ? kt({
            type: "SET_FORMIK_STATE",
            payload: Rn
        }) : kt({
            type: "SET_FORMIK_STATE",
            payload: function() {
                return Rn
            }
        })
    }, [])
      , jn = reactExports.useCallback(function(Rn) {
        kt({
            type: "SET_STATUS",
            payload: Rn
        })
    }, [])
      , Bn = reactExports.useCallback(function(Rn) {
        kt({
            type: "SET_ISSUBMITTING",
            payload: Rn
        })
    }, [])
      , Un = useEventCallback(function() {
        return kt({
            type: "SUBMIT_ATTEMPT"
        }),
        zt().then(function(Rn) {
            var Vn = Rn instanceof Error
              , qn = !Vn && Object.keys(Rn).length === 0;
            if (qn) {
                var dr;
                try {
                    if (dr = Gn(),
                    dr === void 0)
                        return
                } catch (or) {
                    throw or
                }
                return Promise.resolve(dr).then(function(or) {
                    return _t.current && kt({
                        type: "SUBMIT_SUCCESS"
                    }),
                    or
                }).catch(function(or) {
                    if (_t.current)
                        throw kt({
                            type: "SUBMIT_FAILURE"
                        }),
                        or
                })
            } else if (_t.current && (kt({
                type: "SUBMIT_FAILURE"
            }),
            Vn))
                throw Rn
        })
    })
      , Hn = useEventCallback(function(Rn) {
        Rn && Rn.preventDefault && isFunction(Rn.preventDefault) && Rn.preventDefault(),
        Rn && Rn.stopPropagation && isFunction(Rn.stopPropagation) && Rn.stopPropagation(),
        Un().catch(function(Vn) {})
    })
      , cr = {
        resetForm: xt,
        validateForm: zt,
        validateField: $t,
        setErrors: Ht,
        setFieldError: Wt,
        setFieldTouched: hn,
        setFieldValue: Mt,
        setStatus: jn,
        setSubmitting: Bn,
        setTouched: Ft,
        setValues: qt,
        setFormikState: Dn,
        submitForm: Un
    }
      , Gn = useEventCallback(function() {
        return ct(Lt.values, cr)
    })
      , Mn = useEventCallback(function(Rn) {
        Rn && Rn.preventDefault && isFunction(Rn.preventDefault) && Rn.preventDefault(),
        Rn && Rn.stopPropagation && isFunction(Rn.stopPropagation) && Rn.stopPropagation(),
        xt()
    })
      , rr = reactExports.useCallback(function(Rn) {
        return {
            value: getIn$1(Lt.values, Rn),
            error: getIn$1(Lt.errors, Rn),
            touched: !!getIn$1(Lt.touched, Rn),
            initialValue: getIn$1(ht.current, Rn),
            initialTouched: !!getIn$1(yt.current, Rn),
            initialError: getIn$1(mt.current, Rn)
        }
    }, [Lt.errors, Lt.touched, Lt.values])
      , Zn = reactExports.useCallback(function(Rn) {
        return {
            setValue: function(qn, dr) {
                return Mt(Rn, qn, dr)
            },
            setTouched: function(qn, dr) {
                return hn(Rn, qn, dr)
            },
            setError: function(qn) {
                return Wt(Rn, qn)
            }
        }
    }, [Mt, hn, Wt])
      , pr = reactExports.useCallback(function(Rn) {
        var Vn = isObject$4(Rn)
          , qn = Vn ? Rn.name : Rn
          , dr = getIn$1(Lt.values, qn)
          , or = {
            name: qn,
            value: dr,
            onChange: un,
            onBlur: kn
        };
        if (Vn) {
            var ir = Rn.type
              , Cr = Rn.value
              , br = Rn.as
              , an = Rn.multiple;
            ir === "checkbox" ? Cr === void 0 ? or.checked = !!dr : (or.checked = !!(Array.isArray(dr) && ~dr.indexOf(Cr)),
            or.value = Cr) : ir === "radio" ? (or.checked = dr === Cr,
            or.value = Cr) : br === "select" && an && (or.value = or.value || [],
            or.multiple = !0)
        }
        return or
    }, [kn, un, Lt.values])
      , Ur = reactExports.useMemo(function() {
        return !isEqual(ht.current, Lt.values)
    }, [ht.current, Lt.values])
      , xr = reactExports.useMemo(function() {
        return typeof ot < "u" ? Ur ? Lt.errors && Object.keys(Lt.errors).length === 0 : ot !== !1 && isFunction(ot) ? ot(pt) : ot : Lt.errors && Object.keys(Lt.errors).length === 0
    }, [ot, Ur, Lt.errors, pt])
      , wr = _extends$1({}, Lt, {
        initialValues: ht.current,
        initialErrors: mt.current,
        initialTouched: yt.current,
        initialStatus: Et.current,
        handleBlur: kn,
        handleChange: un,
        handleReset: Mn,
        handleSubmit: Hn,
        resetForm: xt,
        setErrors: Ht,
        setFormikState: Dn,
        setFieldTouched: hn,
        setFieldValue: Mt,
        setFieldError: Wt,
        setStatus: jn,
        setSubmitting: Bn,
        setTouched: Ft,
        setValues: qt,
        submitForm: Un,
        validateForm: zt,
        validateField: $t,
        isValid: xr,
        dirty: Ur,
        unregisterField: jt,
        registerField: Dt,
        getFieldProps: pr,
        getFieldMeta: rr,
        getFieldHelpers: Zn,
        validateOnBlur: nt,
        validateOnChange: et,
        validateOnMount: it
    });
    return wr
}
function yupToFormErrors(_e) {
    var $ = {};
    if (_e.inner) {
        if (_e.inner.length === 0)
            return setIn($, _e.path, _e.message);
        for (var nt = _e.inner, et = Array.isArray(nt), tt = 0, nt = et ? nt : nt[Symbol.iterator](); ; ) {
            var rt;
            if (et) {
                if (tt >= nt.length)
                    break;
                rt = nt[tt++]
            } else {
                if (tt = nt.next(),
                tt.done)
                    break;
                rt = tt.value
            }
            var it = rt;
            getIn$1($, it.path) || ($ = setIn($, it.path, it.message))
        }
    }
    return $
}
function validateYupSchema(_e, $, et, tt) {
    et === void 0 && (et = !1);
    var nt = prepareDataForValidation(_e);
    return $[et ? "validateSync" : "validate"](nt, {
        abortEarly: !1,
        context: nt
    })
}
function prepareDataForValidation(_e) {
    var $ = Array.isArray(_e) ? [] : {};
    for (var et in _e)
        if (Object.prototype.hasOwnProperty.call(_e, et)) {
            var tt = String(et);
            Array.isArray(_e[tt]) === !0 ? $[tt] = _e[tt].map(function(nt) {
                return Array.isArray(nt) === !0 || isPlainObject$1(nt) ? prepareDataForValidation(nt) : nt !== "" ? nt : void 0
            }) : isPlainObject$1(_e[tt]) ? $[tt] = prepareDataForValidation(_e[tt]) : $[tt] = _e[tt] !== "" ? _e[tt] : void 0
        }
    return $
}
function arrayMerge(_e, $, et) {
    var tt = _e.slice();
    return $.forEach(function(rt, it) {
        if (typeof tt[it] > "u") {
            var ot = et.clone !== !1
              , st = ot && et.isMergeableObject(rt);
            tt[it] = st ? deepmerge_1(Array.isArray(rt) ? [] : {}, rt, et) : rt
        } else
            et.isMergeableObject(rt) ? tt[it] = deepmerge_1(_e[it], rt, et) : _e.indexOf(rt) === -1 && tt.push(rt)
    }),
    tt
}
function getSelectedValues(_e) {
    return Array.from(_e).filter(function($) {
        return $.selected
    }).map(function($) {
        return $.value
    })
}
function getValueForCheckbox(_e, $, et) {
    if (typeof _e == "boolean")
        return !!$;
    var tt = []
      , nt = !1
      , rt = -1;
    if (Array.isArray(_e))
        tt = _e,
        rt = _e.indexOf(et),
        nt = rt >= 0;
    else if (!et || et == "true" || et == "false")
        return !!$;
    return $ && et && !nt ? tt.concat(et) : nt ? tt.slice(0, rt).concat(tt.slice(rt + 1)) : tt
}
var useIsomorphicLayoutEffect$1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useEventCallback(_e) {
    var $ = reactExports.useRef(_e);
    return useIsomorphicLayoutEffect$1(function() {
        $.current = _e
    }),
    reactExports.useCallback(function() {
        for (var et = arguments.length, tt = new Array(et), nt = 0; nt < et; nt++)
            tt[nt] = arguments[nt];
        return $.current.apply(void 0, tt)
    }, [])
}
var Form = reactExports.forwardRef(function(_e, $) {
    var et = _e.action
      , tt = _objectWithoutPropertiesLoose(_e, ["action"])
      , nt = et ?? "#"
      , rt = useFormikContext()
      , it = rt.handleReset
      , ot = rt.handleSubmit;
    return reactExports.createElement("form", _extends$1({
        onSubmit: ot,
        ref: $,
        onReset: it,
        action: nt
    }, tt))
});
Form.displayName = "Form";
function Cache(_e) {
    this._maxSize = _e,
    this.clear()
}
Cache.prototype.clear = function() {
    this._size = 0,
    this._values = Object.create(null)
}
;
Cache.prototype.get = function(_e) {
    return this._values[_e]
}
;
Cache.prototype.set = function(_e, $) {
    return this._size >= this._maxSize && this.clear(),
    _e in this._values || this._size++,
    this._values[_e] = $
}
;
var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g
  , DIGIT_REGEX = /^\d+$/
  , LEAD_DIGIT_REGEX = /^\d/
  , SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g
  , CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/
  , MAX_CACHE_SIZE = 512
  , pathCache = new Cache(MAX_CACHE_SIZE)
  , setCache = new Cache(MAX_CACHE_SIZE)
  , getCache = new Cache(MAX_CACHE_SIZE)
  , propertyExpr = {
    Cache,
    split,
    normalizePath,
    setter: function(_e) {
        var $ = normalizePath(_e);
        return setCache.get(_e) || setCache.set(_e, function(tt, nt) {
            for (var rt = 0, it = $.length, ot = tt; rt < it - 1; ) {
                var st = $[rt];
                if (st === "__proto__" || st === "constructor" || st === "prototype")
                    return tt;
                ot = ot[$[rt++]]
            }
            ot[$[rt]] = nt
        })
    },
    getter: function(_e, $) {
        var et = normalizePath(_e);
        return getCache.get(_e) || getCache.set(_e, function(nt) {
            for (var rt = 0, it = et.length; rt < it; )
                if (nt != null || !$)
                    nt = nt[et[rt++]];
                else
                    return;
            return nt
        })
    },
    join: function(_e) {
        return _e.reduce(function($, et) {
            return $ + (isQuoted(et) || DIGIT_REGEX.test(et) ? "[" + et + "]" : ($ ? "." : "") + et)
        }, "")
    },
    forEach: function(_e, $, et) {
        forEach(Array.isArray(_e) ? _e : split(_e), $, et)
    }
};
function normalizePath(_e) {
    return pathCache.get(_e) || pathCache.set(_e, split(_e).map(function($) {
        return $.replace(CLEAN_QUOTES_REGEX, "$2")
    }))
}
function split(_e) {
    return _e.match(SPLIT_REGEX) || [""]
}
function forEach(_e, $, et) {
    var tt = _e.length, nt, rt, it, ot;
    for (rt = 0; rt < tt; rt++)
        nt = _e[rt],
        nt && (shouldBeQuoted(nt) && (nt = '"' + nt + '"'),
        ot = isQuoted(nt),
        it = !ot && /^\d+$/.test(nt),
        $.call(et, nt, ot, it, rt, _e))
}
function isQuoted(_e) {
    return typeof _e == "string" && _e && ["'", '"'].indexOf(_e.charAt(0)) !== -1
}
function hasLeadingNumber(_e) {
    return _e.match(LEAD_DIGIT_REGEX) && !_e.match(DIGIT_REGEX)
}
function hasSpecialChars(_e) {
    return SPEC_CHAR_REGEX.test(_e)
}
function shouldBeQuoted(_e) {
    return !isQuoted(_e) && (hasLeadingNumber(_e) || hasSpecialChars(_e))
}
const reWords = /[A-Z\xc0-\xd6\xd8-\xde]?[a-z\xdf-\xf6\xf8-\xff]+(?:['](?:d|ll|m|re|s|t|ve))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde]|$)|(?:[A-Z\xc0-\xd6\xd8-\xde]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:D|LL|M|RE|S|T|VE))?(?=[\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000]|[A-Z\xc0-\xd6\xd8-\xde](?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])|$)|[A-Z\xc0-\xd6\xd8-\xde]?(?:[a-z\xdf-\xf6\xf8-\xff]|[^\ud800-\udfff\xac\xb1\xd7\xf7\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\xbf\u2000-\u206f \t\x0b\f\xa0\ufeff\n\r\u2028\u2029\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\d+\u2700-\u27bfa-z\xdf-\xf6\xf8-\xffA-Z\xc0-\xd6\xd8-\xde])+(?:['](?:d|ll|m|re|s|t|ve))?|[A-Z\xc0-\xd6\xd8-\xde]+(?:['](?:D|LL|M|RE|S|T|VE))?|\d*(?:1ST|2ND|3RD|(?![123])\dTH)(?=\b|[a-z_])|\d*(?:1st|2nd|3rd|(?![123])\dth)(?=\b|[A-Z_])|\d+|(?:[\u2700-\u27bf]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?(?:\u200d(?:[^\ud800-\udfff]|(?:\ud83c[\udde6-\uddff]){2}|[\ud800-\udbff][\udc00-\udfff])[\ufe0e\ufe0f]?(?:[\u0300-\u036f\ufe20-\ufe2f\u20d0-\u20ff]|\ud83c[\udffb-\udfff])?)*/g
  , words = _e => _e.match(reWords) || []
  , upperFirst = _e => _e[0].toUpperCase() + _e.slice(1)
  , join = (_e, $) => words(_e).join($).toLowerCase()
  , camelCase = _e => words(_e).reduce( ($, et) => `${$}${$ ? et[0].toUpperCase() + et.slice(1).toLowerCase() : et.toLowerCase()}`, "")
  , pascalCase = _e => upperFirst(camelCase(_e))
  , snakeCase = _e => join(_e, "_")
  , kebabCase = _e => join(_e, "-")
  , sentenceCase = _e => upperFirst(join(_e, " "))
  , titleCase = _e => words(_e).map(upperFirst).join(" ");
var tinyCase = {
    words,
    upperFirst,
    camelCase,
    pascalCase,
    snakeCase,
    kebabCase,
    sentenceCase,
    titleCase
}
  , toposort$2 = {
    exports: {}
};
toposort$2.exports = function(_e) {
    return toposort(uniqueNodes(_e), _e)
}
;
toposort$2.exports.array = toposort;
function toposort(_e, $) {
    var et = _e.length
      , tt = new Array(et)
      , nt = {}
      , rt = et
      , it = makeOutgoingEdges($)
      , ot = makeNodesHash(_e);
    for ($.forEach(function(lt) {
        if (!ot.has(lt[0]) || !ot.has(lt[1]))
            throw new Error("Unknown node. There is an unknown node in the supplied edges.")
    }); rt--; )
        nt[rt] || st(_e[rt], rt, new Set);
    return tt;
    function st(lt, ct, dt) {
        if (dt.has(lt)) {
            var pt;
            try {
                pt = ", node was:" + JSON.stringify(lt)
            } catch {
                pt = ""
            }
            throw new Error("Cyclic dependency" + pt)
        }
        if (!ot.has(lt))
            throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(lt));
        if (!nt[ct]) {
            nt[ct] = !0;
            var ht = it.get(lt) || new Set;
            if (ht = Array.from(ht),
            ct = ht.length) {
                dt.add(lt);
                do {
                    var mt = ht[--ct];
                    st(mt, ot.get(mt), dt)
                } while (ct);
                dt.delete(lt)
            }
            tt[--et] = lt
        }
    }
}
function uniqueNodes(_e) {
    for (var $ = new Set, et = 0, tt = _e.length; et < tt; et++) {
        var nt = _e[et];
        $.add(nt[0]),
        $.add(nt[1])
    }
    return Array.from($)
}
function makeOutgoingEdges(_e) {
    for (var $ = new Map, et = 0, tt = _e.length; et < tt; et++) {
        var nt = _e[et];
        $.has(nt[0]) || $.set(nt[0], new Set),
        $.has(nt[1]) || $.set(nt[1], new Set),
        $.get(nt[0]).add(nt[1])
    }
    return $
}
function makeNodesHash(_e) {
    for (var $ = new Map, et = 0, tt = _e.length; et < tt; et++)
        $.set(_e[et], et);
    return $
}
var toposortExports = toposort$2.exports;
const toposort$1 = getDefaultExportFromCjs$2(toposortExports)
  , toString = Object.prototype.toString
  , errorToString = Error.prototype.toString
  , regExpToString = RegExp.prototype.toString
  , symbolToString = typeof Symbol < "u" ? Symbol.prototype.toString : () => ""
  , SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
function printNumber(_e) {
    return _e != +_e ? "NaN" : _e === 0 && 1 / _e < 0 ? "-0" : "" + _e
}
function printSimpleValue(_e, $=!1) {
    if (_e == null || _e === !0 || _e === !1)
        return "" + _e;
    const et = typeof _e;
    if (et === "number")
        return printNumber(_e);
    if (et === "string")
        return $ ? `"${_e}"` : _e;
    if (et === "function")
        return "[Function " + (_e.name || "anonymous") + "]";
    if (et === "symbol")
        return symbolToString.call(_e).replace(SYMBOL_REGEXP, "Symbol($1)");
    const tt = toString.call(_e).slice(8, -1);
    return tt === "Date" ? isNaN(_e.getTime()) ? "" + _e : _e.toISOString(_e) : tt === "Error" || _e instanceof Error ? "[" + errorToString.call(_e) + "]" : tt === "RegExp" ? regExpToString.call(_e) : null
}
function printValue(_e, $) {
    let et = printSimpleValue(_e, $);
    return et !== null ? et : JSON.stringify(_e, function(tt, nt) {
        let rt = printSimpleValue(this[tt], $);
        return rt !== null ? rt : nt
    }, 2)
}
function toArray(_e) {
    return _e == null ? [] : [].concat(_e)
}
let _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2, strReg = /\$\{\s*(\w+)\s*\}/g;
_Symbol$toStringTag = Symbol.toStringTag;
class ValidationErrorNoStack {
    constructor($, et, tt, nt) {
        this.name = void 0,
        this.message = void 0,
        this.value = void 0,
        this.path = void 0,
        this.type = void 0,
        this.params = void 0,
        this.errors = void 0,
        this.inner = void 0,
        this[_Symbol$toStringTag] = "Error",
        this.name = "ValidationError",
        this.value = et,
        this.path = tt,
        this.type = nt,
        this.errors = [],
        this.inner = [],
        toArray($).forEach(rt => {
            if (ValidationError.isError(rt)) {
                this.errors.push(...rt.errors);
                const it = rt.inner.length ? rt.inner : [rt];
                this.inner.push(...it)
            } else
                this.errors.push(rt)
        }
        ),
        this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0]
    }
}
_Symbol$hasInstance = Symbol.hasInstance;
_Symbol$toStringTag2 = Symbol.toStringTag;
class ValidationError extends Error {
    static formatError($, et) {
        const tt = et.label || et.path || "this";
        return et = Object.assign({}, et, {
            path: tt,
            originalPath: et.path
        }),
        typeof $ == "string" ? $.replace(strReg, (nt, rt) => printValue(et[rt])) : typeof $ == "function" ? $(et) : $
    }
    static isError($) {
        return $ && $.name === "ValidationError"
    }
    constructor($, et, tt, nt, rt) {
        const it = new ValidationErrorNoStack($,et,tt,nt);
        if (rt)
            return it;
        super(),
        this.value = void 0,
        this.path = void 0,
        this.type = void 0,
        this.params = void 0,
        this.errors = [],
        this.inner = [],
        this[_Symbol$toStringTag2] = "Error",
        this.name = it.name,
        this.message = it.message,
        this.type = it.type,
        this.value = it.value,
        this.path = it.path,
        this.errors = it.errors,
        this.inner = it.inner,
        Error.captureStackTrace && Error.captureStackTrace(this, ValidationError)
    }
    static[_Symbol$hasInstance]($) {
        return ValidationErrorNoStack[Symbol.hasInstance]($) || super[Symbol.hasInstance]($)
    }
}
let mixed = {
    default: "${path} is invalid",
    required: "${path} is a required field",
    defined: "${path} must be defined",
    notNull: "${path} cannot be null",
    oneOf: "${path} must be one of the following values: ${values}",
    notOneOf: "${path} must not be one of the following values: ${values}",
    notType: ({path: _e, type: $, value: et, originalValue: tt}) => {
        const nt = tt != null && tt !== et ? ` (cast from the value \`${printValue(tt, !0)}\`).` : ".";
        return $ !== "mixed" ? `${_e} must be a \`${$}\` type, but the final value was: \`${printValue(et, !0)}\`` + nt : `${_e} must match the configured type. The validated value was: \`${printValue(et, !0)}\`` + nt
    }
}
  , string = {
    length: "${path} must be exactly ${length} characters",
    min: "${path} must be at least ${min} characters",
    max: "${path} must be at most ${max} characters",
    matches: '${path} must match the following: "${regex}"',
    email: "${path} must be a valid email",
    url: "${path} must be a valid URL",
    uuid: "${path} must be a valid UUID",
    datetime: "${path} must be a valid ISO date-time",
    datetime_precision: "${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits",
    datetime_offset: '${path} must be a valid ISO date-time with UTC "Z" timezone',
    trim: "${path} must be a trimmed string",
    lowercase: "${path} must be a lowercase string",
    uppercase: "${path} must be a upper case string"
}
  , number = {
    min: "${path} must be greater than or equal to ${min}",
    max: "${path} must be less than or equal to ${max}",
    lessThan: "${path} must be less than ${less}",
    moreThan: "${path} must be greater than ${more}",
    positive: "${path} must be a positive number",
    negative: "${path} must be a negative number",
    integer: "${path} must be an integer"
}
  , date = {
    min: "${path} field must be later than ${min}",
    max: "${path} field must be at earlier than ${max}"
}
  , boolean = {
    isValue: "${path} field must be ${value}"
}
  , object = {
    noUnknown: "${path} field has unspecified keys: ${unknown}",
    exact: "${path} object contains unknown properties: ${properties}"
}
  , array = {
    min: "${path} field must have at least ${min} items",
    max: "${path} field must have less than or equal to ${max} items",
    length: "${path} must have ${length} items"
}
  , tuple = {
    notType: _e => {
        const {path: $, value: et, spec: tt} = _e
          , nt = tt.types.length;
        if (Array.isArray(et)) {
            if (et.length < nt)
                return `${$} tuple value has too few items, expected a length of ${nt} but got ${et.length} for value: \`${printValue(et, !0)}\``;
            if (et.length > nt)
                return `${$} tuple value has too many items, expected a length of ${nt} but got ${et.length} for value: \`${printValue(et, !0)}\``
        }
        return ValidationError.formatError(mixed.notType, _e)
    }
};
Object.assign(Object.create(null), {
    mixed,
    string,
    number,
    date,
    object,
    array,
    boolean,
    tuple
});
const isSchema = _e => _e && _e.__isYupSchema__;
class Condition {
    static fromOptions($, et) {
        if (!et.then && !et.otherwise)
            throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
        let {is: tt, then: nt, otherwise: rt} = et
          , it = typeof tt == "function" ? tt : (...ot) => ot.every(st => st === tt);
        return new Condition($, (ot, st) => {
            var lt;
            let ct = it(...ot) ? nt : rt;
            return (lt = ct == null ? void 0 : ct(st)) != null ? lt : st
        }
        )
    }
    constructor($, et) {
        this.fn = void 0,
        this.refs = $,
        this.refs = $,
        this.fn = et
    }
    resolve($, et) {
        let tt = this.refs.map(rt => rt.getValue(et == null ? void 0 : et.value, et == null ? void 0 : et.parent, et == null ? void 0 : et.context))
          , nt = this.fn(tt, $, et);
        if (nt === void 0 || nt === $)
            return $;
        if (!isSchema(nt))
            throw new TypeError("conditions must return a schema object");
        return nt.resolve(et)
    }
}
const prefixes = {
    context: "$",
    value: "."
};
class Reference {
    constructor($, et={}) {
        if (this.key = void 0,
        this.isContext = void 0,
        this.isValue = void 0,
        this.isSibling = void 0,
        this.path = void 0,
        this.getter = void 0,
        this.map = void 0,
        typeof $ != "string")
            throw new TypeError("ref must be a string, got: " + $);
        if (this.key = $.trim(),
        $ === "")
            throw new TypeError("ref must be a non-empty string");
        this.isContext = this.key[0] === prefixes.context,
        this.isValue = this.key[0] === prefixes.value,
        this.isSibling = !this.isContext && !this.isValue;
        let tt = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
        this.path = this.key.slice(tt.length),
        this.getter = this.path && propertyExpr.getter(this.path, !0),
        this.map = et.map
    }
    getValue($, et, tt) {
        let nt = this.isContext ? tt : this.isValue ? $ : et;
        return this.getter && (nt = this.getter(nt || {})),
        this.map && (nt = this.map(nt)),
        nt
    }
    cast($, et) {
        return this.getValue($, et == null ? void 0 : et.parent, et == null ? void 0 : et.context)
    }
    resolve() {
        return this
    }
    describe() {
        return {
            type: "ref",
            key: this.key
        }
    }
    toString() {
        return `Ref(${this.key})`
    }
    static isRef($) {
        return $ && $.__isYupRef
    }
}
Reference.prototype.__isYupRef = !0;
const isAbsent = _e => _e == null;
function createValidation(_e) {
    function $({value: et, path: tt="", options: nt, originalValue: rt, schema: it}, ot, st) {
        const {name: lt, test: ct, params: dt, message: pt, skipAbsent: ht} = _e;
        let {parent: mt, context: yt, abortEarly: Et=it.spec.abortEarly, disableStackTrace: _t=it.spec.disableStackTrace} = nt;
        function wt(Xt) {
            return Reference.isRef(Xt) ? Xt.getValue(et, mt, yt) : Xt
        }
        function St(Xt={}) {
            const rn = Object.assign({
                value: et,
                originalValue: rt,
                label: it.spec.label,
                path: Xt.path || tt,
                spec: it.spec,
                disableStackTrace: Xt.disableStackTrace || _t
            }, dt, Xt.params);
            for (const xt of Object.keys(rn))
                rn[xt] = wt(rn[xt]);
            const zt = new ValidationError(ValidationError.formatError(Xt.message || pt, rn),et,rn.path,Xt.type || lt,rn.disableStackTrace);
            return zt.params = rn,
            zt
        }
        const Ct = Et ? ot : st;
        let Nt = {
            path: tt,
            parent: mt,
            type: lt,
            from: nt.from,
            createError: St,
            resolve: wt,
            options: nt,
            originalValue: rt,
            schema: it
        };
        const Lt = Xt => {
            ValidationError.isError(Xt) ? Ct(Xt) : Xt ? st(null) : Ct(St())
        }
          , kt = Xt => {
            ValidationError.isError(Xt) ? Ct(Xt) : ot(Xt)
        }
        ;
        if (ht && isAbsent(et))
            return Lt(!0);
        let Jt;
        try {
            var Pt;
            if (Jt = ct.call(Nt, et, Nt),
            typeof ((Pt = Jt) == null ? void 0 : Pt.then) == "function") {
                if (nt.sync)
                    throw new Error(`Validation test of type: "${Nt.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
                return Promise.resolve(Jt).then(Lt, kt)
            }
        } catch (Xt) {
            kt(Xt);
            return
        }
        Lt(Jt)
    }
    return $.OPTIONS = _e,
    $
}
function getIn(_e, $, et, tt=et) {
    let nt, rt, it;
    return $ ? (propertyExpr.forEach($, (ot, st, lt) => {
        let ct = st ? ot.slice(1, ot.length - 1) : ot;
        _e = _e.resolve({
            context: tt,
            parent: nt,
            value: et
        });
        let dt = _e.type === "tuple"
          , pt = lt ? parseInt(ct, 10) : 0;
        if (_e.innerType || dt) {
            if (dt && !lt)
                throw new Error(`Yup.reach cannot implicitly index into a tuple type. the path part "${it}" must contain an index to the tuple element, e.g. "${it}[0]"`);
            if (et && pt >= et.length)
                throw new Error(`Yup.reach cannot resolve an array item at index: ${ot}, in the path: ${$}. because there is no value at that index. `);
            nt = et,
            et = et && et[pt],
            _e = dt ? _e.spec.types[pt] : _e.innerType
        }
        if (!lt) {
            if (!_e.fields || !_e.fields[ct])
                throw new Error(`The schema does not contain the path: ${$}. (failed at: ${it} which is a type: "${_e.type}")`);
            nt = et,
            et = et && et[ct],
            _e = _e.fields[ct]
        }
        rt = ct,
        it = st ? "[" + ot + "]" : "." + ot
    }
    ),
    {
        schema: _e,
        parent: nt,
        parentPath: rt
    }) : {
        parent: nt,
        parentPath: $,
        schema: _e
    }
}
class ReferenceSet extends Set {
    describe() {
        const $ = [];
        for (const et of this.values())
            $.push(Reference.isRef(et) ? et.describe() : et);
        return $
    }
    resolveAll($) {
        let et = [];
        for (const tt of this.values())
            et.push($(tt));
        return et
    }
    clone() {
        return new ReferenceSet(this.values())
    }
    merge($, et) {
        const tt = this.clone();
        return $.forEach(nt => tt.add(nt)),
        et.forEach(nt => tt.delete(nt)),
        tt
    }
}
function clone(_e, $=new Map) {
    if (isSchema(_e) || !_e || typeof _e != "object")
        return _e;
    if ($.has(_e))
        return $.get(_e);
    let et;
    if (_e instanceof Date)
        et = new Date(_e.getTime()),
        $.set(_e, et);
    else if (_e instanceof RegExp)
        et = new RegExp(_e),
        $.set(_e, et);
    else if (Array.isArray(_e)) {
        et = new Array(_e.length),
        $.set(_e, et);
        for (let tt = 0; tt < _e.length; tt++)
            et[tt] = clone(_e[tt], $)
    } else if (_e instanceof Map) {
        et = new Map,
        $.set(_e, et);
        for (const [tt,nt] of _e.entries())
            et.set(tt, clone(nt, $))
    } else if (_e instanceof Set) {
        et = new Set,
        $.set(_e, et);
        for (const tt of _e)
            et.add(clone(tt, $))
    } else if (_e instanceof Object) {
        et = {},
        $.set(_e, et);
        for (const [tt,nt] of Object.entries(_e))
            et[tt] = clone(nt, $)
    } else
        throw Error(`Unable to clone ${_e}`);
    return et
}
class Schema {
    constructor($) {
        this.type = void 0,
        this.deps = [],
        this.tests = void 0,
        this.transforms = void 0,
        this.conditions = [],
        this._mutate = void 0,
        this.internalTests = {},
        this._whitelist = new ReferenceSet,
        this._blacklist = new ReferenceSet,
        this.exclusiveTests = Object.create(null),
        this._typeCheck = void 0,
        this.spec = void 0,
        this.tests = [],
        this.transforms = [],
        this.withMutation( () => {
            this.typeError(mixed.notType)
        }
        ),
        this.type = $.type,
        this._typeCheck = $.check,
        this.spec = Object.assign({
            strip: !1,
            strict: !1,
            abortEarly: !0,
            recursive: !0,
            disableStackTrace: !1,
            nullable: !1,
            optional: !0,
            coerce: !0
        }, $ == null ? void 0 : $.spec),
        this.withMutation(et => {
            et.nonNullable()
        }
        )
    }
    get _type() {
        return this.type
    }
    clone($) {
        if (this._mutate)
            return $ && Object.assign(this.spec, $),
            this;
        const et = Object.create(Object.getPrototypeOf(this));
        return et.type = this.type,
        et._typeCheck = this._typeCheck,
        et._whitelist = this._whitelist.clone(),
        et._blacklist = this._blacklist.clone(),
        et.internalTests = Object.assign({}, this.internalTests),
        et.exclusiveTests = Object.assign({}, this.exclusiveTests),
        et.deps = [...this.deps],
        et.conditions = [...this.conditions],
        et.tests = [...this.tests],
        et.transforms = [...this.transforms],
        et.spec = clone(Object.assign({}, this.spec, $)),
        et
    }
    label($) {
        let et = this.clone();
        return et.spec.label = $,
        et
    }
    meta(...$) {
        if ($.length === 0)
            return this.spec.meta;
        let et = this.clone();
        return et.spec.meta = Object.assign(et.spec.meta || {}, $[0]),
        et
    }
    withMutation($) {
        let et = this._mutate;
        this._mutate = !0;
        let tt = $(this);
        return this._mutate = et,
        tt
    }
    concat($) {
        if (!$ || $ === this)
            return this;
        if ($.type !== this.type && this.type !== "mixed")
            throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${$.type}`);
        let et = this
          , tt = $.clone();
        const nt = Object.assign({}, et.spec, tt.spec);
        return tt.spec = nt,
        tt.internalTests = Object.assign({}, et.internalTests, tt.internalTests),
        tt._whitelist = et._whitelist.merge($._whitelist, $._blacklist),
        tt._blacklist = et._blacklist.merge($._blacklist, $._whitelist),
        tt.tests = et.tests,
        tt.exclusiveTests = et.exclusiveTests,
        tt.withMutation(rt => {
            $.tests.forEach(it => {
                rt.test(it.OPTIONS)
            }
            )
        }
        ),
        tt.transforms = [...et.transforms, ...tt.transforms],
        tt
    }
    isType($) {
        return $ == null ? !!(this.spec.nullable && $ === null || this.spec.optional && $ === void 0) : this._typeCheck($)
    }
    resolve($) {
        let et = this;
        if (et.conditions.length) {
            let tt = et.conditions;
            et = et.clone(),
            et.conditions = [],
            et = tt.reduce( (nt, rt) => rt.resolve(nt, $), et),
            et = et.resolve($)
        }
        return et
    }
    resolveOptions($) {
        var et, tt, nt, rt;
        return Object.assign({}, $, {
            from: $.from || [],
            strict: (et = $.strict) != null ? et : this.spec.strict,
            abortEarly: (tt = $.abortEarly) != null ? tt : this.spec.abortEarly,
            recursive: (nt = $.recursive) != null ? nt : this.spec.recursive,
            disableStackTrace: (rt = $.disableStackTrace) != null ? rt : this.spec.disableStackTrace
        })
    }
    cast($, et={}) {
        let tt = this.resolve(Object.assign({
            value: $
        }, et))
          , nt = et.assert === "ignore-optionality"
          , rt = tt._cast($, et);
        if (et.assert !== !1 && !tt.isType(rt)) {
            if (nt && isAbsent(rt))
                return rt;
            let it = printValue($)
              , ot = printValue(rt);
            throw new TypeError(`The value of ${et.path || "field"} could not be cast to a value that satisfies the schema type: "${tt.type}".

attempted value: ${it}
` + (ot !== it ? `result of cast: ${ot}` : ""))
        }
        return rt
    }
    _cast($, et) {
        let tt = $ === void 0 ? $ : this.transforms.reduce( (nt, rt) => rt.call(this, nt, $, this), $);
        return tt === void 0 && (tt = this.getDefault(et)),
        tt
    }
    _validate($, et={}, tt, nt) {
        let {path: rt, originalValue: it=$, strict: ot=this.spec.strict} = et
          , st = $;
        ot || (st = this._cast(st, Object.assign({
            assert: !1
        }, et)));
        let lt = [];
        for (let ct of Object.values(this.internalTests))
            ct && lt.push(ct);
        this.runTests({
            path: rt,
            value: st,
            originalValue: it,
            options: et,
            tests: lt
        }, tt, ct => {
            if (ct.length)
                return nt(ct, st);
            this.runTests({
                path: rt,
                value: st,
                originalValue: it,
                options: et,
                tests: this.tests
            }, tt, nt)
        }
        )
    }
    runTests($, et, tt) {
        let nt = !1
          , {tests: rt, value: it, originalValue: ot, path: st, options: lt} = $
          , ct = yt => {
            nt || (nt = !0,
            et(yt, it))
        }
          , dt = yt => {
            nt || (nt = !0,
            tt(yt, it))
        }
          , pt = rt.length
          , ht = [];
        if (!pt)
            return dt([]);
        let mt = {
            value: it,
            originalValue: ot,
            path: st,
            options: lt,
            schema: this
        };
        for (let yt = 0; yt < rt.length; yt++) {
            const Et = rt[yt];
            Et(mt, ct, function(wt) {
                wt && (Array.isArray(wt) ? ht.push(...wt) : ht.push(wt)),
                --pt <= 0 && dt(ht)
            })
        }
    }
    asNestedTest({key: $, index: et, parent: tt, parentPath: nt, originalParent: rt, options: it}) {
        const ot = $ ?? et;
        if (ot == null)
            throw TypeError("Must include `key` or `index` for nested validations");
        const st = typeof ot == "number";
        let lt = tt[ot];
        const ct = Object.assign({}, it, {
            strict: !0,
            parent: tt,
            value: lt,
            originalValue: rt[ot],
            key: void 0,
            [st ? "index" : "key"]: ot,
            path: st || ot.includes(".") ? `${nt || ""}[${st ? ot : `"${ot}"`}]` : (nt ? `${nt}.` : "") + $
        });
        return (dt, pt, ht) => this.resolve(ct)._validate(lt, ct, pt, ht)
    }
    validate($, et) {
        var tt;
        let nt = this.resolve(Object.assign({}, et, {
            value: $
        }))
          , rt = (tt = et == null ? void 0 : et.disableStackTrace) != null ? tt : nt.spec.disableStackTrace;
        return new Promise( (it, ot) => nt._validate($, et, (st, lt) => {
            ValidationError.isError(st) && (st.value = lt),
            ot(st)
        }
        , (st, lt) => {
            st.length ? ot(new ValidationError(st,lt,void 0,void 0,rt)) : it(lt)
        }
        ))
    }
    validateSync($, et) {
        var tt;
        let nt = this.resolve(Object.assign({}, et, {
            value: $
        })), rt, it = (tt = et == null ? void 0 : et.disableStackTrace) != null ? tt : nt.spec.disableStackTrace;
        return nt._validate($, Object.assign({}, et, {
            sync: !0
        }), (ot, st) => {
            throw ValidationError.isError(ot) && (ot.value = st),
            ot
        }
        , (ot, st) => {
            if (ot.length)
                throw new ValidationError(ot,$,void 0,void 0,it);
            rt = st
        }
        ),
        rt
    }
    isValid($, et) {
        return this.validate($, et).then( () => !0, tt => {
            if (ValidationError.isError(tt))
                return !1;
            throw tt
        }
        )
    }
    isValidSync($, et) {
        try {
            return this.validateSync($, et),
            !0
        } catch (tt) {
            if (ValidationError.isError(tt))
                return !1;
            throw tt
        }
    }
    _getDefault($) {
        let et = this.spec.default;
        return et == null ? et : typeof et == "function" ? et.call(this, $) : clone(et)
    }
    getDefault($) {
        return this.resolve($ || {})._getDefault($)
    }
    default($) {
        return arguments.length === 0 ? this._getDefault() : this.clone({
            default: $
        })
    }
    strict($=!0) {
        return this.clone({
            strict: $
        })
    }
    nullability($, et) {
        const tt = this.clone({
            nullable: $
        });
        return tt.internalTests.nullable = createValidation({
            message: et,
            name: "nullable",
            test(nt) {
                return nt === null ? this.schema.spec.nullable : !0
            }
        }),
        tt
    }
    optionality($, et) {
        const tt = this.clone({
            optional: $
        });
        return tt.internalTests.optionality = createValidation({
            message: et,
            name: "optionality",
            test(nt) {
                return nt === void 0 ? this.schema.spec.optional : !0
            }
        }),
        tt
    }
    optional() {
        return this.optionality(!0)
    }
    defined($=mixed.defined) {
        return this.optionality(!1, $)
    }
    nullable() {
        return this.nullability(!0)
    }
    nonNullable($=mixed.notNull) {
        return this.nullability(!1, $)
    }
    required($=mixed.required) {
        return this.clone().withMutation(et => et.nonNullable($).defined($))
    }
    notRequired() {
        return this.clone().withMutation($ => $.nullable().optional())
    }
    transform($) {
        let et = this.clone();
        return et.transforms.push($),
        et
    }
    test(...$) {
        let et;
        if ($.length === 1 ? typeof $[0] == "function" ? et = {
            test: $[0]
        } : et = $[0] : $.length === 2 ? et = {
            name: $[0],
            test: $[1]
        } : et = {
            name: $[0],
            message: $[1],
            test: $[2]
        },
        et.message === void 0 && (et.message = mixed.default),
        typeof et.test != "function")
            throw new TypeError("`test` is a required parameters");
        let tt = this.clone()
          , nt = createValidation(et)
          , rt = et.exclusive || et.name && tt.exclusiveTests[et.name] === !0;
        if (et.exclusive && !et.name)
            throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
        return et.name && (tt.exclusiveTests[et.name] = !!et.exclusive),
        tt.tests = tt.tests.filter(it => !(it.OPTIONS.name === et.name && (rt || it.OPTIONS.test === nt.OPTIONS.test))),
        tt.tests.push(nt),
        tt
    }
    when($, et) {
        !Array.isArray($) && typeof $ != "string" && (et = $,
        $ = ".");
        let tt = this.clone()
          , nt = toArray($).map(rt => new Reference(rt));
        return nt.forEach(rt => {
            rt.isSibling && tt.deps.push(rt.key)
        }
        ),
        tt.conditions.push(typeof et == "function" ? new Condition(nt,et) : Condition.fromOptions(nt, et)),
        tt
    }
    typeError($) {
        let et = this.clone();
        return et.internalTests.typeError = createValidation({
            message: $,
            name: "typeError",
            skipAbsent: !0,
            test(tt) {
                return this.schema._typeCheck(tt) ? !0 : this.createError({
                    params: {
                        type: this.schema.type
                    }
                })
            }
        }),
        et
    }
    oneOf($, et=mixed.oneOf) {
        let tt = this.clone();
        return $.forEach(nt => {
            tt._whitelist.add(nt),
            tt._blacklist.delete(nt)
        }
        ),
        tt.internalTests.whiteList = createValidation({
            message: et,
            name: "oneOf",
            skipAbsent: !0,
            test(nt) {
                let rt = this.schema._whitelist
                  , it = rt.resolveAll(this.resolve);
                return it.includes(nt) ? !0 : this.createError({
                    params: {
                        values: Array.from(rt).join(", "),
                        resolved: it
                    }
                })
            }
        }),
        tt
    }
    notOneOf($, et=mixed.notOneOf) {
        let tt = this.clone();
        return $.forEach(nt => {
            tt._blacklist.add(nt),
            tt._whitelist.delete(nt)
        }
        ),
        tt.internalTests.blacklist = createValidation({
            message: et,
            name: "notOneOf",
            test(nt) {
                let rt = this.schema._blacklist
                  , it = rt.resolveAll(this.resolve);
                return it.includes(nt) ? this.createError({
                    params: {
                        values: Array.from(rt).join(", "),
                        resolved: it
                    }
                }) : !0
            }
        }),
        tt
    }
    strip($=!0) {
        let et = this.clone();
        return et.spec.strip = $,
        et
    }
    describe($) {
        const et = ($ ? this.resolve($) : this).clone()
          , {label: tt, meta: nt, optional: rt, nullable: it} = et.spec;
        return {
            meta: nt,
            label: tt,
            optional: rt,
            nullable: it,
            default: et.getDefault($),
            type: et.type,
            oneOf: et._whitelist.describe(),
            notOneOf: et._blacklist.describe(),
            tests: et.tests.map(st => ({
                name: st.OPTIONS.name,
                params: st.OPTIONS.params
            })).filter( (st, lt, ct) => ct.findIndex(dt => dt.name === st.name) === lt)
        }
    }
}
Schema.prototype.__isYupSchema__ = !0;
for (const _e of ["validate", "validateSync"])
    Schema.prototype[`${_e}At`] = function($, et, tt={}) {
        const {parent: nt, parentPath: rt, schema: it} = getIn(this, $, et, tt.context);
        return it[_e](nt && nt[rt], Object.assign({}, tt, {
            parent: nt,
            path: $
        }))
    }
    ;
for (const _e of ["equals", "is"])
    Schema.prototype[_e] = Schema.prototype.oneOf;
for (const _e of ["not", "nope"])
    Schema.prototype[_e] = Schema.prototype.notOneOf;
const isoReg = /^(\d{4}|[+-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,.](\d{1,}))?)?(?:(Z)|([+-])(\d{2})(?::?(\d{2}))?)?)?$/;
function parseIsoDate(_e) {
    const $ = parseDateStruct(_e);
    if (!$)
        return Date.parse ? Date.parse(_e) : Number.NaN;
    if ($.z === void 0 && $.plusMinus === void 0)
        return new Date($.year,$.month,$.day,$.hour,$.minute,$.second,$.millisecond).valueOf();
    let et = 0;
    return $.z !== "Z" && $.plusMinus !== void 0 && (et = $.hourOffset * 60 + $.minuteOffset,
    $.plusMinus === "+" && (et = 0 - et)),
    Date.UTC($.year, $.month, $.day, $.hour, $.minute + et, $.second, $.millisecond)
}
function parseDateStruct(_e) {
    var $, et;
    const tt = isoReg.exec(_e);
    return tt ? {
        year: toNumber(tt[1]),
        month: toNumber(tt[2], 1) - 1,
        day: toNumber(tt[3], 1),
        hour: toNumber(tt[4]),
        minute: toNumber(tt[5]),
        second: toNumber(tt[6]),
        millisecond: tt[7] ? toNumber(tt[7].substring(0, 3)) : 0,
        precision: ($ = (et = tt[7]) == null ? void 0 : et.length) != null ? $ : void 0,
        z: tt[8] || void 0,
        plusMinus: tt[9] || void 0,
        hourOffset: toNumber(tt[10]),
        minuteOffset: toNumber(tt[11])
    } : null
}
function toNumber(_e, $=0) {
    return Number(_e) || $
}
let rEmail = /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/
  , rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i
  , rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i
  , yearMonthDay = "^\\d{4}-\\d{2}-\\d{2}"
  , hourMinuteSecond = "\\d{2}:\\d{2}:\\d{2}"
  , zOrOffset = "(([+-]\\d{2}(:?\\d{2})?)|Z)"
  , rIsoDateTime = new RegExp(`${yearMonthDay}T${hourMinuteSecond}(\\.\\d+)?${zOrOffset}$`)
  , isTrimmed = _e => isAbsent(_e) || _e === _e.trim()
  , objStringTag = {}.toString();
function create$6() {
    return new StringSchema
}
class StringSchema extends Schema {
    constructor() {
        super({
            type: "string",
            check($) {
                return $ instanceof String && ($ = $.valueOf()),
                typeof $ == "string"
            }
        }),
        this.withMutation( () => {
            this.transform( ($, et, tt) => {
                if (!tt.spec.coerce || tt.isType($) || Array.isArray($))
                    return $;
                const nt = $ != null && $.toString ? $.toString() : $;
                return nt === objStringTag ? $ : nt
            }
            )
        }
        )
    }
    required($) {
        return super.required($).withMutation(et => et.test({
            message: $ || mixed.required,
            name: "required",
            skipAbsent: !0,
            test: tt => !!tt.length
        }))
    }
    notRequired() {
        return super.notRequired().withMutation($ => ($.tests = $.tests.filter(et => et.OPTIONS.name !== "required"),
        $))
    }
    length($, et=string.length) {
        return this.test({
            message: et,
            name: "length",
            exclusive: !0,
            params: {
                length: $
            },
            skipAbsent: !0,
            test(tt) {
                return tt.length === this.resolve($)
            }
        })
    }
    min($, et=string.min) {
        return this.test({
            message: et,
            name: "min",
            exclusive: !0,
            params: {
                min: $
            },
            skipAbsent: !0,
            test(tt) {
                return tt.length >= this.resolve($)
            }
        })
    }
    max($, et=string.max) {
        return this.test({
            name: "max",
            exclusive: !0,
            message: et,
            params: {
                max: $
            },
            skipAbsent: !0,
            test(tt) {
                return tt.length <= this.resolve($)
            }
        })
    }
    matches($, et) {
        let tt = !1, nt, rt;
        return et && (typeof et == "object" ? {excludeEmptyString: tt=!1, message: nt, name: rt} = et : nt = et),
        this.test({
            name: rt || "matches",
            message: nt || string.matches,
            params: {
                regex: $
            },
            skipAbsent: !0,
            test: it => it === "" && tt || it.search($) !== -1
        })
    }
    email($=string.email) {
        return this.matches(rEmail, {
            name: "email",
            message: $,
            excludeEmptyString: !0
        })
    }
    url($=string.url) {
        return this.matches(rUrl, {
            name: "url",
            message: $,
            excludeEmptyString: !0
        })
    }
    uuid($=string.uuid) {
        return this.matches(rUUID, {
            name: "uuid",
            message: $,
            excludeEmptyString: !1
        })
    }
    datetime($) {
        let et = "", tt, nt;
        return $ && (typeof $ == "object" ? {message: et="", allowOffset: tt=!1, precision: nt=void 0} = $ : et = $),
        this.matches(rIsoDateTime, {
            name: "datetime",
            message: et || string.datetime,
            excludeEmptyString: !0
        }).test({
            name: "datetime_offset",
            message: et || string.datetime_offset,
            params: {
                allowOffset: tt
            },
            skipAbsent: !0,
            test: rt => {
                if (!rt || tt)
                    return !0;
                const it = parseDateStruct(rt);
                return it ? !!it.z : !1
            }
        }).test({
            name: "datetime_precision",
            message: et || string.datetime_precision,
            params: {
                precision: nt
            },
            skipAbsent: !0,
            test: rt => {
                if (!rt || nt == null)
                    return !0;
                const it = parseDateStruct(rt);
                return it ? it.precision === nt : !1
            }
        })
    }
    ensure() {
        return this.default("").transform($ => $ === null ? "" : $)
    }
    trim($=string.trim) {
        return this.transform(et => et != null ? et.trim() : et).test({
            message: $,
            name: "trim",
            test: isTrimmed
        })
    }
    lowercase($=string.lowercase) {
        return this.transform(et => isAbsent(et) ? et : et.toLowerCase()).test({
            message: $,
            name: "string_case",
            exclusive: !0,
            skipAbsent: !0,
            test: et => isAbsent(et) || et === et.toLowerCase()
        })
    }
    uppercase($=string.uppercase) {
        return this.transform(et => isAbsent(et) ? et : et.toUpperCase()).test({
            message: $,
            name: "string_case",
            exclusive: !0,
            skipAbsent: !0,
            test: et => isAbsent(et) || et === et.toUpperCase()
        })
    }
}
create$6.prototype = StringSchema.prototype;
let invalidDate = new Date("")
  , isDate = _e => Object.prototype.toString.call(_e) === "[object Date]";
class DateSchema extends Schema {
    constructor() {
        super({
            type: "date",
            check($) {
                return isDate($) && !isNaN($.getTime())
            }
        }),
        this.withMutation( () => {
            this.transform( ($, et, tt) => !tt.spec.coerce || tt.isType($) || $ === null ? $ : ($ = parseIsoDate($),
            isNaN($) ? DateSchema.INVALID_DATE : new Date($)))
        }
        )
    }
    prepareParam($, et) {
        let tt;
        if (Reference.isRef($))
            tt = $;
        else {
            let nt = this.cast($);
            if (!this._typeCheck(nt))
                throw new TypeError(`\`${et}\` must be a Date or a value that can be \`cast()\` to a Date`);
            tt = nt
        }
        return tt
    }
    min($, et=date.min) {
        let tt = this.prepareParam($, "min");
        return this.test({
            message: et,
            name: "min",
            exclusive: !0,
            params: {
                min: $
            },
            skipAbsent: !0,
            test(nt) {
                return nt >= this.resolve(tt)
            }
        })
    }
    max($, et=date.max) {
        let tt = this.prepareParam($, "max");
        return this.test({
            message: et,
            name: "max",
            exclusive: !0,
            params: {
                max: $
            },
            skipAbsent: !0,
            test(nt) {
                return nt <= this.resolve(tt)
            }
        })
    }
}
DateSchema.INVALID_DATE = invalidDate;
function sortFields(_e, $=[]) {
    let et = []
      , tt = new Set
      , nt = new Set($.map( ([it,ot]) => `${it}-${ot}`));
    function rt(it, ot) {
        let st = propertyExpr.split(it)[0];
        tt.add(st),
        nt.has(`${ot}-${st}`) || et.push([ot, st])
    }
    for (const it of Object.keys(_e)) {
        let ot = _e[it];
        tt.add(it),
        Reference.isRef(ot) && ot.isSibling ? rt(ot.path, it) : isSchema(ot) && "deps"in ot && ot.deps.forEach(st => rt(st, it))
    }
    return toposort$1.array(Array.from(tt), et).reverse()
}
function findIndex(_e, $) {
    let et = 1 / 0;
    return _e.some( (tt, nt) => {
        var rt;
        if ((rt = $.path) != null && rt.includes(tt))
            return et = nt,
            !0
    }
    ),
    et
}
function sortByKeyOrder(_e) {
    return ($, et) => findIndex(_e, $) - findIndex(_e, et)
}
const parseJson = (_e, $, et) => {
    if (typeof _e != "string")
        return _e;
    let tt = _e;
    try {
        tt = JSON.parse(_e)
    } catch {}
    return et.isType(tt) ? tt : _e
}
;
function deepPartial(_e) {
    if ("fields"in _e) {
        const $ = {};
        for (const [et,tt] of Object.entries(_e.fields))
            $[et] = deepPartial(tt);
        return _e.setFields($)
    }
    if (_e.type === "array") {
        const $ = _e.optional();
        return $.innerType && ($.innerType = deepPartial($.innerType)),
        $
    }
    return _e.type === "tuple" ? _e.optional().clone({
        types: _e.spec.types.map(deepPartial)
    }) : "optional"in _e ? _e.optional() : _e
}
const deepHas = (_e, $) => {
    const et = [...propertyExpr.normalizePath($)];
    if (et.length === 1)
        return et[0]in _e;
    let tt = et.pop()
      , nt = propertyExpr.getter(propertyExpr.join(et), !0)(_e);
    return !!(nt && tt in nt)
}
;
let isObject$3 = _e => Object.prototype.toString.call(_e) === "[object Object]";
function unknown(_e, $) {
    let et = Object.keys(_e.fields);
    return Object.keys($).filter(tt => et.indexOf(tt) === -1)
}
const defaultSort = sortByKeyOrder([]);
function create$3(_e) {
    return new ObjectSchema(_e)
}
class ObjectSchema extends Schema {
    constructor($) {
        super({
            type: "object",
            check(et) {
                return isObject$3(et) || typeof et == "function"
            }
        }),
        this.fields = Object.create(null),
        this._sortErrors = defaultSort,
        this._nodes = [],
        this._excludedEdges = [],
        this.withMutation( () => {
            $ && this.shape($)
        }
        )
    }
    _cast($, et={}) {
        var tt;
        let nt = super._cast($, et);
        if (nt === void 0)
            return this.getDefault(et);
        if (!this._typeCheck(nt))
            return nt;
        let rt = this.fields
          , it = (tt = et.stripUnknown) != null ? tt : this.spec.noUnknown
          , ot = [].concat(this._nodes, Object.keys(nt).filter(dt => !this._nodes.includes(dt)))
          , st = {}
          , lt = Object.assign({}, et, {
            parent: st,
            __validating: et.__validating || !1
        })
          , ct = !1;
        for (const dt of ot) {
            let pt = rt[dt]
              , ht = dt in nt;
            if (pt) {
                let mt, yt = nt[dt];
                lt.path = (et.path ? `${et.path}.` : "") + dt,
                pt = pt.resolve({
                    value: yt,
                    context: et.context,
                    parent: st
                });
                let Et = pt instanceof Schema ? pt.spec : void 0
                  , _t = Et == null ? void 0 : Et.strict;
                if (Et != null && Et.strip) {
                    ct = ct || dt in nt;
                    continue
                }
                mt = !et.__validating || !_t ? pt.cast(nt[dt], lt) : nt[dt],
                mt !== void 0 && (st[dt] = mt)
            } else
                ht && !it && (st[dt] = nt[dt]);
            (ht !== dt in st || st[dt] !== nt[dt]) && (ct = !0)
        }
        return ct ? st : nt
    }
    _validate($, et={}, tt, nt) {
        let {from: rt=[], originalValue: it=$, recursive: ot=this.spec.recursive} = et;
        et.from = [{
            schema: this,
            value: it
        }, ...rt],
        et.__validating = !0,
        et.originalValue = it,
        super._validate($, et, tt, (st, lt) => {
            if (!ot || !isObject$3(lt)) {
                nt(st, lt);
                return
            }
            it = it || lt;
            let ct = [];
            for (let dt of this._nodes) {
                let pt = this.fields[dt];
                !pt || Reference.isRef(pt) || ct.push(pt.asNestedTest({
                    options: et,
                    key: dt,
                    parent: lt,
                    parentPath: et.path,
                    originalParent: it
                }))
            }
            this.runTests({
                tests: ct,
                value: lt,
                originalValue: it,
                options: et
            }, tt, dt => {
                nt(dt.sort(this._sortErrors).concat(st), lt)
            }
            )
        }
        )
    }
    clone($) {
        const et = super.clone($);
        return et.fields = Object.assign({}, this.fields),
        et._nodes = this._nodes,
        et._excludedEdges = this._excludedEdges,
        et._sortErrors = this._sortErrors,
        et
    }
    concat($) {
        let et = super.concat($)
          , tt = et.fields;
        for (let[nt,rt] of Object.entries(this.fields)) {
            const it = tt[nt];
            tt[nt] = it === void 0 ? rt : it
        }
        return et.withMutation(nt => nt.setFields(tt, [...this._excludedEdges, ...$._excludedEdges]))
    }
    _getDefault($) {
        if ("default"in this.spec)
            return super._getDefault($);
        if (!this._nodes.length)
            return;
        let et = {};
        return this._nodes.forEach(tt => {
            var nt;
            const rt = this.fields[tt];
            let it = $;
            (nt = it) != null && nt.value && (it = Object.assign({}, it, {
                parent: it.value,
                value: it.value[tt]
            })),
            et[tt] = rt && "getDefault"in rt ? rt.getDefault(it) : void 0
        }
        ),
        et
    }
    setFields($, et) {
        let tt = this.clone();
        return tt.fields = $,
        tt._nodes = sortFields($, et),
        tt._sortErrors = sortByKeyOrder(Object.keys($)),
        et && (tt._excludedEdges = et),
        tt
    }
    shape($, et=[]) {
        return this.clone().withMutation(tt => {
            let nt = tt._excludedEdges;
            return et.length && (Array.isArray(et[0]) || (et = [et]),
            nt = [...tt._excludedEdges, ...et]),
            tt.setFields(Object.assign(tt.fields, $), nt)
        }
        )
    }
    partial() {
        const $ = {};
        for (const [et,tt] of Object.entries(this.fields))
            $[et] = "optional"in tt && tt.optional instanceof Function ? tt.optional() : tt;
        return this.setFields($)
    }
    deepPartial() {
        return deepPartial(this)
    }
    pick($) {
        const et = {};
        for (const tt of $)
            this.fields[tt] && (et[tt] = this.fields[tt]);
        return this.setFields(et, this._excludedEdges.filter( ([tt,nt]) => $.includes(tt) && $.includes(nt)))
    }
    omit($) {
        const et = [];
        for (const tt of Object.keys(this.fields))
            $.includes(tt) || et.push(tt);
        return this.pick(et)
    }
    from($, et, tt) {
        let nt = propertyExpr.getter($, !0);
        return this.transform(rt => {
            if (!rt)
                return rt;
            let it = rt;
            return deepHas(rt, $) && (it = Object.assign({}, rt),
            tt || delete it[$],
            it[et] = nt(rt)),
            it
        }
        )
    }
    json() {
        return this.transform(parseJson)
    }
    exact($) {
        return this.test({
            name: "exact",
            exclusive: !0,
            message: $ || object.exact,
            test(et) {
                if (et == null)
                    return !0;
                const tt = unknown(this.schema, et);
                return tt.length === 0 || this.createError({
                    params: {
                        properties: tt.join(", ")
                    }
                })
            }
        })
    }
    stripUnknown() {
        return this.clone({
            noUnknown: !0
        })
    }
    noUnknown($=!0, et=object.noUnknown) {
        typeof $ != "boolean" && (et = $,
        $ = !0);
        let tt = this.test({
            name: "noUnknown",
            exclusive: !0,
            message: et,
            test(nt) {
                if (nt == null)
                    return !0;
                const rt = unknown(this.schema, nt);
                return !$ || rt.length === 0 || this.createError({
                    params: {
                        unknown: rt.join(", ")
                    }
                })
            }
        });
        return tt.spec.noUnknown = $,
        tt
    }
    unknown($=!0, et=object.noUnknown) {
        return this.noUnknown(!$, et)
    }
    transformKeys($) {
        return this.transform(et => {
            if (!et)
                return et;
            const tt = {};
            for (const nt of Object.keys(et))
                tt[$(nt)] = et[nt];
            return tt
        }
        )
    }
    camelCase() {
        return this.transformKeys(tinyCase.camelCase)
    }
    snakeCase() {
        return this.transformKeys(tinyCase.snakeCase)
    }
    constantCase() {
        return this.transformKeys($ => tinyCase.snakeCase($).toUpperCase())
    }
    describe($) {
        const et = ($ ? this.resolve($) : this).clone()
          , tt = super.describe($);
        tt.fields = {};
        for (const [rt,it] of Object.entries(et.fields)) {
            var nt;
            let ot = $;
            (nt = ot) != null && nt.value && (ot = Object.assign({}, ot, {
                parent: ot.value,
                value: ot.value[rt]
            })),
            tt.fields[rt] = it.describe(ot)
        }
        return tt
    }
}
create$3.prototype = ObjectSchema.prototype;
const MAX_FOR_TICKER = 10
  , MIN_FOR_TICKER = 2
  , MAX_FOR_NAME = 32
  , MAX_FOR_INVITATION_CODE = 6
  , MIN_FOR_NAME = 2
  , MAX_FOR_DESCRIPTION = 500
  , validationSchema = create$3({
    tokenSymbol: create$6().matches(/^[A-Z0-9]+$/, "Only supports combinations of uppercase letters and numbers").test({
        name: "checkTickerCharatersLength",
        skipAbsent: !0,
        test(_e, $) {
            const et = Buffer$2.from(_e).length;
            return _e && et < MIN_FOR_TICKER || _e && et > MAX_FOR_TICKER ? $.createError({
                message: `The ticker length should be between ${MIN_FOR_TICKER} to ${MAX_FOR_TICKER} characters.`
            }) : !0
        }
    }).required( () => i18n._({
        id: "w+7M8c"
    })),
    tokenName: create$6().matches(/^\S.*\S$|^\S{0,1}$/, "No spaces at the beginning or end").test({
        name: "checkNameCharatersLength",
        skipAbsent: !0,
        test(_e, $) {
            const et = Buffer$2.from(_e).length;
            return _e && et < MIN_FOR_NAME || _e && et > MAX_FOR_NAME ? $.createError({
                message: `The name length should be between ${MIN_FOR_NAME} to ${MAX_FOR_NAME} characters.`
            }) : !0
        }
    }).required( () => i18n._({
        id: "lRmWzG"
    })),
    description: create$6().max(MAX_FOR_DESCRIPTION, `The description cannot exceed ${MAX_FOR_DESCRIPTION} characters`),
    invitationCode: create$6().test({
        name: "checkNameCharatersLength",
        skipAbsent: !0,
        test(_e, $) {
            return _e && getStringCharactersLength(_e) > MAX_FOR_INVITATION_CODE ? $.createError({
                message: `The invitation code cannot exceed ${MAX_FOR_INVITATION_CODE} characters`
            }) : !0
        }
    }).max(MAX_FOR_INVITATION_CODE, `The invitation code cannot exceed ${MAX_FOR_INVITATION_CODE} characters`).required("Invitation code is required")
})
  , CreateDialog = ({onClose: _e, setData: $, open: et=!1}) => {
    useCheckLogin();
    const tt = useTheme()
      , {accounts: nt} = useGgMemeProgram()
      , rt = nt.data ? nt.data.restrictCreateMarket : !1;
    useNavigate();
    const [it,ot] = reactExports.useState(!1)
      , [st,lt] = reactExports.useState("")
      , [ct,dt] = reactExports.useState("")
      , [pt,ht] = reactExports.useState(!1)
      , [mt,yt] = reactExports.useState("")
      , {isLogin: Et} = useCheckLogin()
      , {loading: _t, request: wt} = tickerGetTicker({
        symbol: ""
    }, !0)
      , St = useFormik({
        initialValues: {
            tokenSymbol: "",
            tokenName: "",
            description: "",
            imgUri: "",
            bannerUrl: "",
            twitterUrl: "",
            telegramUrl: "",
            websiteUrl: "",
            invitationCode: ""
        },
        validationSchema,
        onSubmit: async ($t, Dt) => {
            Dt.setSubmitting(!0)
        }
    })
      , {errors: Ct, values: Nt} = St
      , Lt = reactExports.useMemo( () => {
        const $t = Nt.tokenSymbol !== "" && !Ct.tokenSymbol && !mt
          , Dt = Nt.tokenName !== "" && !Ct.tokenName
          , jt = Nt.imgUri !== ""
          , Ft = rt ? Nt.invitationCode !== "" && !Ct.invitationCode : !0;
        return $t && Dt && jt && Ft
    }
    , [Ct, Nt, mt, rt])
      , kt = $t => {
        let Dt = $t;
        $t !== "" ? Dt = "https://static.super.exchange/" + $t : lt(i18n._({
            id: "ZVYlhZ"
        })),
        St.setFieldValue("imgUri", Dt)
    }
      , Ut = $t => {
        lt($t),
        St.setFieldValue("imgUri", "")
    }
      , Jt = () => {
        ht(!pt)
    }
      , Pt = $t => {
        St.handleBlur($t),
        Nt.tokenSymbol !== "" && wt({
            symbol: Nt.tokenSymbol
        }).then(Dt => {
            Dt.code !== 70001 ? yt(i18n._({
                id: "S4uIAF"
            })) : yt("")
        }
        )
    }
      , Xt = $t => {
        const Dt = $t.target.value;
        St.setFieldValue("tokenSymbol", Dt === "" ? "" : Dt.toUpperCase()),
        St.setFieldTouched("tokenSymbol", !0)
    }
      , rn = () => {
        $(Nt),
        _e()
    }
      , {isMatchMobile: zt} = useAppBreakpoints()
      , xt = reactExports.useMemo( () => (Ct == null ? void 0 : Ct.tokenSymbol) || mt, [mt, Ct]);
    return jsxRuntimeExports.jsx(Dialog, {
        title: i18n._({
            id: "gvAbMv"
        }),
        width: 726,
        open: et,
        onClose: _e,
        zIndex: 1400,
        children: jsxRuntimeExports.jsxs("div", {
            className: "flex flex-col space-y-6",
            children: [jsxRuntimeExports.jsxs("div", {
                className: "form-control space-y-3",
                children: [jsxRuntimeExports.jsxs("div", {
                    className: "flex items-center space-x-2",
                    children: [jsxRuntimeExports.jsxs("div", {
                        className: "flex items-center text-[16px]",
                        children: [jsxRuntimeExports.jsx("span", {
                            className: "",
                            children: jsxRuntimeExports.jsx(Trans, {
                                id: "hG89Ed"
                            })
                        }), jsxRuntimeExports.jsx("span", {
                            className: "text-red-600",
                            children: "*"
                        })]
                    }), jsxRuntimeExports.jsx(Text, {
                        className: "text-xs",
                        level: "l1",
                        children: jsxRuntimeExports.jsx(Trans, {
                            id: "yRfzEC"
                        })
                    })]
                }), jsxRuntimeExports.jsx("div", {
                    className: "flex",
                    children: jsxRuntimeExports.jsx(UploadImage, {
                        setAvatarPath: kt,
                        setUploadError: Ut,
                        type: "token",
                        width: zt ? 150 : 128,
                        height: zt ? 150 : 128,
                        disabled: Et ? null : jsxRuntimeExports.jsx(Box, {
                            className: "absolute left-0 top-0 bg-black/60 flex items-center justify-center",
                            sx: {
                                width: zt ? 150 : 128,
                                height: zt ? 150 : 128
                            },
                            children: jsxRuntimeExports.jsx(WalletButton, {
                                size: "small",
                                className: "text-xs rounded-lg"
                            })
                        })
                    })
                }), st && jsxRuntimeExports.jsx(Text, {
                    variant: "body2",
                    color: "error",
                    children: st
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: "form-control w-full space-y-3",
                children: [jsxRuntimeExports.jsxs("div", {
                    className: "flex items-center space-x-2",
                    children: [jsxRuntimeExports.jsxs("div", {
                        className: "flex items-center text-[16px]",
                        children: [jsxRuntimeExports.jsx("span", {
                            className: "",
                            children: jsxRuntimeExports.jsx(Trans, {
                                id: "LK9M3g"
                            })
                        }), jsxRuntimeExports.jsx("span", {
                            className: " text-red-600",
                            children: "*"
                        })]
                    }), jsxRuntimeExports.jsx(Text, {
                        className: "text-xs",
                        level: "l1",
                        children: jsxRuntimeExports.jsx(Trans, {
                            id: "u3QMKC"
                        })
                    })]
                }), jsxRuntimeExports.jsx(FormField, {
                    fullWidth: !0,
                    placeholder: "",
                    id: "tokenSymbol",
                    name: "tokenSymbol",
                    inputProps: {
                        maxLength: MAX_FOR_TICKER
                    },
                    value: St.values.tokenSymbol,
                    onChange: Xt,
                    onBlur: Pt,
                    disabled: _t,
                    error: St.touched.tokenSymbol && xt,
                    errorMsg: xt,
                    endAdornment: jsxRuntimeExports.jsxs("div", {
                        className: "flex",
                        children: [_t ? jsxRuntimeExports.jsx(Box, {
                            className: "mr-2",
                            children: jsxRuntimeExports.jsx(Loading, {})
                        }) : null, jsxRuntimeExports.jsx(Typography, {
                            variant: "body2",
                            color: isGreaterThan(Buffer$2.from(St.values.tokenSymbol).length, MAX_FOR_TICKER) ? "error" : "text.secondary",
                            children: Buffer$2.from(St.values.tokenSymbol).length
                        }), jsxRuntimeExports.jsxs(Typography, {
                            variant: "body2",
                            color: "text.secondary",
                            children: ["/", MAX_FOR_TICKER]
                        })]
                    })
                })]
            }), jsxRuntimeExports.jsxs("div", {
                className: "form-control w-full space-y-3",
                children: [jsxRuntimeExports.jsx("div", {
                    className: "text-[16px]",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "flex items-center",
                        children: [jsxRuntimeExports.jsx("span", {
                            className: "",
                            children: jsxRuntimeExports.jsx(Trans, {
                                id: "6YtxFj"
                            })
                        }), jsxRuntimeExports.jsx("span", {
                            className: " text-red-600",
                            children: "*"
                        })]
                    })
                }), jsxRuntimeExports.jsx(FormField, {
                    fullWidth: !0,
                    placeholder: "",
                    id: "tokenName",
                    name: "tokenName",
                    inputProps: {
                        maxLength: MAX_FOR_NAME
                    },
                    value: St.values.tokenName,
                    onChange: St.handleChange,
                    onBlur: St.handleBlur,
                    error: St.touched.tokenName && !!St.errors.tokenName,
                    errorMsg: St.errors.tokenName,
                    endAdornment: jsxRuntimeExports.jsxs("div", {
                        className: "flex",
                        children: [jsxRuntimeExports.jsx(Typography, {
                            variant: "body2",
                            color: isGreaterThan(Buffer$2.from(St.values.tokenName).length, MAX_FOR_NAME) ? "error" : "text.secondary",
                            children: Buffer$2.from(St.values.tokenName).length
                        }), jsxRuntimeExports.jsxs(Typography, {
                            variant: "body2",
                            color: "text.secondary",
                            children: ["/", MAX_FOR_NAME]
                        })]
                    })
                })]
            }), jsxRuntimeExports.jsxs(Box, {
                children: [rt && jsxRuntimeExports.jsxs("div", {
                    className: "form-control w-full space-y-3",
                    children: [jsxRuntimeExports.jsx("div", {
                        className: "text-[16px]",
                        children: jsxRuntimeExports.jsxs("div", {
                            className: "flex items-center",
                            children: [jsxRuntimeExports.jsx("span", {
                                className: "",
                                children: jsxRuntimeExports.jsx(Trans, {
                                    id: "RPXn8S"
                                })
                            }), jsxRuntimeExports.jsx("span", {
                                className: "text-red-600",
                                children: "*"
                            })]
                        })
                    }), jsxRuntimeExports.jsx(FormField, {
                        fullWidth: !0,
                        placeholder: "",
                        id: "invitationCode",
                        name: "invitationCode",
                        inputProps: {
                            maxLength: MAX_FOR_INVITATION_CODE
                        },
                        value: St.values.invitationCode,
                        onChange: St.handleChange,
                        onBlur: St.handleBlur,
                        error: St.touched.invitationCode && !!St.errors.invitationCode,
                        errorMsg: St.errors.invitationCode,
                        endAdornment: jsxRuntimeExports.jsxs("div", {
                            className: "flex",
                            children: [jsxRuntimeExports.jsx(Typography, {
                                variant: "body2",
                                color: isGreaterThan(St.values.invitationCode.length, MAX_FOR_INVITATION_CODE) ? "error" : "text.secondary",
                                children: Buffer$2.from(St.values.invitationCode).length
                            }), jsxRuntimeExports.jsxs(Typography, {
                                variant: "body2",
                                color: "text.secondary",
                                children: ["/", MAX_FOR_INVITATION_CODE]
                            })]
                        })
                    })]
                }), jsxRuntimeExports.jsxs(Box, {
                    children: [jsxRuntimeExports.jsxs(Button, {
                        className: "p-0 mt-4",
                        onClick: Jt,
                        disableRipple: !0,
                        sx: {
                            "&:hover": {
                                background: "none",
                                boxShadow: "none"
                            }
                        },
                        children: [jsxRuntimeExports.jsx(AddIcon, {
                            sx: {
                                color: tt.palette.primary.main
                            }
                        }), jsxRuntimeExports.jsx(Text, {
                            color: tt.palette.primary.main,
                            variant: "h6",
                            children: jsxRuntimeExports.jsx(Trans, {
                                id: "OJ/YxQ"
                            })
                        })]
                    }), jsxRuntimeExports.jsx(Collapse, {
                        in: pt,
                        children: jsxRuntimeExports.jsxs(Box, {
                            className: "flex flex-col space-y-6 mt-4",
                            children: [jsxRuntimeExports.jsxs("div", {
                                className: "form-control w-full space-y-3",
                                children: [jsxRuntimeExports.jsx("div", {
                                    className: "text-[16px]",
                                    children: jsxRuntimeExports.jsx("div", {
                                        className: "flex items-center",
                                        children: jsxRuntimeExports.jsx("span", {
                                            className: "",
                                            children: jsxRuntimeExports.jsx(Trans, {
                                                id: "7yIbX8"
                                            })
                                        })
                                    })
                                }), jsxRuntimeExports.jsx(FormField, {
                                    fullWidth: !0,
                                    placeholder: "",
                                    inputProps: {
                                        maxLength: MAX_FOR_URL
                                    },
                                    id: "twitterUrl",
                                    name: "twitterUrl",
                                    value: St.values.twitterUrl,
                                    onChange: St.handleChange,
                                    onBlur: St.handleBlur,
                                    error: St.touched.twitterUrl && !!St.errors.twitterUrl,
                                    errorMsg: St.errors.twitterUrl
                                })]
                            }), jsxRuntimeExports.jsxs("div", {
                                className: "form-control w-full space-y-3",
                                children: [jsxRuntimeExports.jsx("div", {
                                    className: "text-[16px]",
                                    children: jsxRuntimeExports.jsx("div", {
                                        className: "flex items-center",
                                        children: jsxRuntimeExports.jsx("span", {
                                            className: "",
                                            children: jsxRuntimeExports.jsx(Trans, {
                                                id: "aM8Y3P"
                                            })
                                        })
                                    })
                                }), jsxRuntimeExports.jsx(FormField, {
                                    fullWidth: !0,
                                    placeholder: "",
                                    inputProps: {
                                        maxLength: MAX_FOR_URL
                                    },
                                    id: "telegramUrl",
                                    name: "telegramUrl",
                                    value: St.values.telegramUrl,
                                    onChange: St.handleChange,
                                    onBlur: St.handleBlur,
                                    error: St.touched.telegramUrl && !!St.errors.telegramUrl,
                                    errorMsg: St.errors.telegramUrl
                                })]
                            }), jsxRuntimeExports.jsxs("div", {
                                className: "form-control w-full space-y-3",
                                children: [jsxRuntimeExports.jsx("div", {
                                    className: "text-[16px]",
                                    children: jsxRuntimeExports.jsx("div", {
                                        className: "flex items-center",
                                        children: jsxRuntimeExports.jsx("span", {
                                            className: "",
                                            children: jsxRuntimeExports.jsx(Trans, {
                                                id: "On0aF2"
                                            })
                                        })
                                    })
                                }), jsxRuntimeExports.jsx(FormField, {
                                    fullWidth: !0,
                                    placeholder: "",
                                    inputProps: {
                                        maxLength: MAX_FOR_URL
                                    },
                                    id: "websiteUrl",
                                    name: "websiteUrl",
                                    value: St.values.websiteUrl,
                                    onChange: St.handleChange,
                                    onBlur: St.handleBlur,
                                    error: St.touched.websiteUrl && !!St.errors.websiteUrl,
                                    errorMsg: St.errors.websiteUrl
                                })]
                            })]
                        })
                    })]
                }), jsxRuntimeExports.jsx(Box, {
                    className: "flex items-center space-x-2 mt-4",
                    children: jsxRuntimeExports.jsxs(Text, {
                        children: [jsxRuntimeExports.jsx(WarningIcon, {
                            sx: {
                                color: "#F0CD17"
                            },
                            className: "mr-2"
                        }), jsxRuntimeExports.jsx(Trans, {
                            id: "PIRkiz"
                        })]
                    })
                })]
            }), jsxRuntimeExports.jsx("div", {
                children: Et ? jsxRuntimeExports.jsx(CommonButton, {
                    className: "px-[80px]",
                    disabled: !Lt,
                    onClick: () => rn(),
                    children: jsxRuntimeExports.jsx(Trans, {
                        id: "hYgDIe"
                    })
                }) : jsxRuntimeExports.jsx(WalletButton, {})
            })]
        })
    })
}
  , MULTIPLIER = BigInt(1e19)
  , SUPPLY_MULTIPLIER = BigInt(1e4)
  , MAX_TOKEN_SUPPLY = BigInt(1e9) * BigInt(1e6);
BigInt(1e8);
const U64_MAX = (BigInt(1) << BigInt(64)) - BigInt(1)
  , FIND_ROOT_MAX_ERROR = BigInt(1e5)
  , CURVE_1_PARAMS = {
    n: 32,
    k_with_multiplier_sol: BigInt("8750000000000000000") * BigInt(LAMPORTS_PER_SOL$1),
    c_with_sol: BigInt("875000000"),
    token_supply_at_boundary: MAX_TOKEN_SUPPLY * BigInt(95) / BigInt(100),
    native_amount_at_boundary: BigInt(3642026972)
}
  , CURVE_2_PARAMS = {
    n: 16,
    k_with_multiplier_sol: BigInt("39761280660000000000") * BigInt(LAMPORTS_PER_SOL$1),
    c_with_sol: BigInt("5392026971"),
    token_supply_at_boundary: MAX_TOKEN_SUPPLY * BigInt(90) / BigInt(100),
    native_amount_at_boundary: BigInt(16065526972 + 1)
}
  , CURVE_3_PARAMS = {
    n: 8,
    k_with_multiplier_sol: BigInt("184735467600000000000") * BigInt(LAMPORTS_PER_SOL$1),
    c_with_sol: BigInt("26849580917"),
    token_supply_at_boundary: MAX_TOKEN_SUPPLY * BigInt(80) / BigInt(100),
    native_amount_at_boundary: BigInt(83261338320 + 1)
}
  , CURVE_4_PARAMS = {
    n: 4,
    k_with_multiplier_sol: BigInt("902028650400000000000") * BigInt(LAMPORTS_PER_SOL$1),
    c_with_sol: BigInt("136960500156"),
    token_supply_at_boundary: MAX_TOKEN_SUPPLY * BigInt(20) / BigInt(100),
    native_amount_at_boundary: BigInt(56239830149844)
}
  , CURVE_5_PARAMS = {
    n: 3,
    k_with_multiplier_sol: BigInt("6013524336000000000000") * BigInt(LAMPORTS_PER_SOL$1),
    c_with_sol: BigInt("18929224050156"),
    token_supply_at_boundary: MAX_TOKEN_SUPPLY * BigInt(10) / BigInt(100),
    native_amount_at_boundary: BigInt(582423209549844)
}
  , CURVE_6_PARAMS = {
    n: 2,
    k_with_multiplier_sol: BigInt("90202865040000000000000") * BigInt(LAMPORTS_PER_SOL$1),
    c_with_sol: BigInt("319605440850156"),
    token_supply_at_boundary: MAX_TOKEN_SUPPLY * BigInt(5) / BigInt(100),
    native_amount_at_boundary: BigInt("3288509160749844")
}
  , CURVE_7_PARAMS = {
    n: 1,
    k_with_multiplier_sol: BigInt("3608114602000000000000000") * BigInt(LAMPORTS_PER_SOL$1),
    c_with_sol: BigInt("3927720043250156"),
    token_supply_at_boundary: BigInt(1),
    native_amount_at_boundary: U64_MAX
}
  , CURVE_LAST_PARAMS = CURVE_7_PARAMS
  , CURVES = [CURVE_1_PARAMS, CURVE_2_PARAMS, CURVE_3_PARAMS, CURVE_4_PARAMS, CURVE_5_PARAMS, CURVE_6_PARAMS, CURVE_7_PARAMS];
function find_root(_e, $, et, tt) {
    let nt = $ + et;
    if (tt.k_with_multiplier_sol == CURVE_LAST_PARAMS.k_with_multiplier_sol) {
        let ot = MAX_TOKEN_SUPPLY * (CURVE_LAST_PARAMS.k_with_multiplier_sol / MULTIPLIER)
          , st = nt + CURVE_LAST_PARAMS.c_with_sol
          , lt = ceil_div(ot, st);
        if (lt >= _e)
            throw new Error("Buy amount too large");
        return _e - lt
    }
    let rt = tt.token_supply_at_boundary
      , it = _e;
    for (; it - rt > FIND_ROOT_MAX_ERROR; ) {
        let ot = rt + it >> BigInt(1)
          , st = calculate_curve(ot, !0, tt);
        nt > st ? it = ot : rt = ot
    }
    return _e - it
}
function calculate_curve(_e, $, et) {
    let tt = pow(_e, BigInt(et.n), $);
    return div_with_rounding(et.k_with_multiplier_sol, tt, $) - et.c_with_sol
}
function search_curve(_e) {
    for (let $ of CURVES)
        if (_e > $.token_supply_at_boundary)
            return $;
    return CURVE_LAST_PARAMS
}
function calculate_price(_e, $, et) {
    let tt = new Decimal(_e.toString()).div(new Decimal(1e6))
      , nt = new Decimal(($ + et.c_with_sol).toString()).div(new Decimal(LAMPORTS_PER_SOL$1))
      , rt = Decimal.set({
        precision: 15,
        rounding: Decimal.ROUND_DOWN
    });
    return new rt(et.n).mul(nt).div(tt)
}
function calculate_market_cap(_e) {
    return _e.mul(new Decimal(MAX_TOKEN_SUPPLY.toString()).div(new Decimal(1e6)))
}
function div_with_rounding(_e, $, et) {
    let tt = _e / $;
    return et && _e % $ != BigInt(0) ? tt + BigInt(1) : tt
}
function ceil_div(_e, $) {
    let et = _e / $;
    return et * $ == _e ? et : et + BigInt(1)
}
function pow(_e, $, et) {
    let tt = MULTIPLIER
      , nt = _e * SUPPLY_MULTIPLIER;
    for (; $ > BigInt(0); )
        $ % BigInt(2) == BigInt(1) && (tt = tt * nt,
        tt = div_with_rounding(tt, MULTIPLIER, et)),
        nt = nt * nt,
        nt = div_with_rounding(nt, MULTIPLIER, et),
        $ /= BigInt(2);
    return tt
}
function compute_swap_with_fee(_e, $, et) {
    let tt = compute_swap(BigInt(_e), BigInt($), et), nt;
    et ? nt = BigInt($) - BigInt(_e) : nt = BigInt($) + BigInt(_e);
    let rt = compute_fee(tt, nt), it;
    return et ? it = tt + rt : it = tt - rt,
    {
        y: tt,
        fee: rt,
        total: it
    }
}
function compute_swap(_e, $, et) {
    let tt;
    if (et) {
        if (tt = $ - _e,
        tt == BigInt(0))
            throw new Error("Cannot buy all remaining supply")
    } else if (tt = $ + _e,
    tt > MAX_TOKEN_SUPPLY)
        throw new Error("Cannot sell more than max token supply");
    let nt = BigInt(0);
    if (et) {
        let rt = BigInt(0)
          , it = !0
          , ot = BigInt(0);
        for (let st of CURVES)
            if ($ > st.token_supply_at_boundary)
                if (it && (it = !1,
                rt = calculate_curve($, !1, st)),
                tt >= st.token_supply_at_boundary) {
                    ot = calculate_curve(tt, !0, st);
                    break
                } else
                    $ = st.token_supply_at_boundary;
        nt = ot - rt
    } else {
        let rt = BigInt(0)
          , it = BigInt(0);
        for (let ot = CURVES.length - 1; ot >= 0; ot--) {
            let st = CURVES[ot], lt;
            if (ot == 0 ? lt = MAX_TOKEN_SUPPLY : lt = CURVES[ot - 1].token_supply_at_boundary,
            $ < lt)
                if (rt == BigInt(0) && (rt = calculate_curve($, !1, st)),
                tt <= lt) {
                    it = calculate_curve(tt, !0, st);
                    break
                } else
                    $ = lt
        }
        rt > it && (nt = rt - it)
    }
    return nt
}
function compute_buy_token_exact_in_with_fee(_e, $) {
    let et = compute_buy_token_exact_in(BigInt(_e), BigInt($))
      , tt = BigInt($) - et
      , nt = compute_fee(_e, tt);
    return {
        buy_amount: et,
        y: BigInt(_e),
        fee: nt,
        total: BigInt(_e) + nt
    }
}
function compute_buy_token_exact_in(_e, $) {
    let et = BigInt(0)
      , tt = !0
      , nt = BigInt(0);
    for (let rt of CURVES)
        if ($ > rt.token_supply_at_boundary) {
            tt && (tt = !1,
            et = calculate_curve($, !1, rt));
            let it = rt.native_amount_at_boundary - et;
            if (_e < it || rt.k_with_multiplier_sol == CURVE_LAST_PARAMS.k_with_multiplier_sol) {
                nt += find_root($, et, _e, rt);
                break
            } else if (_e == it) {
                nt += $ - rt.token_supply_at_boundary;
                break
            } else
                nt += $ - rt.token_supply_at_boundary,
                $ = rt.token_supply_at_boundary,
                _e -= it,
                et = rt.native_amount_at_boundary
        }
    return nt
}
function compute_fee(_e, $) {
    let et;
    return BigInt($) >= CURVE_3_PARAMS.token_supply_at_boundary ? et = BigInt(100) : BigInt($) >= CURVE_4_PARAMS.token_supply_at_boundary ? et = BigInt(50) : et = BigInt(10),
    BigInt(_e) * et / BigInt(1e4)
}


function curve_points(_e, $=1e3, et=300, tt=BigInt(200) * BigInt(1e9)) {
    if (et < 100)
        throw new Error("Invalid max threshold");
    if ($ < 2)
        throw new Error("Invalid max points");
    let nt = []
      , rt = MAX_TOKEN_SUPPLY - BigInt(_e)
      , ot = compute_swap(rt, MAX_TOKEN_SUPPLY, !0) * BigInt(et) / BigInt(100)
      , st = compute_swap(MAX_TOKEN_SUPPLY - BigInt(1), MAX_TOKEN_SUPPLY, !0);
    ot > st && (ot = st),
    ot < BigInt(tt) && (ot = BigInt(tt));
    let lt = compute_buy_token_exact_in(ot, MAX_TOKEN_SUPPLY), ct = BigInt(0), dt = ceil_div(lt - ct, BigInt($ - 1)), pt;
    for (let mt = 0; mt < $; mt++) {
        let yt = ct + dt * BigInt(mt)
          , Et = BigInt(0);
        yt > BigInt(0) && (Et = compute_swap(yt, MAX_TOKEN_SUPPLY, !0));
        let _t = {
            buy_amount: yt,
            y: Et,
            current: !1,
            market_cap: calculate_market_cap(calculate_price(MAX_TOKEN_SUPPLY - yt, Et, search_curve(MAX_TOKEN_SUPPLY - yt)))
        };
        nt.push(_t),
        pt === void 0 && yt >= BigInt(rt) && (pt = Number(mt))
    }
    let ht = nt[pt];
    if (ht.y == rt)
        ht.current = !0;
    else {
        let mt = compute_swap(rt, MAX_TOKEN_SUPPLY, !0);
        ht.buy_amount = rt,
        ht.y = mt,
        ht.current = !0,
        ht.market_cap = calculate_market_cap(calculate_price(BigInt(_e), mt, search_curve(BigInt(_e))))
    }
    return nt
}
styled("div")`
  width: 100vw;
  min-height: 100vh;
  box-sizing: border-box;
  overflow: hidden;
`;
styled("main")( () => ({
    "@media screen and (max-width: 768px)": {
        paddingLeft: "0.75rem",
        paddingRight: "0.75rem",
        width: "100%"
    },
    "@media screen and (min-width: 769px) and (max-width: 999px)": {
        padding: "0px 16px",
        width: "100%"
    },
    "@media screen and (min-width: 1000px) and (max-width: 1119px)": {
        padding: "0 24px",
        width: "100%"
    },
    "@media screen and (min-width: 1296px)": {
        margin: "0 auto",
        width: "1296px",
        "&.home": {
            width: "1360px"
        }
    }
}));
function useTransactionToast() {
    return _e => {
        Vt.success(jsxRuntimeExports.jsxs("div", {
            className: "text-center",
            children: [jsxRuntimeExports.jsx("div", {
                className: "text-lg",
                children: jsxRuntimeExports.jsx(Trans, {
                    id: "nk+Rnj"
                })
            }), jsxRuntimeExports.jsx(ExplorerLink, {
                path: `tx/${_e}`,
                label: i18n._({
                    id: "dxNth1"
                }),
                className: "btn btn-xs btn-primary"
            })]
        }))
    }
}
const useInitializeMarket = () => {
    const {connection: _e} = useConnection()
      , $ = useWallet()
      , {cluster: et} = useCluster()
      , tt = useTransactionToast()
      , {program: nt, accounts: rt} = useGgMemeProgram()
      , {request: it} = tickerGetInitializeTransaction({
        requestBody: {}
    }, !0)
      , ot = useMutation({
        mutationKey: ["counter", "initializeMarketByApi", {
            cluster: et
        }],
        mutationFn: async lt => {
            const ct = rt.data.feeRecipient
              , dt = multipliedBy(lt.buyAmount, Math.pow(10, DEFAULT_TOKEN_DECIMALS))
              , pt = multipliedBy(lt.maxPay, LAMPORTS_PER_SOL$1)
              , ht = {
                token_name: lt.tokenName,
                token_symbol: lt.tokenSymbol,
                uri: lt.metadataUri,
                pay_amount: pt,
                buy_amount: dt,
                fee_recipient: ct.toBase58(),
                payer: $.publicKey.toBase58(),
                is_exact_in: lt.isExactIn,
                invitation_code: lt.invitationCode
            }
              , mt = await it({
                requestBody: ht
            });
            if (mt)
                if (mt.code === API_Code.Success) {
                    const yt = bs58.decode(mt.data.transaction)
                      , Et = Transaction.from(yt)
                      , _t = await _e.getLatestBlockhash()
                      , wt = await $.sendTransaction(Et, _e);
                    return await _e.confirmTransaction({
                        signature: wt,
                        ..._t
                    }, "confirmed"),
                    wt
                } else
                    throw new Error(mt == null ? void 0 : mt.msg);
            else
                throw new Error("Failed to useInitializeMarket account")
        }
        ,
        onSuccess: lt => (tt(lt),
        rt.refetch()),
        onError: lt => {
            (lt == null ? void 0 : lt.message) === "User rejected the request." && Vt.error(i18n._({
                id: "jbh7F5"
            }))
        }
    });
    return {
        initializeMarket: useMutation({
            mutationKey: ["counter", "initializeMarket", {
                cluster: et
            }],
            mutationFn: async lt => {
                const ct = getProgramAccountPublicKey(Program_Account_Name.ConfigAccount, et.network)
                  , dt = rt.data.feeRecipient
                  , pt = multipliedBy(lt.buyAmount, Math.pow(10, DEFAULT_TOKEN_DECIMALS))
                  , ht = multipliedBy(lt.maxPay, LAMPORTS_PER_SOL$1)
                  , mt = {
                    name: lt.tokenName,
                    symbol: lt.tokenSymbol,
                    uri: lt.metadataUri,
                    buyAmount: new BN(pt)
                }
                  , yt = Keypair.generate()
                  , [Et] = PublicKey.findProgramAddressSync([Buffer$2.from(METADATA_SEED), TOKEN_METADATA_PROGRAM_ID.toBuffer(), yt.publicKey.toBuffer()], TOKEN_METADATA_PROGRAM_ID)
                  , [_t] = PublicKey.findProgramAddressSync([Buffer$2.from("market"), Buffer$2.from(lt.tokenSymbol), ct.toBuffer()], nt.programId)
                  , wt = getAssociatedTokenAddressSync(yt.publicKey, _t, !0)
                  , St = getAssociatedTokenAddressSync(yt.publicKey, $.publicKey, !0)
                  , [Ct] = PublicKey.findProgramAddressSync([Buffer$2.from("market_vault"), Buffer$2.from(mt.symbol), ct.toBuffer()], nt.programId)
                  , [Nt] = PublicKey.findProgramAddressSync([Buffer$2.from("market_community_vault"), Buffer$2.from(mt.symbol), ct.toBuffer()], nt.programId)
                  , Lt = await nt.methods.initializeMarket(mt).accountsPartial({
                    tokenVault: wt,
                    market: _t,
                    config: ct,
                    tokenMetadata: Et,
                    tokenMint: yt.publicKey,
                    feeRecipient: dt,
                    nativeVault: Ct,
                    communityVault: Nt
                }).instruction()
                  , kt = createAssociatedTokenAccountInstruction($.publicKey, St, $.publicKey, yt.publicKey)
                  , Ut = lt.isExactIn ? await nt.methods.buyTokenExactIn({
                    payAmount: new BN(ht),
                    minReceive: new BN(pt),
                    donateRate: 0
                }).accountsPartial({
                    config: ct,
                    market: _t,
                    feeRecipient: dt,
                    tokenVault: wt,
                    tokenRecipient: St,
                    nativeVault: Ct,
                    communityVault: Nt
                }).instruction() : await nt.methods.buyToken({
                    buyAmount: new BN(pt),
                    maxPay: new BN(ht)
                }).accountsPartial({
                    config: ct,
                    market: _t,
                    feeRecipient: dt,
                    tokenVault: wt,
                    tokenRecipient: St,
                    nativeVault: Ct,
                    communityVault: Nt
                }).instruction()
                  , Jt = await _e.getLatestBlockhash()
                  , Pt = new Transaction;
                Pt.add(Lt, kt, Ut),
                Pt.feePayer = $.publicKey,
                Pt.recentBlockhash = Jt.blockhash,
                Pt.sign(yt);
                const Xt = Pt.compileMessage()
                  , rn = new VersionedTransaction(Xt)
                  , zt = await _e.simulateTransaction(rn, {
                    innerInstructions: !0
                });
                let xt = 0;
                zt && zt.value.innerInstructions.forEach(Dt => {
                    Dt.instructions.forEach(jt => {
                        var Ft, Ht, qt, Wt, Mt, Yt;
                        "parsed"in jt && (Ht = (Ft = jt.parsed) == null ? void 0 : Ft.info) != null && Ht.lamports && ((Wt = (qt = jt.parsed) == null ? void 0 : qt.info) == null ? void 0 : Wt.source) === $.publicKey.toBase58() && (xt = xt + ((Yt = (Mt = jt.parsed) == null ? void 0 : Mt.info) == null ? void 0 : Yt.lamports))
                    }
                    )
                }
                );
                const $t = xt / LAMPORTS_PER_SOL$1;
                return {
                    estimatedLamports: xt,
                    estimatedFee: $t
                }
            }
            ,
            onError: () => {
                Vt.error("Failed to useInitializeMarket account")
            }
        }),
        initializeMarketByApi: ot
    }
}
  , solInfo = {
    symbol: "SOL",
    isNative: !0,
    logoURI: solIcon
}
  , BuyDialog = ({data: _e, onClose: $, open: et=!1}) => {
    const {latestDatas: tt, subscribeMarketCreated: nt, unsubscribeMarketCreated: rt, readyState: it} = usePricesContext()
      , {initializeMarketByApi: ot} = useInitializeMarket()
      , {accounts: st} = useGgMemeProgram()
      , [lt,ct,dt] = reactExports.useMemo( () => {
        let un = "999"
          , hn = "0.000028112"
          , _n = "0";
        if (st.data) {
            _n = st.data.createMarketFee.toNumber();
            const kn = st.data.createMarketMinBuyAmount;
            un = (Number(kn) / DEFAULT_TOKEN_DECIMALS_NUMBER).toString();
            const {total: Dn} = compute_swap_with_fee(kn, MAX_TOKEN_SUPPLY, !0);
            hn = (Number(Dn) / LAMPORTS_PER_SOL$1).toString()
        }
        return [un, hn, _n]
    }
    , [st])
      , pt = {
        symbol: _e.tokenSymbol,
        isNative: !1,
        logoURI: _e.imgUri
    }
      , ht = useNavigate()
      , [mt,yt] = reactExports.useState("")
      , [Et,_t] = reactExports.useState("")
      , [wt,St] = reactExports.useState("")
      , [Ct,Nt] = reactExports.useState("")
      , [Lt,kt] = reactExports.useState("")
      , [Ut,Jt] = reactExports.useState(pt)
      , [Pt,Xt] = reactExports.useState(!1)
      , [rn,zt] = reactExports.useState(!1);
    reactExports.useEffect( () => {
        if (it === dist$1.ReadyState.OPEN)
            return nt(),
            () => {
                rt()
            }
    }
    , [it]),
    reactExports.useEffect( () => {
        tt && tt[SubscribeTypes.MARKET_CREATED] && tt[SubscribeTypes.MARKET_CREATED].symbol === _e.tokenSymbol && (ht(`/${_e.tokenSymbol}`),
        $())
    }
    , [tt]);
    const xt = un => {
        if (un === "") {
            _t(""),
            St(""),
            kt("");
            return
        }
        const hn = formatDecimalPlaces(un, Ut.isNative ? DEFAULT_NATIVE_DECIMALS : DEFAULT_TOKEN_DECIMALS);
        if (_t(hn),
        Number(multipliedBy(hn, DEFAULT_TOKEN_DECIMALS_NUMBER)) >= Number(MAX_TOKEN_SUPPLY)) {
            zt(!0);
            return
        } else
            zt(!1);
        if (Ut.isNative) {
            const _n = Number(hn) * LAMPORTS_PER_SOL$1
              , {total: kn, buy_amount: Dn} = compute_buy_token_exact_in_with_fee(_n, MAX_TOKEN_SUPPLY)
              , jn = div(Number(Dn), DEFAULT_TOKEN_DECIMALS_NUMBER)
              , Bn = translation(div(Number(kn), LAMPORTS_PER_SOL$1), DEFAULT_NATIVE_DECIMALS);
            Nt(Bn.toString()),
            St(hn),
            kt(jn.toString())
        } else {
            const _n = Number(hn) * DEFAULT_TOKEN_DECIMALS_NUMBER
              , {y: kn, total: Dn} = compute_swap_with_fee(_n, MAX_TOKEN_SUPPLY, !0)
              , jn = translation(div(Number(Dn), LAMPORTS_PER_SOL$1), DEFAULT_NATIVE_DECIMALS)
              , Bn = translation(div(Number(kn), LAMPORTS_PER_SOL$1), DEFAULT_NATIVE_DECIMALS);
            Nt(jn.toString()),
            St(Bn.toString()),
            kt(hn)
        }
    }
      , $t = () => {
        Ut.isNative ? (_t(Lt),
        Jt(pt)) : (_t(wt),
        Jt(solInfo))
    }
    ;
    reactExports.useEffect( () => {
        xt(Et)
    }
    , [Ut]);
    const [Dt,jt,Ft] = reactExports.useMemo( () => {
        let un = i18n._({
            id: "7VpPHA"
        })
          , hn = !1
          , _n = !0;
        return Et === "" ? [i18n._({
            id: "7VpPHA"
        }), !0, !1] : Et !== "" && !Ut.isNative && Number(Et) < Number(lt) ? [i18n._({
            id: "FPgHom",
            values: {
                0: pt.symbol,
                MIN_TOKEN_AMOUNT: lt
            }
        }), !0, !1] : Et !== "" && Ut.isNative && Number(Et) < Number(ct) ? [i18n._({
            id: "6wKvID",
            values: {
                0: solInfo.symbol,
                MIN_SOL_AMOUNT: ct
            }
        }), !0, !1] : rn ? [i18n._({
            id: "uRvjFC"
        }), !0, !1] : ot.isPending ? [i18n._({
            id: "UbRKMZ"
        }), !0, !0] : Pt ? [i18n._({
            id: "E9bKSA"
        }), !0, !0] : [un, hn, _n]
    }
    , [Et, Ut.symbol, pt.symbol, ot, Pt])
      , [{loading: Ht},qt] = useAxios$1("", {
        manual: !0
    })
      , {data: Wt, request: Mt} = userGenerateUploadUrls({
        requestBody: {
            files_suffix: [".json"]
        }
    }, !0);
    reactExports.useEffect( () => {
        if ((Wt == null ? void 0 : Wt.code) === 200 && Wt.data.upload_files) {
            const [un] = Wt.data.upload_files
              , {form_data: hn} = un
              , _n = new FormData;
            Object.keys(hn || {}).forEach(Bn => {
                hn !== void 0 && _n.append(Bn, hn[Bn])
            }
            );
            const kn = {
                name: _e.tokenName,
                symbol: _e.tokenSymbol,
                description: _e.description,
                image: _e.imgUri,
                external_url: "",
                attributes: [{
                    trait_type: "twitter",
                    value: _e.twitterUrl
                }, {
                    trait_type: "telegram",
                    value: _e.telegramUrl
                }, {
                    trait_type: "website",
                    value: _e.websiteUrl
                }, {
                    trait_type: "banner",
                    value: _e.bannerUrl
                }]
            }
              , Dn = JSON.stringify(kn)
              , jn = new Blob([Dn],{
                type: "application/json"
            });
            _n.append("file", jn),
            Xt(!0),
            qt({
                url: un.upload_url,
                method: "POST",
                data: _n
            }).then( () => {
                const Bn = "https://static.super.exchange/" + un.file_path;
                ot.mutateAsync({
                    metadataUri: Bn,
                    tokenName: _e.tokenName,
                    tokenSymbol: _e.tokenSymbol,
                    description: _e.description,
                    buyAmount: Number(Lt),
                    maxPay: Ut.isNative ? Number(wt) : Number(Ct),
                    isExactIn: Ut.isNative,
                    invitationCode: _e.invitationCode
                }).catch(Un => {
                    Xt(!1)
                }
                )
            }
            ).catch(Bn => {
                Vt.error(Bn.message)
            }
            )
        }
    }
    , [Wt]),
    reactExports.useEffect( () => {
        if (!jt) {
            const un = plus(formatNativeBalance(dt), Ut.isNative ? wt : Ct);
            yt(un)
        }
    }
    , [_e, Lt, wt, Ut, jt]);
    const Yt = () => {
        Mt({
            requestBody: {
                files_suffix: [".json"]
            }
        })
    }
    ;
    return jsxRuntimeExports.jsx(Dialog, {
        title: i18n._({
            id: "qTk7nN"
        }),
        width: 467,
        open: et,
        onClose: $,
        onConfirm: Yt,
        confirmLabel: Dt,
        disabled: jt,
        zIndex: 1400,
        children: jsxRuntimeExports.jsxs(Box, {
            className: "flex flex-col space-y-6",
            children: [jsxRuntimeExports.jsx(Text, {
                children: jsxRuntimeExports.jsx(Trans, {
                    id: "VbTpsk"
                })
            }), jsxRuntimeExports.jsx(Box, {
                children: jsxRuntimeExports.jsx(Button, {
                    color: "secondary",
                    variant: "contained",
                    onClick: $t,
                    children: i18n._({
                        id: "1+P9RR",
                        values: {
                            0: Ut.isNative ? pt.symbol : solInfo.symbol
                        }
                    })
                })
            }), jsxRuntimeExports.jsxs(Box, {
                children: [jsxRuntimeExports.jsx(Box, {
                    className: "form-control w-full",
                    children: jsxRuntimeExports.jsx(FormField, {
                        value: Et,
                        placeholder: "0.0",
                        fullWidth: !0,
                        onChange: un => {
                            (isNumeric(un.target.value.replaceAll(",", "")) || !un.target.value) && xt(un.target.value.replaceAll(",", ""))
                        }
                        ,
                        endAdornment: jsxRuntimeExports.jsxs(MenuItem, {
                            className: "flex items-center space-x-2",
                            children: [jsxRuntimeExports.jsx(Avatar$1, {
                                src: Ut.logoURI,
                                sx: {
                                    width: 20,
                                    height: 20
                                }
                            }), jsxRuntimeExports.jsx("span", {
                                className: "font-bold",
                                children: Ut.symbol
                            })]
                        })
                    })
                }), Ut.isNative && jsxRuntimeExports.jsxs(Box, {
                    className: "flex space-x-3 mt-3",
                    children: [jsxRuntimeExports.jsx(Button, {
                        variant: "contained",
                        size: "small",
                        onClick: () => xt(""),
                        children: jsxRuntimeExports.jsx(Trans, {
                            id: "OfhWJH"
                        })
                    }), jsxRuntimeExports.jsx(Button, {
                        variant: "contained",
                        size: "small",
                        onClick: () => xt("0.1"),
                        children: "0.1 SOL"
                    }), jsxRuntimeExports.jsx(Button, {
                        variant: "contained",
                        size: "small",
                        onClick: () => xt("0.5"),
                        children: "0.5 SOL"
                    }), jsxRuntimeExports.jsx(Button, {
                        variant: "contained",
                        size: "small",
                        onClick: () => xt("1"),
                        children: "1 SOL"
                    })]
                })]
            }), Ft && dt ? Ut.isNative ? jsxRuntimeExports.jsxs(Box, {
                className: "space-y-2",
                children: [jsxRuntimeExports.jsx(Box, {
                    className: "flex itmes-center",
                    children: jsxRuntimeExports.jsxs(Text, {
                        children: [jsxRuntimeExports.jsx(Trans, {
                            id: "P+769u"
                        }), " ", Lt, " ", pt.symbol]
                    })
                }), jsxRuntimeExports.jsxs(Text, {
                    color: "text.secondary",
                    variant: "body2",
                    children: [jsxRuntimeExports.jsx(Trans, {
                        id: "dzzTA7"
                    }), " ", mt, " SOL"]
                }), jsxRuntimeExports.jsxs(Text, {
                    color: "text.secondary",
                    variant: "body2",
                    children: ["(", jsxRuntimeExports.jsx(Trans, {
                        id: "OwztUC"
                    }), " ", formatNativeBalance(dt), " SOL)"]
                })]
            }) : jsxRuntimeExports.jsxs(Box, {
                className: "flex flex-col mt-2",
                children: [jsxRuntimeExports.jsxs(Text, {
                    color: "text.secondary",
                    variant: "body2",
                    children: [jsxRuntimeExports.jsx(Trans, {
                        id: "dzzTA7"
                    }), " ", mt, " SOL"]
                }), jsxRuntimeExports.jsxs(Text, {
                    color: "text.secondary",
                    variant: "body2",
                    children: ["(", jsxRuntimeExports.jsx(Trans, {
                        id: "OwztUC"
                    }), " ", formatNativeBalance(dt), " SOL)"]
                })]
            }) : null]
        })
    })
}
;
function SearchSvg(_e) {
    const {fill: $} = _e;
    return jsxRuntimeExports.jsx("svg", {
        width: "29",
        height: "28",
        viewBox: "0 0 29 28",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        ..._e,
        children: jsxRuntimeExports.jsx("path", {
            d: "M24.9706 24.5L19.8956 19.425M13.3039 7C16.5256 7 19.1372 9.61167 19.1372 12.8333M22.6372 12.8333C22.6372 17.988 18.4586 22.1667 13.3039 22.1667C8.14926 22.1667 3.97058 17.988 3.97058 12.8333C3.97058 7.67868 8.14926 3.5 13.3039 3.5C18.4586 3.5 22.6372 7.67868 22.6372 12.8333Z",
            stroke: "white",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
        })
    })
}
function Header() {
    const {isLogin: _e} = useCheckLogin()
      , {isMatchMobile: $} = useAppBreakpoints()
      , et = useTheme()
      , [tt,nt] = reactExports.useState(!1)
      , [rt,it] = reactExports.useState(!1)
      , [ot,st] = reactExports.useState({
        bannerUrl: "",
        tokenName: "",
        tokenSymbol: "",
        description: "",
        imgUri: "",
        twitterUrl: "",
        telegramUrl: "",
        websiteUrl: "",
        invitationCode: ""
    })
      , lt = () => {
        nt(!1)
    }
      , ct = () => {
        it(!1)
    }
      , dt = _t => {
        st(_t),
        it(!0)
    }
      , pt = _t => {
        _t.meta ? nt(!0) : nt(!1),
        _t.buy ? it(!0) : it(!1)
    }
      , [ht,mt] = reactExports.useState(!1)
      , yt = _t => () => {
        mt(_t)
    }
      , Et = useMediaQuery(et.breakpoints.down(1200));
    return jsxRuntimeExports.jsxs(Box, {
        className: "flex items-center",
        component: "header",
        sx: {
            height: $ ? Dom_Size.HEIGHT_HEADER_MOBILE : Dom_Size.HEIGHT_HEADER,
            borderBottom: `1px solid ${et.palette.divider}`
        },
        children: [jsxRuntimeExports.jsxs(Box, {
            className: "w-full flex items-center justify-between",
            children: [jsxRuntimeExports.jsx(Box, {
                className: "relative flex-1 flex items-center justify-start",
                children: jsxRuntimeExports.jsxs(Box, {
                    className: "flex items-center space-x-3 pl-4 sm:space-x-0",
                    children: [jsxRuntimeExports.jsx(Link, {
                        className: "inline-block min-w-fit",
                        to: "/",
                        children: jsxRuntimeExports.jsx("img", {
                            className: cn($ ? "size-4" : "size-5"),
                            src: Logo,
                            alt: ""
                        })
                    }), !$ && jsxRuntimeExports.jsx(Nav, {})]
                })
            }), jsxRuntimeExports.jsx(Box, {
                className: "relative flex justify-end",
                children: jsxRuntimeExports.jsx(Box, {
                    className: "flex items-center relative px-4",
                    children: jsxRuntimeExports.jsxs("div", {
                        className: "flex space-x-4 sm:space-x-2 items-center",
                        children: [Et ? jsxRuntimeExports.jsx(IconButton, {
                            onClick: yt(!0),
                            children: jsxRuntimeExports.jsx(SearchSvg, {
                                className: "size-6"
                            })
                        }) : jsxRuntimeExports.jsx(Box, {
                            className: "w-[280px]",
                            children: jsxRuntimeExports.jsx(Search, {})
                        }), jsxRuntimeExports.jsx(LanguagePopover, {}), !$ && jsxRuntimeExports.jsx(CreateButton, {
                            handleOpenCreate: pt
                        }), _e ? "" : jsxRuntimeExports.jsx(WalletButton, {}), jsxRuntimeExports.jsx(UserInfoBox, {
                            handleOpenCreate: pt
                        })]
                    })
                })
            })]
        }), tt && jsxRuntimeExports.jsx(CreateDialog, {
            onClose: lt,
            setData: dt,
            open: tt
        }), rt && jsxRuntimeExports.jsx(BuyDialog, {
            data: ot,
            onClose: ct,
            open: rt
        }), jsxRuntimeExports.jsxs(Drawer, {
            open: ht,
            onClose: yt(!1),
            sx: {
                "& >.MuiPaper-root": {
                    width: $ ? "100%" : "80%",
                    padding: "16px"
                }
            },
            children: [jsxRuntimeExports.jsxs("div", {
                className: "flex items-center justify-between",
                children: [jsxRuntimeExports.jsx(Typography, {
                    variant: "h6",
                    fontWeight: 700,
                    children: jsxRuntimeExports.jsx(Trans, {
                        id: "A1taO8"
                    })
                }), jsxRuntimeExports.jsx(IconButton, {
                    className: "-mr-2",
                    onClick: yt(!1),
                    children: jsxRuntimeExports.jsx(CloseIcon, {
                        size: 60
                    })
                })]
            }), jsxRuntimeExports.jsx(Search, {
                onSelect: yt(!1)
            })]
        })]
    })
}
const Icon = _e => {
    const {stroke: $="#A4A7AE", size: et=14} = _e;
    return jsxRuntimeExports.jsx("svg", {
        width: "18",
        height: "19",
        viewBox: "0 0 18 19",
        fill: "none",
        xmlns: "http://www.w3.org/2000/svg",
        children: jsxRuntimeExports.jsx("path", {
            d: "M7.58666 10.4094C8.45318 10.9095 8.88642 11.1596 9.36226 11.16C9.83807 11.1604 10.2718 10.9111 11.1392 10.4125L16.6684 7.23419C16.9179 7.09072 17.0718 6.82476 17.0718 6.53685C17.0718 6.24893 16.9179 5.98297 16.6684 5.8395L11.1372 2.66001C10.2707 2.16193 9.83746 1.9129 9.36212 1.91309C8.88676 1.91327 8.45373 2.16264 7.58765 2.66139L2.83269 5.39961C2.79744 5.4199 2.77983 5.43007 2.7634 5.43968C1.13914 6.39052 0.135624 8.12644 0.122206 10.0085C0.12207 10.0275 0.12207 10.0478 0.12207 10.0885C0.12207 10.1291 0.12207 10.1494 0.122206 10.1684C0.135594 12.0484 1.13687 13.7827 2.75824 14.7343C2.77462 14.7439 2.79223 14.754 2.8274 14.7744L5.8059 16.4941C7.54146 17.4961 8.40923 17.9971 9.36221 17.9975C10.3152 17.9978 11.1833 17.4974 12.9195 16.4964L16.0637 14.6839C16.9331 14.1827 17.3678 13.9322 17.6065 13.519C17.8451 13.1059 17.8451 12.6042 17.8451 11.6007V9.66217C17.8451 9.38381 17.6944 9.12727 17.4512 8.9918C17.2158 8.86073 16.929 8.86267 16.6954 8.99692L10.2482 12.703C9.81561 12.9516 9.59931 13.076 9.36198 13.0761C9.12463 13.0761 8.90827 12.9519 8.47555 12.7035L4.11191 10.1987C3.89333 10.0732 3.78403 10.0105 3.69625 9.99916C3.49612 9.97332 3.30368 10.0854 3.22744 10.2723C3.19402 10.3542 3.19468 10.4803 3.19604 10.7323C3.19704 10.9178 3.19754 11.0106 3.21487 11.0959C3.25372 11.287 3.35425 11.4601 3.50104 11.5884C3.56659 11.6458 3.64693 11.6922 3.80765 11.7849L8.47309 14.4776C8.90694 14.728 9.12386 14.8532 9.36204 14.8533C9.60025 14.8533 9.81724 14.7283 10.2512 14.4781L15.9697 11.1818C16.1179 11.0963 16.192 11.0536 16.2476 11.0857C16.3032 11.1178 16.3032 11.2034 16.3032 11.3745V12.2537C16.3032 12.5046 16.3032 12.63 16.2435 12.7333C16.1838 12.8366 16.0752 12.8992 15.8578 13.0245L11.1412 15.7434C10.2729 16.2439 9.83871 16.4942 9.36215 16.4939C8.88556 16.4937 8.45163 16.2431 7.58378 15.7417L3.17098 13.1927C3.15697 13.1846 3.14996 13.1805 3.14343 13.1767C2.21818 12.636 1.64726 11.6469 1.64191 10.5753C1.64187 10.5677 1.64187 10.5596 1.64187 10.5434V9.7363C1.64187 9.14471 1.95695 8.5979 2.46877 8.30123C2.92103 8.0391 3.47889 8.03857 3.93163 8.29988L7.58666 10.4094Z",
            fill: "#9CA3AF"
        })
    })
}
;
function Footer() {
    return jsxRuntimeExports.jsxs("footer", {
        className: "footer flex items-center justify-start px-4",
        children: [jsxRuntimeExports.jsx(StyledIcon, {
            href: "https://docs.super.exchange/",
            target: "_blank",
            rel: "noopener noreferrer",
            className: "mr-2 w-[24px] text-center",
            children: jsxRuntimeExports.jsx(Icon, {
                size: 18
            })
        }), jsxRuntimeExports.jsx("a", {
            href: "https://x.com/_superexchange",
            target: "_blank",
            rel: "noopener noreferrer",
            className: "mr-2 w-[24px] text-center",
            children: jsxRuntimeExports.jsx(XIcon, {
                sx: {
                    fontSize: 18
                }
            })
        }), jsxRuntimeExports.jsx(Typography, {
            href: "https://t.me/SuperExchangeCommunity",
            target: "_blank",
            rel: "noopener noreferrer",
            component: "a",
            children: jsxRuntimeExports.jsx(TelegramIcon, {})
        })]
    })
}
const StyledIcon = styled("a")`
&:hover{
  svg path{
    fill: ${ ({theme: _e}) => _e.palette.primary.main};
  }
}
`
  , RootContainer = styled("div")`
  width: 100vw;
  min-height: 100vh;
  box-sizing: border-box;
  overflow: hidden;
`
  , PageContainer = styled("div")( ({theme: _e}) => ({
    margin: "0 auto",
    width: "888px",
    border: `1px solid ${_e.palette.divider}`,
    borderTop: "none",
    "@media screen and (max-width: 768px)": {
        width: "100%"
    },
    "@media screen and (min-width: 769px) and (max-width: 999px)": {
        padding: "0px 16px",
        width: "100%"
    },
    "@media screen and (min-width: 1000px) and (max-width: 1119px)": {
        padding: "0 16px",
        width: "100%"
    }
}))
  , MainContainer = styled("main")( () => ({
    width: "100%",
    "@media screen and (max-width: 768px)": {
        width: "100%"
    },
    "@media screen and (min-width: 769px) and (max-width: 999px)": {
        padding: "0px 16px",
        width: "100%"
    },
    "@media screen and (min-width: 1000px) and (max-width: 1119px)": {
        padding: "0 16px",
        width: "100%"
    }
}))
  , useQuery = () => new URLSearchParams(useLocation().search);
function BaseLayout({children: _e}) {
    const {isMatchMobile: $} = useAppBreakpoints()
      , tt = useQuery().get("ref");
    return reactExports.useEffect( () => {
        tt && store$2.set("INVITE_BY", tt)
    }
    , [tt]),
    jsxRuntimeExports.jsxs(RootContainer, {
        children: [jsxRuntimeExports.jsx(Header, {}), $ && jsxRuntimeExports.jsx(Nav, {}), jsxRuntimeExports.jsxs(MainContainer, {
            sx: {
                minHeight: "calc(100vh - 180px)"
            },
            children: [jsxRuntimeExports.jsx(reactExports.Suspense, {
                fallback: jsxRuntimeExports.jsx("div", {
                    className: "text-center my-32",
                    children: jsxRuntimeExports.jsx("span", {
                        className: "loading loading-spinner loading-lg"
                    })
                }),
                children: _e
            }), jsxRuntimeExports.jsx(Oe, {
                position: "bottom-right"
            })]
        }), !$ && jsxRuntimeExports.jsx(Footer, {})]
    })
}
const Home = reactExports.lazy( () => __vitePreload( () => import("./index-BC86n3gC.js"), __vite__mapDeps([5, 6, 7, 8, 9, 10, 11])))
  , Trade = reactExports.lazy( () => __vitePreload( () => import("./index-Se2PPd5m.js.js"), __vite__mapDeps([12, 13, 9, 8, 11, 10, 4])))
  , Points = reactExports.lazy( () => __vitePreload( () => import("./index-BjdiwIS9.js"), __vite__mapDeps([14, 8, 11, 7, 15])))
  , Portfolio = reactExports.lazy( () => __vitePreload( () => import("./index-D6iOzXLi.js"), __vite__mapDeps([16, 6, 7, 8, 9, 13])))
  , routes = [{
    path: "/:ticker/:tab?",
    element: jsxRuntimeExports.jsx(TradeContextProvider, {
        children: jsxRuntimeExports.jsx(AccountSubscribeContextProvider, {
            children: jsxRuntimeExports.jsx(Trade, {})
        })
    }),
    caseSensitive: !0
}, {
    path: "/points",
    element: jsxRuntimeExports.jsx(Points, {}),
    caseSensitive: !0
}, {
    path: "/portfolio",
    element: jsxRuntimeExports.jsx(Portfolio, {}),
    caseSensitive: !0
}];
function AppRoutes() {
    const _e = useRoutes([{
        path: "/",
        element: jsxRuntimeExports.jsx(Home, {})
    }, ...routes, {
        path: "*",
        element: jsxRuntimeExports.jsx(Navigate, {
            to: "/",
            replace: !0
        })
    }]);
    return jsxRuntimeExports.jsx(BaseLayout, {
        children: _e
    })
}
const themeConfig = {
    dark: {
        bgColor: "#090909",
        bgColorL1: "#414141",
        bgColorL2: "#1D2024",
        bgDisabled: "#3A3A3A",
        textColor: "#FFFFFF",
        textColorL1: "#9CA3AF",
        textColorL2: alpha("#FFFFFF", .6),
        textColorL3: "#A4A7AE",
        cardBg: "#1a1a1b",
        paperBg: "#060606",
        dividerColorL1: alpha("#FFFFFF", .1),
        dividerColor: alpha("#47474F", .8),
        primaryColor: "#98FF78",
        infoColor: "#9CA3AF",
        successColor: "#17B26A",
        errorColor: "#FF494C",
        hoverColor: "#212225",
        borderColor: "#47474F",
        borderColorL1: alpha("#FFFFFF", .3),
        inputBg: "#1d1d1e",
        inputBgL1: "#414141",
        pink: "#ed8bdb"
    },
    light: {
        bgColor: "#f3f4f6",
        bgColorL1: "#EEEEEE",
        bgColorL2: "#F9F9F9",
        bgDisabled: "#3A3A3A",
        textColor: "#1F2937",
        textColorL1: "#4B5563",
        textColorL2: "#6B7280",
        textColorL3: "#999999",
        cardBg: "#fff",
        paperBg: "#fff",
        dividerColorL1: "#Ebebeb",
        dividerColor: alpha("#000000", .1),
        primaryColor: "#98FF78",
        successColor: "#17B26A",
        errorColor: "#FF494C",
        hoverColor: alpha("#000000", .03),
        infoColor: "#9CA3AF",
        borderColor: "#DCDFEA",
        borderColorL1: "#B0CFF7",
        inputBg: "#FFF",
        inputBgL1: "#EBF3FD",
        pink: "#ed8bdb"
    }
}
  , createThemeOptions = _e => {
    const {bgColor: $, bgColorL1: et, bgColorL2: tt, bgDisabled: nt, textColor: rt, textColorL1: it, textColorL2: ot, textColorL3: st, cardBg: lt, paperBg: ct, dividerColor: dt, dividerColorL1: pt, primaryColor: ht, infoColor: mt, successColor: yt, errorColor: Et, hoverColor: _t, borderColor: wt, borderColorL1: St, inputBg: Ct, inputBgL1: Nt, pink: Lt} = themeConfig[_e];
    return {
        mode: _e,
        custom: {
            cardBg: lt,
            paperBg: ct,
            dividerColor: dt,
            dividerColorL1: pt,
            textColor: rt,
            textColorL1: it,
            textColorL2: ot,
            textColorL3: st,
            borderColor: wt,
            borderColorL1: St,
            inputBg: Ct,
            inputBgL1: Nt,
            pink: Lt
        },
        breakpoints: {
            values: {
                xs: 0,
                sm: 640,
                md: 768,
                lg: 1024.05,
                xl: 1200
            }
        },
        palette: {
            mode: _e,
            primary: {
                main: ht,
                dark: darken(ht, .2),
                contrastText: "#000"
            },
            secondary: {
                main: wt,
                contrastText: _e === "dark" ? "#FFF" : "#000"
            },
            background: {
                default: $,
                paper: _e === "dark" ? ct : tt
            },
            text: {
                primary: rt,
                secondary: it,
                disabled: ot
            },
            grey: {
                200: ot,
                300: st,
                500: $
            },
            divider: dt,
            error: {
                main: Et,
                contrastText: "#FFF"
            },
            info: {
                main: mt
            },
            warning: {
                main: "#FF7F00",
                contrastText: "#FFF"
            },
            success: {
                main: yt,
                contrastText: "#FFF"
            },
            action: {
                disabled: ot,
                disabledBackground: nt,
                hover: _t
            }
        },
        typography: {
            fontFamily: '"Chivo Mono", "Arial", "Roboto", "Segoe UI", "Noto Sans", Helvetica, "Apple Color Emoji", "Segoe UI Emoji"',
            fontWeightLight: 300,
            fontWeightRegular: 400,
            fontWeightMedium: 500,
            fontWeightBold: 700,
            h1: {
                fontSize: "32px"
            },
            h2: {
                fontSize: "28px"
            },
            h3: {
                fontSize: "24px"
            },
            h4: {
                fontSize: "20px"
            },
            h5: {
                fontSize: "18px"
            },
            h6: {
                fontSize: "16px"
            },
            body1: {
                fontSize: "0.875rem",
                fontWeight: 500
            },
            body2: {
                fontSize: "0.75rem",
                fontWeight: 500
            }
        },
        components: {
            MuiTypography: {
                defaultProps: {
                    variantMapping: {
                        body1: "div",
                        body2: "div"
                    }
                }
            },
            MuiSnackbar: {
                styleOverrides: {
                    root: {
                        boxShadow: "0px 0px 20px 0px rgba(152, 255, 120, 0.60)",
                        backgroundImage: "none",
                        background: ct,
                        borderRadius: "1rem",
                        ".MuiPaper-root": {
                            background: ct,
                            color: rt,
                            maxWidth: 450,
                            padding: 2
                        }
                    }
                }
            },
            MuiPaper: {
                styleOverrides: {
                    root: {
                        boxShadow: "0px 0px 20px 0px rgba(152, 255, 120, 0.60)",
                        backgroundImage: "none"
                    },
                    outlined: {
                        borderWidth: _e === "dark" ? 0 : 1
                    }
                }
            },
            MuiInputBase: {
                styleOverrides: {
                    root: {
                        "& .MuiInputBase-input": {
                            borderRadius: 0
                        }
                    }
                }
            },
            MuiButtonBase: {
                defaultProps: {
                    disableRipple: !0
                }
            },
            MuiButton: {
                styleOverrides: {
                    root: {
                        textTransform: "none",
                        boxShadow: "none",
                        whiteSpace: "nowrap",
                        borderRadius: "0px",
                        "&:hover": {},
                        "& .MuiButton-icon": {
                            lineHeight: 1
                        }
                    },
                    contained: {
                        "&.MuiButton-colorPrimary": {},
                        "&.Mui-disabled": {
                            color: st,
                            boxShadow: "none",
                            background: "#494E54"
                        }
                    },
                    outlined: {
                        "&.MuiButton-colorPrimary": {
                            borderColor: ht,
                            "&:hover": {
                                borderColor: alpha(ht, .8),
                                boxShadow: "0px 2px 9.4px 0px rgba(152, 255, 120, 0.58)"
                            }
                        },
                        "&.MuiButton-colorSecondary": {
                            color: rt,
                            borderColor: wt,
                            "&:hover": {
                                borderColor: ht,
                                boxShadow: "0px 2px 9.4px 0px rgba(152, 255, 120, 0.58)"
                            }
                        }
                    },
                    sizeLarge: {},
                    sizeMedium: {},
                    sizeSmall: {}
                }
            },
            MuiOutlinedInput: {
                styleOverrides: {
                    notchedOutline: {
                        border: `1px solid ${wt}`,
                        paddingLeft: "20px"
                    },
                    root: {
                        borderRadius: "0px",
                        background: Ct,
                        [`&:hover .${outlinedInputClasses.notchedOutline}`]: {
                            border: `2px solid ${wt}`
                        },
                        [`&.Mui-focused .${outlinedInputClasses.notchedOutline}`]: {
                            border: `2px solid ${St}`
                        }
                    },
                    input: {
                        borderRadius: "0px"
                    }
                }
            },
            MuiSkeleton: {
                styleOverrides: {
                    root: {
                        height: "32px"
                    }
                }
            },
            MuiAccordion: {
                styleOverrides: {
                    root: {
                        margin: "0px",
                        "&.Mui-expanded": {
                            margin: "0px"
                        }
                    }
                }
            },
            MuiAccordionDetails: {
                styleOverrides: {
                    root: {
                        margin: "0px",
                        wordBreak: "break-all"
                    }
                }
            },
            MuiAccordionSummary: {
                styleOverrides: {
                    root: {
                        minHeight: "32px !important"
                    },
                    content: {
                        margin: 0,
                        "&.Mui-expanded": {
                            margin: "0px"
                        }
                    }
                }
            },
            MuiTooltip: {
                styleOverrides: {
                    tooltip: {
                        maxWidth: 320,
                        backgroundColor: tt,
                        fontSize: "14px",
                        padding: "20px 24px",
                        borderRadius: "0px",
                        boxShadow: "0px 0px 16px 0px rgba(152, 255, 120, 0.50)",
                        filter: "drop-shadow(0px 4px 6px rgba(0, 0, 0, 0.14))",
                        overflowWrap: "break-word",
                        "@media screen and (max-width: 768px)": {
                            maxWidth: 320
                        }
                    },
                    tooltipArrow: {
                        background: $,
                        color: rt
                    },
                    arrow: {
                        color: $
                    }
                }
            },
            MuiSelect: {
                styleOverrides: {
                    root: {
                        borderImageWidth: 0
                    },
                    select: {
                        height: "32px",
                        lineHeight: "32px",
                        padding: "0 12px"
                    },
                    nativeInput: {
                        borderImageWidth: 0,
                        border: 0
                    }
                }
            },
            MuiChip: {
                styleOverrides: {
                    root: {
                        borderRadius: "0px",
                        borderColor: wt
                    },
                    colorDefault: {
                        background: ct
                    },
                    icon: {
                        marginLeft: "10px"
                    },
                    label: {
                        padding: "12px"
                    }
                }
            },
            MuiCard: {
                styleOverrides: {
                    root: {
                        background: _e === "dark" ? tt : ct,
                        borderRadius: "0px"
                    }
                }
            },
            MuiCardContent: {
                styleOverrides: {
                    root: {
                        padding: "20px",
                        "&:last-child": {
                            paddingBottom: "20px"
                        }
                    }
                }
            },
            MuiDialog: {
                styleOverrides: {
                    root: {
                        "& .MuiCard-root": {
                            backgroundColor: ct
                        },
                        "& .MuiTableContainer-root": {
                            width: "calc(100%)",
                            transform: "translate(0, 0)"
                        }
                    },
                    paper: {
                        boxShadow: "0px 0px 20px 0px rgba(152, 255, 120, 0.60)",
                        background: ct,
                        borderRadius: "0px",
                        margin: 0,
                        minWidth: 360,
                        "@media screen and (max-width: 767px)": {
                            minWidth: "auto"
                        }
                    },
                    paperWidthSm: {
                        width: 420,
                        maxWidth: 750,
                        "@media screen and (max-width: 767px)": {
                            position: "absolute",
                            width: "100%",
                            bottom: 0,
                            maxHeight: "85%",
                            height: "auto",
                            overflowY: "auto"
                        }
                    },
                    paperWidthMd: {
                        width: 550,
                        maxWidth: 750
                    }
                }
            },
            MuiDialogTitle: {
                styleOverrides: {
                    root: {
                        padding: "16px",
                        background: "transparent !important",
                        "@media screen and (max-width: 640px)": {
                            padding: "16px 24px 24px"
                        },
                        "& .MuiButtonBase-root": {}
                    }
                }
            },
            MuiDialogContent: {
                styleOverrides: {
                    root: {
                        padding: "32px",
                        "@media screen and (max-width: 640px)": {
                            padding: "16px 24px 24px"
                        }
                    }
                }
            },
            MuiDialogActions: {
                styleOverrides: {
                    root: {
                        padding: "32px",
                        "@media screen and (max-width: 640px)": {
                            padding: "12px 24px 16px"
                        }
                    }
                }
            },
            MuiPopover: {
                styleOverrides: {
                    root: {
                        border: `1px solid ${dt}`
                    },
                    paper: {
                        background: ct,
                        borderRadius: 0,
                        border: `1px solid ${dt}`
                    }
                }
            },
            MuiTabs: {
                styleOverrides: {
                    root: {
                        textTransform: "capitalize"
                    },
                    indicator: {
                        height: "3px"
                    }
                }
            },
            MuiTab: {
                styleOverrides: {
                    root: {
                        textTransform: "capitalize",
                        minHeight: "auto",
                        minWidth: "auto",
                        "&.Mui-selected": {
                            color: rt,
                            fontWeight: 700
                        }
                    }
                }
            },
            MuiToggleButtonGroup: {
                styleOverrides: {
                    root: {
                        borderRadius: 8
                    },
                    grouped: {
                        color: it,
                        margin: "2px",
                        padding: "2px 8px",
                        border: 0,
                        textTransform: "none",
                        backgroundColor: "transparent",
                        "&.Mui-selected": {
                            color: rt,
                            backgroundColor: ct,
                            border: `1px solid ${dt}`,
                            "&:hover": {
                                backgroundColor: ct
                            }
                        },
                        "&.Mui-disabled": {
                            border: 0
                        },
                        "&:not(:first-of-type)": {
                            borderRadius: "8px"
                        },
                        "&:first-of-type": {
                            borderRadius: 8,
                            marginRight: 0
                        }
                    }
                }
            }
        }
    }
}
  , getTheme = _e => createTheme(createThemeOptions(_e));
function changeThemeForHtml(_e) {
    var $;
    ($ = document.querySelector("html")) == null || $.setAttribute("theme", _e)
}
const useApplicationStore = create$1(_e => ({
    isVisibleMediaViewer: !1,
    setIsVisibleMediaViewer: $ => _e({
        isVisibleMediaViewer: $
    })
}));
function isObject$2(_e) {
    return _e !== null && typeof _e == "object" && "constructor"in _e && _e.constructor === Object
}
function extend$2(_e, $) {
    _e === void 0 && (_e = {}),
    $ === void 0 && ($ = {});
    const et = ["__proto__", "constructor", "prototype"];
    Object.keys($).filter(tt => et.indexOf(tt) < 0).forEach(tt => {
        typeof _e[tt] > "u" ? _e[tt] = $[tt] : isObject$2($[tt]) && isObject$2(_e[tt]) && Object.keys($[tt]).length > 0 && extend$2(_e[tt], $[tt])
    }
    )
}
const ssrDocument = {
    body: {},
    addEventListener() {},
    removeEventListener() {},
    activeElement: {
        blur() {},
        nodeName: ""
    },
    querySelector() {
        return null
    },
    querySelectorAll() {
        return []
    },
    getElementById() {
        return null
    },
    createEvent() {
        return {
            initEvent() {}
        }
    },
    createElement() {
        return {
            children: [],
            childNodes: [],
            style: {},
            setAttribute() {},
            getElementsByTagName() {
                return []
            }
        }
    },
    createElementNS() {
        return {}
    },
    importNode() {
        return null
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    }
};
function getDocument() {
    const _e = typeof document < "u" ? document : {};
    return extend$2(_e, ssrDocument),
    _e
}
const ssrWindow = {
    document: ssrDocument,
    navigator: {
        userAgent: ""
    },
    location: {
        hash: "",
        host: "",
        hostname: "",
        href: "",
        origin: "",
        pathname: "",
        protocol: "",
        search: ""
    },
    history: {
        replaceState() {},
        pushState() {},
        go() {},
        back() {}
    },
    CustomEvent: function() {
        return this
    },
    addEventListener() {},
    removeEventListener() {},
    getComputedStyle() {
        return {
            getPropertyValue() {
                return ""
            }
        }
    },
    Image() {},
    Date() {},
    screen: {},
    setTimeout() {},
    clearTimeout() {},
    matchMedia() {
        return {}
    },
    requestAnimationFrame(_e) {
        return typeof setTimeout > "u" ? (_e(),
        null) : setTimeout(_e, 0)
    },
    cancelAnimationFrame(_e) {
        typeof setTimeout > "u" || clearTimeout(_e)
    }
};
function getWindow() {
    const _e = typeof window < "u" ? window : {};
    return extend$2(_e, ssrWindow),
    _e
}
function classesToTokens(_e) {
    return _e === void 0 && (_e = ""),
    _e.trim().split(" ").filter($ => !!$.trim())
}
function deleteProps(_e) {
    const $ = _e;
    Object.keys($).forEach(et => {
        try {
            $[et] = null
        } catch {}
        try {
            delete $[et]
        } catch {}
    }
    )
}
function nextTick(_e, $) {
    return $ === void 0 && ($ = 0),
    setTimeout(_e, $)
}
function now() {
    return Date.now()
}
function getComputedStyle$1(_e) {
    const $ = getWindow();
    let et;
    return $.getComputedStyle && (et = $.getComputedStyle(_e, null)),
    !et && _e.currentStyle && (et = _e.currentStyle),
    et || (et = _e.style),
    et
}
function getTranslate(_e, $) {
    $ === void 0 && ($ = "x");
    const et = getWindow();
    let tt, nt, rt;
    const it = getComputedStyle$1(_e);
    return et.WebKitCSSMatrix ? (nt = it.transform || it.webkitTransform,
    nt.split(",").length > 6 && (nt = nt.split(", ").map(ot => ot.replace(",", ".")).join(", ")),
    rt = new et.WebKitCSSMatrix(nt === "none" ? "" : nt)) : (rt = it.MozTransform || it.OTransform || it.MsTransform || it.msTransform || it.transform || it.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"),
    tt = rt.toString().split(",")),
    $ === "x" && (et.WebKitCSSMatrix ? nt = rt.m41 : tt.length === 16 ? nt = parseFloat(tt[12]) : nt = parseFloat(tt[4])),
    $ === "y" && (et.WebKitCSSMatrix ? nt = rt.m42 : tt.length === 16 ? nt = parseFloat(tt[13]) : nt = parseFloat(tt[5])),
    nt || 0
}
function isObject$1(_e) {
    return typeof _e == "object" && _e !== null && _e.constructor && Object.prototype.toString.call(_e).slice(8, -1) === "Object"
}
function isNode(_e) {
    return typeof window < "u" && typeof window.HTMLElement < "u" ? _e instanceof HTMLElement : _e && (_e.nodeType === 1 || _e.nodeType === 11)
}
function extend$1() {
    const _e = Object(arguments.length <= 0 ? void 0 : arguments[0])
      , $ = ["__proto__", "constructor", "prototype"];
    for (let et = 1; et < arguments.length; et += 1) {
        const tt = et < 0 || arguments.length <= et ? void 0 : arguments[et];
        if (tt != null && !isNode(tt)) {
            const nt = Object.keys(Object(tt)).filter(rt => $.indexOf(rt) < 0);
            for (let rt = 0, it = nt.length; rt < it; rt += 1) {
                const ot = nt[rt]
                  , st = Object.getOwnPropertyDescriptor(tt, ot);
                st !== void 0 && st.enumerable && (isObject$1(_e[ot]) && isObject$1(tt[ot]) ? tt[ot].__swiper__ ? _e[ot] = tt[ot] : extend$1(_e[ot], tt[ot]) : !isObject$1(_e[ot]) && isObject$1(tt[ot]) ? (_e[ot] = {},
                tt[ot].__swiper__ ? _e[ot] = tt[ot] : extend$1(_e[ot], tt[ot])) : _e[ot] = tt[ot])
            }
        }
    }
    return _e
}
function setCSSProperty(_e, $, et) {
    _e.style.setProperty($, et)
}
function animateCSSModeScroll(_e) {
    let {swiper: $, targetPosition: et, side: tt} = _e;
    const nt = getWindow()
      , rt = -$.translate;
    let it = null, ot;
    const st = $.params.speed;
    $.wrapperEl.style.scrollSnapType = "none",
    nt.cancelAnimationFrame($.cssModeFrameID);
    const lt = et > rt ? "next" : "prev"
      , ct = (pt, ht) => lt === "next" && pt >= ht || lt === "prev" && pt <= ht
      , dt = () => {
        ot = new Date().getTime(),
        it === null && (it = ot);
        const pt = Math.max(Math.min((ot - it) / st, 1), 0)
          , ht = .5 - Math.cos(pt * Math.PI) / 2;
        let mt = rt + ht * (et - rt);
        if (ct(mt, et) && (mt = et),
        $.wrapperEl.scrollTo({
            [tt]: mt
        }),
        ct(mt, et)) {
            $.wrapperEl.style.overflow = "hidden",
            $.wrapperEl.style.scrollSnapType = "",
            setTimeout( () => {
                $.wrapperEl.style.overflow = "",
                $.wrapperEl.scrollTo({
                    [tt]: mt
                })
            }
            ),
            nt.cancelAnimationFrame($.cssModeFrameID);
            return
        }
        $.cssModeFrameID = nt.requestAnimationFrame(dt)
    }
    ;
    dt()
}
function elementChildren(_e, $) {
    $ === void 0 && ($ = "");
    const et = getWindow()
      , tt = [..._e.children];
    return et.HTMLSlotElement && _e instanceof HTMLSlotElement && tt.push(..._e.assignedElements()),
    $ ? tt.filter(nt => nt.matches($)) : tt
}
function elementIsChildOfSlot(_e, $) {
    const et = [$];
    for (; et.length > 0; ) {
        const tt = et.shift();
        if (_e === tt)
            return !0;
        et.push(...tt.children, ...tt.shadowRoot ? tt.shadowRoot.children : [], ...tt.assignedElements ? tt.assignedElements() : [])
    }
}
function elementIsChildOf(_e, $) {
    const et = getWindow();
    let tt = $.contains(_e);
    return !tt && et.HTMLSlotElement && $ instanceof HTMLSlotElement && (tt = [...$.assignedElements()].includes(_e),
    tt || (tt = elementIsChildOfSlot(_e, $))),
    tt
}
function showWarning(_e) {
    try {
        return
    } catch {}
}
function createElement(_e, $) {
    $ === void 0 && ($ = []);
    const et = document.createElement(_e);
    return et.classList.add(...Array.isArray($) ? $ : classesToTokens($)),
    et
}
function elementPrevAll(_e, $) {
    const et = [];
    for (; _e.previousElementSibling; ) {
        const tt = _e.previousElementSibling;
        $ ? tt.matches($) && et.push(tt) : et.push(tt),
        _e = tt
    }
    return et
}
function elementNextAll(_e, $) {
    const et = [];
    for (; _e.nextElementSibling; ) {
        const tt = _e.nextElementSibling;
        $ ? tt.matches($) && et.push(tt) : et.push(tt),
        _e = tt
    }
    return et
}
function elementStyle(_e, $) {
    return getWindow().getComputedStyle(_e, null).getPropertyValue($)
}
function elementIndex(_e) {
    let $ = _e, et;
    if ($) {
        for (et = 0; ($ = $.previousSibling) !== null; )
            $.nodeType === 1 && (et += 1);
        return et
    }
}
function elementParents(_e, $) {
    const et = [];
    let tt = _e.parentElement;
    for (; tt; )
        et.push(tt),
        tt = tt.parentElement;
    return et
}
function elementOuterSize(_e, $, et) {
    const tt = getWindow();
    return _e[$ === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(tt.getComputedStyle(_e, null).getPropertyValue($ === "width" ? "margin-right" : "margin-top")) + parseFloat(tt.getComputedStyle(_e, null).getPropertyValue($ === "width" ? "margin-left" : "margin-bottom"))
}
function makeElementsArray(_e) {
    return (Array.isArray(_e) ? _e : [_e]).filter($ => !!$)
}
function createElementIfNotDefined(_e, $, et, tt) {
    return _e.params.createElements && Object.keys(tt).forEach(nt => {
        if (!et[nt] && et.auto === !0) {
            let rt = elementChildren(_e.el, `.${tt[nt]}`)[0];
            rt || (rt = createElement("div", tt[nt]),
            rt.className = tt[nt],
            _e.el.append(rt)),
            et[nt] = rt,
            $[nt] = rt
        }
    }
    ),
    et
}
function Navigation(_e) {
    let {swiper: $, extendParams: et, on: tt, emit: nt} = _e;
    et({
        navigation: {
            nextEl: null,
            prevEl: null,
            hideOnClick: !1,
            disabledClass: "swiper-button-disabled",
            hiddenClass: "swiper-button-hidden",
            lockClass: "swiper-button-lock",
            navigationDisabledClass: "swiper-navigation-disabled"
        }
    }),
    $.navigation = {
        nextEl: null,
        prevEl: null
    };
    function rt(mt) {
        let yt;
        return mt && typeof mt == "string" && $.isElement && (yt = $.el.querySelector(mt) || $.hostEl.querySelector(mt),
        yt) ? yt : (mt && (typeof mt == "string" && (yt = [...document.querySelectorAll(mt)]),
        $.params.uniqueNavElements && typeof mt == "string" && yt && yt.length > 1 && $.el.querySelectorAll(mt).length === 1 ? yt = $.el.querySelector(mt) : yt && yt.length === 1 && (yt = yt[0])),
        mt && !yt ? mt : yt)
    }
    function it(mt, yt) {
        const Et = $.params.navigation;
        mt = makeElementsArray(mt),
        mt.forEach(_t => {
            _t && (_t.classList[yt ? "add" : "remove"](...Et.disabledClass.split(" ")),
            _t.tagName === "BUTTON" && (_t.disabled = yt),
            $.params.watchOverflow && $.enabled && _t.classList[$.isLocked ? "add" : "remove"](Et.lockClass))
        }
        )
    }
    function ot() {
        const {nextEl: mt, prevEl: yt} = $.navigation;
        if ($.params.loop) {
            it(yt, !1),
            it(mt, !1);
            return
        }
        it(yt, $.isBeginning && !$.params.rewind),
        it(mt, $.isEnd && !$.params.rewind)
    }
    function st(mt) {
        mt.preventDefault(),
        !($.isBeginning && !$.params.loop && !$.params.rewind) && ($.slidePrev(),
        nt("navigationPrev"))
    }
    function lt(mt) {
        mt.preventDefault(),
        !($.isEnd && !$.params.loop && !$.params.rewind) && ($.slideNext(),
        nt("navigationNext"))
    }
    function ct() {
        const mt = $.params.navigation;
        if ($.params.navigation = createElementIfNotDefined($, $.originalParams.navigation, $.params.navigation, {
            nextEl: "swiper-button-next",
            prevEl: "swiper-button-prev"
        }),
        !(mt.nextEl || mt.prevEl))
            return;
        let yt = rt(mt.nextEl)
          , Et = rt(mt.prevEl);
        Object.assign($.navigation, {
            nextEl: yt,
            prevEl: Et
        }),
        yt = makeElementsArray(yt),
        Et = makeElementsArray(Et);
        const _t = (wt, St) => {
            wt && wt.addEventListener("click", St === "next" ? lt : st),
            !$.enabled && wt && wt.classList.add(...mt.lockClass.split(" "))
        }
        ;
        yt.forEach(wt => _t(wt, "next")),
        Et.forEach(wt => _t(wt, "prev"))
    }
    function dt() {
        let {nextEl: mt, prevEl: yt} = $.navigation;
        mt = makeElementsArray(mt),
        yt = makeElementsArray(yt);
        const Et = (_t, wt) => {
            _t.removeEventListener("click", wt === "next" ? lt : st),
            _t.classList.remove(...$.params.navigation.disabledClass.split(" "))
        }
        ;
        mt.forEach(_t => Et(_t, "next")),
        yt.forEach(_t => Et(_t, "prev"))
    }
    tt("init", () => {
        $.params.navigation.enabled === !1 ? ht() : (ct(),
        ot())
    }
    ),
    tt("toEdge fromEdge lock unlock", () => {
        ot()
    }
    ),
    tt("destroy", () => {
        dt()
    }
    ),
    tt("enable disable", () => {
        let {nextEl: mt, prevEl: yt} = $.navigation;
        if (mt = makeElementsArray(mt),
        yt = makeElementsArray(yt),
        $.enabled) {
            ot();
            return
        }
        [...mt, ...yt].filter(Et => !!Et).forEach(Et => Et.classList.add($.params.navigation.lockClass))
    }
    ),
    tt("click", (mt, yt) => {
        let {nextEl: Et, prevEl: _t} = $.navigation;
        Et = makeElementsArray(Et),
        _t = makeElementsArray(_t);
        const wt = yt.target;
        let St = _t.includes(wt) || Et.includes(wt);
        if ($.isElement && !St) {
            const Ct = yt.path || yt.composedPath && yt.composedPath();
            Ct && (St = Ct.find(Nt => Et.includes(Nt) || _t.includes(Nt)))
        }
        if ($.params.navigation.hideOnClick && !St) {
            if ($.pagination && $.params.pagination && $.params.pagination.clickable && ($.pagination.el === wt || $.pagination.el.contains(wt)))
                return;
            let Ct;
            Et.length ? Ct = Et[0].classList.contains($.params.navigation.hiddenClass) : _t.length && (Ct = _t[0].classList.contains($.params.navigation.hiddenClass)),
            nt(Ct === !0 ? "navigationShow" : "navigationHide"),
            [...Et, ..._t].filter(Nt => !!Nt).forEach(Nt => Nt.classList.toggle($.params.navigation.hiddenClass))
        }
    }
    );
    const pt = () => {
        $.el.classList.remove(...$.params.navigation.navigationDisabledClass.split(" ")),
        ct(),
        ot()
    }
      , ht = () => {
        $.el.classList.add(...$.params.navigation.navigationDisabledClass.split(" ")),
        dt()
    }
    ;
    Object.assign($.navigation, {
        enable: pt,
        disable: ht,
        update: ot,
        init: ct,
        destroy: dt
    })
}
let support;
function calcSupport() {
    const _e = getWindow()
      , $ = getDocument();
    return {
        smoothScroll: $.documentElement && $.documentElement.style && "scrollBehavior"in $.documentElement.style,
        touch: !!("ontouchstart"in _e || _e.DocumentTouch && $ instanceof _e.DocumentTouch)
    }
}
function getSupport() {
    return support || (support = calcSupport()),
    support
}
let deviceCached;
function calcDevice(_e) {
    let {userAgent: $} = _e === void 0 ? {} : _e;
    const et = getSupport()
      , tt = getWindow()
      , nt = tt.navigator.platform
      , rt = $ || tt.navigator.userAgent
      , it = {
        ios: !1,
        android: !1
    }
      , ot = tt.screen.width
      , st = tt.screen.height
      , lt = rt.match(/(Android);?[\s\/]+([\d.]+)?/);
    let ct = rt.match(/(iPad).*OS\s([\d_]+)/);
    const dt = rt.match(/(iPod)(.*OS\s([\d_]+))?/)
      , pt = !ct && rt.match(/(iPhone\sOS|iOS)\s([\d_]+)/)
      , ht = nt === "Win32";
    let mt = nt === "MacIntel";
    const yt = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
    return !ct && mt && et.touch && yt.indexOf(`${ot}x${st}`) >= 0 && (ct = rt.match(/(Version)\/([\d.]+)/),
    ct || (ct = [0, 1, "13_0_0"]),
    mt = !1),
    lt && !ht && (it.os = "android",
    it.android = !0),
    (ct || pt || dt) && (it.os = "ios",
    it.ios = !0),
    it
}
function getDevice(_e) {
    return _e === void 0 && (_e = {}),
    deviceCached || (deviceCached = calcDevice(_e)),
    deviceCached
}
let browser;
function calcBrowser() {
    const _e = getWindow()
      , $ = getDevice();
    let et = !1;
    function tt() {
        const ot = _e.navigator.userAgent.toLowerCase();
        return ot.indexOf("safari") >= 0 && ot.indexOf("chrome") < 0 && ot.indexOf("android") < 0
    }
    if (tt()) {
        const ot = String(_e.navigator.userAgent);
        if (ot.includes("Version/")) {
            const [st,lt] = ot.split("Version/")[1].split(" ")[0].split(".").map(ct => Number(ct));
            et = st < 16 || st === 16 && lt < 2
        }
    }
    const nt = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(_e.navigator.userAgent)
      , rt = tt()
      , it = rt || nt && $.ios;
    return {
        isSafari: et || rt,
        needPerspectiveFix: et,
        need3dFix: it,
        isWebView: nt
    }
}
function getBrowser() {
    return browser || (browser = calcBrowser()),
    browser
}
function Resize(_e) {
    let {swiper: $, on: et, emit: tt} = _e;
    const nt = getWindow();
    let rt = null
      , it = null;
    const ot = () => {
        !$ || $.destroyed || !$.initialized || (tt("beforeResize"),
        tt("resize"))
    }
      , st = () => {
        !$ || $.destroyed || !$.initialized || (rt = new ResizeObserver(dt => {
            it = nt.requestAnimationFrame( () => {
                const {width: pt, height: ht} = $;
                let mt = pt
                  , yt = ht;
                dt.forEach(Et => {
                    let {contentBoxSize: _t, contentRect: wt, target: St} = Et;
                    St && St !== $.el || (mt = wt ? wt.width : (_t[0] || _t).inlineSize,
                    yt = wt ? wt.height : (_t[0] || _t).blockSize)
                }
                ),
                (mt !== pt || yt !== ht) && ot()
            }
            )
        }
        ),
        rt.observe($.el))
    }
      , lt = () => {
        it && nt.cancelAnimationFrame(it),
        rt && rt.unobserve && $.el && (rt.unobserve($.el),
        rt = null)
    }
      , ct = () => {
        !$ || $.destroyed || !$.initialized || tt("orientationchange")
    }
    ;
    et("init", () => {
        if ($.params.resizeObserver && typeof nt.ResizeObserver < "u") {
            st();
            return
        }
        nt.addEventListener("resize", ot),
        nt.addEventListener("orientationchange", ct)
    }
    ),
    et("destroy", () => {
        lt(),
        nt.removeEventListener("resize", ot),
        nt.removeEventListener("orientationchange", ct)
    }
    )
}
function Observer(_e) {
    let {swiper: $, extendParams: et, on: tt, emit: nt} = _e;
    const rt = []
      , it = getWindow()
      , ot = function(ct, dt) {
        dt === void 0 && (dt = {});
        const pt = it.MutationObserver || it.WebkitMutationObserver
          , ht = new pt(mt => {
            if ($.__preventObserver__)
                return;
            if (mt.length === 1) {
                nt("observerUpdate", mt[0]);
                return
            }
            const yt = function() {
                nt("observerUpdate", mt[0])
            };
            it.requestAnimationFrame ? it.requestAnimationFrame(yt) : it.setTimeout(yt, 0)
        }
        );
        ht.observe(ct, {
            attributes: typeof dt.attributes > "u" ? !0 : dt.attributes,
            childList: $.isElement || (typeof dt.childList > "u" ? !0 : dt).childList,
            characterData: typeof dt.characterData > "u" ? !0 : dt.characterData
        }),
        rt.push(ht)
    }
      , st = () => {
        if ($.params.observer) {
            if ($.params.observeParents) {
                const ct = elementParents($.hostEl);
                for (let dt = 0; dt < ct.length; dt += 1)
                    ot(ct[dt])
            }
            ot($.hostEl, {
                childList: $.params.observeSlideChildren
            }),
            ot($.wrapperEl, {
                attributes: !1
            })
        }
    }
      , lt = () => {
        rt.forEach(ct => {
            ct.disconnect()
        }
        ),
        rt.splice(0, rt.length)
    }
    ;
    et({
        observer: !1,
        observeParents: !1,
        observeSlideChildren: !1
    }),
    tt("init", st),
    tt("destroy", lt)
}
var eventsEmitter = {
    on(_e, $, et) {
        const tt = this;
        if (!tt.eventsListeners || tt.destroyed || typeof $ != "function")
            return tt;
        const nt = et ? "unshift" : "push";
        return _e.split(" ").forEach(rt => {
            tt.eventsListeners[rt] || (tt.eventsListeners[rt] = []),
            tt.eventsListeners[rt][nt]($)
        }
        ),
        tt
    },
    once(_e, $, et) {
        const tt = this;
        if (!tt.eventsListeners || tt.destroyed || typeof $ != "function")
            return tt;
        function nt() {
            tt.off(_e, nt),
            nt.__emitterProxy && delete nt.__emitterProxy;
            for (var rt = arguments.length, it = new Array(rt), ot = 0; ot < rt; ot++)
                it[ot] = arguments[ot];
            $.apply(tt, it)
        }
        return nt.__emitterProxy = $,
        tt.on(_e, nt, et)
    },
    onAny(_e, $) {
        const et = this;
        if (!et.eventsListeners || et.destroyed || typeof _e != "function")
            return et;
        const tt = $ ? "unshift" : "push";
        return et.eventsAnyListeners.indexOf(_e) < 0 && et.eventsAnyListeners[tt](_e),
        et
    },
    offAny(_e) {
        const $ = this;
        if (!$.eventsListeners || $.destroyed || !$.eventsAnyListeners)
            return $;
        const et = $.eventsAnyListeners.indexOf(_e);
        return et >= 0 && $.eventsAnyListeners.splice(et, 1),
        $
    },
    off(_e, $) {
        const et = this;
        return !et.eventsListeners || et.destroyed || !et.eventsListeners || _e.split(" ").forEach(tt => {
            typeof $ > "u" ? et.eventsListeners[tt] = [] : et.eventsListeners[tt] && et.eventsListeners[tt].forEach( (nt, rt) => {
                (nt === $ || nt.__emitterProxy && nt.__emitterProxy === $) && et.eventsListeners[tt].splice(rt, 1)
            }
            )
        }
        ),
        et
    },
    emit() {
        const _e = this;
        if (!_e.eventsListeners || _e.destroyed || !_e.eventsListeners)
            return _e;
        let $, et, tt;
        for (var nt = arguments.length, rt = new Array(nt), it = 0; it < nt; it++)
            rt[it] = arguments[it];
        return typeof rt[0] == "string" || Array.isArray(rt[0]) ? ($ = rt[0],
        et = rt.slice(1, rt.length),
        tt = _e) : ($ = rt[0].events,
        et = rt[0].data,
        tt = rt[0].context || _e),
        et.unshift(tt),
        (Array.isArray($) ? $ : $.split(" ")).forEach(st => {
            _e.eventsAnyListeners && _e.eventsAnyListeners.length && _e.eventsAnyListeners.forEach(lt => {
                lt.apply(tt, [st, ...et])
            }
            ),
            _e.eventsListeners && _e.eventsListeners[st] && _e.eventsListeners[st].forEach(lt => {
                lt.apply(tt, et)
            }
            )
        }
        ),
        _e
    }
};
function updateSize() {
    const _e = this;
    let $, et;
    const tt = _e.el;
    typeof _e.params.width < "u" && _e.params.width !== null ? $ = _e.params.width : $ = tt.clientWidth,
    typeof _e.params.height < "u" && _e.params.height !== null ? et = _e.params.height : et = tt.clientHeight,
    !($ === 0 && _e.isHorizontal() || et === 0 && _e.isVertical()) && ($ = $ - parseInt(elementStyle(tt, "padding-left") || 0, 10) - parseInt(elementStyle(tt, "padding-right") || 0, 10),
    et = et - parseInt(elementStyle(tt, "padding-top") || 0, 10) - parseInt(elementStyle(tt, "padding-bottom") || 0, 10),
    Number.isNaN($) && ($ = 0),
    Number.isNaN(et) && (et = 0),
    Object.assign(_e, {
        width: $,
        height: et,
        size: _e.isHorizontal() ? $ : et
    }))
}
function updateSlides() {
    const _e = this;
    function $(Pt, Xt) {
        return parseFloat(Pt.getPropertyValue(_e.getDirectionLabel(Xt)) || 0)
    }
    const et = _e.params
      , {wrapperEl: tt, slidesEl: nt, size: rt, rtlTranslate: it, wrongRTL: ot} = _e
      , st = _e.virtual && et.virtual.enabled
      , lt = st ? _e.virtual.slides.length : _e.slides.length
      , ct = elementChildren(nt, `.${_e.params.slideClass}, swiper-slide`)
      , dt = st ? _e.virtual.slides.length : ct.length;
    let pt = [];
    const ht = []
      , mt = [];
    let yt = et.slidesOffsetBefore;
    typeof yt == "function" && (yt = et.slidesOffsetBefore.call(_e));
    let Et = et.slidesOffsetAfter;
    typeof Et == "function" && (Et = et.slidesOffsetAfter.call(_e));
    const _t = _e.snapGrid.length
      , wt = _e.slidesGrid.length;
    let St = et.spaceBetween
      , Ct = -yt
      , Nt = 0
      , Lt = 0;
    if (typeof rt > "u")
        return;
    typeof St == "string" && St.indexOf("%") >= 0 ? St = parseFloat(St.replace("%", "")) / 100 * rt : typeof St == "string" && (St = parseFloat(St)),
    _e.virtualSize = -St,
    ct.forEach(Pt => {
        it ? Pt.style.marginLeft = "" : Pt.style.marginRight = "",
        Pt.style.marginBottom = "",
        Pt.style.marginTop = ""
    }
    ),
    et.centeredSlides && et.cssMode && (setCSSProperty(tt, "--swiper-centered-offset-before", ""),
    setCSSProperty(tt, "--swiper-centered-offset-after", ""));
    const kt = et.grid && et.grid.rows > 1 && _e.grid;
    kt ? _e.grid.initSlides(ct) : _e.grid && _e.grid.unsetSlides();
    let Ut;
    const Jt = et.slidesPerView === "auto" && et.breakpoints && Object.keys(et.breakpoints).filter(Pt => typeof et.breakpoints[Pt].slidesPerView < "u").length > 0;
    for (let Pt = 0; Pt < dt; Pt += 1) {
        Ut = 0;
        let Xt;
        if (ct[Pt] && (Xt = ct[Pt]),
        kt && _e.grid.updateSlide(Pt, Xt, ct),
        !(ct[Pt] && elementStyle(Xt, "display") === "none")) {
            if (et.slidesPerView === "auto") {
                Jt && (ct[Pt].style[_e.getDirectionLabel("width")] = "");
                const rn = getComputedStyle(Xt)
                  , zt = Xt.style.transform
                  , xt = Xt.style.webkitTransform;
                if (zt && (Xt.style.transform = "none"),
                xt && (Xt.style.webkitTransform = "none"),
                et.roundLengths)
                    Ut = _e.isHorizontal() ? elementOuterSize(Xt, "width") : elementOuterSize(Xt, "height");
                else {
                    const $t = $(rn, "width")
                      , Dt = $(rn, "padding-left")
                      , jt = $(rn, "padding-right")
                      , Ft = $(rn, "margin-left")
                      , Ht = $(rn, "margin-right")
                      , qt = rn.getPropertyValue("box-sizing");
                    if (qt && qt === "border-box")
                        Ut = $t + Ft + Ht;
                    else {
                        const {clientWidth: Wt, offsetWidth: Mt} = Xt;
                        Ut = $t + Dt + jt + Ft + Ht + (Mt - Wt)
                    }
                }
                zt && (Xt.style.transform = zt),
                xt && (Xt.style.webkitTransform = xt),
                et.roundLengths && (Ut = Math.floor(Ut))
            } else
                Ut = (rt - (et.slidesPerView - 1) * St) / et.slidesPerView,
                et.roundLengths && (Ut = Math.floor(Ut)),
                ct[Pt] && (ct[Pt].style[_e.getDirectionLabel("width")] = `${Ut}px`);
            ct[Pt] && (ct[Pt].swiperSlideSize = Ut),
            mt.push(Ut),
            et.centeredSlides ? (Ct = Ct + Ut / 2 + Nt / 2 + St,
            Nt === 0 && Pt !== 0 && (Ct = Ct - rt / 2 - St),
            Pt === 0 && (Ct = Ct - rt / 2 - St),
            Math.abs(Ct) < 1 / 1e3 && (Ct = 0),
            et.roundLengths && (Ct = Math.floor(Ct)),
            Lt % et.slidesPerGroup === 0 && pt.push(Ct),
            ht.push(Ct)) : (et.roundLengths && (Ct = Math.floor(Ct)),
            (Lt - Math.min(_e.params.slidesPerGroupSkip, Lt)) % _e.params.slidesPerGroup === 0 && pt.push(Ct),
            ht.push(Ct),
            Ct = Ct + Ut + St),
            _e.virtualSize += Ut + St,
            Nt = Ut,
            Lt += 1
        }
    }
    if (_e.virtualSize = Math.max(_e.virtualSize, rt) + Et,
    it && ot && (et.effect === "slide" || et.effect === "coverflow") && (tt.style.width = `${_e.virtualSize + St}px`),
    et.setWrapperSize && (tt.style[_e.getDirectionLabel("width")] = `${_e.virtualSize + St}px`),
    kt && _e.grid.updateWrapperSize(Ut, pt),
    !et.centeredSlides) {
        const Pt = [];
        for (let Xt = 0; Xt < pt.length; Xt += 1) {
            let rn = pt[Xt];
            et.roundLengths && (rn = Math.floor(rn)),
            pt[Xt] <= _e.virtualSize - rt && Pt.push(rn)
        }
        pt = Pt,
        Math.floor(_e.virtualSize - rt) - Math.floor(pt[pt.length - 1]) > 1 && pt.push(_e.virtualSize - rt)
    }
    if (st && et.loop) {
        const Pt = mt[0] + St;
        if (et.slidesPerGroup > 1) {
            const Xt = Math.ceil((_e.virtual.slidesBefore + _e.virtual.slidesAfter) / et.slidesPerGroup)
              , rn = Pt * et.slidesPerGroup;
            for (let zt = 0; zt < Xt; zt += 1)
                pt.push(pt[pt.length - 1] + rn)
        }
        for (let Xt = 0; Xt < _e.virtual.slidesBefore + _e.virtual.slidesAfter; Xt += 1)
            et.slidesPerGroup === 1 && pt.push(pt[pt.length - 1] + Pt),
            ht.push(ht[ht.length - 1] + Pt),
            _e.virtualSize += Pt
    }
    if (pt.length === 0 && (pt = [0]),
    St !== 0) {
        const Pt = _e.isHorizontal() && it ? "marginLeft" : _e.getDirectionLabel("marginRight");
        ct.filter( (Xt, rn) => !et.cssMode || et.loop ? !0 : rn !== ct.length - 1).forEach(Xt => {
            Xt.style[Pt] = `${St}px`
        }
        )
    }
    if (et.centeredSlides && et.centeredSlidesBounds) {
        let Pt = 0;
        mt.forEach(rn => {
            Pt += rn + (St || 0)
        }
        ),
        Pt -= St;
        const Xt = Pt > rt ? Pt - rt : 0;
        pt = pt.map(rn => rn <= 0 ? -yt : rn > Xt ? Xt + Et : rn)
    }
    if (et.centerInsufficientSlides) {
        let Pt = 0;
        mt.forEach(rn => {
            Pt += rn + (St || 0)
        }
        ),
        Pt -= St;
        const Xt = (et.slidesOffsetBefore || 0) + (et.slidesOffsetAfter || 0);
        if (Pt + Xt < rt) {
            const rn = (rt - Pt - Xt) / 2;
            pt.forEach( (zt, xt) => {
                pt[xt] = zt - rn
            }
            ),
            ht.forEach( (zt, xt) => {
                ht[xt] = zt + rn
            }
            )
        }
    }
    if (Object.assign(_e, {
        slides: ct,
        snapGrid: pt,
        slidesGrid: ht,
        slidesSizesGrid: mt
    }),
    et.centeredSlides && et.cssMode && !et.centeredSlidesBounds) {
        setCSSProperty(tt, "--swiper-centered-offset-before", `${-pt[0]}px`),
        setCSSProperty(tt, "--swiper-centered-offset-after", `${_e.size / 2 - mt[mt.length - 1] / 2}px`);
        const Pt = -_e.snapGrid[0]
          , Xt = -_e.slidesGrid[0];
        _e.snapGrid = _e.snapGrid.map(rn => rn + Pt),
        _e.slidesGrid = _e.slidesGrid.map(rn => rn + Xt)
    }
    if (dt !== lt && _e.emit("slidesLengthChange"),
    pt.length !== _t && (_e.params.watchOverflow && _e.checkOverflow(),
    _e.emit("snapGridLengthChange")),
    ht.length !== wt && _e.emit("slidesGridLengthChange"),
    et.watchSlidesProgress && _e.updateSlidesOffset(),
    _e.emit("slidesUpdated"),
    !st && !et.cssMode && (et.effect === "slide" || et.effect === "fade")) {
        const Pt = `${et.containerModifierClass}backface-hidden`
          , Xt = _e.el.classList.contains(Pt);
        dt <= et.maxBackfaceHiddenSlides ? Xt || _e.el.classList.add(Pt) : Xt && _e.el.classList.remove(Pt)
    }
}
function updateAutoHeight(_e) {
    const $ = this
      , et = []
      , tt = $.virtual && $.params.virtual.enabled;
    let nt = 0, rt;
    typeof _e == "number" ? $.setTransition(_e) : _e === !0 && $.setTransition($.params.speed);
    const it = ot => tt ? $.slides[$.getSlideIndexByData(ot)] : $.slides[ot];
    if ($.params.slidesPerView !== "auto" && $.params.slidesPerView > 1)
        if ($.params.centeredSlides)
            ($.visibleSlides || []).forEach(ot => {
                et.push(ot)
            }
            );
        else
            for (rt = 0; rt < Math.ceil($.params.slidesPerView); rt += 1) {
                const ot = $.activeIndex + rt;
                if (ot > $.slides.length && !tt)
                    break;
                et.push(it(ot))
            }
    else
        et.push(it($.activeIndex));
    for (rt = 0; rt < et.length; rt += 1)
        if (typeof et[rt] < "u") {
            const ot = et[rt].offsetHeight;
            nt = ot > nt ? ot : nt
        }
    (nt || nt === 0) && ($.wrapperEl.style.height = `${nt}px`)
}
function updateSlidesOffset() {
    const _e = this
      , $ = _e.slides
      , et = _e.isElement ? _e.isHorizontal() ? _e.wrapperEl.offsetLeft : _e.wrapperEl.offsetTop : 0;
    for (let tt = 0; tt < $.length; tt += 1)
        $[tt].swiperSlideOffset = (_e.isHorizontal() ? $[tt].offsetLeft : $[tt].offsetTop) - et - _e.cssOverflowAdjustment()
}
const toggleSlideClasses$1 = (_e, $, et) => {
    $ && !_e.classList.contains(et) ? _e.classList.add(et) : !$ && _e.classList.contains(et) && _e.classList.remove(et)
}
;
function updateSlidesProgress(_e) {
    _e === void 0 && (_e = this && this.translate || 0);
    const $ = this
      , et = $.params
      , {slides: tt, rtlTranslate: nt, snapGrid: rt} = $;
    if (tt.length === 0)
        return;
    typeof tt[0].swiperSlideOffset > "u" && $.updateSlidesOffset();
    let it = -_e;
    nt && (it = _e),
    $.visibleSlidesIndexes = [],
    $.visibleSlides = [];
    let ot = et.spaceBetween;
    typeof ot == "string" && ot.indexOf("%") >= 0 ? ot = parseFloat(ot.replace("%", "")) / 100 * $.size : typeof ot == "string" && (ot = parseFloat(ot));
    for (let st = 0; st < tt.length; st += 1) {
        const lt = tt[st];
        let ct = lt.swiperSlideOffset;
        et.cssMode && et.centeredSlides && (ct -= tt[0].swiperSlideOffset);
        const dt = (it + (et.centeredSlides ? $.minTranslate() : 0) - ct) / (lt.swiperSlideSize + ot)
          , pt = (it - rt[0] + (et.centeredSlides ? $.minTranslate() : 0) - ct) / (lt.swiperSlideSize + ot)
          , ht = -(it - ct)
          , mt = ht + $.slidesSizesGrid[st]
          , yt = ht >= 0 && ht <= $.size - $.slidesSizesGrid[st]
          , Et = ht >= 0 && ht < $.size - 1 || mt > 1 && mt <= $.size || ht <= 0 && mt >= $.size;
        Et && ($.visibleSlides.push(lt),
        $.visibleSlidesIndexes.push(st)),
        toggleSlideClasses$1(lt, Et, et.slideVisibleClass),
        toggleSlideClasses$1(lt, yt, et.slideFullyVisibleClass),
        lt.progress = nt ? -dt : dt,
        lt.originalProgress = nt ? -pt : pt
    }
}
function updateProgress(_e) {
    const $ = this;
    if (typeof _e > "u") {
        const ct = $.rtlTranslate ? -1 : 1;
        _e = $ && $.translate && $.translate * ct || 0
    }
    const et = $.params
      , tt = $.maxTranslate() - $.minTranslate();
    let {progress: nt, isBeginning: rt, isEnd: it, progressLoop: ot} = $;
    const st = rt
      , lt = it;
    if (tt === 0)
        nt = 0,
        rt = !0,
        it = !0;
    else {
        nt = (_e - $.minTranslate()) / tt;
        const ct = Math.abs(_e - $.minTranslate()) < 1
          , dt = Math.abs(_e - $.maxTranslate()) < 1;
        rt = ct || nt <= 0,
        it = dt || nt >= 1,
        ct && (nt = 0),
        dt && (nt = 1)
    }
    if (et.loop) {
        const ct = $.getSlideIndexByData(0)
          , dt = $.getSlideIndexByData($.slides.length - 1)
          , pt = $.slidesGrid[ct]
          , ht = $.slidesGrid[dt]
          , mt = $.slidesGrid[$.slidesGrid.length - 1]
          , yt = Math.abs(_e);
        yt >= pt ? ot = (yt - pt) / mt : ot = (yt + mt - ht) / mt,
        ot > 1 && (ot -= 1)
    }
    Object.assign($, {
        progress: nt,
        progressLoop: ot,
        isBeginning: rt,
        isEnd: it
    }),
    (et.watchSlidesProgress || et.centeredSlides && et.autoHeight) && $.updateSlidesProgress(_e),
    rt && !st && $.emit("reachBeginning toEdge"),
    it && !lt && $.emit("reachEnd toEdge"),
    (st && !rt || lt && !it) && $.emit("fromEdge"),
    $.emit("progress", nt)
}
const toggleSlideClasses = (_e, $, et) => {
    $ && !_e.classList.contains(et) ? _e.classList.add(et) : !$ && _e.classList.contains(et) && _e.classList.remove(et)
}
;
function updateSlidesClasses() {
    const _e = this
      , {slides: $, params: et, slidesEl: tt, activeIndex: nt} = _e
      , rt = _e.virtual && et.virtual.enabled
      , it = _e.grid && et.grid && et.grid.rows > 1
      , ot = dt => elementChildren(tt, `.${et.slideClass}${dt}, swiper-slide${dt}`)[0];
    let st, lt, ct;
    if (rt)
        if (et.loop) {
            let dt = nt - _e.virtual.slidesBefore;
            dt < 0 && (dt = _e.virtual.slides.length + dt),
            dt >= _e.virtual.slides.length && (dt -= _e.virtual.slides.length),
            st = ot(`[data-swiper-slide-index="${dt}"]`)
        } else
            st = ot(`[data-swiper-slide-index="${nt}"]`);
    else
        it ? (st = $.find(dt => dt.column === nt),
        ct = $.find(dt => dt.column === nt + 1),
        lt = $.find(dt => dt.column === nt - 1)) : st = $[nt];
    st && (it || (ct = elementNextAll(st, `.${et.slideClass}, swiper-slide`)[0],
    et.loop && !ct && (ct = $[0]),
    lt = elementPrevAll(st, `.${et.slideClass}, swiper-slide`)[0],
    et.loop && !lt === 0 && (lt = $[$.length - 1]))),
    $.forEach(dt => {
        toggleSlideClasses(dt, dt === st, et.slideActiveClass),
        toggleSlideClasses(dt, dt === ct, et.slideNextClass),
        toggleSlideClasses(dt, dt === lt, et.slidePrevClass)
    }
    ),
    _e.emitSlidesClasses()
}
const processLazyPreloader = (_e, $) => {
    if (!_e || _e.destroyed || !_e.params)
        return;
    const et = () => _e.isElement ? "swiper-slide" : `.${_e.params.slideClass}`
      , tt = $.closest(et());
    if (tt) {
        let nt = tt.querySelector(`.${_e.params.lazyPreloaderClass}`);
        !nt && _e.isElement && (tt.shadowRoot ? nt = tt.shadowRoot.querySelector(`.${_e.params.lazyPreloaderClass}`) : requestAnimationFrame( () => {
            tt.shadowRoot && (nt = tt.shadowRoot.querySelector(`.${_e.params.lazyPreloaderClass}`),
            nt && nt.remove())
        }
        )),
        nt && nt.remove()
    }
}
  , unlazy = (_e, $) => {
    if (!_e.slides[$])
        return;
    const et = _e.slides[$].querySelector('[loading="lazy"]');
    et && et.removeAttribute("loading")
}
  , preload = _e => {
    if (!_e || _e.destroyed || !_e.params)
        return;
    let $ = _e.params.lazyPreloadPrevNext;
    const et = _e.slides.length;
    if (!et || !$ || $ < 0)
        return;
    $ = Math.min($, et);
    const tt = _e.params.slidesPerView === "auto" ? _e.slidesPerViewDynamic() : Math.ceil(_e.params.slidesPerView)
      , nt = _e.activeIndex;
    if (_e.params.grid && _e.params.grid.rows > 1) {
        const it = nt
          , ot = [it - $];
        ot.push(...Array.from({
            length: $
        }).map( (st, lt) => it + tt + lt)),
        _e.slides.forEach( (st, lt) => {
            ot.includes(st.column) && unlazy(_e, lt)
        }
        );
        return
    }
    const rt = nt + tt - 1;
    if (_e.params.rewind || _e.params.loop)
        for (let it = nt - $; it <= rt + $; it += 1) {
            const ot = (it % et + et) % et;
            (ot < nt || ot > rt) && unlazy(_e, ot)
        }
    else
        for (let it = Math.max(nt - $, 0); it <= Math.min(rt + $, et - 1); it += 1)
            it !== nt && (it > rt || it < nt) && unlazy(_e, it)
}
;
function getActiveIndexByTranslate(_e) {
    const {slidesGrid: $, params: et} = _e
      , tt = _e.rtlTranslate ? _e.translate : -_e.translate;
    let nt;
    for (let rt = 0; rt < $.length; rt += 1)
        typeof $[rt + 1] < "u" ? tt >= $[rt] && tt < $[rt + 1] - ($[rt + 1] - $[rt]) / 2 ? nt = rt : tt >= $[rt] && tt < $[rt + 1] && (nt = rt + 1) : tt >= $[rt] && (nt = rt);
    return et.normalizeSlideIndex && (nt < 0 || typeof nt > "u") && (nt = 0),
    nt
}
function updateActiveIndex(_e) {
    const $ = this
      , et = $.rtlTranslate ? $.translate : -$.translate
      , {snapGrid: tt, params: nt, activeIndex: rt, realIndex: it, snapIndex: ot} = $;
    let st = _e, lt;
    const ct = ht => {
        let mt = ht - $.virtual.slidesBefore;
        return mt < 0 && (mt = $.virtual.slides.length + mt),
        mt >= $.virtual.slides.length && (mt -= $.virtual.slides.length),
        mt
    }
    ;
    if (typeof st > "u" && (st = getActiveIndexByTranslate($)),
    tt.indexOf(et) >= 0)
        lt = tt.indexOf(et);
    else {
        const ht = Math.min(nt.slidesPerGroupSkip, st);
        lt = ht + Math.floor((st - ht) / nt.slidesPerGroup)
    }
    if (lt >= tt.length && (lt = tt.length - 1),
    st === rt && !$.params.loop) {
        lt !== ot && ($.snapIndex = lt,
        $.emit("snapIndexChange"));
        return
    }
    if (st === rt && $.params.loop && $.virtual && $.params.virtual.enabled) {
        $.realIndex = ct(st);
        return
    }
    const dt = $.grid && nt.grid && nt.grid.rows > 1;
    let pt;
    if ($.virtual && nt.virtual.enabled && nt.loop)
        pt = ct(st);
    else if (dt) {
        const ht = $.slides.find(yt => yt.column === st);
        let mt = parseInt(ht.getAttribute("data-swiper-slide-index"), 10);
        Number.isNaN(mt) && (mt = Math.max($.slides.indexOf(ht), 0)),
        pt = Math.floor(mt / nt.grid.rows)
    } else if ($.slides[st]) {
        const ht = $.slides[st].getAttribute("data-swiper-slide-index");
        ht ? pt = parseInt(ht, 10) : pt = st
    } else
        pt = st;
    Object.assign($, {
        previousSnapIndex: ot,
        snapIndex: lt,
        previousRealIndex: it,
        realIndex: pt,
        previousIndex: rt,
        activeIndex: st
    }),
    $.initialized && preload($),
    $.emit("activeIndexChange"),
    $.emit("snapIndexChange"),
    ($.initialized || $.params.runCallbacksOnInit) && (it !== pt && $.emit("realIndexChange"),
    $.emit("slideChange"))
}
function updateClickedSlide(_e, $) {
    const et = this
      , tt = et.params;
    let nt = _e.closest(`.${tt.slideClass}, swiper-slide`);
    !nt && et.isElement && $ && $.length > 1 && $.includes(_e) && [...$.slice($.indexOf(_e) + 1, $.length)].forEach(ot => {
        !nt && ot.matches && ot.matches(`.${tt.slideClass}, swiper-slide`) && (nt = ot)
    }
    );
    let rt = !1, it;
    if (nt) {
        for (let ot = 0; ot < et.slides.length; ot += 1)
            if (et.slides[ot] === nt) {
                rt = !0,
                it = ot;
                break
            }
    }
    if (nt && rt)
        et.clickedSlide = nt,
        et.virtual && et.params.virtual.enabled ? et.clickedIndex = parseInt(nt.getAttribute("data-swiper-slide-index"), 10) : et.clickedIndex = it;
    else {
        et.clickedSlide = void 0,
        et.clickedIndex = void 0;
        return
    }
    tt.slideToClickedSlide && et.clickedIndex !== void 0 && et.clickedIndex !== et.activeIndex && et.slideToClickedSlide()
}
var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide
};
function getSwiperTranslate(_e) {
    _e === void 0 && (_e = this.isHorizontal() ? "x" : "y");
    const $ = this
      , {params: et, rtlTranslate: tt, translate: nt, wrapperEl: rt} = $;
    if (et.virtualTranslate)
        return tt ? -nt : nt;
    if (et.cssMode)
        return nt;
    let it = getTranslate(rt, _e);
    return it += $.cssOverflowAdjustment(),
    tt && (it = -it),
    it || 0
}
function setTranslate(_e, $) {
    const et = this
      , {rtlTranslate: tt, params: nt, wrapperEl: rt, progress: it} = et;
    let ot = 0
      , st = 0;
    const lt = 0;
    et.isHorizontal() ? ot = tt ? -_e : _e : st = _e,
    nt.roundLengths && (ot = Math.floor(ot),
    st = Math.floor(st)),
    et.previousTranslate = et.translate,
    et.translate = et.isHorizontal() ? ot : st,
    nt.cssMode ? rt[et.isHorizontal() ? "scrollLeft" : "scrollTop"] = et.isHorizontal() ? -ot : -st : nt.virtualTranslate || (et.isHorizontal() ? ot -= et.cssOverflowAdjustment() : st -= et.cssOverflowAdjustment(),
    rt.style.transform = `translate3d(${ot}px, ${st}px, ${lt}px)`);
    let ct;
    const dt = et.maxTranslate() - et.minTranslate();
    dt === 0 ? ct = 0 : ct = (_e - et.minTranslate()) / dt,
    ct !== it && et.updateProgress(_e),
    et.emit("setTranslate", et.translate, $)
}
function minTranslate() {
    return -this.snapGrid[0]
}
function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1]
}
function translateTo(_e, $, et, tt, nt) {
    _e === void 0 && (_e = 0),
    $ === void 0 && ($ = this.params.speed),
    et === void 0 && (et = !0),
    tt === void 0 && (tt = !0);
    const rt = this
      , {params: it, wrapperEl: ot} = rt;
    if (rt.animating && it.preventInteractionOnTransition)
        return !1;
    const st = rt.minTranslate()
      , lt = rt.maxTranslate();
    let ct;
    if (tt && _e > st ? ct = st : tt && _e < lt ? ct = lt : ct = _e,
    rt.updateProgress(ct),
    it.cssMode) {
        const dt = rt.isHorizontal();
        if ($ === 0)
            ot[dt ? "scrollLeft" : "scrollTop"] = -ct;
        else {
            if (!rt.support.smoothScroll)
                return animateCSSModeScroll({
                    swiper: rt,
                    targetPosition: -ct,
                    side: dt ? "left" : "top"
                }),
                !0;
            ot.scrollTo({
                [dt ? "left" : "top"]: -ct,
                behavior: "smooth"
            })
        }
        return !0
    }
    return $ === 0 ? (rt.setTransition(0),
    rt.setTranslate(ct),
    et && (rt.emit("beforeTransitionStart", $, nt),
    rt.emit("transitionEnd"))) : (rt.setTransition($),
    rt.setTranslate(ct),
    et && (rt.emit("beforeTransitionStart", $, nt),
    rt.emit("transitionStart")),
    rt.animating || (rt.animating = !0,
    rt.onTranslateToWrapperTransitionEnd || (rt.onTranslateToWrapperTransitionEnd = function(pt) {
        !rt || rt.destroyed || pt.target === this && (rt.wrapperEl.removeEventListener("transitionend", rt.onTranslateToWrapperTransitionEnd),
        rt.onTranslateToWrapperTransitionEnd = null,
        delete rt.onTranslateToWrapperTransitionEnd,
        rt.animating = !1,
        et && rt.emit("transitionEnd"))
    }
    ),
    rt.wrapperEl.addEventListener("transitionend", rt.onTranslateToWrapperTransitionEnd))),
    !0
}
var translate = {
    getTranslate: getSwiperTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo
};
function setTransition(_e, $) {
    const et = this;
    et.params.cssMode || (et.wrapperEl.style.transitionDuration = `${_e}ms`,
    et.wrapperEl.style.transitionDelay = _e === 0 ? "0ms" : ""),
    et.emit("setTransition", _e, $)
}
function transitionEmit(_e) {
    let {swiper: $, runCallbacks: et, direction: tt, step: nt} = _e;
    const {activeIndex: rt, previousIndex: it} = $;
    let ot = tt;
    if (ot || (rt > it ? ot = "next" : rt < it ? ot = "prev" : ot = "reset"),
    $.emit(`transition${nt}`),
    et && rt !== it) {
        if (ot === "reset") {
            $.emit(`slideResetTransition${nt}`);
            return
        }
        $.emit(`slideChangeTransition${nt}`),
        ot === "next" ? $.emit(`slideNextTransition${nt}`) : $.emit(`slidePrevTransition${nt}`)
    }
}
function transitionStart(_e, $) {
    _e === void 0 && (_e = !0);
    const et = this
      , {params: tt} = et;
    tt.cssMode || (tt.autoHeight && et.updateAutoHeight(),
    transitionEmit({
        swiper: et,
        runCallbacks: _e,
        direction: $,
        step: "Start"
    }))
}
function transitionEnd(_e, $) {
    _e === void 0 && (_e = !0);
    const et = this
      , {params: tt} = et;
    et.animating = !1,
    !tt.cssMode && (et.setTransition(0),
    transitionEmit({
        swiper: et,
        runCallbacks: _e,
        direction: $,
        step: "End"
    }))
}
var transition = {
    setTransition,
    transitionStart,
    transitionEnd
};
function slideTo(_e, $, et, tt, nt) {
    _e === void 0 && (_e = 0),
    et === void 0 && (et = !0),
    typeof _e == "string" && (_e = parseInt(_e, 10));
    const rt = this;
    let it = _e;
    it < 0 && (it = 0);
    const {params: ot, snapGrid: st, slidesGrid: lt, previousIndex: ct, activeIndex: dt, rtlTranslate: pt, wrapperEl: ht, enabled: mt} = rt;
    if (!mt && !tt && !nt || rt.destroyed || rt.animating && ot.preventInteractionOnTransition)
        return !1;
    typeof $ > "u" && ($ = rt.params.speed);
    const yt = Math.min(rt.params.slidesPerGroupSkip, it);
    let Et = yt + Math.floor((it - yt) / rt.params.slidesPerGroup);
    Et >= st.length && (Et = st.length - 1);
    const _t = -st[Et];
    if (ot.normalizeSlideIndex)
        for (let kt = 0; kt < lt.length; kt += 1) {
            const Ut = -Math.floor(_t * 100)
              , Jt = Math.floor(lt[kt] * 100)
              , Pt = Math.floor(lt[kt + 1] * 100);
            typeof lt[kt + 1] < "u" ? Ut >= Jt && Ut < Pt - (Pt - Jt) / 2 ? it = kt : Ut >= Jt && Ut < Pt && (it = kt + 1) : Ut >= Jt && (it = kt)
        }
    if (rt.initialized && it !== dt && (!rt.allowSlideNext && (pt ? _t > rt.translate && _t > rt.minTranslate() : _t < rt.translate && _t < rt.minTranslate()) || !rt.allowSlidePrev && _t > rt.translate && _t > rt.maxTranslate() && (dt || 0) !== it))
        return !1;
    it !== (ct || 0) && et && rt.emit("beforeSlideChangeStart"),
    rt.updateProgress(_t);
    let wt;
    it > dt ? wt = "next" : it < dt ? wt = "prev" : wt = "reset";
    const St = rt.virtual && rt.params.virtual.enabled;
    if (!(St && nt) && (pt && -_t === rt.translate || !pt && _t === rt.translate))
        return rt.updateActiveIndex(it),
        ot.autoHeight && rt.updateAutoHeight(),
        rt.updateSlidesClasses(),
        ot.effect !== "slide" && rt.setTranslate(_t),
        wt !== "reset" && (rt.transitionStart(et, wt),
        rt.transitionEnd(et, wt)),
        !1;
    if (ot.cssMode) {
        const kt = rt.isHorizontal()
          , Ut = pt ? _t : -_t;
        if ($ === 0)
            St && (rt.wrapperEl.style.scrollSnapType = "none",
            rt._immediateVirtual = !0),
            St && !rt._cssModeVirtualInitialSet && rt.params.initialSlide > 0 ? (rt._cssModeVirtualInitialSet = !0,
            requestAnimationFrame( () => {
                ht[kt ? "scrollLeft" : "scrollTop"] = Ut
            }
            )) : ht[kt ? "scrollLeft" : "scrollTop"] = Ut,
            St && requestAnimationFrame( () => {
                rt.wrapperEl.style.scrollSnapType = "",
                rt._immediateVirtual = !1
            }
            );
        else {
            if (!rt.support.smoothScroll)
                return animateCSSModeScroll({
                    swiper: rt,
                    targetPosition: Ut,
                    side: kt ? "left" : "top"
                }),
                !0;
            ht.scrollTo({
                [kt ? "left" : "top"]: Ut,
                behavior: "smooth"
            })
        }
        return !0
    }
    const Lt = getBrowser().isSafari;
    return St && !nt && Lt && rt.isElement && rt.virtual.update(!1, !1, it),
    rt.setTransition($),
    rt.setTranslate(_t),
    rt.updateActiveIndex(it),
    rt.updateSlidesClasses(),
    rt.emit("beforeTransitionStart", $, tt),
    rt.transitionStart(et, wt),
    $ === 0 ? rt.transitionEnd(et, wt) : rt.animating || (rt.animating = !0,
    rt.onSlideToWrapperTransitionEnd || (rt.onSlideToWrapperTransitionEnd = function(Ut) {
        !rt || rt.destroyed || Ut.target === this && (rt.wrapperEl.removeEventListener("transitionend", rt.onSlideToWrapperTransitionEnd),
        rt.onSlideToWrapperTransitionEnd = null,
        delete rt.onSlideToWrapperTransitionEnd,
        rt.transitionEnd(et, wt))
    }
    ),
    rt.wrapperEl.addEventListener("transitionend", rt.onSlideToWrapperTransitionEnd)),
    !0
}
function slideToLoop(_e, $, et, tt) {
    _e === void 0 && (_e = 0),
    et === void 0 && (et = !0),
    typeof _e == "string" && (_e = parseInt(_e, 10));
    const nt = this;
    if (nt.destroyed)
        return;
    typeof $ > "u" && ($ = nt.params.speed);
    const rt = nt.grid && nt.params.grid && nt.params.grid.rows > 1;
    let it = _e;
    if (nt.params.loop)
        if (nt.virtual && nt.params.virtual.enabled)
            it = it + nt.virtual.slidesBefore;
        else {
            let ot;
            if (rt) {
                const pt = it * nt.params.grid.rows;
                ot = nt.slides.find(ht => ht.getAttribute("data-swiper-slide-index") * 1 === pt).column
            } else
                ot = nt.getSlideIndexByData(it);
            const st = rt ? Math.ceil(nt.slides.length / nt.params.grid.rows) : nt.slides.length
              , {centeredSlides: lt} = nt.params;
            let ct = nt.params.slidesPerView;
            ct === "auto" ? ct = nt.slidesPerViewDynamic() : (ct = Math.ceil(parseFloat(nt.params.slidesPerView, 10)),
            lt && ct % 2 === 0 && (ct = ct + 1));
            let dt = st - ot < ct;
            if (lt && (dt = dt || ot < Math.ceil(ct / 2)),
            tt && lt && nt.params.slidesPerView !== "auto" && !rt && (dt = !1),
            dt) {
                const pt = lt ? ot < nt.activeIndex ? "prev" : "next" : ot - nt.activeIndex - 1 < nt.params.slidesPerView ? "next" : "prev";
                nt.loopFix({
                    direction: pt,
                    slideTo: !0,
                    activeSlideIndex: pt === "next" ? ot + 1 : ot - st + 1,
                    slideRealIndex: pt === "next" ? nt.realIndex : void 0
                })
            }
            if (rt) {
                const pt = it * nt.params.grid.rows;
                it = nt.slides.find(ht => ht.getAttribute("data-swiper-slide-index") * 1 === pt).column
            } else
                it = nt.getSlideIndexByData(it)
        }
    return requestAnimationFrame( () => {
        nt.slideTo(it, $, et, tt)
    }
    ),
    nt
}
function slideNext(_e, $, et) {
    $ === void 0 && ($ = !0);
    const tt = this
      , {enabled: nt, params: rt, animating: it} = tt;
    if (!nt || tt.destroyed)
        return tt;
    typeof _e > "u" && (_e = tt.params.speed);
    let ot = rt.slidesPerGroup;
    rt.slidesPerView === "auto" && rt.slidesPerGroup === 1 && rt.slidesPerGroupAuto && (ot = Math.max(tt.slidesPerViewDynamic("current", !0), 1));
    const st = tt.activeIndex < rt.slidesPerGroupSkip ? 1 : ot
      , lt = tt.virtual && rt.virtual.enabled;
    if (rt.loop) {
        if (it && !lt && rt.loopPreventsSliding)
            return !1;
        if (tt.loopFix({
            direction: "next"
        }),
        tt._clientLeft = tt.wrapperEl.clientLeft,
        tt.activeIndex === tt.slides.length - 1 && rt.cssMode)
            return requestAnimationFrame( () => {
                tt.slideTo(tt.activeIndex + st, _e, $, et)
            }
            ),
            !0
    }
    return rt.rewind && tt.isEnd ? tt.slideTo(0, _e, $, et) : tt.slideTo(tt.activeIndex + st, _e, $, et)
}
function slidePrev(_e, $, et) {
    $ === void 0 && ($ = !0);
    const tt = this
      , {params: nt, snapGrid: rt, slidesGrid: it, rtlTranslate: ot, enabled: st, animating: lt} = tt;
    if (!st || tt.destroyed)
        return tt;
    typeof _e > "u" && (_e = tt.params.speed);
    const ct = tt.virtual && nt.virtual.enabled;
    if (nt.loop) {
        if (lt && !ct && nt.loopPreventsSliding)
            return !1;
        tt.loopFix({
            direction: "prev"
        }),
        tt._clientLeft = tt.wrapperEl.clientLeft
    }
    const dt = ot ? tt.translate : -tt.translate;
    function pt(wt) {
        return wt < 0 ? -Math.floor(Math.abs(wt)) : Math.floor(wt)
    }
    const ht = pt(dt)
      , mt = rt.map(wt => pt(wt))
      , yt = nt.freeMode && nt.freeMode.enabled;
    let Et = rt[mt.indexOf(ht) - 1];
    if (typeof Et > "u" && (nt.cssMode || yt)) {
        let wt;
        rt.forEach( (St, Ct) => {
            ht >= St && (wt = Ct)
        }
        ),
        typeof wt < "u" && (Et = yt ? rt[wt] : rt[wt > 0 ? wt - 1 : wt])
    }
    let _t = 0;
    if (typeof Et < "u" && (_t = it.indexOf(Et),
    _t < 0 && (_t = tt.activeIndex - 1),
    nt.slidesPerView === "auto" && nt.slidesPerGroup === 1 && nt.slidesPerGroupAuto && (_t = _t - tt.slidesPerViewDynamic("previous", !0) + 1,
    _t = Math.max(_t, 0))),
    nt.rewind && tt.isBeginning) {
        const wt = tt.params.virtual && tt.params.virtual.enabled && tt.virtual ? tt.virtual.slides.length - 1 : tt.slides.length - 1;
        return tt.slideTo(wt, _e, $, et)
    } else if (nt.loop && tt.activeIndex === 0 && nt.cssMode)
        return requestAnimationFrame( () => {
            tt.slideTo(_t, _e, $, et)
        }
        ),
        !0;
    return tt.slideTo(_t, _e, $, et)
}
function slideReset(_e, $, et) {
    $ === void 0 && ($ = !0);
    const tt = this;
    if (!tt.destroyed)
        return typeof _e > "u" && (_e = tt.params.speed),
        tt.slideTo(tt.activeIndex, _e, $, et)
}
function slideToClosest(_e, $, et, tt) {
    $ === void 0 && ($ = !0),
    tt === void 0 && (tt = .5);
    const nt = this;
    if (nt.destroyed)
        return;
    typeof _e > "u" && (_e = nt.params.speed);
    let rt = nt.activeIndex;
    const it = Math.min(nt.params.slidesPerGroupSkip, rt)
      , ot = it + Math.floor((rt - it) / nt.params.slidesPerGroup)
      , st = nt.rtlTranslate ? nt.translate : -nt.translate;
    if (st >= nt.snapGrid[ot]) {
        const lt = nt.snapGrid[ot]
          , ct = nt.snapGrid[ot + 1];
        st - lt > (ct - lt) * tt && (rt += nt.params.slidesPerGroup)
    } else {
        const lt = nt.snapGrid[ot - 1]
          , ct = nt.snapGrid[ot];
        st - lt <= (ct - lt) * tt && (rt -= nt.params.slidesPerGroup)
    }
    return rt = Math.max(rt, 0),
    rt = Math.min(rt, nt.slidesGrid.length - 1),
    nt.slideTo(rt, _e, $, et)
}
function slideToClickedSlide() {
    const _e = this;
    if (_e.destroyed)
        return;
    const {params: $, slidesEl: et} = _e
      , tt = $.slidesPerView === "auto" ? _e.slidesPerViewDynamic() : $.slidesPerView;
    let nt = _e.clickedIndex, rt;
    const it = _e.isElement ? "swiper-slide" : `.${$.slideClass}`;
    if ($.loop) {
        if (_e.animating)
            return;
        rt = parseInt(_e.clickedSlide.getAttribute("data-swiper-slide-index"), 10),
        $.centeredSlides ? nt < _e.loopedSlides - tt / 2 || nt > _e.slides.length - _e.loopedSlides + tt / 2 ? (_e.loopFix(),
        nt = _e.getSlideIndex(elementChildren(et, `${it}[data-swiper-slide-index="${rt}"]`)[0]),
        nextTick( () => {
            _e.slideTo(nt)
        }
        )) : _e.slideTo(nt) : nt > _e.slides.length - tt ? (_e.loopFix(),
        nt = _e.getSlideIndex(elementChildren(et, `${it}[data-swiper-slide-index="${rt}"]`)[0]),
        nextTick( () => {
            _e.slideTo(nt)
        }
        )) : _e.slideTo(nt)
    } else
        _e.slideTo(nt)
}
var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide
};
function loopCreate(_e) {
    const $ = this
      , {params: et, slidesEl: tt} = $;
    if (!et.loop || $.virtual && $.params.virtual.enabled)
        return;
    const nt = () => {
        elementChildren(tt, `.${et.slideClass}, swiper-slide`).forEach( (dt, pt) => {
            dt.setAttribute("data-swiper-slide-index", pt)
        }
        )
    }
      , rt = $.grid && et.grid && et.grid.rows > 1
      , it = et.slidesPerGroup * (rt ? et.grid.rows : 1)
      , ot = $.slides.length % it !== 0
      , st = rt && $.slides.length % et.grid.rows !== 0
      , lt = ct => {
        for (let dt = 0; dt < ct; dt += 1) {
            const pt = $.isElement ? createElement("swiper-slide", [et.slideBlankClass]) : createElement("div", [et.slideClass, et.slideBlankClass]);
            $.slidesEl.append(pt)
        }
    }
    ;
    if (ot) {
        if (et.loopAddBlankSlides) {
            const ct = it - $.slides.length % it;
            lt(ct),
            $.recalcSlides(),
            $.updateSlides()
        } else
            showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        nt()
    } else if (st) {
        if (et.loopAddBlankSlides) {
            const ct = et.grid.rows - $.slides.length % et.grid.rows;
            lt(ct),
            $.recalcSlides(),
            $.updateSlides()
        } else
            showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
        nt()
    } else
        nt();
    $.loopFix({
        slideRealIndex: _e,
        direction: et.centeredSlides ? void 0 : "next"
    })
}
function loopFix(_e) {
    let {slideRealIndex: $, slideTo: et=!0, direction: tt, setTranslate: nt, activeSlideIndex: rt, byController: it, byMousewheel: ot} = _e === void 0 ? {} : _e;
    const st = this;
    if (!st.params.loop)
        return;
    st.emit("beforeLoopFix");
    const {slides: lt, allowSlidePrev: ct, allowSlideNext: dt, slidesEl: pt, params: ht} = st
      , {centeredSlides: mt} = ht;
    if (st.allowSlidePrev = !0,
    st.allowSlideNext = !0,
    st.virtual && ht.virtual.enabled) {
        et && (!ht.centeredSlides && st.snapIndex === 0 ? st.slideTo(st.virtual.slides.length, 0, !1, !0) : ht.centeredSlides && st.snapIndex < ht.slidesPerView ? st.slideTo(st.virtual.slides.length + st.snapIndex, 0, !1, !0) : st.snapIndex === st.snapGrid.length - 1 && st.slideTo(st.virtual.slidesBefore, 0, !1, !0)),
        st.allowSlidePrev = ct,
        st.allowSlideNext = dt,
        st.emit("loopFix");
        return
    }
    let yt = ht.slidesPerView;
    yt === "auto" ? yt = st.slidesPerViewDynamic() : (yt = Math.ceil(parseFloat(ht.slidesPerView, 10)),
    mt && yt % 2 === 0 && (yt = yt + 1));
    const Et = ht.slidesPerGroupAuto ? yt : ht.slidesPerGroup;
    let _t = Et;
    _t % Et !== 0 && (_t += Et - _t % Et),
    _t += ht.loopAdditionalSlides,
    st.loopedSlides = _t;
    const wt = st.grid && ht.grid && ht.grid.rows > 1;
    lt.length < yt + _t ? showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : wt && ht.grid.fill === "row" && showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
    const St = []
      , Ct = [];
    let Nt = st.activeIndex;
    typeof rt > "u" ? rt = st.getSlideIndex(lt.find(zt => zt.classList.contains(ht.slideActiveClass))) : Nt = rt;
    const Lt = tt === "next" || !tt
      , kt = tt === "prev" || !tt;
    let Ut = 0
      , Jt = 0;
    const Pt = wt ? Math.ceil(lt.length / ht.grid.rows) : lt.length
      , rn = (wt ? lt[rt].column : rt) + (mt && typeof nt > "u" ? -yt / 2 + .5 : 0);
    if (rn < _t) {
        Ut = Math.max(_t - rn, Et);
        for (let zt = 0; zt < _t - rn; zt += 1) {
            const xt = zt - Math.floor(zt / Pt) * Pt;
            if (wt) {
                const $t = Pt - xt - 1;
                for (let Dt = lt.length - 1; Dt >= 0; Dt -= 1)
                    lt[Dt].column === $t && St.push(Dt)
            } else
                St.push(Pt - xt - 1)
        }
    } else if (rn + yt > Pt - _t) {
        Jt = Math.max(rn - (Pt - _t * 2), Et);
        for (let zt = 0; zt < Jt; zt += 1) {
            const xt = zt - Math.floor(zt / Pt) * Pt;
            wt ? lt.forEach( ($t, Dt) => {
                $t.column === xt && Ct.push(Dt)
            }
            ) : Ct.push(xt)
        }
    }
    if (st.__preventObserver__ = !0,
    requestAnimationFrame( () => {
        st.__preventObserver__ = !1
    }
    ),
    kt && St.forEach(zt => {
        lt[zt].swiperLoopMoveDOM = !0,
        pt.prepend(lt[zt]),
        lt[zt].swiperLoopMoveDOM = !1
    }
    ),
    Lt && Ct.forEach(zt => {
        lt[zt].swiperLoopMoveDOM = !0,
        pt.append(lt[zt]),
        lt[zt].swiperLoopMoveDOM = !1
    }
    ),
    st.recalcSlides(),
    ht.slidesPerView === "auto" ? st.updateSlides() : wt && (St.length > 0 && kt || Ct.length > 0 && Lt) && st.slides.forEach( (zt, xt) => {
        st.grid.updateSlide(xt, zt, st.slides)
    }
    ),
    ht.watchSlidesProgress && st.updateSlidesOffset(),
    et) {
        if (St.length > 0 && kt) {
            if (typeof $ > "u") {
                const zt = st.slidesGrid[Nt]
                  , $t = st.slidesGrid[Nt + Ut] - zt;
                ot ? st.setTranslate(st.translate - $t) : (st.slideTo(Nt + Math.ceil(Ut), 0, !1, !0),
                nt && (st.touchEventsData.startTranslate = st.touchEventsData.startTranslate - $t,
                st.touchEventsData.currentTranslate = st.touchEventsData.currentTranslate - $t))
            } else if (nt) {
                const zt = wt ? St.length / ht.grid.rows : St.length;
                st.slideTo(st.activeIndex + zt, 0, !1, !0),
                st.touchEventsData.currentTranslate = st.translate
            }
        } else if (Ct.length > 0 && Lt)
            if (typeof $ > "u") {
                const zt = st.slidesGrid[Nt]
                  , $t = st.slidesGrid[Nt - Jt] - zt;
                ot ? st.setTranslate(st.translate - $t) : (st.slideTo(Nt - Jt, 0, !1, !0),
                nt && (st.touchEventsData.startTranslate = st.touchEventsData.startTranslate - $t,
                st.touchEventsData.currentTranslate = st.touchEventsData.currentTranslate - $t))
            } else {
                const zt = wt ? Ct.length / ht.grid.rows : Ct.length;
                st.slideTo(st.activeIndex - zt, 0, !1, !0)
            }
    }
    if (st.allowSlidePrev = ct,
    st.allowSlideNext = dt,
    st.controller && st.controller.control && !it) {
        const zt = {
            slideRealIndex: $,
            direction: tt,
            setTranslate: nt,
            activeSlideIndex: rt,
            byController: !0
        };
        Array.isArray(st.controller.control) ? st.controller.control.forEach(xt => {
            !xt.destroyed && xt.params.loop && xt.loopFix({
                ...zt,
                slideTo: xt.params.slidesPerView === ht.slidesPerView ? et : !1
            })
        }
        ) : st.controller.control instanceof st.constructor && st.controller.control.params.loop && st.controller.control.loopFix({
            ...zt,
            slideTo: st.controller.control.params.slidesPerView === ht.slidesPerView ? et : !1
        })
    }
    st.emit("loopFix")
}
function loopDestroy() {
    const _e = this
      , {params: $, slidesEl: et} = _e;
    if (!$.loop || _e.virtual && _e.params.virtual.enabled)
        return;
    _e.recalcSlides();
    const tt = [];
    _e.slides.forEach(nt => {
        const rt = typeof nt.swiperSlideIndex > "u" ? nt.getAttribute("data-swiper-slide-index") * 1 : nt.swiperSlideIndex;
        tt[rt] = nt
    }
    ),
    _e.slides.forEach(nt => {
        nt.removeAttribute("data-swiper-slide-index")
    }
    ),
    tt.forEach(nt => {
        et.append(nt)
    }
    ),
    _e.recalcSlides(),
    _e.slideTo(_e.realIndex, 0)
}
var loop = {
    loopCreate,
    loopFix,
    loopDestroy
};
function setGrabCursor(_e) {
    const $ = this;
    if (!$.params.simulateTouch || $.params.watchOverflow && $.isLocked || $.params.cssMode)
        return;
    const et = $.params.touchEventsTarget === "container" ? $.el : $.wrapperEl;
    $.isElement && ($.__preventObserver__ = !0),
    et.style.cursor = "move",
    et.style.cursor = _e ? "grabbing" : "grab",
    $.isElement && requestAnimationFrame( () => {
        $.__preventObserver__ = !1
    }
    )
}
function unsetGrabCursor() {
    const _e = this;
    _e.params.watchOverflow && _e.isLocked || _e.params.cssMode || (_e.isElement && (_e.__preventObserver__ = !0),
    _e[_e.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "",
    _e.isElement && requestAnimationFrame( () => {
        _e.__preventObserver__ = !1
    }
    ))
}
var grabCursor = {
    setGrabCursor,
    unsetGrabCursor
};
function closestElement(_e, $) {
    $ === void 0 && ($ = this);
    function et(tt) {
        if (!tt || tt === getDocument() || tt === getWindow())
            return null;
        tt.assignedSlot && (tt = tt.assignedSlot);
        const nt = tt.closest(_e);
        return !nt && !tt.getRootNode ? null : nt || et(tt.getRootNode().host)
    }
    return et($)
}
function preventEdgeSwipe(_e, $, et) {
    const tt = getWindow()
      , {params: nt} = _e
      , rt = nt.edgeSwipeDetection
      , it = nt.edgeSwipeThreshold;
    return rt && (et <= it || et >= tt.innerWidth - it) ? rt === "prevent" ? ($.preventDefault(),
    !0) : !1 : !0
}
function onTouchStart(_e) {
    const $ = this
      , et = getDocument();
    let tt = _e;
    tt.originalEvent && (tt = tt.originalEvent);
    const nt = $.touchEventsData;
    if (tt.type === "pointerdown") {
        if (nt.pointerId !== null && nt.pointerId !== tt.pointerId)
            return;
        nt.pointerId = tt.pointerId
    } else
        tt.type === "touchstart" && tt.targetTouches.length === 1 && (nt.touchId = tt.targetTouches[0].identifier);
    if (tt.type === "touchstart") {
        preventEdgeSwipe($, tt, tt.targetTouches[0].pageX);
        return
    }
    const {params: rt, touches: it, enabled: ot} = $;
    if (!ot || !rt.simulateTouch && tt.pointerType === "mouse" || $.animating && rt.preventInteractionOnTransition)
        return;
    !$.animating && rt.cssMode && rt.loop && $.loopFix();
    let st = tt.target;
    if (rt.touchEventsTarget === "wrapper" && !elementIsChildOf(st, $.wrapperEl) || "which"in tt && tt.which === 3 || "button"in tt && tt.button > 0 || nt.isTouched && nt.isMoved)
        return;
    const lt = !!rt.noSwipingClass && rt.noSwipingClass !== ""
      , ct = tt.composedPath ? tt.composedPath() : tt.path;
    lt && tt.target && tt.target.shadowRoot && ct && (st = ct[0]);
    const dt = rt.noSwipingSelector ? rt.noSwipingSelector : `.${rt.noSwipingClass}`
      , pt = !!(tt.target && tt.target.shadowRoot);
    if (rt.noSwiping && (pt ? closestElement(dt, st) : st.closest(dt))) {
        $.allowClick = !0;
        return
    }
    if (rt.swipeHandler && !st.closest(rt.swipeHandler))
        return;
    it.currentX = tt.pageX,
    it.currentY = tt.pageY;
    const ht = it.currentX
      , mt = it.currentY;
    if (!preventEdgeSwipe($, tt, ht))
        return;
    Object.assign(nt, {
        isTouched: !0,
        isMoved: !1,
        allowTouchCallbacks: !0,
        isScrolling: void 0,
        startMoving: void 0
    }),
    it.startX = ht,
    it.startY = mt,
    nt.touchStartTime = now(),
    $.allowClick = !0,
    $.updateSize(),
    $.swipeDirection = void 0,
    rt.threshold > 0 && (nt.allowThresholdMove = !1);
    let yt = !0;
    st.matches(nt.focusableElements) && (yt = !1,
    st.nodeName === "SELECT" && (nt.isTouched = !1)),
    et.activeElement && et.activeElement.matches(nt.focusableElements) && et.activeElement !== st && (tt.pointerType === "mouse" || tt.pointerType !== "mouse" && !st.matches(nt.focusableElements)) && et.activeElement.blur();
    const Et = yt && $.allowTouchMove && rt.touchStartPreventDefault;
    (rt.touchStartForcePreventDefault || Et) && !st.isContentEditable && tt.preventDefault(),
    rt.freeMode && rt.freeMode.enabled && $.freeMode && $.animating && !rt.cssMode && $.freeMode.onTouchStart(),
    $.emit("touchStart", tt)
}
function onTouchMove(_e) {
    const $ = getDocument()
      , et = this
      , tt = et.touchEventsData
      , {params: nt, touches: rt, rtlTranslate: it, enabled: ot} = et;
    if (!ot || !nt.simulateTouch && _e.pointerType === "mouse")
        return;
    let st = _e;
    if (st.originalEvent && (st = st.originalEvent),
    st.type === "pointermove" && (tt.touchId !== null || st.pointerId !== tt.pointerId))
        return;
    let lt;
    if (st.type === "touchmove") {
        if (lt = [...st.changedTouches].find(Nt => Nt.identifier === tt.touchId),
        !lt || lt.identifier !== tt.touchId)
            return
    } else
        lt = st;
    if (!tt.isTouched) {
        tt.startMoving && tt.isScrolling && et.emit("touchMoveOpposite", st);
        return
    }
    const ct = lt.pageX
      , dt = lt.pageY;
    if (st.preventedByNestedSwiper) {
        rt.startX = ct,
        rt.startY = dt;
        return
    }
    if (!et.allowTouchMove) {
        st.target.matches(tt.focusableElements) || (et.allowClick = !1),
        tt.isTouched && (Object.assign(rt, {
            startX: ct,
            startY: dt,
            currentX: ct,
            currentY: dt
        }),
        tt.touchStartTime = now());
        return
    }
    if (nt.touchReleaseOnEdges && !nt.loop) {
        if (et.isVertical()) {
            if (dt < rt.startY && et.translate <= et.maxTranslate() || dt > rt.startY && et.translate >= et.minTranslate()) {
                tt.isTouched = !1,
                tt.isMoved = !1;
                return
            }
        } else if (ct < rt.startX && et.translate <= et.maxTranslate() || ct > rt.startX && et.translate >= et.minTranslate())
            return
    }
    if ($.activeElement && $.activeElement.matches(tt.focusableElements) && $.activeElement !== st.target && st.pointerType !== "mouse" && $.activeElement.blur(),
    $.activeElement && st.target === $.activeElement && st.target.matches(tt.focusableElements)) {
        tt.isMoved = !0,
        et.allowClick = !1;
        return
    }
    tt.allowTouchCallbacks && et.emit("touchMove", st),
    rt.previousX = rt.currentX,
    rt.previousY = rt.currentY,
    rt.currentX = ct,
    rt.currentY = dt;
    const pt = rt.currentX - rt.startX
      , ht = rt.currentY - rt.startY;
    if (et.params.threshold && Math.sqrt(pt ** 2 + ht ** 2) < et.params.threshold)
        return;
    if (typeof tt.isScrolling > "u") {
        let Nt;
        et.isHorizontal() && rt.currentY === rt.startY || et.isVertical() && rt.currentX === rt.startX ? tt.isScrolling = !1 : pt * pt + ht * ht >= 25 && (Nt = Math.atan2(Math.abs(ht), Math.abs(pt)) * 180 / Math.PI,
        tt.isScrolling = et.isHorizontal() ? Nt > nt.touchAngle : 90 - Nt > nt.touchAngle)
    }
    if (tt.isScrolling && et.emit("touchMoveOpposite", st),
    typeof tt.startMoving > "u" && (rt.currentX !== rt.startX || rt.currentY !== rt.startY) && (tt.startMoving = !0),
    tt.isScrolling || st.type === "touchmove" && tt.preventTouchMoveFromPointerMove) {
        tt.isTouched = !1;
        return
    }
    if (!tt.startMoving)
        return;
    et.allowClick = !1,
    !nt.cssMode && st.cancelable && st.preventDefault(),
    nt.touchMoveStopPropagation && !nt.nested && st.stopPropagation();
    let mt = et.isHorizontal() ? pt : ht
      , yt = et.isHorizontal() ? rt.currentX - rt.previousX : rt.currentY - rt.previousY;
    nt.oneWayMovement && (mt = Math.abs(mt) * (it ? 1 : -1),
    yt = Math.abs(yt) * (it ? 1 : -1)),
    rt.diff = mt,
    mt *= nt.touchRatio,
    it && (mt = -mt,
    yt = -yt);
    const Et = et.touchesDirection;
    et.swipeDirection = mt > 0 ? "prev" : "next",
    et.touchesDirection = yt > 0 ? "prev" : "next";
    const _t = et.params.loop && !nt.cssMode
      , wt = et.touchesDirection === "next" && et.allowSlideNext || et.touchesDirection === "prev" && et.allowSlidePrev;
    if (!tt.isMoved) {
        if (_t && wt && et.loopFix({
            direction: et.swipeDirection
        }),
        tt.startTranslate = et.getTranslate(),
        et.setTransition(0),
        et.animating) {
            const Nt = new window.CustomEvent("transitionend",{
                bubbles: !0,
                cancelable: !0,
                detail: {
                    bySwiperTouchMove: !0
                }
            });
            et.wrapperEl.dispatchEvent(Nt)
        }
        tt.allowMomentumBounce = !1,
        nt.grabCursor && (et.allowSlideNext === !0 || et.allowSlidePrev === !0) && et.setGrabCursor(!0),
        et.emit("sliderFirstMove", st)
    }
    if (new Date().getTime(),
    nt._loopSwapReset !== !1 && tt.isMoved && tt.allowThresholdMove && Et !== et.touchesDirection && _t && wt && Math.abs(mt) >= 1) {
        Object.assign(rt, {
            startX: ct,
            startY: dt,
            currentX: ct,
            currentY: dt,
            startTranslate: tt.currentTranslate
        }),
        tt.loopSwapReset = !0,
        tt.startTranslate = tt.currentTranslate;
        return
    }
    et.emit("sliderMove", st),
    tt.isMoved = !0,
    tt.currentTranslate = mt + tt.startTranslate;
    let St = !0
      , Ct = nt.resistanceRatio;
    if (nt.touchReleaseOnEdges && (Ct = 0),
    mt > 0 ? (_t && wt && tt.allowThresholdMove && tt.currentTranslate > (nt.centeredSlides ? et.minTranslate() - et.slidesSizesGrid[et.activeIndex + 1] - (nt.slidesPerView !== "auto" && et.slides.length - nt.slidesPerView >= 2 ? et.slidesSizesGrid[et.activeIndex + 1] + et.params.spaceBetween : 0) - et.params.spaceBetween : et.minTranslate()) && et.loopFix({
        direction: "prev",
        setTranslate: !0,
        activeSlideIndex: 0
    }),
    tt.currentTranslate > et.minTranslate() && (St = !1,
    nt.resistance && (tt.currentTranslate = et.minTranslate() - 1 + (-et.minTranslate() + tt.startTranslate + mt) ** Ct))) : mt < 0 && (_t && wt && tt.allowThresholdMove && tt.currentTranslate < (nt.centeredSlides ? et.maxTranslate() + et.slidesSizesGrid[et.slidesSizesGrid.length - 1] + et.params.spaceBetween + (nt.slidesPerView !== "auto" && et.slides.length - nt.slidesPerView >= 2 ? et.slidesSizesGrid[et.slidesSizesGrid.length - 1] + et.params.spaceBetween : 0) : et.maxTranslate()) && et.loopFix({
        direction: "next",
        setTranslate: !0,
        activeSlideIndex: et.slides.length - (nt.slidesPerView === "auto" ? et.slidesPerViewDynamic() : Math.ceil(parseFloat(nt.slidesPerView, 10)))
    }),
    tt.currentTranslate < et.maxTranslate() && (St = !1,
    nt.resistance && (tt.currentTranslate = et.maxTranslate() + 1 - (et.maxTranslate() - tt.startTranslate - mt) ** Ct))),
    St && (st.preventedByNestedSwiper = !0),
    !et.allowSlideNext && et.swipeDirection === "next" && tt.currentTranslate < tt.startTranslate && (tt.currentTranslate = tt.startTranslate),
    !et.allowSlidePrev && et.swipeDirection === "prev" && tt.currentTranslate > tt.startTranslate && (tt.currentTranslate = tt.startTranslate),
    !et.allowSlidePrev && !et.allowSlideNext && (tt.currentTranslate = tt.startTranslate),
    nt.threshold > 0)
        if (Math.abs(mt) > nt.threshold || tt.allowThresholdMove) {
            if (!tt.allowThresholdMove) {
                tt.allowThresholdMove = !0,
                rt.startX = rt.currentX,
                rt.startY = rt.currentY,
                tt.currentTranslate = tt.startTranslate,
                rt.diff = et.isHorizontal() ? rt.currentX - rt.startX : rt.currentY - rt.startY;
                return
            }
        } else {
            tt.currentTranslate = tt.startTranslate;
            return
        }
    !nt.followFinger || nt.cssMode || ((nt.freeMode && nt.freeMode.enabled && et.freeMode || nt.watchSlidesProgress) && (et.updateActiveIndex(),
    et.updateSlidesClasses()),
    nt.freeMode && nt.freeMode.enabled && et.freeMode && et.freeMode.onTouchMove(),
    et.updateProgress(tt.currentTranslate),
    et.setTranslate(tt.currentTranslate))
}
function onTouchEnd(_e) {
    const $ = this
      , et = $.touchEventsData;
    let tt = _e;
    tt.originalEvent && (tt = tt.originalEvent);
    let nt;
    if (tt.type === "touchend" || tt.type === "touchcancel") {
        if (nt = [...tt.changedTouches].find(Nt => Nt.identifier === et.touchId),
        !nt || nt.identifier !== et.touchId)
            return
    } else {
        if (et.touchId !== null || tt.pointerId !== et.pointerId)
            return;
        nt = tt
    }
    if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(tt.type) && !(["pointercancel", "contextmenu"].includes(tt.type) && ($.browser.isSafari || $.browser.isWebView)))
        return;
    et.pointerId = null,
    et.touchId = null;
    const {params: it, touches: ot, rtlTranslate: st, slidesGrid: lt, enabled: ct} = $;
    if (!ct || !it.simulateTouch && tt.pointerType === "mouse")
        return;
    if (et.allowTouchCallbacks && $.emit("touchEnd", tt),
    et.allowTouchCallbacks = !1,
    !et.isTouched) {
        et.isMoved && it.grabCursor && $.setGrabCursor(!1),
        et.isMoved = !1,
        et.startMoving = !1;
        return
    }
    it.grabCursor && et.isMoved && et.isTouched && ($.allowSlideNext === !0 || $.allowSlidePrev === !0) && $.setGrabCursor(!1);
    const dt = now()
      , pt = dt - et.touchStartTime;
    if ($.allowClick) {
        const Nt = tt.path || tt.composedPath && tt.composedPath();
        $.updateClickedSlide(Nt && Nt[0] || tt.target, Nt),
        $.emit("tap click", tt),
        pt < 300 && dt - et.lastClickTime < 300 && $.emit("doubleTap doubleClick", tt)
    }
    if (et.lastClickTime = now(),
    nextTick( () => {
        $.destroyed || ($.allowClick = !0)
    }
    ),
    !et.isTouched || !et.isMoved || !$.swipeDirection || ot.diff === 0 && !et.loopSwapReset || et.currentTranslate === et.startTranslate && !et.loopSwapReset) {
        et.isTouched = !1,
        et.isMoved = !1,
        et.startMoving = !1;
        return
    }
    et.isTouched = !1,
    et.isMoved = !1,
    et.startMoving = !1;
    let ht;
    if (it.followFinger ? ht = st ? $.translate : -$.translate : ht = -et.currentTranslate,
    it.cssMode)
        return;
    if (it.freeMode && it.freeMode.enabled) {
        $.freeMode.onTouchEnd({
            currentPos: ht
        });
        return
    }
    const mt = ht >= -$.maxTranslate() && !$.params.loop;
    let yt = 0
      , Et = $.slidesSizesGrid[0];
    for (let Nt = 0; Nt < lt.length; Nt += Nt < it.slidesPerGroupSkip ? 1 : it.slidesPerGroup) {
        const Lt = Nt < it.slidesPerGroupSkip - 1 ? 1 : it.slidesPerGroup;
        typeof lt[Nt + Lt] < "u" ? (mt || ht >= lt[Nt] && ht < lt[Nt + Lt]) && (yt = Nt,
        Et = lt[Nt + Lt] - lt[Nt]) : (mt || ht >= lt[Nt]) && (yt = Nt,
        Et = lt[lt.length - 1] - lt[lt.length - 2])
    }
    let _t = null
      , wt = null;
    it.rewind && ($.isBeginning ? wt = it.virtual && it.virtual.enabled && $.virtual ? $.virtual.slides.length - 1 : $.slides.length - 1 : $.isEnd && (_t = 0));
    const St = (ht - lt[yt]) / Et
      , Ct = yt < it.slidesPerGroupSkip - 1 ? 1 : it.slidesPerGroup;
    if (pt > it.longSwipesMs) {
        if (!it.longSwipes) {
            $.slideTo($.activeIndex);
            return
        }
        $.swipeDirection === "next" && (St >= it.longSwipesRatio ? $.slideTo(it.rewind && $.isEnd ? _t : yt + Ct) : $.slideTo(yt)),
        $.swipeDirection === "prev" && (St > 1 - it.longSwipesRatio ? $.slideTo(yt + Ct) : wt !== null && St < 0 && Math.abs(St) > it.longSwipesRatio ? $.slideTo(wt) : $.slideTo(yt))
    } else {
        if (!it.shortSwipes) {
            $.slideTo($.activeIndex);
            return
        }
        $.navigation && (tt.target === $.navigation.nextEl || tt.target === $.navigation.prevEl) ? tt.target === $.navigation.nextEl ? $.slideTo(yt + Ct) : $.slideTo(yt) : ($.swipeDirection === "next" && $.slideTo(_t !== null ? _t : yt + Ct),
        $.swipeDirection === "prev" && $.slideTo(wt !== null ? wt : yt))
    }
}
function onResize() {
    const _e = this
      , {params: $, el: et} = _e;
    if (et && et.offsetWidth === 0)
        return;
    $.breakpoints && _e.setBreakpoint();
    const {allowSlideNext: tt, allowSlidePrev: nt, snapGrid: rt} = _e
      , it = _e.virtual && _e.params.virtual.enabled;
    _e.allowSlideNext = !0,
    _e.allowSlidePrev = !0,
    _e.updateSize(),
    _e.updateSlides(),
    _e.updateSlidesClasses();
    const ot = it && $.loop;
    ($.slidesPerView === "auto" || $.slidesPerView > 1) && _e.isEnd && !_e.isBeginning && !_e.params.centeredSlides && !ot ? _e.slideTo(_e.slides.length - 1, 0, !1, !0) : _e.params.loop && !it ? _e.slideToLoop(_e.realIndex, 0, !1, !0) : _e.slideTo(_e.activeIndex, 0, !1, !0),
    _e.autoplay && _e.autoplay.running && _e.autoplay.paused && (clearTimeout(_e.autoplay.resizeTimeout),
    _e.autoplay.resizeTimeout = setTimeout( () => {
        _e.autoplay && _e.autoplay.running && _e.autoplay.paused && _e.autoplay.resume()
    }
    , 500)),
    _e.allowSlidePrev = nt,
    _e.allowSlideNext = tt,
    _e.params.watchOverflow && rt !== _e.snapGrid && _e.checkOverflow()
}
function onClick(_e) {
    const $ = this;
    $.enabled && ($.allowClick || ($.params.preventClicks && _e.preventDefault(),
    $.params.preventClicksPropagation && $.animating && (_e.stopPropagation(),
    _e.stopImmediatePropagation())))
}
function onScroll() {
    const _e = this
      , {wrapperEl: $, rtlTranslate: et, enabled: tt} = _e;
    if (!tt)
        return;
    _e.previousTranslate = _e.translate,
    _e.isHorizontal() ? _e.translate = -$.scrollLeft : _e.translate = -$.scrollTop,
    _e.translate === 0 && (_e.translate = 0),
    _e.updateActiveIndex(),
    _e.updateSlidesClasses();
    let nt;
    const rt = _e.maxTranslate() - _e.minTranslate();
    rt === 0 ? nt = 0 : nt = (_e.translate - _e.minTranslate()) / rt,
    nt !== _e.progress && _e.updateProgress(et ? -_e.translate : _e.translate),
    _e.emit("setTranslate", _e.translate, !1)
}
function onLoad(_e) {
    const $ = this;
    processLazyPreloader($, _e.target),
    !($.params.cssMode || $.params.slidesPerView !== "auto" && !$.params.autoHeight) && $.update()
}
function onDocumentTouchStart() {
    const _e = this;
    _e.documentTouchHandlerProceeded || (_e.documentTouchHandlerProceeded = !0,
    _e.params.touchReleaseOnEdges && (_e.el.style.touchAction = "auto"))
}
const events = (_e, $) => {
    const et = getDocument()
      , {params: tt, el: nt, wrapperEl: rt, device: it} = _e
      , ot = !!tt.nested
      , st = $ === "on" ? "addEventListener" : "removeEventListener"
      , lt = $;
    !nt || typeof nt == "string" || (et[st]("touchstart", _e.onDocumentTouchStart, {
        passive: !1,
        capture: ot
    }),
    nt[st]("touchstart", _e.onTouchStart, {
        passive: !1
    }),
    nt[st]("pointerdown", _e.onTouchStart, {
        passive: !1
    }),
    et[st]("touchmove", _e.onTouchMove, {
        passive: !1,
        capture: ot
    }),
    et[st]("pointermove", _e.onTouchMove, {
        passive: !1,
        capture: ot
    }),
    et[st]("touchend", _e.onTouchEnd, {
        passive: !0
    }),
    et[st]("pointerup", _e.onTouchEnd, {
        passive: !0
    }),
    et[st]("pointercancel", _e.onTouchEnd, {
        passive: !0
    }),
    et[st]("touchcancel", _e.onTouchEnd, {
        passive: !0
    }),
    et[st]("pointerout", _e.onTouchEnd, {
        passive: !0
    }),
    et[st]("pointerleave", _e.onTouchEnd, {
        passive: !0
    }),
    et[st]("contextmenu", _e.onTouchEnd, {
        passive: !0
    }),
    (tt.preventClicks || tt.preventClicksPropagation) && nt[st]("click", _e.onClick, !0),
    tt.cssMode && rt[st]("scroll", _e.onScroll),
    tt.updateOnWindowResize ? _e[lt](it.ios || it.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : _e[lt]("observerUpdate", onResize, !0),
    nt[st]("load", _e.onLoad, {
        capture: !0
    }))
}
;
function attachEvents() {
    const _e = this
      , {params: $} = _e;
    _e.onTouchStart = onTouchStart.bind(_e),
    _e.onTouchMove = onTouchMove.bind(_e),
    _e.onTouchEnd = onTouchEnd.bind(_e),
    _e.onDocumentTouchStart = onDocumentTouchStart.bind(_e),
    $.cssMode && (_e.onScroll = onScroll.bind(_e)),
    _e.onClick = onClick.bind(_e),
    _e.onLoad = onLoad.bind(_e),
    events(_e, "on")
}
function detachEvents() {
    events(this, "off")
}
var events$1 = {
    attachEvents,
    detachEvents
};
const isGridEnabled = (_e, $) => _e.grid && $.grid && $.grid.rows > 1;
function setBreakpoint() {
    const _e = this
      , {realIndex: $, initialized: et, params: tt, el: nt} = _e
      , rt = tt.breakpoints;
    if (!rt || rt && Object.keys(rt).length === 0)
        return;
    const it = getDocument()
      , ot = tt.breakpointsBase === "window" || !tt.breakpointsBase ? tt.breakpointsBase : "container"
      , st = ["window", "container"].includes(tt.breakpointsBase) || !tt.breakpointsBase ? _e.el : it.querySelector(tt.breakpointsBase)
      , lt = _e.getBreakpoint(rt, ot, st);
    if (!lt || _e.currentBreakpoint === lt)
        return;
    const dt = (lt in rt ? rt[lt] : void 0) || _e.originalParams
      , pt = isGridEnabled(_e, tt)
      , ht = isGridEnabled(_e, dt)
      , mt = _e.params.grabCursor
      , yt = dt.grabCursor
      , Et = tt.enabled;
    pt && !ht ? (nt.classList.remove(`${tt.containerModifierClass}grid`, `${tt.containerModifierClass}grid-column`),
    _e.emitContainerClasses()) : !pt && ht && (nt.classList.add(`${tt.containerModifierClass}grid`),
    (dt.grid.fill && dt.grid.fill === "column" || !dt.grid.fill && tt.grid.fill === "column") && nt.classList.add(`${tt.containerModifierClass}grid-column`),
    _e.emitContainerClasses()),
    mt && !yt ? _e.unsetGrabCursor() : !mt && yt && _e.setGrabCursor(),
    ["navigation", "pagination", "scrollbar"].forEach(Lt => {
        if (typeof dt[Lt] > "u")
            return;
        const kt = tt[Lt] && tt[Lt].enabled
          , Ut = dt[Lt] && dt[Lt].enabled;
        kt && !Ut && _e[Lt].disable(),
        !kt && Ut && _e[Lt].enable()
    }
    );
    const _t = dt.direction && dt.direction !== tt.direction
      , wt = tt.loop && (dt.slidesPerView !== tt.slidesPerView || _t)
      , St = tt.loop;
    _t && et && _e.changeDirection(),
    extend$1(_e.params, dt);
    const Ct = _e.params.enabled
      , Nt = _e.params.loop;
    Object.assign(_e, {
        allowTouchMove: _e.params.allowTouchMove,
        allowSlideNext: _e.params.allowSlideNext,
        allowSlidePrev: _e.params.allowSlidePrev
    }),
    Et && !Ct ? _e.disable() : !Et && Ct && _e.enable(),
    _e.currentBreakpoint = lt,
    _e.emit("_beforeBreakpoint", dt),
    et && (wt ? (_e.loopDestroy(),
    _e.loopCreate($),
    _e.updateSlides()) : !St && Nt ? (_e.loopCreate($),
    _e.updateSlides()) : St && !Nt && _e.loopDestroy()),
    _e.emit("breakpoint", dt)
}
function getBreakpoint(_e, $, et) {
    if ($ === void 0 && ($ = "window"),
    !_e || $ === "container" && !et)
        return;
    let tt = !1;
    const nt = getWindow()
      , rt = $ === "window" ? nt.innerHeight : et.clientHeight
      , it = Object.keys(_e).map(ot => {
        if (typeof ot == "string" && ot.indexOf("@") === 0) {
            const st = parseFloat(ot.substr(1));
            return {
                value: rt * st,
                point: ot
            }
        }
        return {
            value: ot,
            point: ot
        }
    }
    );
    it.sort( (ot, st) => parseInt(ot.value, 10) - parseInt(st.value, 10));
    for (let ot = 0; ot < it.length; ot += 1) {
        const {point: st, value: lt} = it[ot];
        $ === "window" ? nt.matchMedia(`(min-width: ${lt}px)`).matches && (tt = st) : lt <= et.clientWidth && (tt = st)
    }
    return tt || "max"
}
var breakpoints = {
    setBreakpoint,
    getBreakpoint
};
function prepareClasses(_e, $) {
    const et = [];
    return _e.forEach(tt => {
        typeof tt == "object" ? Object.keys(tt).forEach(nt => {
            tt[nt] && et.push($ + nt)
        }
        ) : typeof tt == "string" && et.push($ + tt)
    }
    ),
    et
}
function addClasses() {
    const _e = this
      , {classNames: $, params: et, rtl: tt, el: nt, device: rt} = _e
      , it = prepareClasses(["initialized", et.direction, {
        "free-mode": _e.params.freeMode && et.freeMode.enabled
    }, {
        autoheight: et.autoHeight
    }, {
        rtl: tt
    }, {
        grid: et.grid && et.grid.rows > 1
    }, {
        "grid-column": et.grid && et.grid.rows > 1 && et.grid.fill === "column"
    }, {
        android: rt.android
    }, {
        ios: rt.ios
    }, {
        "css-mode": et.cssMode
    }, {
        centered: et.cssMode && et.centeredSlides
    }, {
        "watch-progress": et.watchSlidesProgress
    }], et.containerModifierClass);
    $.push(...it),
    nt.classList.add(...$),
    _e.emitContainerClasses()
}
function removeClasses() {
    const _e = this
      , {el: $, classNames: et} = _e;
    !$ || typeof $ == "string" || ($.classList.remove(...et),
    _e.emitContainerClasses())
}
var classes = {
    addClasses,
    removeClasses
};
function checkOverflow() {
    const _e = this
      , {isLocked: $, params: et} = _e
      , {slidesOffsetBefore: tt} = et;
    if (tt) {
        const nt = _e.slides.length - 1
          , rt = _e.slidesGrid[nt] + _e.slidesSizesGrid[nt] + tt * 2;
        _e.isLocked = _e.size > rt
    } else
        _e.isLocked = _e.snapGrid.length === 1;
    et.allowSlideNext === !0 && (_e.allowSlideNext = !_e.isLocked),
    et.allowSlidePrev === !0 && (_e.allowSlidePrev = !_e.isLocked),
    $ && $ !== _e.isLocked && (_e.isEnd = !1),
    $ !== _e.isLocked && _e.emit(_e.isLocked ? "lock" : "unlock")
}
var checkOverflow$1 = {
    checkOverflow
}
  , defaults = {
    init: !0,
    direction: "horizontal",
    oneWayMovement: !1,
    swiperElementNodeName: "SWIPER-CONTAINER",
    touchEventsTarget: "wrapper",
    initialSlide: 0,
    speed: 300,
    cssMode: !1,
    updateOnWindowResize: !0,
    resizeObserver: !0,
    nested: !1,
    createElements: !1,
    eventsPrefix: "swiper",
    enabled: !0,
    focusableElements: "input, select, option, textarea, button, video, label",
    width: null,
    height: null,
    preventInteractionOnTransition: !1,
    userAgent: null,
    url: null,
    edgeSwipeDetection: !1,
    edgeSwipeThreshold: 20,
    autoHeight: !1,
    setWrapperSize: !1,
    virtualTranslate: !1,
    effect: "slide",
    breakpoints: void 0,
    breakpointsBase: "window",
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    slidesPerGroupAuto: !1,
    centeredSlides: !1,
    centeredSlidesBounds: !1,
    slidesOffsetBefore: 0,
    slidesOffsetAfter: 0,
    normalizeSlideIndex: !0,
    centerInsufficientSlides: !1,
    watchOverflow: !0,
    roundLengths: !1,
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: !0,
    shortSwipes: !0,
    longSwipes: !0,
    longSwipesRatio: .5,
    longSwipesMs: 300,
    followFinger: !0,
    allowTouchMove: !0,
    threshold: 5,
    touchMoveStopPropagation: !1,
    touchStartPreventDefault: !0,
    touchStartForcePreventDefault: !1,
    touchReleaseOnEdges: !1,
    uniqueNavElements: !0,
    resistance: !0,
    resistanceRatio: .85,
    watchSlidesProgress: !1,
    grabCursor: !1,
    preventClicks: !0,
    preventClicksPropagation: !0,
    slideToClickedSlide: !1,
    loop: !1,
    loopAddBlankSlides: !0,
    loopAdditionalSlides: 0,
    loopPreventsSliding: !0,
    rewind: !1,
    allowSlidePrev: !0,
    allowSlideNext: !0,
    swipeHandler: null,
    noSwiping: !0,
    noSwipingClass: "swiper-no-swiping",
    noSwipingSelector: null,
    passiveListeners: !0,
    maxBackfaceHiddenSlides: 10,
    containerModifierClass: "swiper-",
    slideClass: "swiper-slide",
    slideBlankClass: "swiper-slide-blank",
    slideActiveClass: "swiper-slide-active",
    slideVisibleClass: "swiper-slide-visible",
    slideFullyVisibleClass: "swiper-slide-fully-visible",
    slideNextClass: "swiper-slide-next",
    slidePrevClass: "swiper-slide-prev",
    wrapperClass: "swiper-wrapper",
    lazyPreloaderClass: "swiper-lazy-preloader",
    lazyPreloadPrevNext: 0,
    runCallbacksOnInit: !0,
    _emitClasses: !1
};
function moduleExtendParams(_e, $) {
    return function(tt) {
        tt === void 0 && (tt = {});
        const nt = Object.keys(tt)[0]
          , rt = tt[nt];
        if (typeof rt != "object" || rt === null) {
            extend$1($, tt);
            return
        }
        if (_e[nt] === !0 && (_e[nt] = {
            enabled: !0
        }),
        nt === "navigation" && _e[nt] && _e[nt].enabled && !_e[nt].prevEl && !_e[nt].nextEl && (_e[nt].auto = !0),
        ["pagination", "scrollbar"].indexOf(nt) >= 0 && _e[nt] && _e[nt].enabled && !_e[nt].el && (_e[nt].auto = !0),
        !(nt in _e && "enabled"in rt)) {
            extend$1($, tt);
            return
        }
        typeof _e[nt] == "object" && !("enabled"in _e[nt]) && (_e[nt].enabled = !0),
        _e[nt] || (_e[nt] = {
            enabled: !1
        }),
        extend$1($, tt)
    }
}
const prototypes = {
    eventsEmitter,
    update,
    translate,
    transition,
    slide,
    loop,
    grabCursor,
    events: events$1,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes
}
  , extendedDefaults = {};
let Swiper$2 = class Au {
    constructor() {
        let $, et;
        for (var tt = arguments.length, nt = new Array(tt), rt = 0; rt < tt; rt++)
            nt[rt] = arguments[rt];
        nt.length === 1 && nt[0].constructor && Object.prototype.toString.call(nt[0]).slice(8, -1) === "Object" ? et = nt[0] : [$,et] = nt,
        et || (et = {}),
        et = extend$1({}, et),
        $ && !et.el && (et.el = $);
        const it = getDocument();
        if (et.el && typeof et.el == "string" && it.querySelectorAll(et.el).length > 1) {
            const ct = [];
            return it.querySelectorAll(et.el).forEach(dt => {
                const pt = extend$1({}, et, {
                    el: dt
                });
                ct.push(new Au(pt))
            }
            ),
            ct
        }
        const ot = this;
        ot.__swiper__ = !0,
        ot.support = getSupport(),
        ot.device = getDevice({
            userAgent: et.userAgent
        }),
        ot.browser = getBrowser(),
        ot.eventsListeners = {},
        ot.eventsAnyListeners = [],
        ot.modules = [...ot.__modules__],
        et.modules && Array.isArray(et.modules) && ot.modules.push(...et.modules);
        const st = {};
        ot.modules.forEach(ct => {
            ct({
                params: et,
                swiper: ot,
                extendParams: moduleExtendParams(et, st),
                on: ot.on.bind(ot),
                once: ot.once.bind(ot),
                off: ot.off.bind(ot),
                emit: ot.emit.bind(ot)
            })
        }
        );
        const lt = extend$1({}, defaults, st);
        return ot.params = extend$1({}, lt, extendedDefaults, et),
        ot.originalParams = extend$1({}, ot.params),
        ot.passedParams = extend$1({}, et),
        ot.params && ot.params.on && Object.keys(ot.params.on).forEach(ct => {
            ot.on(ct, ot.params.on[ct])
        }
        ),
        ot.params && ot.params.onAny && ot.onAny(ot.params.onAny),
        Object.assign(ot, {
            enabled: ot.params.enabled,
            el: $,
            classNames: [],
            slides: [],
            slidesGrid: [],
            snapGrid: [],
            slidesSizesGrid: [],
            isHorizontal() {
                return ot.params.direction === "horizontal"
            },
            isVertical() {
                return ot.params.direction === "vertical"
            },
            activeIndex: 0,
            realIndex: 0,
            isBeginning: !0,
            isEnd: !1,
            translate: 0,
            previousTranslate: 0,
            progress: 0,
            velocity: 0,
            animating: !1,
            cssOverflowAdjustment() {
                return Math.trunc(this.translate / 2 ** 23) * 2 ** 23
            },
            allowSlideNext: ot.params.allowSlideNext,
            allowSlidePrev: ot.params.allowSlidePrev,
            touchEventsData: {
                isTouched: void 0,
                isMoved: void 0,
                allowTouchCallbacks: void 0,
                touchStartTime: void 0,
                isScrolling: void 0,
                currentTranslate: void 0,
                startTranslate: void 0,
                allowThresholdMove: void 0,
                focusableElements: ot.params.focusableElements,
                lastClickTime: 0,
                clickTimeout: void 0,
                velocities: [],
                allowMomentumBounce: void 0,
                startMoving: void 0,
                pointerId: null,
                touchId: null
            },
            allowClick: !0,
            allowTouchMove: ot.params.allowTouchMove,
            touches: {
                startX: 0,
                startY: 0,
                currentX: 0,
                currentY: 0,
                diff: 0
            },
            imagesToLoad: [],
            imagesLoaded: 0
        }),
        ot.emit("_swiper"),
        ot.params.init && ot.init(),
        ot
    }
    getDirectionLabel($) {
        return this.isHorizontal() ? $ : {
            width: "height",
            "margin-top": "margin-left",
            "margin-bottom ": "margin-right",
            "margin-left": "margin-top",
            "margin-right": "margin-bottom",
            "padding-left": "padding-top",
            "padding-right": "padding-bottom",
            marginRight: "marginBottom"
        }[$]
    }
    getSlideIndex($) {
        const {slidesEl: et, params: tt} = this
          , nt = elementChildren(et, `.${tt.slideClass}, swiper-slide`)
          , rt = elementIndex(nt[0]);
        return elementIndex($) - rt
    }
    getSlideIndexByData($) {
        return this.getSlideIndex(this.slides.find(et => et.getAttribute("data-swiper-slide-index") * 1 === $))
    }
    recalcSlides() {
        const $ = this
          , {slidesEl: et, params: tt} = $;
        $.slides = elementChildren(et, `.${tt.slideClass}, swiper-slide`)
    }
    enable() {
        const $ = this;
        $.enabled || ($.enabled = !0,
        $.params.grabCursor && $.setGrabCursor(),
        $.emit("enable"))
    }
    disable() {
        const $ = this;
        $.enabled && ($.enabled = !1,
        $.params.grabCursor && $.unsetGrabCursor(),
        $.emit("disable"))
    }
    setProgress($, et) {
        const tt = this;
        $ = Math.min(Math.max($, 0), 1);
        const nt = tt.minTranslate()
          , it = (tt.maxTranslate() - nt) * $ + nt;
        tt.translateTo(it, typeof et > "u" ? 0 : et),
        tt.updateActiveIndex(),
        tt.updateSlidesClasses()
    }
    emitContainerClasses() {
        const $ = this;
        if (!$.params._emitClasses || !$.el)
            return;
        const et = $.el.className.split(" ").filter(tt => tt.indexOf("swiper") === 0 || tt.indexOf($.params.containerModifierClass) === 0);
        $.emit("_containerClasses", et.join(" "))
    }
    getSlideClasses($) {
        const et = this;
        return et.destroyed ? "" : $.className.split(" ").filter(tt => tt.indexOf("swiper-slide") === 0 || tt.indexOf(et.params.slideClass) === 0).join(" ")
    }
    emitSlidesClasses() {
        const $ = this;
        if (!$.params._emitClasses || !$.el)
            return;
        const et = [];
        $.slides.forEach(tt => {
            const nt = $.getSlideClasses(tt);
            et.push({
                slideEl: tt,
                classNames: nt
            }),
            $.emit("_slideClass", tt, nt)
        }
        ),
        $.emit("_slideClasses", et)
    }
    slidesPerViewDynamic($, et) {
        $ === void 0 && ($ = "current"),
        et === void 0 && (et = !1);
        const tt = this
          , {params: nt, slides: rt, slidesGrid: it, slidesSizesGrid: ot, size: st, activeIndex: lt} = tt;
        let ct = 1;
        if (typeof nt.slidesPerView == "number")
            return nt.slidesPerView;
        if (nt.centeredSlides) {
            let dt = rt[lt] ? Math.ceil(rt[lt].swiperSlideSize) : 0, pt;
            for (let ht = lt + 1; ht < rt.length; ht += 1)
                rt[ht] && !pt && (dt += Math.ceil(rt[ht].swiperSlideSize),
                ct += 1,
                dt > st && (pt = !0));
            for (let ht = lt - 1; ht >= 0; ht -= 1)
                rt[ht] && !pt && (dt += rt[ht].swiperSlideSize,
                ct += 1,
                dt > st && (pt = !0))
        } else if ($ === "current")
            for (let dt = lt + 1; dt < rt.length; dt += 1)
                (et ? it[dt] + ot[dt] - it[lt] < st : it[dt] - it[lt] < st) && (ct += 1);
        else
            for (let dt = lt - 1; dt >= 0; dt -= 1)
                it[lt] - it[dt] < st && (ct += 1);
        return ct
    }
    update() {
        const $ = this;
        if (!$ || $.destroyed)
            return;
        const {snapGrid: et, params: tt} = $;
        tt.breakpoints && $.setBreakpoint(),
        [...$.el.querySelectorAll('[loading="lazy"]')].forEach(it => {
            it.complete && processLazyPreloader($, it)
        }
        ),
        $.updateSize(),
        $.updateSlides(),
        $.updateProgress(),
        $.updateSlidesClasses();
        function nt() {
            const it = $.rtlTranslate ? $.translate * -1 : $.translate
              , ot = Math.min(Math.max(it, $.maxTranslate()), $.minTranslate());
            $.setTranslate(ot),
            $.updateActiveIndex(),
            $.updateSlidesClasses()
        }
        let rt;
        if (tt.freeMode && tt.freeMode.enabled && !tt.cssMode)
            nt(),
            tt.autoHeight && $.updateAutoHeight();
        else {
            if ((tt.slidesPerView === "auto" || tt.slidesPerView > 1) && $.isEnd && !tt.centeredSlides) {
                const it = $.virtual && tt.virtual.enabled ? $.virtual.slides : $.slides;
                rt = $.slideTo(it.length - 1, 0, !1, !0)
            } else
                rt = $.slideTo($.activeIndex, 0, !1, !0);
            rt || nt()
        }
        tt.watchOverflow && et !== $.snapGrid && $.checkOverflow(),
        $.emit("update")
    }
    changeDirection($, et) {
        et === void 0 && (et = !0);
        const tt = this
          , nt = tt.params.direction;
        return $ || ($ = nt === "horizontal" ? "vertical" : "horizontal"),
        $ === nt || $ !== "horizontal" && $ !== "vertical" || (tt.el.classList.remove(`${tt.params.containerModifierClass}${nt}`),
        tt.el.classList.add(`${tt.params.containerModifierClass}${$}`),
        tt.emitContainerClasses(),
        tt.params.direction = $,
        tt.slides.forEach(rt => {
            $ === "vertical" ? rt.style.width = "" : rt.style.height = ""
        }
        ),
        tt.emit("changeDirection"),
        et && tt.update()),
        tt
    }
    changeLanguageDirection($) {
        const et = this;
        et.rtl && $ === "rtl" || !et.rtl && $ === "ltr" || (et.rtl = $ === "rtl",
        et.rtlTranslate = et.params.direction === "horizontal" && et.rtl,
        et.rtl ? (et.el.classList.add(`${et.params.containerModifierClass}rtl`),
        et.el.dir = "rtl") : (et.el.classList.remove(`${et.params.containerModifierClass}rtl`),
        et.el.dir = "ltr"),
        et.update())
    }
    mount($) {
        const et = this;
        if (et.mounted)
            return !0;
        let tt = $ || et.params.el;
        if (typeof tt == "string" && (tt = document.querySelector(tt)),
        !tt)
            return !1;
        tt.swiper = et,
        tt.parentNode && tt.parentNode.host && tt.parentNode.host.nodeName === et.params.swiperElementNodeName.toUpperCase() && (et.isElement = !0);
        const nt = () => `.${(et.params.wrapperClass || "").trim().split(" ").join(".")}`;
        let it = tt && tt.shadowRoot && tt.shadowRoot.querySelector ? tt.shadowRoot.querySelector(nt()) : elementChildren(tt, nt())[0];
        return !it && et.params.createElements && (it = createElement("div", et.params.wrapperClass),
        tt.append(it),
        elementChildren(tt, `.${et.params.slideClass}`).forEach(ot => {
            it.append(ot)
        }
        )),
        Object.assign(et, {
            el: tt,
            wrapperEl: it,
            slidesEl: et.isElement && !tt.parentNode.host.slideSlots ? tt.parentNode.host : it,
            hostEl: et.isElement ? tt.parentNode.host : tt,
            mounted: !0,
            rtl: tt.dir.toLowerCase() === "rtl" || elementStyle(tt, "direction") === "rtl",
            rtlTranslate: et.params.direction === "horizontal" && (tt.dir.toLowerCase() === "rtl" || elementStyle(tt, "direction") === "rtl"),
            wrongRTL: elementStyle(it, "display") === "-webkit-box"
        }),
        !0
    }
    init($) {
        const et = this;
        if (et.initialized || et.mount($) === !1)
            return et;
        et.emit("beforeInit"),
        et.params.breakpoints && et.setBreakpoint(),
        et.addClasses(),
        et.updateSize(),
        et.updateSlides(),
        et.params.watchOverflow && et.checkOverflow(),
        et.params.grabCursor && et.enabled && et.setGrabCursor(),
        et.params.loop && et.virtual && et.params.virtual.enabled ? et.slideTo(et.params.initialSlide + et.virtual.slidesBefore, 0, et.params.runCallbacksOnInit, !1, !0) : et.slideTo(et.params.initialSlide, 0, et.params.runCallbacksOnInit, !1, !0),
        et.params.loop && et.loopCreate(),
        et.attachEvents();
        const nt = [...et.el.querySelectorAll('[loading="lazy"]')];
        return et.isElement && nt.push(...et.hostEl.querySelectorAll('[loading="lazy"]')),
        nt.forEach(rt => {
            rt.complete ? processLazyPreloader(et, rt) : rt.addEventListener("load", it => {
                processLazyPreloader(et, it.target)
            }
            )
        }
        ),
        preload(et),
        et.initialized = !0,
        preload(et),
        et.emit("init"),
        et.emit("afterInit"),
        et
    }
    destroy($, et) {
        $ === void 0 && ($ = !0),
        et === void 0 && (et = !0);
        const tt = this
          , {params: nt, el: rt, wrapperEl: it, slides: ot} = tt;
        return typeof tt.params > "u" || tt.destroyed || (tt.emit("beforeDestroy"),
        tt.initialized = !1,
        tt.detachEvents(),
        nt.loop && tt.loopDestroy(),
        et && (tt.removeClasses(),
        rt && typeof rt != "string" && rt.removeAttribute("style"),
        it && it.removeAttribute("style"),
        ot && ot.length && ot.forEach(st => {
            st.classList.remove(nt.slideVisibleClass, nt.slideFullyVisibleClass, nt.slideActiveClass, nt.slideNextClass, nt.slidePrevClass),
            st.removeAttribute("style"),
            st.removeAttribute("data-swiper-slide-index")
        }
        )),
        tt.emit("destroy"),
        Object.keys(tt.eventsListeners).forEach(st => {
            tt.off(st)
        }
        ),
        $ !== !1 && (tt.el && typeof tt.el != "string" && (tt.el.swiper = null),
        deleteProps(tt)),
        tt.destroyed = !0),
        null
    }
    static extendDefaults($) {
        extend$1(extendedDefaults, $)
    }
    static get extendedDefaults() {
        return extendedDefaults
    }
    static get defaults() {
        return defaults
    }
    static installModule($) {
        Au.prototype.__modules__ || (Au.prototype.__modules__ = []);
        const et = Au.prototype.__modules__;
        typeof $ == "function" && et.indexOf($) < 0 && et.push($)
    }
    static use($) {
        return Array.isArray($) ? ($.forEach(et => Au.installModule(et)),
        Au) : (Au.installModule($),
        Au)
    }
}
;
Object.keys(prototypes).forEach(_e => {
    Object.keys(prototypes[_e]).forEach($ => {
        Swiper$2.prototype[$] = prototypes[_e][$]
    }
    )
}
);
Swiper$2.use([Resize, Observer]);
const paramsList = ["eventsPrefix", "injectStyles", "injectStylesUrls", "modules", "init", "_direction", "oneWayMovement", "swiperElementNodeName", "touchEventsTarget", "initialSlide", "_speed", "cssMode", "updateOnWindowResize", "resizeObserver", "nested", "focusableElements", "_enabled", "_width", "_height", "preventInteractionOnTransition", "userAgent", "url", "_edgeSwipeDetection", "_edgeSwipeThreshold", "_freeMode", "_autoHeight", "setWrapperSize", "virtualTranslate", "_effect", "breakpoints", "breakpointsBase", "_spaceBetween", "_slidesPerView", "maxBackfaceHiddenSlides", "_grid", "_slidesPerGroup", "_slidesPerGroupSkip", "_slidesPerGroupAuto", "_centeredSlides", "_centeredSlidesBounds", "_slidesOffsetBefore", "_slidesOffsetAfter", "normalizeSlideIndex", "_centerInsufficientSlides", "_watchOverflow", "roundLengths", "touchRatio", "touchAngle", "simulateTouch", "_shortSwipes", "_longSwipes", "longSwipesRatio", "longSwipesMs", "_followFinger", "allowTouchMove", "_threshold", "touchMoveStopPropagation", "touchStartPreventDefault", "touchStartForcePreventDefault", "touchReleaseOnEdges", "uniqueNavElements", "_resistance", "_resistanceRatio", "_watchSlidesProgress", "_grabCursor", "preventClicks", "preventClicksPropagation", "_slideToClickedSlide", "_loop", "loopAdditionalSlides", "loopAddBlankSlides", "loopPreventsSliding", "_rewind", "_allowSlidePrev", "_allowSlideNext", "_swipeHandler", "_noSwiping", "noSwipingClass", "noSwipingSelector", "passiveListeners", "containerModifierClass", "slideClass", "slideActiveClass", "slideVisibleClass", "slideFullyVisibleClass", "slideNextClass", "slidePrevClass", "slideBlankClass", "wrapperClass", "lazyPreloaderClass", "lazyPreloadPrevNext", "runCallbacksOnInit", "observer", "observeParents", "observeSlideChildren", "a11y", "_autoplay", "_controller", "coverflowEffect", "cubeEffect", "fadeEffect", "flipEffect", "creativeEffect", "cardsEffect", "hashNavigation", "history", "keyboard", "mousewheel", "_navigation", "_pagination", "parallax", "_scrollbar", "_thumbs", "virtual", "zoom", "control"];
function isObject(_e) {
    return typeof _e == "object" && _e !== null && _e.constructor && Object.prototype.toString.call(_e).slice(8, -1) === "Object" && !_e.__swiper__
}
function extend(_e, $) {
    const et = ["__proto__", "constructor", "prototype"];
    Object.keys($).filter(tt => et.indexOf(tt) < 0).forEach(tt => {
        typeof _e[tt] > "u" ? _e[tt] = $[tt] : isObject($[tt]) && isObject(_e[tt]) && Object.keys($[tt]).length > 0 ? $[tt].__swiper__ ? _e[tt] = $[tt] : extend(_e[tt], $[tt]) : _e[tt] = $[tt]
    }
    )
}
function needsNavigation(_e) {
    return _e === void 0 && (_e = {}),
    _e.navigation && typeof _e.navigation.nextEl > "u" && typeof _e.navigation.prevEl > "u"
}
function needsPagination(_e) {
    return _e === void 0 && (_e = {}),
    _e.pagination && typeof _e.pagination.el > "u"
}
function needsScrollbar(_e) {
    return _e === void 0 && (_e = {}),
    _e.scrollbar && typeof _e.scrollbar.el > "u"
}
function uniqueClasses(_e) {
    _e === void 0 && (_e = "");
    const $ = _e.split(" ").map(tt => tt.trim()).filter(tt => !!tt)
      , et = [];
    return $.forEach(tt => {
        et.indexOf(tt) < 0 && et.push(tt)
    }
    ),
    et.join(" ")
}
function wrapperClass(_e) {
    return _e === void 0 && (_e = ""),
    _e ? _e.includes("swiper-wrapper") ? _e : `swiper-wrapper ${_e}` : "swiper-wrapper"
}
function updateSwiper(_e) {
    let {swiper: $, slides: et, passedParams: tt, changedParams: nt, nextEl: rt, prevEl: it, scrollbarEl: ot, paginationEl: st} = _e;
    const lt = nt.filter(Jt => Jt !== "children" && Jt !== "direction" && Jt !== "wrapperClass")
      , {params: ct, pagination: dt, navigation: pt, scrollbar: ht, virtual: mt, thumbs: yt} = $;
    let Et, _t, wt, St, Ct, Nt, Lt, kt;
    nt.includes("thumbs") && tt.thumbs && tt.thumbs.swiper && !tt.thumbs.swiper.destroyed && ct.thumbs && (!ct.thumbs.swiper || ct.thumbs.swiper.destroyed) && (Et = !0),
    nt.includes("controller") && tt.controller && tt.controller.control && ct.controller && !ct.controller.control && (_t = !0),
    nt.includes("pagination") && tt.pagination && (tt.pagination.el || st) && (ct.pagination || ct.pagination === !1) && dt && !dt.el && (wt = !0),
    nt.includes("scrollbar") && tt.scrollbar && (tt.scrollbar.el || ot) && (ct.scrollbar || ct.scrollbar === !1) && ht && !ht.el && (St = !0),
    nt.includes("navigation") && tt.navigation && (tt.navigation.prevEl || it) && (tt.navigation.nextEl || rt) && (ct.navigation || ct.navigation === !1) && pt && !pt.prevEl && !pt.nextEl && (Ct = !0);
    const Ut = Jt => {
        $[Jt] && ($[Jt].destroy(),
        Jt === "navigation" ? ($.isElement && ($[Jt].prevEl.remove(),
        $[Jt].nextEl.remove()),
        ct[Jt].prevEl = void 0,
        ct[Jt].nextEl = void 0,
        $[Jt].prevEl = void 0,
        $[Jt].nextEl = void 0) : ($.isElement && $[Jt].el.remove(),
        ct[Jt].el = void 0,
        $[Jt].el = void 0))
    }
    ;
    nt.includes("loop") && $.isElement && (ct.loop && !tt.loop ? Nt = !0 : !ct.loop && tt.loop ? Lt = !0 : kt = !0),
    lt.forEach(Jt => {
        if (isObject(ct[Jt]) && isObject(tt[Jt]))
            Object.assign(ct[Jt], tt[Jt]),
            (Jt === "navigation" || Jt === "pagination" || Jt === "scrollbar") && "enabled"in tt[Jt] && !tt[Jt].enabled && Ut(Jt);
        else {
            const Pt = tt[Jt];
            (Pt === !0 || Pt === !1) && (Jt === "navigation" || Jt === "pagination" || Jt === "scrollbar") ? Pt === !1 && Ut(Jt) : ct[Jt] = tt[Jt]
        }
    }
    ),
    lt.includes("controller") && !_t && $.controller && $.controller.control && ct.controller && ct.controller.control && ($.controller.control = ct.controller.control),
    nt.includes("children") && et && mt && ct.virtual.enabled ? (mt.slides = et,
    mt.update(!0)) : nt.includes("virtual") && mt && ct.virtual.enabled && (et && (mt.slides = et),
    mt.update(!0)),
    nt.includes("children") && et && ct.loop && (kt = !0),
    Et && yt.init() && yt.update(!0),
    _t && ($.controller.control = ct.controller.control),
    wt && ($.isElement && (!st || typeof st == "string") && (st = document.createElement("div"),
    st.classList.add("swiper-pagination"),
    st.part.add("pagination"),
    $.el.appendChild(st)),
    st && (ct.pagination.el = st),
    dt.init(),
    dt.render(),
    dt.update()),
    St && ($.isElement && (!ot || typeof ot == "string") && (ot = document.createElement("div"),
    ot.classList.add("swiper-scrollbar"),
    ot.part.add("scrollbar"),
    $.el.appendChild(ot)),
    ot && (ct.scrollbar.el = ot),
    ht.init(),
    ht.updateSize(),
    ht.setTranslate()),
    Ct && ($.isElement && ((!rt || typeof rt == "string") && (rt = document.createElement("div"),
    rt.classList.add("swiper-button-next"),
    rt.innerHTML = $.hostEl.constructor.nextButtonSvg,
    rt.part.add("button-next"),
    $.el.appendChild(rt)),
    (!it || typeof it == "string") && (it = document.createElement("div"),
    it.classList.add("swiper-button-prev"),
    it.innerHTML = $.hostEl.constructor.prevButtonSvg,
    it.part.add("button-prev"),
    $.el.appendChild(it))),
    rt && (ct.navigation.nextEl = rt),
    it && (ct.navigation.prevEl = it),
    pt.init(),
    pt.update()),
    nt.includes("allowSlideNext") && ($.allowSlideNext = tt.allowSlideNext),
    nt.includes("allowSlidePrev") && ($.allowSlidePrev = tt.allowSlidePrev),
    nt.includes("direction") && $.changeDirection(tt.direction, !1),
    (Nt || kt) && $.loopDestroy(),
    (Lt || kt) && $.loopCreate(),
    $.update()
}
function getParams(_e, $) {
    _e === void 0 && (_e = {}),
    $ === void 0 && ($ = !0);
    const et = {
        on: {}
    }
      , tt = {}
      , nt = {};
    extend(et, defaults),
    et._emitClasses = !0,
    et.init = !1;
    const rt = {}
      , it = paramsList.map(st => st.replace(/_/, ""))
      , ot = Object.assign({}, _e);
    return Object.keys(ot).forEach(st => {
        typeof _e[st] > "u" || (it.indexOf(st) >= 0 ? isObject(_e[st]) ? (et[st] = {},
        nt[st] = {},
        extend(et[st], _e[st]),
        extend(nt[st], _e[st])) : (et[st] = _e[st],
        nt[st] = _e[st]) : st.search(/on[A-Z]/) === 0 && typeof _e[st] == "function" ? $ ? tt[`${st[2].toLowerCase()}${st.substr(3)}`] = _e[st] : et.on[`${st[2].toLowerCase()}${st.substr(3)}`] = _e[st] : rt[st] = _e[st])
    }
    ),
    ["navigation", "pagination", "scrollbar"].forEach(st => {
        et[st] === !0 && (et[st] = {}),
        et[st] === !1 && delete et[st]
    }
    ),
    {
        params: et,
        passedParams: nt,
        rest: rt,
        events: tt
    }
}
function mountSwiper(_e, $) {
    let {el: et, nextEl: tt, prevEl: nt, paginationEl: rt, scrollbarEl: it, swiper: ot} = _e;
    needsNavigation($) && tt && nt && (ot.params.navigation.nextEl = tt,
    ot.originalParams.navigation.nextEl = tt,
    ot.params.navigation.prevEl = nt,
    ot.originalParams.navigation.prevEl = nt),
    needsPagination($) && rt && (ot.params.pagination.el = rt,
    ot.originalParams.pagination.el = rt),
    needsScrollbar($) && it && (ot.params.scrollbar.el = it,
    ot.originalParams.scrollbar.el = it),
    ot.init(et)
}
function getChangedParams(_e, $, et, tt, nt) {
    const rt = [];
    if (!$)
        return rt;
    const it = st => {
        rt.indexOf(st) < 0 && rt.push(st)
    }
    ;
    if (et && tt) {
        const st = tt.map(nt)
          , lt = et.map(nt);
        st.join("") !== lt.join("") && it("children"),
        tt.length !== et.length && it("children")
    }
    return paramsList.filter(st => st[0] === "_").map(st => st.replace(/_/, "")).forEach(st => {
        if (st in _e && st in $)
            if (isObject(_e[st]) && isObject($[st])) {
                const lt = Object.keys(_e[st])
                  , ct = Object.keys($[st]);
                lt.length !== ct.length ? it(st) : (lt.forEach(dt => {
                    _e[st][dt] !== $[st][dt] && it(st)
                }
                ),
                ct.forEach(dt => {
                    _e[st][dt] !== $[st][dt] && it(st)
                }
                ))
            } else
                _e[st] !== $[st] && it(st)
    }
    ),
    rt
}
const updateOnVirtualData = _e => {
    !_e || _e.destroyed || !_e.params.virtual || _e.params.virtual && !_e.params.virtual.enabled || (_e.updateSlides(),
    _e.updateProgress(),
    _e.updateSlidesClasses(),
    _e.parallax && _e.params.parallax && _e.params.parallax.enabled && _e.parallax.setTranslate())
}
;
function _extends() {
    return _extends = Object.assign ? Object.assign.bind() : function(_e) {
        for (var $ = 1; $ < arguments.length; $++) {
            var et = arguments[$];
            for (var tt in et)
                Object.prototype.hasOwnProperty.call(et, tt) && (_e[tt] = et[tt])
        }
        return _e
    }
    ,
    _extends.apply(this, arguments)
}
function isChildSwiperSlide(_e) {
    return _e.type && _e.type.displayName && _e.type.displayName.includes("SwiperSlide")
}
function processChildren(_e) {
    const $ = [];
    return React.Children.toArray(_e).forEach(et => {
        isChildSwiperSlide(et) ? $.push(et) : et.props && et.props.children && processChildren(et.props.children).forEach(tt => $.push(tt))
    }
    ),
    $
}
function getChildren(_e) {
    const $ = []
      , et = {
        "container-start": [],
        "container-end": [],
        "wrapper-start": [],
        "wrapper-end": []
    };
    return React.Children.toArray(_e).forEach(tt => {
        if (isChildSwiperSlide(tt))
            $.push(tt);
        else if (tt.props && tt.props.slot && et[tt.props.slot])
            et[tt.props.slot].push(tt);
        else if (tt.props && tt.props.children) {
            const nt = processChildren(tt.props.children);
            nt.length > 0 ? nt.forEach(rt => $.push(rt)) : et["container-end"].push(tt)
        } else
            et["container-end"].push(tt)
    }
    ),
    {
        slides: $,
        slots: et
    }
}
function renderVirtual(_e, $, et) {
    if (!et)
        return null;
    const tt = ct => {
        let dt = ct;
        return ct < 0 ? dt = $.length + ct : dt >= $.length && (dt = dt - $.length),
        dt
    }
      , nt = _e.isHorizontal() ? {
        [_e.rtlTranslate ? "right" : "left"]: `${et.offset}px`
    } : {
        top: `${et.offset}px`
    }
      , {from: rt, to: it} = et
      , ot = _e.params.loop ? -$.length : 0
      , st = _e.params.loop ? $.length * 2 : $.length
      , lt = [];
    for (let ct = ot; ct < st; ct += 1)
        ct >= rt && ct <= it && lt.push($[tt(ct)]);
    return lt.map( (ct, dt) => React.cloneElement(ct, {
        swiper: _e,
        style: nt,
        key: ct.props.virtualIndex || ct.key || `slide-${dt}`
    }))
}
function useIsomorphicLayoutEffect(_e, $) {
    return typeof window > "u" ? reactExports.useEffect(_e, $) : reactExports.useLayoutEffect(_e, $)
}
const SwiperSlideContext = reactExports.createContext(null)
  , SwiperContext = reactExports.createContext(null)
  , Swiper$1 = reactExports.forwardRef(function(_e, $) {
    let {className: et, tag: tt="div", wrapperTag: nt="div", children: rt, onSwiper: it, ...ot} = _e === void 0 ? {} : _e
      , st = !1;
    const [lt,ct] = reactExports.useState("swiper")
      , [dt,pt] = reactExports.useState(null)
      , [ht,mt] = reactExports.useState(!1)
      , yt = reactExports.useRef(!1)
      , Et = reactExports.useRef(null)
      , _t = reactExports.useRef(null)
      , wt = reactExports.useRef(null)
      , St = reactExports.useRef(null)
      , Ct = reactExports.useRef(null)
      , Nt = reactExports.useRef(null)
      , Lt = reactExports.useRef(null)
      , kt = reactExports.useRef(null)
      , {params: Ut, passedParams: Jt, rest: Pt, events: Xt} = getParams(ot)
      , {slides: rn, slots: zt} = getChildren(rt)
      , xt = () => {
        mt(!ht)
    }
    ;
    Object.assign(Ut.on, {
        _containerClasses(Ht, qt) {
            ct(qt)
        }
    });
    const $t = () => {
        Object.assign(Ut.on, Xt),
        st = !0;
        const Ht = {
            ...Ut
        };
        if (delete Ht.wrapperClass,
        _t.current = new Swiper$2(Ht),
        _t.current.virtual && _t.current.params.virtual.enabled) {
            _t.current.virtual.slides = rn;
            const qt = {
                cache: !1,
                slides: rn,
                renderExternal: pt,
                renderExternalUpdate: !1
            };
            extend(_t.current.params.virtual, qt),
            extend(_t.current.originalParams.virtual, qt)
        }
    }
    ;
    Et.current || $t(),
    _t.current && _t.current.on("_beforeBreakpoint", xt);
    const Dt = () => {
        st || !Xt || !_t.current || Object.keys(Xt).forEach(Ht => {
            _t.current.on(Ht, Xt[Ht])
        }
        )
    }
      , jt = () => {
        !Xt || !_t.current || Object.keys(Xt).forEach(Ht => {
            _t.current.off(Ht, Xt[Ht])
        }
        )
    }
    ;
    reactExports.useEffect( () => () => {
        _t.current && _t.current.off("_beforeBreakpoint", xt)
    }
    ),
    reactExports.useEffect( () => {
        !yt.current && _t.current && (_t.current.emitSlidesClasses(),
        yt.current = !0)
    }
    ),
    useIsomorphicLayoutEffect( () => {
        if ($ && ($.current = Et.current),
        !!Et.current)
            return _t.current.destroyed && $t(),
            mountSwiper({
                el: Et.current,
                nextEl: Ct.current,
                prevEl: Nt.current,
                paginationEl: Lt.current,
                scrollbarEl: kt.current,
                swiper: _t.current
            }, Ut),
            it && !_t.current.destroyed && it(_t.current),
            () => {
                _t.current && !_t.current.destroyed && _t.current.destroy(!0, !1)
            }
    }
    , []),
    useIsomorphicLayoutEffect( () => {
        Dt();
        const Ht = getChangedParams(Jt, wt.current, rn, St.current, qt => qt.key);
        return wt.current = Jt,
        St.current = rn,
        Ht.length && _t.current && !_t.current.destroyed && updateSwiper({
            swiper: _t.current,
            slides: rn,
            passedParams: Jt,
            changedParams: Ht,
            nextEl: Ct.current,
            prevEl: Nt.current,
            scrollbarEl: kt.current,
            paginationEl: Lt.current
        }),
        () => {
            jt()
        }
    }
    ),
    useIsomorphicLayoutEffect( () => {
        updateOnVirtualData(_t.current)
    }
    , [dt]);
    function Ft() {
        return Ut.virtual ? renderVirtual(_t.current, rn, dt) : rn.map( (Ht, qt) => React.cloneElement(Ht, {
            swiper: _t.current,
            swiperSlideIndex: qt
        }))
    }
    return React.createElement(tt, _extends({
        ref: Et,
        className: uniqueClasses(`${lt}${et ? ` ${et}` : ""}`)
    }, Pt), React.createElement(SwiperContext.Provider, {
        value: _t.current
    }, zt["container-start"], React.createElement(nt, {
        className: wrapperClass(Ut.wrapperClass)
    }, zt["wrapper-start"], Ft(), zt["wrapper-end"]), needsNavigation(Ut) && React.createElement(React.Fragment, null, React.createElement("div", {
        ref: Nt,
        className: "swiper-button-prev"
    }), React.createElement("div", {
        ref: Ct,
        className: "swiper-button-next"
    })), needsScrollbar(Ut) && React.createElement("div", {
        ref: kt,
        className: "swiper-scrollbar"
    }), needsPagination(Ut) && React.createElement("div", {
        ref: Lt,
        className: "swiper-pagination"
    }), zt["container-end"]))
});
Swiper$1.displayName = "Swiper";
const SwiperSlide = reactExports.forwardRef(function(_e, $) {
    let {tag: et="div", children: tt, className: nt="", swiper: rt, zoom: it, lazy: ot, virtualIndex: st, swiperSlideIndex: lt, ...ct} = _e === void 0 ? {} : _e;
    const dt = reactExports.useRef(null)
      , [pt,ht] = reactExports.useState("swiper-slide")
      , [mt,yt] = reactExports.useState(!1);
    function Et(Ct, Nt, Lt) {
        Nt === dt.current && ht(Lt)
    }
    useIsomorphicLayoutEffect( () => {
        if (typeof lt < "u" && (dt.current.swiperSlideIndex = lt),
        $ && ($.current = dt.current),
        !(!dt.current || !rt)) {
            if (rt.destroyed) {
                pt !== "swiper-slide" && ht("swiper-slide");
                return
            }
            return rt.on("_slideClass", Et),
            () => {
                rt && rt.off("_slideClass", Et)
            }
        }
    }
    ),
    useIsomorphicLayoutEffect( () => {
        rt && dt.current && !rt.destroyed && ht(rt.getSlideClasses(dt.current))
    }
    , [rt]);
    const _t = {
        isActive: pt.indexOf("swiper-slide-active") >= 0,
        isVisible: pt.indexOf("swiper-slide-visible") >= 0,
        isPrev: pt.indexOf("swiper-slide-prev") >= 0,
        isNext: pt.indexOf("swiper-slide-next") >= 0
    }
      , wt = () => typeof tt == "function" ? tt(_t) : tt
      , St = () => {
        yt(!0)
    }
    ;
    return React.createElement(et, _extends({
        ref: dt,
        className: uniqueClasses(`${pt}${nt ? ` ${nt}` : ""}`),
        "data-swiper-slide-index": st,
        onLoad: St
    }, ct), it && React.createElement(SwiperSlideContext.Provider, {
        value: _t
    }, React.createElement("div", {
        className: "swiper-zoom-container",
        "data-swiper-zoom": typeof it == "number" ? it : void 0
    }, wt(), ot && !mt && React.createElement("div", {
        className: "swiper-lazy-preloader"
    }))), !it && React.createElement(SwiperSlideContext.Provider, {
        value: _t
    }, wt(), ot && !mt && React.createElement("div", {
        className: "swiper-lazy-preloader"
    })))
});
SwiperSlide.displayName = "SwiperSlide";
const swiperLeft = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAUkSURBVHgB7Z1PSBxXHMe/iWXXipFCAjHa0uklvSgEVlrMKaeemmPxJkFQ8Fjitdfeclb0kvUg2Kuxh548lAQCgUACQQ9hJCFiYEM0kpiFQN53Z18yjjOzM+N7b3Zm3wd+7n/Bj7/3Z96/PYd8qYq4ImJQxCURF9r30b7v56OIIxFNEe/asSei0X4tF87BLFLYiIgfcVpSVqRMt31rTKgpgRQ2Bk9eFfrZgSfThWZ0CqSosXaYkBYGM/MRvKx8Bw3oENgN4oJQHrPyERSjWuBVETWoq9tUIzNyB4pQJZDCbsCr44rAroj7UFCsVQhkUWXWdUtxTQq7Q5R4pmzsQ3Yo7BcREyK+QfHg3+6IqIh4iYxkzUAW2d9EXEQ5YGf8P2Qo0lkykPJ+F/EdysMAvGxk3dhM88G0AqW8bm1lzwKrJAcpJaYRWGZ5ktQSkwrsBXmSVBKTCryJctV5naBEXr8/F/Ep7o1JBE7C+4/0GmxY6Ce2i9NJIC/NfkXvchleMX4d9YbzMR9mfTcJS+y1fZxAyiva5ZkOeKVyI+rFqCLMonsNFgkzkFcpjeALURlYgyVI6IBJX8QbHViCUB67NHv+J4MZyFS9CksU4whkYVAgB0R74WojK2xQxvxPBAXauq8z4/4HfoEObPYlgVk4Ih8EBVqS8SULpUBatY1Hcr4sEJACR2BJAxOuNQMpBTqwpKWVdFJgbvO509PT37uue3t/f/8v3kdx4OKo1qwc0/EWcoDCVlZWblcqFY69YXd3d8dxnDsoDnVm4CXkQFAeGRgY+BbF4goFGi++YfKazeb7hYWFuygWFyjQaOc5St7s7Oyd1dXVzCsEcuKiUYElk0daGViBAUoojwwaycCSymvBbswcNLK4uHh9ZmbmD788ExweHjbW1tbuzc/P34dGtAs8ODj4e2hoKJdVXMzyarX6JzRyHprp7+/PrW93fHz8AZrRLrBer/+DHGD2ra+vb0AzXFnK6TptDcnc3NwD3ooG41bwtaWlpbruOkozTc7KnZooUc3GxsbL0dHRRq1WOzHXPDExcW14ePjN5ubmCxSTtxT4Ewx0ZUoq8YACOa5lpJUsocQ9CuTuyB9giJJJdNkPdOCtuDfK8vLyZLBhMdFvU8w9dmNeIQfYOovLu7v+50z02xTTYDdGbmA2PicsuzhTU1M32eE20W9TCDd/f5QbbbgWcByWNHCL2Ja8EtmDJS0uf0iBrAdT7dCxeEknBTZhszANLL6tcxn8gwlPYEmKK+/4BdpinAy2vq58EBzOslnYmRPnLoQJtFkYDbPvxIVHUCDl2SyMZhuBTdlhI9IUeARLEDo5dWxKmMAmNJyvUgJCnUTNiTBVbb/wK9w7vB32Qtyk0hZsg0Lk8Sih9HX4IHfmGBts7VL+R8yQX6f9wtwny7Uzl9GbPBXxOO4NSeaFWXk20Hu8QUzRlSTZ8s9izAVAnL0zspKrC2CX5V8oPHSCv8hFb0ikPI6MJzrFKM25Mb0gMZU8kvbkojJLTC2PZDk7S0rkhLzRNX8aYYPBOs/I4WOEEp+hHF0cdlW2RLxHBs5yfiBh68zUH1Hwu0zDJHgIr5v2CRlReQTodbS3PxUAXudvoUuOAPXzM7xd74PoTuSQ1DYUoescaUqkzG4RKQeKWd8pPeVc50HcLNasG/PMSG3iJKaOgnfaYWJXvJzjpjjtC6fy+jICB152qspMNgYc9KSwUn4ZQRQUytWx8rwaRsV360e2mEf4eo6V/BaH3L4O4zN1DHErcSFABwAAAABJRU5ErkJggg=="
  , swiperRight = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFAAAABQCAYAAACOEfKtAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAUySURBVHgB7Z3PaxRnGMe/67a7MbGh0II0qel6iL1EKNhW9CQUekl67KE5pJBDSE6leO61/0IOgdAcekh7LPSQUw7FQkFoUJEIyhjFEDGBbEI2DgR8vzv76jjuzM5M5p15Zmc+8LizvwQ/Pu/Ped93K8iWuopPVJxT8bGKDzrX6Fy7eaniUIWt4qAT2yp2O+9lQgXpooWNqPgM70qKi5ZpdR5TE5qWQAqbgCOvDvM8gCPTgmFMCqSoiU6kIa0bzMzbcLLyAAYwIVCCOC+Ux6y8jYRJWuAlFVeQXN2WNDojHyAhkhJIYTfg1HF54LGKW0igWCchkEWVWSeluIaF3SFKPFU2VhEfCvtaxZcq3kP+4L+9oaKm4iliEjcDWWS/VfER+gN2xtcQo0jHyUDKm1LxIfqHQTjZyLrRjvLFqAK1PKmt7GlgldRARIlRBPazPE1kiWEFFkGeJpLEsAK/Q3/Veb2gRI7fH6k4CfpgGIHX4PyPFA02LPQT2MXpJZBDs6soLufhFOPnfh84E/Bl1nfXUBI4tg8SSHl5G56ZgCOVG35v+hVhFt0vUKJhBnKUsut9wy8Dr6DES9cJk6rPBxso8UJ57NJsu1/0ZiBT9RJK/LgMTxZ6BXJCtAijjbiwQZlwv+AVWNZ9vbnsfuIW2ECZfWFgFo7oJ16B4piZmfnUsqybOzs7v/AaMnidhboVptVvIJC1tbWfRkdHLw4NDQ1PTk5+tbW1dW9jY6OJbOE4+b6KE52BIxBKq9U60te1Wm1waWnppoBMZMK170DqDOSoQ+T9jb29vSfMvGq1+j6f81FIJrZUPNECxY57KYmyBEo8q+IuBTIdRU9ZCZXIhGsL5JyX+NGHUInPKZDyxDYibgRKbAv8HDm6QS5MYosC2SnM1QhEkERbCxxEzpAikQKv4nSLjDJDgESbi4vmYJDFxcXrs7Oz33MUgRSxbftoeXn5z4WFhVswiHGB+/v7vw4PD2fSSFFivV7/GQY5A8MMDAycRUYcHx+3YBjjAldWVv5oNpu7yIDV1dW/YBgW4R+Q44lU1rHz8/M/el9Xsza/zc3N/Quz2MYz0CQZyyMHFHiIHCJAHmlnoJEdPCYRIo+0M/AFcoQgeSRfRViYPLJNgc+QAwTKI7sUqDcwi0WoPJbcl7obY0EoQuWRdsnVArchlOnp6SnvawLkEYt/aIG0GWmHTlp4x9JC5JF20ul5QK57480lcVsZxsbGmuPj4xcqlQrU9NTvQuRxh+dDXrg3G/LG0hRKwsCNiRYv3GNhscVYGGx9Lf3EO5lwByW9eOvchW4Cyyz0h9n31sDDK5Dyyiz0ZxOeQUe3+UAKzOUUl2Ho5J1jU7oJtGHgfJU+oKsTvxlppqrY0UkGcO/wZrc3gqb011E2KEQfj9KVao8vcoRyAcXmHwRM+fVa0sF9slyAeR7F5K6K/4M+EOauHCvPTO7rZsweAoquJsyiIhZjbnu/CCcbiwC7LH8jwUMn+BdZKIZEyuOKhlCz9FGWtRVBYiR5JOq6wH6WGFkeibOwUkvk/GHuVrb6wAaDdV4qh48RSuResX7o4rCrsq7iCDE47dJets5M/RHkb5kwk+A/ON20E8QkySNAr8M5GzoPcJy/DiFHgLrhnhPuej8HmegpqU0khKlzpCmRMqWI1BPFrO8SPeXc5EHcLNasG7PMSGPiNGkdBd/oRBqbGimNdRzFGV84ldWPETTgZGdSmcnGgJOeFNaXP0bgB4VyD4k+r4ZRcz260S3mId6cY6V/xSGzn8N4BcPf6YWskaRlAAAAAElFTkSuQmCC"
  , useMediaStore = create$1(_e => ({
    mediaType: "",
    mediaActiveId: 0,
    mediaList: [],
    setMediaType: $ => _e({
        mediaType: $
    }),
    setMediaActiveId: $ => _e({
        mediaActiveId: $
    }),
    setMediaList: $ => _e({
        mediaList: $
    })
}));
function ImageWithLoading({url: _e, iconWrapperSize: $, containerClass: et}) {
    const tt = useTheme()
      , nt = reactExports.useMemo( () => $ != null && $.height ? typeof $.height == "string" ? $.height : `${$.height}px` : "500px", [$]);
    return jsxRuntimeExports.jsx("img", {
        className: cn("rounded-xl", et),
        style: {
            background: tt.palette.background.paper,
            height: nt
        },
        src: _e
    })
}
const SwiperStyle = {
    "--swiper-navigation-size": "16px",
    "--swiper-navigation-color": "#fff",
    "--swiper-pagination-color": "#fff"
}
  , DIALOG_RIGHT_WIDTH = "520px"
  , DIALOG_LEFT_MIN_WIDTH = "500px";
function Swiper({materials: _e, activeIndex: $=0, setActiveIndex: et= () => {}
}) {
    const {setIsVisibleMediaViewer: tt} = useApplicationStore()
      , {setMediaActiveId: nt, setMediaList: rt, setMediaType: it} = useMediaStore()
      , ot = reactExports.useRef(null)
      , [st,lt] = reactExports.useState(void 0)
      , [ct,dt] = reactExports.useState("")
      , [pt,ht] = reactExports.useState(0)
      , mt = () => {
        const [{width: wt, height: St}] = _e;
        if (wt && St) {
            lt(wt / St);
            return
        }
        const Ct = new Image;
        Ct.src = _e[0].url,
        Ct.addEventListener("load", () => {
            const {width: Nt, height: Lt} = Ct;
            lt(Nt / Lt)
        }
        )
    }
      , yt = wt => {
        et(wt.activeIndex)
    }
      , Et = wt => {
        it("origin"),
        rt(_e),
        nt(wt),
        tt(!0)
    }
      , _t = wt => {
        var St, Ct;
        switch (wt.key) {
        case " ":
            {
                ht(Date.now());
                break
            }
        case "ArrowLeft":
            {
                (St = ot.current) == null || St.swiper.slidePrev();
                break
            }
        case "ArrowRight":
            {
                (Ct = ot.current) == null || Ct.swiper.slideNext();
                break
            }
        }
    }
    ;
    return reactExports.useEffect( () => {
        var wt, St;
        pt && ct && (ct === SCROLL_DIRECTION.PREV ? (wt = ot.current) == null || wt.swiper.slidePrev() : (St = ot.current) == null || St.swiper.slideNext())
    }
    , [pt, ct]),
    reactExports.useLayoutEffect( () => (document.addEventListener("keydown", _t),
    mt(),
    () => {
        dt(""),
        document.removeEventListener("keydown", _t)
    }
    ), []),
    reactExports.useEffect( () => {
        ot.current && ot.current.swiper.slideTo($)
    }
    , [$]),
    jsxRuntimeExports.jsx(StyledSwiperOutBox, {
        className: "swiper-box",
        sx: {
            width: st ? `calc(${st} * (100vh - 64px))` : "auto"
        },
        children: jsxRuntimeExports.jsx(Swiper$1, {
            ref: ot,
            initialSlide: $,
            allowTouchMove: !0,
            navigation: !0,
            touchStartPreventDefault: !0,
            onSlideChange: yt,
            modules: [Navigation],
            slidesPerView: "auto",
            className: "h-full relative",
            style: SwiperStyle,
            onClick: wt => {
                tt(!1)
            }
            ,
            onSlideNextTransitionEnd: () => {
                dt(SCROLL_DIRECTION.NEXT),
                ht(0)
            }
            ,
            onSlidePrevTransitionEnd: () => {
                dt(SCROLL_DIRECTION.PREV),
                ht(0)
            }
            ,
            children: _e.map( (wt, St) => jsxRuntimeExports.jsx(SwiperSlide, {
                children: wt.file_type === Media_Type.Video ? jsxRuntimeExports.jsx(Box, {
                    className: "h-full flex items-center justify-center"
                }) : jsxRuntimeExports.jsx(Box, {
                    onClick: () => Et(St),
                    className: "h-full flex items-center justify-center bg-no-repeat bg-contain bg-center",
                    children: jsxRuntimeExports.jsx(ImageWithLoading, {
                        url: wt.url,
                        containerClass: "object-contain",
                        iconWrapperSize: {
                            height: "100%"
                        }
                    })
                })
            }, St))
        })
    })
}
const StyledSwiperOutBox = styled(Box)( ({theme: _e}) => ({
    minWidth: DIALOG_LEFT_MIN_WIDTH,
    maxWidth: `calc(100vw - 200px - ${DIALOG_RIGHT_WIDTH})`,
    minHeight: "calc(100vh - 76px)",
    ".swiper-button-prev, .swiper-button-next, .swiper-pagination, .MuiChip-root": {
        opacity: "0 !important",
        transition: `${_e.transitions.create(["opacity"], {
            duration: _e.transitions.duration.standard,
            easing: _e.transitions.easing.easeInOut
        })}`
    },
    "&:hover": {
        ".swiper-pagination, .swiper-button-prev, .swiper-button-next, .MuiChip-root": {
            opacity: "1 !important",
            transition: `${_e.transitions.create(["opacity"], {
                duration: _e.transitions.duration.standard,
                easing: _e.transitions.easing.easeInOut
            })}`
        },
        ".swiper-button-disabled": {
            opacity: "0.6 !important"
        }
    },
    ".swiper-button-prev": {
        background: `url(${swiperLeft}) 0 0 no-repeat`,
        left: "16px"
    },
    ".swiper-button-next": {
        background: `url(${swiperRight}) 0 0 no-repeat`,
        right: "16px"
    },
    ".swiper-button-next, .swiper-button-prev": {
        width: "40px",
        height: "40px",
        borderRadius: "50%",
        backgroundSize: "100% 100%",
        "&::after": {
            content: '""'
        }
    },
    ".swiper-button-disabled": {
        cursor: "not-allowed",
        pointerEvents: "auto",
        display: "none"
    },
    ".swiper-pagination-bullet": {
        width: "6px",
        height: "6px"
    }
}));
function CloseButton({onClose: _e, _className: $=""}) {
    const et = useTheme();
    return jsxRuntimeExports.jsx(IconButton, {
        sx: {
            width: "40px",
            position: "absolute",
            top: 20,
            left: 20,
            color: "#FFF",
            height: "40px",
            backgroundColor: alpha(et.palette.common.black, .6),
            zIndex: 10
        },
        onClick: _e,
        className: $,
        children: jsxRuntimeExports.jsx(CloseIcon$1, {
            sx: {
                fontWeight: "bold",
                color: "#fff"
            }
        })
    })
}
const MediaFullScreenViewer = React.memo( () => {
    const {setIsVisibleMediaViewer: _e} = useApplicationStore()
      , {mediaType: $, mediaList: et, mediaActiveId: tt, setMediaActiveId: nt} = useMediaStore()
      , [rt,it] = reactExports.useState([]);
    return reactExports.useEffect( () => {
        if ($ === "local") {
            const ot = lodashExports.cloneDeep(et).map(st => (st.url = getObjectURL(st.file),
            st.thumbnail_file = getObjectURL(st.file),
            st));
            it(ot)
        } else
            it(et)
    }
    , []),
    jsxRuntimeExports.jsxs(StyledDialog, {
        fullScreen: !0,
        open: !0,
        onClose: () => {
            _e(!1)
        }
        ,
        className: "media-full-screen-viewer",
        children: [jsxRuntimeExports.jsx(CloseButton, {
            onClose: () => _e(!1)
        }), rt && rt.length > 0 && jsxRuntimeExports.jsx(Swiper, {
            materials: rt,
            activeIndex: tt,
            setActiveIndex: ot => nt(ot)
        })]
    })
}
)
  , StyledDialog = styled(Dialog$1)( ({theme: _e}) => ({
    ".MuiDialog-paper": {
        width: "100%",
        height: "100%",
        maxWidth: "100%",
        maxHeight: "100%",
        borderRadius: 0,
        background: alpha(_e.palette.common.black, .9),
        ".swiper-box": {
            width: "100%",
            minWidth: "100%",
            maxWidth: "100%",
            minHeight: "100%",
            ".swiper-button-prev, .swiper-button-next, .swiper-pagination, .MuiChip-root": {
                opacity: "1 !important"
            },
            ".swiper-button-prev": {
                left: "20px"
            },
            ".swiper-button-next": {
                right: "20px"
            },
            ".swiper-button-prev:after,  .swiper-button-next:after": {
                fontSize: "20px"
            },
            ".MuiChip-label": {
                fontSize: "18px"
            }
        }
    }
}))
  , ErrorBoundarySvg = "data:image/svg+xml,%3csvg%20width='92'%20height='82'%20viewBox='0%200%2092%2082'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3crect%20y='1'%20width='92'%20height='81'%20rx='4.5'%20fill='%2354637C'/%3e%3cpath%20d='M7%2020.5C7%2018.0147%209.01472%2016%2011.5%2016H80.5C82.9853%2016%2085%2018.0147%2085%2020.5V70.5C85%2072.9853%2082.9853%2075%2080.5%2075H11.5C9.01472%2075%207%2072.9853%207%2070.5V20.5Z'%20fill='%232A384A'/%3e%3cpath%20d='M43.4019%2029.5C44.5566%2027.5%2047.4434%2027.5%2048.5981%2029.5L65.9186%2059.5C67.0733%2061.5%2065.6299%2064%2063.3205%2064H28.6795C26.3701%2064%2024.9267%2061.5%2026.0814%2059.5L43.4019%2029.5Z'%20fill='%2354637C'/%3e%3cpath%20fill-rule='evenodd'%20clip-rule='evenodd'%20d='M45.0244%2050.2294C45.0244%2051.5583%2045.4834%2052.6347%2046.0488%2052.6347C46.6143%2052.6347%2047.0732%2051.5583%2047.0732%2050.2294L48.0977%2039.4053C48.0977%2038.0764%2047.1808%2037%2046.0488%2037C44.9169%2037%2044%2038.0764%2044%2039.4053L45.0244%2050.2294ZM44%2057.1735C44%2055.8994%2044.9169%2054.8675%2046.0488%2054.8675C47.1808%2054.8675%2048.0977%2055.8994%2048.0977%2057.1735C48.0977%2058.4476%2047.1808%2059.4796%2046.0488%2059.4796C44.9169%2059.4796%2044%2058.4476%2044%2057.1735Z'%20fill='%232A384A'/%3e%3cg%20opacity='0.5'%3e%3crect%20x='9'%20y='7'%20width='4'%20height='4'%20rx='2'%20fill='%232A384A'/%3e%3crect%20x='17'%20y='7'%20width='4'%20height='4'%20rx='2'%20fill='%232A384A'/%3e%3crect%20x='25'%20y='7'%20width='4'%20height='4'%20rx='2'%20fill='%232A384A'/%3e%3cpath%20d='M33%209C33%207.89543%2033.8954%207%2035%207H81C82.1046%207%2083%207.89543%2083%209C83%2010.1046%2082.1046%2011%2081%2011H35C33.8954%2011%2033%2010.1046%2033%209Z'%20fill='%232A384A'/%3e%3c/g%3e%3c/svg%3e";
class ErrorComponent extends reactExports.Component {
    constructor($) {
        super($),
        this.state = {
            hasError: !1,
            Error: null,
            ErrorInfo: null
        }
    }
    static getDerivedStateFromError() {
        return {
            hasError: !0
        }
    }
    componentDidCatch($, et) {
        this.setState(tt => ({
            hasError: tt.hasError,
            Error: $,
            ErrorInfo: et
        }))
    }
    render() {
        return this.state.hasError ? jsxRuntimeExports.jsx(Box, {
            className: "rounded-2xl w-full h-[578px] flex justify-center items-center",
            sx: {
                background: "#2A384A"
            },
            children: jsxRuntimeExports.jsxs("div", {
                className: "text-center",
                children: [jsxRuntimeExports.jsx("img", {
                    className: "m-auto",
                    src: ErrorBoundarySvg,
                    alt: ""
                }), jsxRuntimeExports.jsx(Typography, {
                    fontSize: 16,
                    fontWeight: 600,
                    className: "mt-12",
                    children: "Page error"
                }), jsxRuntimeExports.jsx(Typography, {
                    color: "secondary",
                    fontSize: 14,
                    fontWeight: 400,
                    className: "mt-1.5 sm:px-4",
                    children: "The page appears to be experiencing some issues. You can try refreshing the interface."
                }), jsxRuntimeExports.jsx(Button, {
                    variant: "outlined",
                    color: "secondary",
                    className: "w-[120px] mt-6",
                    onClick: () => {
                        window.location.reload()
                    }
                    ,
                    children: "Reload"
                })]
            })
        }) : this.props.children
    }
}
const ErrorBoundary = _e => {
    const $ = useNavigate()
      , {pathname: et} = useLocation();
    return jsxRuntimeExports.jsx(ErrorComponent, {
        navigate: $,
        children: _e.children
    }, et)
}
  , LoginDialog = ({onClose: _e}) => {
    const {login: $, logout: et, isLoginLoading: tt} = useLogin()
      , [nt,rt] = reactExports.useState(!1)
      , it = () => {
        et(),
        _e()
    }
    ;
    return reactExports.useEffect( () => {
        nt || ($(),
        rt(!0))
    }
    , []),
    jsxRuntimeExports.jsx(Dialog, {
        title: i18n._({
            id: "5Wrnud"
        }),
        open: !0,
        onClose: it,
        children: jsxRuntimeExports.jsx(Box, {
            className: "flex flex-col space-y-6",
            children: jsxRuntimeExports.jsx(Button, {
                variant: "contained",
                onClick: $,
                disabled: tt,
                children: tt ? jsxRuntimeExports.jsx(Trans, {
                    id: "QvIt9E"
                }) : jsxRuntimeExports.jsx(Trans, {
                    id: "MDYeYg"
                })
            })
        })
    })
}
  , GlobalComponents = () => {
    const [_e,$] = reactExports.useState(!1)
      , {wallet: et, connected: tt, publicKey: nt, connecting: rt, disconnecting: it, disconnect: ot} = useWallet()
      , {token: st, clearUserInfo: lt, signAddress: ct} = useStore$1();
    reactExports.useEffect( () => {
        rt || it || (tt && st === "" && $(!0),
        !tt && st === "" && $(!1))
    }
    , [rt, it, tt, st]),
    useUpdateEffect( () => {
        it && lt()
    }
    , [it]),
    reactExports.useEffect( () => {
        (et == null ? void 0 : et.readyState) === WalletReadyState.NotDetected && (ot(),
        lt())
    }
    , [et == null ? void 0 : et.readyState]),
    useUpdateEffect( () => {
        st && $(!1)
    }
    , [st]),
    reactExports.useEffect( () => {
        nt && nt.toBase58() !== ct && lt()
    }
    , [nt, ct]),
    reactExports.useEffect( () => {
        it && lt()
    }
    , [it]);
    const dt = () => {
        $(!1)
    }
    ;
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {
        children: _e && jsxRuntimeExports.jsx(LoginDialog, {
            onClose: dt
        })
    })
}
;
var vconsole_min = {
    exports: {}
};
/*!
 * vConsole v3.15.1 (https://github.com/Tencent/vConsole)
 *
 * Tencent is pleased to support the open source community by making vConsole available.
 * Copyright (C) 2017 THL A29 Limited, a Tencent company. All rights reserved.
 * Licensed under the MIT License (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at
 * http://opensource.org/licenses/MIT
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
 */
(function(module, exports) {
    (function(_e, $) {
        module.exports = $()
    }
    )(commonjsGlobal$1 || self, function() {
        return function() {
            var __webpack_modules__ = {
                4264: function(_e, $, et) {
                    _e.exports = et(7588)
                },
                5036: function(_e, $, et) {
                    et(1719),
                    et(5677),
                    et(6394),
                    et(5334),
                    et(6969),
                    et(2021),
                    et(8328),
                    et(2129);
                    var tt = et(1287);
                    _e.exports = tt.Promise
                },
                2582: function(_e, $, et) {
                    et(1646),
                    et(6394),
                    et(2004),
                    et(462),
                    et(8407),
                    et(2429),
                    et(1172),
                    et(8288),
                    et(1274),
                    et(8201),
                    et(6626),
                    et(3211),
                    et(9952),
                    et(15),
                    et(9831),
                    et(7521),
                    et(2972),
                    et(6956),
                    et(5222),
                    et(2257);
                    var tt = et(1287);
                    _e.exports = tt.Symbol
                },
                8257: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(9212)
                      , rt = et(5637)
                      , it = tt.TypeError;
                    _e.exports = function(ot) {
                        if (nt(ot))
                            return ot;
                        throw it(rt(ot) + " is not a function")
                    }
                },
                1186: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(2097)
                      , rt = et(5637)
                      , it = tt.TypeError;
                    _e.exports = function(ot) {
                        if (nt(ot))
                            return ot;
                        throw it(rt(ot) + " is not a constructor")
                    }
                },
                9882: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(9212)
                      , rt = tt.String
                      , it = tt.TypeError;
                    _e.exports = function(ot) {
                        if (typeof ot == "object" || nt(ot))
                            return ot;
                        throw it("Can't set " + rt(ot) + " as a prototype")
                    }
                },
                6288: function(_e, $, et) {
                    var tt = et(3649)
                      , nt = et(3590)
                      , rt = et(4615)
                      , it = tt("unscopables")
                      , ot = Array.prototype;
                    ot[it] == null && rt.f(ot, it, {
                        configurable: !0,
                        value: nt(null)
                    }),
                    _e.exports = function(st) {
                        ot[it][st] = !0
                    }
                },
                4761: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(2447)
                      , rt = tt.TypeError;
                    _e.exports = function(it, ot) {
                        if (nt(ot, it))
                            return it;
                        throw rt("Incorrect invocation")
                    }
                },
                2569: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(794)
                      , rt = tt.String
                      , it = tt.TypeError;
                    _e.exports = function(ot) {
                        if (nt(ot))
                            return ot;
                        throw it(rt(ot) + " is not an object")
                    }
                },
                5766: function(_e, $, et) {
                    var tt = et(2977)
                      , nt = et(6782)
                      , rt = et(1825)
                      , it = function(ot) {
                        return function(st, lt, ct) {
                            var dt, pt = tt(st), ht = rt(pt), mt = nt(ct, ht);
                            if (ot && lt != lt) {
                                for (; ht > mt; )
                                    if ((dt = pt[mt++]) != dt)
                                        return !0
                            } else
                                for (; ht > mt; mt++)
                                    if ((ot || mt in pt) && pt[mt] === lt)
                                        return ot || mt || 0;
                            return !ot && -1
                        }
                    };
                    _e.exports = {
                        includes: it(!0),
                        indexOf: it(!1)
                    }
                },
                4805: function(_e, $, et) {
                    var tt = et(2938)
                      , nt = et(7386)
                      , rt = et(5044)
                      , it = et(1324)
                      , ot = et(1825)
                      , st = et(4822)
                      , lt = nt([].push)
                      , ct = function(dt) {
                        var pt = dt == 1
                          , ht = dt == 2
                          , mt = dt == 3
                          , yt = dt == 4
                          , Et = dt == 6
                          , _t = dt == 7
                          , wt = dt == 5 || Et;
                        return function(St, Ct, Nt, Lt) {
                            for (var kt, Ut, Jt = it(St), Pt = rt(Jt), Xt = tt(Ct, Nt), rn = ot(Pt), zt = 0, xt = Lt || st, $t = pt ? xt(St, rn) : ht || _t ? xt(St, 0) : void 0; rn > zt; zt++)
                                if ((wt || zt in Pt) && (Ut = Xt(kt = Pt[zt], zt, Jt),
                                dt))
                                    if (pt)
                                        $t[zt] = Ut;
                                    else if (Ut)
                                        switch (dt) {
                                        case 3:
                                            return !0;
                                        case 5:
                                            return kt;
                                        case 6:
                                            return zt;
                                        case 2:
                                            lt($t, kt)
                                        }
                                    else
                                        switch (dt) {
                                        case 4:
                                            return !1;
                                        case 7:
                                            lt($t, kt)
                                        }
                            return Et ? -1 : mt || yt ? yt : $t
                        }
                    };
                    _e.exports = {
                        forEach: ct(0),
                        map: ct(1),
                        filter: ct(2),
                        some: ct(3),
                        every: ct(4),
                        find: ct(5),
                        findIndex: ct(6),
                        filterReject: ct(7)
                    }
                },
                9269: function(_e, $, et) {
                    var tt = et(6544)
                      , nt = et(3649)
                      , rt = et(4061)
                      , it = nt("species");
                    _e.exports = function(ot) {
                        return rt >= 51 || !tt(function() {
                            var st = [];
                            return (st.constructor = {})[it] = function() {
                                return {
                                    foo: 1
                                }
                            }
                            ,
                            st[ot](Boolean).foo !== 1
                        })
                    }
                },
                4546: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(6782)
                      , rt = et(1825)
                      , it = et(5999)
                      , ot = tt.Array
                      , st = Math.max;
                    _e.exports = function(lt, ct, dt) {
                        for (var pt = rt(lt), ht = nt(ct, pt), mt = nt(dt === void 0 ? pt : dt, pt), yt = ot(st(mt - ht, 0)), Et = 0; ht < mt; ht++,
                        Et++)
                            it(yt, Et, lt[ht]);
                        return yt.length = Et,
                        yt
                    }
                },
                6917: function(_e, $, et) {
                    var tt = et(7386);
                    _e.exports = tt([].slice)
                },
                5289: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(4521)
                      , rt = et(2097)
                      , it = et(794)
                      , ot = et(3649)("species")
                      , st = tt.Array;
                    _e.exports = function(lt) {
                        var ct;
                        return nt(lt) && (ct = lt.constructor,
                        (rt(ct) && (ct === st || nt(ct.prototype)) || it(ct) && (ct = ct[ot]) === null) && (ct = void 0)),
                        ct === void 0 ? st : ct
                    }
                },
                4822: function(_e, $, et) {
                    var tt = et(5289);
                    _e.exports = function(nt, rt) {
                        return new (tt(nt))(rt === 0 ? 0 : rt)
                    }
                },
                3616: function(_e, $, et) {
                    var tt = et(3649)("iterator")
                      , nt = !1;
                    try {
                        var rt = 0
                          , it = {
                            next: function() {
                                return {
                                    done: !!rt++
                                }
                            },
                            return: function() {
                                nt = !0
                            }
                        };
                        it[tt] = function() {
                            return this
                        }
                        ,
                        Array.from(it, function() {
                            throw 2
                        })
                    } catch {}
                    _e.exports = function(ot, st) {
                        if (!st && !nt)
                            return !1;
                        var lt = !1;
                        try {
                            var ct = {};
                            ct[tt] = function() {
                                return {
                                    next: function() {
                                        return {
                                            done: lt = !0
                                        }
                                    }
                                }
                            }
                            ,
                            ot(ct)
                        } catch {}
                        return lt
                    }
                },
                9624: function(_e, $, et) {
                    var tt = et(7386)
                      , nt = tt({}.toString)
                      , rt = tt("".slice);
                    _e.exports = function(it) {
                        return rt(nt(it), 8, -1)
                    }
                },
                3058: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(8191)
                      , rt = et(9212)
                      , it = et(9624)
                      , ot = et(3649)("toStringTag")
                      , st = tt.Object
                      , lt = it(function() {
                        return arguments
                    }()) == "Arguments";
                    _e.exports = nt ? it : function(ct) {
                        var dt, pt, ht;
                        return ct === void 0 ? "Undefined" : ct === null ? "Null" : typeof (pt = function(mt, yt) {
                            try {
                                return mt[yt]
                            } catch {}
                        }(dt = st(ct), ot)) == "string" ? pt : lt ? it(dt) : (ht = it(dt)) == "Object" && rt(dt.callee) ? "Arguments" : ht
                    }
                },
                1509: function(_e, $, et) {
                    var tt = et(7386)("".replace)
                      , nt = String(Error("zxcasd").stack)
                      , rt = /\n\s*at [^:]*:[^\n]*/
                      , it = rt.test(nt);
                    _e.exports = function(ot, st) {
                        if (it && typeof ot == "string")
                            for (; st--; )
                                ot = tt(ot, rt, "");
                        return ot
                    }
                },
                3478: function(_e, $, et) {
                    var tt = et(2870)
                      , nt = et(929)
                      , rt = et(6683)
                      , it = et(4615);
                    _e.exports = function(ot, st, lt) {
                        for (var ct = nt(st), dt = it.f, pt = rt.f, ht = 0; ht < ct.length; ht++) {
                            var mt = ct[ht];
                            tt(ot, mt) || lt && tt(lt, mt) || dt(ot, mt, pt(st, mt))
                        }
                    }
                },
                926: function(_e, $, et) {
                    var tt = et(6544);
                    _e.exports = !tt(function() {
                        function nt() {}
                        return nt.prototype.constructor = null,
                        Object.getPrototypeOf(new nt) !== nt.prototype
                    })
                },
                4683: function(_e, $, et) {
                    var tt = et(2365).IteratorPrototype
                      , nt = et(3590)
                      , rt = et(4677)
                      , it = et(8821)
                      , ot = et(339)
                      , st = function() {
                        return this
                    };
                    _e.exports = function(lt, ct, dt, pt) {
                        var ht = ct + " Iterator";
                        return lt.prototype = nt(tt, {
                            next: rt(+!pt, dt)
                        }),
                        it(lt, ht, !1, !0),
                        ot[ht] = st,
                        lt
                    }
                },
                57: function(_e, $, et) {
                    var tt = et(8494)
                      , nt = et(4615)
                      , rt = et(4677);
                    _e.exports = tt ? function(it, ot, st) {
                        return nt.f(it, ot, rt(1, st))
                    }
                    : function(it, ot, st) {
                        return it[ot] = st,
                        it
                    }
                },
                4677: function(_e) {
                    _e.exports = function($, et) {
                        return {
                            enumerable: !(1 & $),
                            configurable: !(2 & $),
                            writable: !(4 & $),
                            value: et
                        }
                    }
                },
                5999: function(_e, $, et) {
                    var tt = et(8734)
                      , nt = et(4615)
                      , rt = et(4677);
                    _e.exports = function(it, ot, st) {
                        var lt = tt(ot);
                        lt in it ? nt.f(it, lt, rt(0, st)) : it[lt] = st
                    }
                },
                9012: function(_e, $, et) {
                    var tt = et(7263)
                      , nt = et(8262)
                      , rt = et(6268)
                      , it = et(4340)
                      , ot = et(9212)
                      , st = et(4683)
                      , lt = et(729)
                      , ct = et(7496)
                      , dt = et(8821)
                      , pt = et(57)
                      , ht = et(1270)
                      , mt = et(3649)
                      , yt = et(339)
                      , Et = et(2365)
                      , _t = it.PROPER
                      , wt = it.CONFIGURABLE
                      , St = Et.IteratorPrototype
                      , Ct = Et.BUGGY_SAFARI_ITERATORS
                      , Nt = mt("iterator")
                      , Lt = "keys"
                      , kt = "values"
                      , Ut = "entries"
                      , Jt = function() {
                        return this
                    };
                    _e.exports = function(Pt, Xt, rn, zt, xt, $t, Dt) {
                        st(rn, Xt, zt);
                        var jt, Ft, Ht, qt = function(kn) {
                            if (kn === xt && hn)
                                return hn;
                            if (!Ct && kn in Yt)
                                return Yt[kn];
                            switch (kn) {
                            case Lt:
                            case kt:
                            case Ut:
                                return function() {
                                    return new rn(this,kn)
                                }
                            }
                            return function() {
                                return new rn(this)
                            }
                        }, Wt = Xt + " Iterator", Mt = !1, Yt = Pt.prototype, un = Yt[Nt] || Yt["@@iterator"] || xt && Yt[xt], hn = !Ct && un || qt(xt), _n = Xt == "Array" && Yt.entries || un;
                        if (_n && (jt = lt(_n.call(new Pt))) !== Object.prototype && jt.next && (rt || lt(jt) === St || (ct ? ct(jt, St) : ot(jt[Nt]) || ht(jt, Nt, Jt)),
                        dt(jt, Wt, !0, !0),
                        rt && (yt[Wt] = Jt)),
                        _t && xt == kt && un && un.name !== kt && (!rt && wt ? pt(Yt, "name", kt) : (Mt = !0,
                        hn = function() {
                            return nt(un, this)
                        }
                        )),
                        xt)
                            if (Ft = {
                                values: qt(kt),
                                keys: $t ? hn : qt(Lt),
                                entries: qt(Ut)
                            },
                            Dt)
                                for (Ht in Ft)
                                    (Ct || Mt || !(Ht in Yt)) && ht(Yt, Ht, Ft[Ht]);
                            else
                                tt({
                                    target: Xt,
                                    proto: !0,
                                    forced: Ct || Mt
                                }, Ft);
                        return rt && !Dt || Yt[Nt] === hn || ht(Yt, Nt, hn, {
                            name: xt
                        }),
                        yt[Xt] = hn,
                        Ft
                    }
                },
                2219: function(_e, $, et) {
                    var tt = et(1287)
                      , nt = et(2870)
                      , rt = et(491)
                      , it = et(4615).f;
                    _e.exports = function(ot) {
                        var st = tt.Symbol || (tt.Symbol = {});
                        nt(st, ot) || it(st, ot, {
                            value: rt.f(ot)
                        })
                    }
                },
                8494: function(_e, $, et) {
                    var tt = et(6544);
                    _e.exports = !tt(function() {
                        return Object.defineProperty({}, 1, {
                            get: function() {
                                return 7
                            }
                        })[1] != 7
                    })
                },
                6668: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(794)
                      , rt = tt.document
                      , it = nt(rt) && nt(rt.createElement);
                    _e.exports = function(ot) {
                        return it ? rt.createElement(ot) : {}
                    }
                },
                6778: function(_e) {
                    _e.exports = {
                        CSSRuleList: 0,
                        CSSStyleDeclaration: 0,
                        CSSValueList: 0,
                        ClientRectList: 0,
                        DOMRectList: 0,
                        DOMStringList: 0,
                        DOMTokenList: 1,
                        DataTransferItemList: 0,
                        FileList: 0,
                        HTMLAllCollection: 0,
                        HTMLCollection: 0,
                        HTMLFormElement: 0,
                        HTMLSelectElement: 0,
                        MediaList: 0,
                        MimeTypeArray: 0,
                        NamedNodeMap: 0,
                        NodeList: 1,
                        PaintRequestList: 0,
                        Plugin: 0,
                        PluginArray: 0,
                        SVGLengthList: 0,
                        SVGNumberList: 0,
                        SVGPathSegList: 0,
                        SVGPointList: 0,
                        SVGStringList: 0,
                        SVGTransformList: 0,
                        SourceBufferList: 0,
                        StyleSheetList: 0,
                        TextTrackCueList: 0,
                        TextTrackList: 0,
                        TouchList: 0
                    }
                },
                9307: function(_e, $, et) {
                    var tt = et(6668)("span").classList
                      , nt = tt && tt.constructor && tt.constructor.prototype;
                    _e.exports = nt === Object.prototype ? void 0 : nt
                },
                2274: function(_e) {
                    _e.exports = typeof window == "object"
                },
                3256: function(_e, $, et) {
                    var tt = et(6918)
                      , nt = et(7583);
                    _e.exports = /ipad|iphone|ipod/i.test(tt) && nt.Pebble !== void 0
                },
                7020: function(_e, $, et) {
                    var tt = et(6918);
                    _e.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(tt)
                },
                5354: function(_e, $, et) {
                    var tt = et(9624)
                      , nt = et(7583);
                    _e.exports = tt(nt.process) == "process"
                },
                6846: function(_e, $, et) {
                    var tt = et(6918);
                    _e.exports = /web0s(?!.*chrome)/i.test(tt)
                },
                6918: function(_e, $, et) {
                    var tt = et(5897);
                    _e.exports = tt("navigator", "userAgent") || ""
                },
                4061: function(_e, $, et) {
                    var tt, nt, rt = et(7583), it = et(6918), ot = rt.process, st = rt.Deno, lt = ot && ot.versions || st && st.version, ct = lt && lt.v8;
                    ct && (nt = (tt = ct.split("."))[0] > 0 && tt[0] < 4 ? 1 : +(tt[0] + tt[1])),
                    !nt && it && (!(tt = it.match(/Edge\/(\d+)/)) || tt[1] >= 74) && (tt = it.match(/Chrome\/(\d+)/)) && (nt = +tt[1]),
                    _e.exports = nt
                },
                5690: function(_e) {
                    _e.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"]
                },
                1178: function(_e, $, et) {
                    var tt = et(6544)
                      , nt = et(4677);
                    _e.exports = !tt(function() {
                        var rt = Error("a");
                        return !("stack"in rt) || (Object.defineProperty(rt, "stack", nt(1, 7)),
                        rt.stack !== 7)
                    })
                },
                7263: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(6683).f
                      , rt = et(57)
                      , it = et(1270)
                      , ot = et(460)
                      , st = et(3478)
                      , lt = et(4451);
                    _e.exports = function(ct, dt) {
                        var pt, ht, mt, yt, Et, _t = ct.target, wt = ct.global, St = ct.stat;
                        if (pt = wt ? tt : St ? tt[_t] || ot(_t, {}) : (tt[_t] || {}).prototype)
                            for (ht in dt) {
                                if (yt = dt[ht],
                                mt = ct.noTargetGet ? (Et = nt(pt, ht)) && Et.value : pt[ht],
                                !lt(wt ? ht : _t + (St ? "." : "#") + ht, ct.forced) && mt !== void 0) {
                                    if (typeof yt == typeof mt)
                                        continue;
                                    st(yt, mt)
                                }
                                (ct.sham || mt && mt.sham) && rt(yt, "sham", !0),
                                it(pt, ht, yt, ct)
                            }
                    }
                },
                6544: function(_e) {
                    _e.exports = function($) {
                        try {
                            return !!$()
                        } catch {
                            return !0
                        }
                    }
                },
                1611: function(_e, $, et) {
                    var tt = et(8987)
                      , nt = Function.prototype
                      , rt = nt.apply
                      , it = nt.call;
                    _e.exports = typeof Reflect == "object" && Reflect.apply || (tt ? it.bind(rt) : function() {
                        return it.apply(rt, arguments)
                    }
                    )
                },
                2938: function(_e, $, et) {
                    var tt = et(7386)
                      , nt = et(8257)
                      , rt = et(8987)
                      , it = tt(tt.bind);
                    _e.exports = function(ot, st) {
                        return nt(ot),
                        st === void 0 ? ot : rt ? it(ot, st) : function() {
                            return ot.apply(st, arguments)
                        }
                    }
                },
                8987: function(_e, $, et) {
                    var tt = et(6544);
                    _e.exports = !tt(function() {
                        var nt = (function() {}
                        ).bind();
                        return typeof nt != "function" || nt.hasOwnProperty("prototype")
                    })
                },
                8262: function(_e, $, et) {
                    var tt = et(8987)
                      , nt = Function.prototype.call;
                    _e.exports = tt ? nt.bind(nt) : function() {
                        return nt.apply(nt, arguments)
                    }
                },
                4340: function(_e, $, et) {
                    var tt = et(8494)
                      , nt = et(2870)
                      , rt = Function.prototype
                      , it = tt && Object.getOwnPropertyDescriptor
                      , ot = nt(rt, "name")
                      , st = ot && (function() {}
                    ).name === "something"
                      , lt = ot && (!tt || tt && it(rt, "name").configurable);
                    _e.exports = {
                        EXISTS: ot,
                        PROPER: st,
                        CONFIGURABLE: lt
                    }
                },
                7386: function(_e, $, et) {
                    var tt = et(8987)
                      , nt = Function.prototype
                      , rt = nt.bind
                      , it = nt.call
                      , ot = tt && rt.bind(it, it);
                    _e.exports = tt ? function(st) {
                        return st && ot(st)
                    }
                    : function(st) {
                        return st && function() {
                            return it.apply(st, arguments)
                        }
                    }
                },
                5897: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(9212)
                      , rt = function(it) {
                        return nt(it) ? it : void 0
                    };
                    _e.exports = function(it, ot) {
                        return arguments.length < 2 ? rt(tt[it]) : tt[it] && tt[it][ot]
                    }
                },
                8272: function(_e, $, et) {
                    var tt = et(3058)
                      , nt = et(911)
                      , rt = et(339)
                      , it = et(3649)("iterator");
                    _e.exports = function(ot) {
                        if (ot != null)
                            return nt(ot, it) || nt(ot, "@@iterator") || rt[tt(ot)]
                    }
                },
                6307: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(8262)
                      , rt = et(8257)
                      , it = et(2569)
                      , ot = et(5637)
                      , st = et(8272)
                      , lt = tt.TypeError;
                    _e.exports = function(ct, dt) {
                        var pt = arguments.length < 2 ? st(ct) : dt;
                        if (rt(pt))
                            return it(nt(pt, ct));
                        throw lt(ot(ct) + " is not iterable")
                    }
                },
                911: function(_e, $, et) {
                    var tt = et(8257);
                    _e.exports = function(nt, rt) {
                        var it = nt[rt];
                        return it == null ? void 0 : tt(it)
                    }
                },
                7583: function(_e, $, et) {
                    var tt = function(nt) {
                        return nt && nt.Math == Math && nt
                    };
                    _e.exports = tt(typeof globalThis == "object" && globalThis) || tt(typeof window == "object" && window) || tt(typeof self == "object" && self) || tt(typeof et.g == "object" && et.g) || function() {
                        return this
                    }() || Function("return this")()
                },
                2870: function(_e, $, et) {
                    var tt = et(7386)
                      , nt = et(1324)
                      , rt = tt({}.hasOwnProperty);
                    _e.exports = Object.hasOwn || function(it, ot) {
                        return rt(nt(it), ot)
                    }
                },
                4639: function(_e) {
                    _e.exports = {}
                },
                2716: function(_e, $, et) {
                    var tt = et(7583);
                    _e.exports = function(nt, rt) {
                        var it = tt.console;
                        it && it.error && (arguments.length == 1 ? it.error(nt) : it.error(nt, rt))
                    }
                },
                482: function(_e, $, et) {
                    var tt = et(5897);
                    _e.exports = tt("document", "documentElement")
                },
                275: function(_e, $, et) {
                    var tt = et(8494)
                      , nt = et(6544)
                      , rt = et(6668);
                    _e.exports = !tt && !nt(function() {
                        return Object.defineProperty(rt("div"), "a", {
                            get: function() {
                                return 7
                            }
                        }).a != 7
                    })
                },
                5044: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(7386)
                      , rt = et(6544)
                      , it = et(9624)
                      , ot = tt.Object
                      , st = nt("".split);
                    _e.exports = rt(function() {
                        return !ot("z").propertyIsEnumerable(0)
                    }) ? function(lt) {
                        return it(lt) == "String" ? st(lt, "") : ot(lt)
                    }
                    : ot
                },
                9734: function(_e, $, et) {
                    var tt = et(7386)
                      , nt = et(9212)
                      , rt = et(1314)
                      , it = tt(Function.toString);
                    nt(rt.inspectSource) || (rt.inspectSource = function(ot) {
                        return it(ot)
                    }
                    ),
                    _e.exports = rt.inspectSource
                },
                4402: function(_e, $, et) {
                    var tt = et(794)
                      , nt = et(57);
                    _e.exports = function(rt, it) {
                        tt(it) && "cause"in it && nt(rt, "cause", it.cause)
                    }
                },
                2743: function(_e, $, et) {
                    var tt, nt, rt, it = et(9491), ot = et(7583), st = et(7386), lt = et(794), ct = et(57), dt = et(2870), pt = et(1314), ht = et(9137), mt = et(4639), yt = "Object already initialized", Et = ot.TypeError, _t = ot.WeakMap;
                    if (it || pt.state) {
                        var wt = pt.state || (pt.state = new _t)
                          , St = st(wt.get)
                          , Ct = st(wt.has)
                          , Nt = st(wt.set);
                        tt = function(kt, Ut) {
                            if (Ct(wt, kt))
                                throw new Et(yt);
                            return Ut.facade = kt,
                            Nt(wt, kt, Ut),
                            Ut
                        }
                        ,
                        nt = function(kt) {
                            return St(wt, kt) || {}
                        }
                        ,
                        rt = function(kt) {
                            return Ct(wt, kt)
                        }
                    } else {
                        var Lt = ht("state");
                        mt[Lt] = !0,
                        tt = function(kt, Ut) {
                            if (dt(kt, Lt))
                                throw new Et(yt);
                            return Ut.facade = kt,
                            ct(kt, Lt, Ut),
                            Ut
                        }
                        ,
                        nt = function(kt) {
                            return dt(kt, Lt) ? kt[Lt] : {}
                        }
                        ,
                        rt = function(kt) {
                            return dt(kt, Lt)
                        }
                    }
                    _e.exports = {
                        set: tt,
                        get: nt,
                        has: rt,
                        enforce: function(kt) {
                            return rt(kt) ? nt(kt) : tt(kt, {})
                        },
                        getterFor: function(kt) {
                            return function(Ut) {
                                var Jt;
                                if (!lt(Ut) || (Jt = nt(Ut)).type !== kt)
                                    throw Et("Incompatible receiver, " + kt + " required");
                                return Jt
                            }
                        }
                    }
                },
                114: function(_e, $, et) {
                    var tt = et(3649)
                      , nt = et(339)
                      , rt = tt("iterator")
                      , it = Array.prototype;
                    _e.exports = function(ot) {
                        return ot !== void 0 && (nt.Array === ot || it[rt] === ot)
                    }
                },
                4521: function(_e, $, et) {
                    var tt = et(9624);
                    _e.exports = Array.isArray || function(nt) {
                        return tt(nt) == "Array"
                    }
                },
                9212: function(_e) {
                    _e.exports = function($) {
                        return typeof $ == "function"
                    }
                },
                2097: function(_e, $, et) {
                    var tt = et(7386)
                      , nt = et(6544)
                      , rt = et(9212)
                      , it = et(3058)
                      , ot = et(5897)
                      , st = et(9734)
                      , lt = function() {}
                      , ct = []
                      , dt = ot("Reflect", "construct")
                      , pt = /^\s*(?:class|function)\b/
                      , ht = tt(pt.exec)
                      , mt = !pt.exec(lt)
                      , yt = function(_t) {
                        if (!rt(_t))
                            return !1;
                        try {
                            return dt(lt, ct, _t),
                            !0
                        } catch {
                            return !1
                        }
                    }
                      , Et = function(_t) {
                        if (!rt(_t))
                            return !1;
                        switch (it(_t)) {
                        case "AsyncFunction":
                        case "GeneratorFunction":
                        case "AsyncGeneratorFunction":
                            return !1
                        }
                        try {
                            return mt || !!ht(pt, st(_t))
                        } catch {
                            return !0
                        }
                    };
                    Et.sham = !0,
                    _e.exports = !dt || nt(function() {
                        var _t;
                        return yt(yt.call) || !yt(Object) || !yt(function() {
                            _t = !0
                        }) || _t
                    }) ? Et : yt
                },
                4451: function(_e, $, et) {
                    var tt = et(6544)
                      , nt = et(9212)
                      , rt = /#|\.prototype\./
                      , it = function(dt, pt) {
                        var ht = st[ot(dt)];
                        return ht == ct || ht != lt && (nt(pt) ? tt(pt) : !!pt)
                    }
                      , ot = it.normalize = function(dt) {
                        return String(dt).replace(rt, ".").toLowerCase()
                    }
                      , st = it.data = {}
                      , lt = it.NATIVE = "N"
                      , ct = it.POLYFILL = "P";
                    _e.exports = it
                },
                794: function(_e, $, et) {
                    var tt = et(9212);
                    _e.exports = function(nt) {
                        return typeof nt == "object" ? nt !== null : tt(nt)
                    }
                },
                6268: function(_e) {
                    _e.exports = !1
                },
                5871: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(5897)
                      , rt = et(9212)
                      , it = et(2447)
                      , ot = et(7786)
                      , st = tt.Object;
                    _e.exports = ot ? function(lt) {
                        return typeof lt == "symbol"
                    }
                    : function(lt) {
                        var ct = nt("Symbol");
                        return rt(ct) && it(ct.prototype, st(lt))
                    }
                },
                4026: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(2938)
                      , rt = et(8262)
                      , it = et(2569)
                      , ot = et(5637)
                      , st = et(114)
                      , lt = et(1825)
                      , ct = et(2447)
                      , dt = et(6307)
                      , pt = et(8272)
                      , ht = et(7093)
                      , mt = tt.TypeError
                      , yt = function(_t, wt) {
                        this.stopped = _t,
                        this.result = wt
                    }
                      , Et = yt.prototype;
                    _e.exports = function(_t, wt, St) {
                        var Ct, Nt, Lt, kt, Ut, Jt, Pt, Xt = St && St.that, rn = !(!St || !St.AS_ENTRIES), zt = !(!St || !St.IS_ITERATOR), xt = !(!St || !St.INTERRUPTED), $t = nt(wt, Xt), Dt = function(Ft) {
                            return Ct && ht(Ct, "normal", Ft),
                            new yt(!0,Ft)
                        }, jt = function(Ft) {
                            return rn ? (it(Ft),
                            xt ? $t(Ft[0], Ft[1], Dt) : $t(Ft[0], Ft[1])) : xt ? $t(Ft, Dt) : $t(Ft)
                        };
                        if (zt)
                            Ct = _t;
                        else {
                            if (!(Nt = pt(_t)))
                                throw mt(ot(_t) + " is not iterable");
                            if (st(Nt)) {
                                for (Lt = 0,
                                kt = lt(_t); kt > Lt; Lt++)
                                    if ((Ut = jt(_t[Lt])) && ct(Et, Ut))
                                        return Ut;
                                return new yt(!1)
                            }
                            Ct = dt(_t, Nt)
                        }
                        for (Jt = Ct.next; !(Pt = rt(Jt, Ct)).done; ) {
                            try {
                                Ut = jt(Pt.value)
                            } catch (Ft) {
                                ht(Ct, "throw", Ft)
                            }
                            if (typeof Ut == "object" && Ut && ct(Et, Ut))
                                return Ut
                        }
                        return new yt(!1)
                    }
                },
                7093: function(_e, $, et) {
                    var tt = et(8262)
                      , nt = et(2569)
                      , rt = et(911);
                    _e.exports = function(it, ot, st) {
                        var lt, ct;
                        nt(it);
                        try {
                            if (!(lt = rt(it, "return"))) {
                                if (ot === "throw")
                                    throw st;
                                return st
                            }
                            lt = tt(lt, it)
                        } catch (dt) {
                            ct = !0,
                            lt = dt
                        }
                        if (ot === "throw")
                            throw st;
                        if (ct)
                            throw lt;
                        return nt(lt),
                        st
                    }
                },
                2365: function(_e, $, et) {
                    var tt, nt, rt, it = et(6544), ot = et(9212), st = et(3590), lt = et(729), ct = et(1270), dt = et(3649), pt = et(6268), ht = dt("iterator"), mt = !1;
                    [].keys && ("next"in (rt = [].keys()) ? (nt = lt(lt(rt))) !== Object.prototype && (tt = nt) : mt = !0),
                    tt == null || it(function() {
                        var yt = {};
                        return tt[ht].call(yt) !== yt
                    }) ? tt = {} : pt && (tt = st(tt)),
                    ot(tt[ht]) || ct(tt, ht, function() {
                        return this
                    }),
                    _e.exports = {
                        IteratorPrototype: tt,
                        BUGGY_SAFARI_ITERATORS: mt
                    }
                },
                339: function(_e) {
                    _e.exports = {}
                },
                1825: function(_e, $, et) {
                    var tt = et(97);
                    _e.exports = function(nt) {
                        return tt(nt.length)
                    }
                },
                2095: function(_e, $, et) {
                    var tt, nt, rt, it, ot, st, lt, ct, dt = et(7583), pt = et(2938), ht = et(6683).f, mt = et(8117).set, yt = et(7020), Et = et(3256), _t = et(6846), wt = et(5354), St = dt.MutationObserver || dt.WebKitMutationObserver, Ct = dt.document, Nt = dt.process, Lt = dt.Promise, kt = ht(dt, "queueMicrotask"), Ut = kt && kt.value;
                    Ut || (tt = function() {
                        var Jt, Pt;
                        for (wt && (Jt = Nt.domain) && Jt.exit(); nt; ) {
                            Pt = nt.fn,
                            nt = nt.next;
                            try {
                                Pt()
                            } catch (Xt) {
                                throw nt ? it() : rt = void 0,
                                Xt
                            }
                        }
                        rt = void 0,
                        Jt && Jt.enter()
                    }
                    ,
                    yt || wt || _t || !St || !Ct ? !Et && Lt && Lt.resolve ? ((lt = Lt.resolve(void 0)).constructor = Lt,
                    ct = pt(lt.then, lt),
                    it = function() {
                        ct(tt)
                    }
                    ) : wt ? it = function() {
                        Nt.nextTick(tt)
                    }
                    : (mt = pt(mt, dt),
                    it = function() {
                        mt(tt)
                    }
                    ) : (ot = !0,
                    st = Ct.createTextNode(""),
                    new St(tt).observe(st, {
                        characterData: !0
                    }),
                    it = function() {
                        st.data = ot = !ot
                    }
                    )),
                    _e.exports = Ut || function(Jt) {
                        var Pt = {
                            fn: Jt,
                            next: void 0
                        };
                        rt && (rt.next = Pt),
                        nt || (nt = Pt,
                        it()),
                        rt = Pt
                    }
                },
                783: function(_e, $, et) {
                    var tt = et(7583);
                    _e.exports = tt.Promise
                },
                8640: function(_e, $, et) {
                    var tt = et(4061)
                      , nt = et(6544);
                    _e.exports = !!Object.getOwnPropertySymbols && !nt(function() {
                        var rt = Symbol();
                        return !String(rt) || !(Object(rt)instanceof Symbol) || !Symbol.sham && tt && tt < 41
                    })
                },
                9491: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(9212)
                      , rt = et(9734)
                      , it = tt.WeakMap;
                    _e.exports = nt(it) && /native code/.test(rt(it))
                },
                5084: function(_e, $, et) {
                    var tt = et(8257)
                      , nt = function(rt) {
                        var it, ot;
                        this.promise = new rt(function(st, lt) {
                            if (it !== void 0 || ot !== void 0)
                                throw TypeError("Bad Promise constructor");
                            it = st,
                            ot = lt
                        }
                        ),
                        this.resolve = tt(it),
                        this.reject = tt(ot)
                    };
                    _e.exports.f = function(rt) {
                        return new nt(rt)
                    }
                },
                2764: function(_e, $, et) {
                    var tt = et(8320);
                    _e.exports = function(nt, rt) {
                        return nt === void 0 ? arguments.length < 2 ? "" : rt : tt(nt)
                    }
                },
                3590: function(_e, $, et) {
                    var tt, nt = et(2569), rt = et(8728), it = et(5690), ot = et(4639), st = et(482), lt = et(6668), ct = et(9137), dt = ct("IE_PROTO"), pt = function() {}, ht = function(Et) {
                        return "<script>" + Et + "<\/script>"
                    }, mt = function(Et) {
                        Et.write(ht("")),
                        Et.close();
                        var _t = Et.parentWindow.Object;
                        return Et = null,
                        _t
                    }, yt = function() {
                        try {
                            tt = new ActiveXObject("htmlfile")
                        } catch {}
                        var Et, _t;
                        yt = typeof document < "u" ? document.domain && tt ? mt(tt) : ((_t = lt("iframe")).style.display = "none",
                        st.appendChild(_t),
                        _t.src = "javascript:",
                        (Et = _t.contentWindow.document).open(),
                        Et.write(ht("document.F=Object")),
                        Et.close(),
                        Et.F) : mt(tt);
                        for (var wt = it.length; wt--; )
                            delete yt.prototype[it[wt]];
                        return yt()
                    };
                    ot[dt] = !0,
                    _e.exports = Object.create || function(Et, _t) {
                        var wt;
                        return Et !== null ? (pt.prototype = nt(Et),
                        wt = new pt,
                        pt.prototype = null,
                        wt[dt] = Et) : wt = yt(),
                        _t === void 0 ? wt : rt.f(wt, _t)
                    }
                },
                8728: function(_e, $, et) {
                    var tt = et(8494)
                      , nt = et(7670)
                      , rt = et(4615)
                      , it = et(2569)
                      , ot = et(2977)
                      , st = et(5432);
                    $.f = tt && !nt ? Object.defineProperties : function(lt, ct) {
                        it(lt);
                        for (var dt, pt = ot(ct), ht = st(ct), mt = ht.length, yt = 0; mt > yt; )
                            rt.f(lt, dt = ht[yt++], pt[dt]);
                        return lt
                    }
                },
                4615: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(8494)
                      , rt = et(275)
                      , it = et(7670)
                      , ot = et(2569)
                      , st = et(8734)
                      , lt = tt.TypeError
                      , ct = Object.defineProperty
                      , dt = Object.getOwnPropertyDescriptor
                      , pt = "enumerable"
                      , ht = "configurable"
                      , mt = "writable";
                    $.f = nt ? it ? function(yt, Et, _t) {
                        if (ot(yt),
                        Et = st(Et),
                        ot(_t),
                        typeof yt == "function" && Et === "prototype" && "value"in _t && mt in _t && !_t.writable) {
                            var wt = dt(yt, Et);
                            wt && wt.writable && (yt[Et] = _t.value,
                            _t = {
                                configurable: ht in _t ? _t.configurable : wt.configurable,
                                enumerable: pt in _t ? _t.enumerable : wt.enumerable,
                                writable: !1
                            })
                        }
                        return ct(yt, Et, _t)
                    }
                    : ct : function(yt, Et, _t) {
                        if (ot(yt),
                        Et = st(Et),
                        ot(_t),
                        rt)
                            try {
                                return ct(yt, Et, _t)
                            } catch {}
                        if ("get"in _t || "set"in _t)
                            throw lt("Accessors not supported");
                        return "value"in _t && (yt[Et] = _t.value),
                        yt
                    }
                },
                6683: function(_e, $, et) {
                    var tt = et(8494)
                      , nt = et(8262)
                      , rt = et(112)
                      , it = et(4677)
                      , ot = et(2977)
                      , st = et(8734)
                      , lt = et(2870)
                      , ct = et(275)
                      , dt = Object.getOwnPropertyDescriptor;
                    $.f = tt ? dt : function(pt, ht) {
                        if (pt = ot(pt),
                        ht = st(ht),
                        ct)
                            try {
                                return dt(pt, ht)
                            } catch {}
                        if (lt(pt, ht))
                            return it(!nt(rt.f, pt, ht), pt[ht])
                    }
                },
                3130: function(_e, $, et) {
                    var tt = et(9624)
                      , nt = et(2977)
                      , rt = et(9275).f
                      , it = et(4546)
                      , ot = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
                    _e.exports.f = function(st) {
                        return ot && tt(st) == "Window" ? function(lt) {
                            try {
                                return rt(lt)
                            } catch {
                                return it(ot)
                            }
                        }(st) : rt(nt(st))
                    }
                },
                9275: function(_e, $, et) {
                    var tt = et(8356)
                      , nt = et(5690).concat("length", "prototype");
                    $.f = Object.getOwnPropertyNames || function(rt) {
                        return tt(rt, nt)
                    }
                },
                4012: function(_e, $) {
                    $.f = Object.getOwnPropertySymbols
                },
                729: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(2870)
                      , rt = et(9212)
                      , it = et(1324)
                      , ot = et(9137)
                      , st = et(926)
                      , lt = ot("IE_PROTO")
                      , ct = tt.Object
                      , dt = ct.prototype;
                    _e.exports = st ? ct.getPrototypeOf : function(pt) {
                        var ht = it(pt);
                        if (nt(ht, lt))
                            return ht[lt];
                        var mt = ht.constructor;
                        return rt(mt) && ht instanceof mt ? mt.prototype : ht instanceof ct ? dt : null
                    }
                },
                2447: function(_e, $, et) {
                    var tt = et(7386);
                    _e.exports = tt({}.isPrototypeOf)
                },
                8356: function(_e, $, et) {
                    var tt = et(7386)
                      , nt = et(2870)
                      , rt = et(2977)
                      , it = et(5766).indexOf
                      , ot = et(4639)
                      , st = tt([].push);
                    _e.exports = function(lt, ct) {
                        var dt, pt = rt(lt), ht = 0, mt = [];
                        for (dt in pt)
                            !nt(ot, dt) && nt(pt, dt) && st(mt, dt);
                        for (; ct.length > ht; )
                            nt(pt, dt = ct[ht++]) && (~it(mt, dt) || st(mt, dt));
                        return mt
                    }
                },
                5432: function(_e, $, et) {
                    var tt = et(8356)
                      , nt = et(5690);
                    _e.exports = Object.keys || function(rt) {
                        return tt(rt, nt)
                    }
                },
                112: function(_e, $) {
                    var et = {}.propertyIsEnumerable
                      , tt = Object.getOwnPropertyDescriptor
                      , nt = tt && !et.call({
                        1: 2
                    }, 1);
                    $.f = nt ? function(rt) {
                        var it = tt(this, rt);
                        return !!it && it.enumerable
                    }
                    : et
                },
                7496: function(_e, $, et) {
                    var tt = et(7386)
                      , nt = et(2569)
                      , rt = et(9882);
                    _e.exports = Object.setPrototypeOf || ("__proto__"in {} ? function() {
                        var it, ot = !1, st = {};
                        try {
                            (it = tt(Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set))(st, []),
                            ot = st instanceof Array
                        } catch {}
                        return function(lt, ct) {
                            return nt(lt),
                            rt(ct),
                            ot ? it(lt, ct) : lt.__proto__ = ct,
                            lt
                        }
                    }() : void 0)
                },
                3060: function(_e, $, et) {
                    var tt = et(8191)
                      , nt = et(3058);
                    _e.exports = tt ? {}.toString : function() {
                        return "[object " + nt(this) + "]"
                    }
                },
                6252: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(8262)
                      , rt = et(9212)
                      , it = et(794)
                      , ot = tt.TypeError;
                    _e.exports = function(st, lt) {
                        var ct, dt;
                        if (lt === "string" && rt(ct = st.toString) && !it(dt = nt(ct, st)) || rt(ct = st.valueOf) && !it(dt = nt(ct, st)) || lt !== "string" && rt(ct = st.toString) && !it(dt = nt(ct, st)))
                            return dt;
                        throw ot("Can't convert object to primitive value")
                    }
                },
                929: function(_e, $, et) {
                    var tt = et(5897)
                      , nt = et(7386)
                      , rt = et(9275)
                      , it = et(4012)
                      , ot = et(2569)
                      , st = nt([].concat);
                    _e.exports = tt("Reflect", "ownKeys") || function(lt) {
                        var ct = rt.f(ot(lt))
                          , dt = it.f;
                        return dt ? st(ct, dt(lt)) : ct
                    }
                },
                1287: function(_e, $, et) {
                    var tt = et(7583);
                    _e.exports = tt
                },
                544: function(_e) {
                    _e.exports = function($) {
                        try {
                            return {
                                error: !1,
                                value: $()
                            }
                        } catch (et) {
                            return {
                                error: !0,
                                value: et
                            }
                        }
                    }
                },
                5732: function(_e, $, et) {
                    var tt = et(2569)
                      , nt = et(794)
                      , rt = et(5084);
                    _e.exports = function(it, ot) {
                        if (tt(it),
                        nt(ot) && ot.constructor === it)
                            return ot;
                        var st = rt.f(it);
                        return (0,
                        st.resolve)(ot),
                        st.promise
                    }
                },
                2723: function(_e) {
                    var $ = function() {
                        this.head = null,
                        this.tail = null
                    };
                    $.prototype = {
                        add: function(et) {
                            var tt = {
                                item: et,
                                next: null
                            };
                            this.head ? this.tail.next = tt : this.head = tt,
                            this.tail = tt
                        },
                        get: function() {
                            var et = this.head;
                            if (et)
                                return this.head = et.next,
                                this.tail === et && (this.tail = null),
                                et.item
                        }
                    },
                    _e.exports = $
                },
                6893: function(_e, $, et) {
                    var tt = et(1270);
                    _e.exports = function(nt, rt, it) {
                        for (var ot in rt)
                            tt(nt, ot, rt[ot], it);
                        return nt
                    }
                },
                1270: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(9212)
                      , rt = et(2870)
                      , it = et(57)
                      , ot = et(460)
                      , st = et(9734)
                      , lt = et(2743)
                      , ct = et(4340).CONFIGURABLE
                      , dt = lt.get
                      , pt = lt.enforce
                      , ht = String(String).split("String");
                    (_e.exports = function(mt, yt, Et, _t) {
                        var wt, St = !!_t && !!_t.unsafe, Ct = !!_t && !!_t.enumerable, Nt = !!_t && !!_t.noTargetGet, Lt = _t && _t.name !== void 0 ? _t.name : yt;
                        nt(Et) && (String(Lt).slice(0, 7) === "Symbol(" && (Lt = "[" + String(Lt).replace(/^Symbol\(([^)]*)\)/, "$1") + "]"),
                        (!rt(Et, "name") || ct && Et.name !== Lt) && it(Et, "name", Lt),
                        (wt = pt(Et)).source || (wt.source = ht.join(typeof Lt == "string" ? Lt : ""))),
                        mt !== tt ? (St ? !Nt && mt[yt] && (Ct = !0) : delete mt[yt],
                        Ct ? mt[yt] = Et : it(mt, yt, Et)) : Ct ? mt[yt] = Et : ot(yt, Et)
                    }
                    )(Function.prototype, "toString", function() {
                        return nt(this) && dt(this).source || st(this)
                    })
                },
                3955: function(_e, $, et) {
                    var tt = et(7583).TypeError;
                    _e.exports = function(nt) {
                        if (nt == null)
                            throw tt("Can't call method on " + nt);
                        return nt
                    }
                },
                460: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = Object.defineProperty;
                    _e.exports = function(rt, it) {
                        try {
                            nt(tt, rt, {
                                value: it,
                                configurable: !0,
                                writable: !0
                            })
                        } catch {
                            tt[rt] = it
                        }
                        return it
                    }
                },
                7730: function(_e, $, et) {
                    var tt = et(5897)
                      , nt = et(4615)
                      , rt = et(3649)
                      , it = et(8494)
                      , ot = rt("species");
                    _e.exports = function(st) {
                        var lt = tt(st)
                          , ct = nt.f;
                        it && lt && !lt[ot] && ct(lt, ot, {
                            configurable: !0,
                            get: function() {
                                return this
                            }
                        })
                    }
                },
                8821: function(_e, $, et) {
                    var tt = et(4615).f
                      , nt = et(2870)
                      , rt = et(3649)("toStringTag");
                    _e.exports = function(it, ot, st) {
                        it && !st && (it = it.prototype),
                        it && !nt(it, rt) && tt(it, rt, {
                            configurable: !0,
                            value: ot
                        })
                    }
                },
                9137: function(_e, $, et) {
                    var tt = et(7836)
                      , nt = et(8284)
                      , rt = tt("keys");
                    _e.exports = function(it) {
                        return rt[it] || (rt[it] = nt(it))
                    }
                },
                1314: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(460)
                      , rt = "__core-js_shared__"
                      , it = tt[rt] || nt(rt, {});
                    _e.exports = it
                },
                7836: function(_e, $, et) {
                    var tt = et(6268)
                      , nt = et(1314);
                    (_e.exports = function(rt, it) {
                        return nt[rt] || (nt[rt] = it !== void 0 ? it : {})
                    }
                    )("versions", []).push({
                        version: "3.21.1",
                        mode: tt ? "pure" : "global",
                        copyright: " 2014-2022 Denis Pushkarev (zloirock.ru)",
                        license: "https://github.com/zloirock/core-js/blob/v3.21.1/LICENSE",
                        source: "https://github.com/zloirock/core-js"
                    })
                },
                564: function(_e, $, et) {
                    var tt = et(2569)
                      , nt = et(1186)
                      , rt = et(3649)("species");
                    _e.exports = function(it, ot) {
                        var st, lt = tt(it).constructor;
                        return lt === void 0 || (st = tt(lt)[rt]) == null ? ot : nt(st)
                    }
                },
                6389: function(_e, $, et) {
                    var tt = et(7386)
                      , nt = et(7486)
                      , rt = et(8320)
                      , it = et(3955)
                      , ot = tt("".charAt)
                      , st = tt("".charCodeAt)
                      , lt = tt("".slice)
                      , ct = function(dt) {
                        return function(pt, ht) {
                            var mt, yt, Et = rt(it(pt)), _t = nt(ht), wt = Et.length;
                            return _t < 0 || _t >= wt ? dt ? "" : void 0 : (mt = st(Et, _t)) < 55296 || mt > 56319 || _t + 1 === wt || (yt = st(Et, _t + 1)) < 56320 || yt > 57343 ? dt ? ot(Et, _t) : mt : dt ? lt(Et, _t, _t + 2) : yt - 56320 + (mt - 55296 << 10) + 65536
                        }
                    };
                    _e.exports = {
                        codeAt: ct(!1),
                        charAt: ct(!0)
                    }
                },
                8117: function(_e, $, et) {
                    var tt, nt, rt, it, ot = et(7583), st = et(1611), lt = et(2938), ct = et(9212), dt = et(2870), pt = et(6544), ht = et(482), mt = et(6917), yt = et(6668), Et = et(7520), _t = et(7020), wt = et(5354), St = ot.setImmediate, Ct = ot.clearImmediate, Nt = ot.process, Lt = ot.Dispatch, kt = ot.Function, Ut = ot.MessageChannel, Jt = ot.String, Pt = 0, Xt = {}, rn = "onreadystatechange";
                    try {
                        tt = ot.location
                    } catch {}
                    var zt = function(jt) {
                        if (dt(Xt, jt)) {
                            var Ft = Xt[jt];
                            delete Xt[jt],
                            Ft()
                        }
                    }
                      , xt = function(jt) {
                        return function() {
                            zt(jt)
                        }
                    }
                      , $t = function(jt) {
                        zt(jt.data)
                    }
                      , Dt = function(jt) {
                        ot.postMessage(Jt(jt), tt.protocol + "//" + tt.host)
                    };
                    St && Ct || (St = function(jt) {
                        Et(arguments.length, 1);
                        var Ft = ct(jt) ? jt : kt(jt)
                          , Ht = mt(arguments, 1);
                        return Xt[++Pt] = function() {
                            st(Ft, void 0, Ht)
                        }
                        ,
                        nt(Pt),
                        Pt
                    }
                    ,
                    Ct = function(jt) {
                        delete Xt[jt]
                    }
                    ,
                    wt ? nt = function(jt) {
                        Nt.nextTick(xt(jt))
                    }
                    : Lt && Lt.now ? nt = function(jt) {
                        Lt.now(xt(jt))
                    }
                    : Ut && !_t ? (it = (rt = new Ut).port2,
                    rt.port1.onmessage = $t,
                    nt = lt(it.postMessage, it)) : ot.addEventListener && ct(ot.postMessage) && !ot.importScripts && tt && tt.protocol !== "file:" && !pt(Dt) ? (nt = Dt,
                    ot.addEventListener("message", $t, !1)) : nt = rn in yt("script") ? function(jt) {
                        ht.appendChild(yt("script")).onreadystatechange = function() {
                            ht.removeChild(this),
                            zt(jt)
                        }
                    }
                    : function(jt) {
                        setTimeout(xt(jt), 0)
                    }
                    ),
                    _e.exports = {
                        set: St,
                        clear: Ct
                    }
                },
                6782: function(_e, $, et) {
                    var tt = et(7486)
                      , nt = Math.max
                      , rt = Math.min;
                    _e.exports = function(it, ot) {
                        var st = tt(it);
                        return st < 0 ? nt(st + ot, 0) : rt(st, ot)
                    }
                },
                2977: function(_e, $, et) {
                    var tt = et(5044)
                      , nt = et(3955);
                    _e.exports = function(rt) {
                        return tt(nt(rt))
                    }
                },
                7486: function(_e) {
                    var $ = Math.ceil
                      , et = Math.floor;
                    _e.exports = function(tt) {
                        var nt = +tt;
                        return nt != nt || nt === 0 ? 0 : (nt > 0 ? et : $)(nt)
                    }
                },
                97: function(_e, $, et) {
                    var tt = et(7486)
                      , nt = Math.min;
                    _e.exports = function(rt) {
                        return rt > 0 ? nt(tt(rt), 9007199254740991) : 0
                    }
                },
                1324: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(3955)
                      , rt = tt.Object;
                    _e.exports = function(it) {
                        return rt(nt(it))
                    }
                },
                2670: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(8262)
                      , rt = et(794)
                      , it = et(5871)
                      , ot = et(911)
                      , st = et(6252)
                      , lt = et(3649)
                      , ct = tt.TypeError
                      , dt = lt("toPrimitive");
                    _e.exports = function(pt, ht) {
                        if (!rt(pt) || it(pt))
                            return pt;
                        var mt, yt = ot(pt, dt);
                        if (yt) {
                            if (ht === void 0 && (ht = "default"),
                            mt = nt(yt, pt, ht),
                            !rt(mt) || it(mt))
                                return mt;
                            throw ct("Can't convert object to primitive value")
                        }
                        return ht === void 0 && (ht = "number"),
                        st(pt, ht)
                    }
                },
                8734: function(_e, $, et) {
                    var tt = et(2670)
                      , nt = et(5871);
                    _e.exports = function(rt) {
                        var it = tt(rt, "string");
                        return nt(it) ? it : it + ""
                    }
                },
                8191: function(_e, $, et) {
                    var tt = {};
                    tt[et(3649)("toStringTag")] = "z",
                    _e.exports = String(tt) === "[object z]"
                },
                8320: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(3058)
                      , rt = tt.String;
                    _e.exports = function(it) {
                        if (nt(it) === "Symbol")
                            throw TypeError("Cannot convert a Symbol value to a string");
                        return rt(it)
                    }
                },
                5637: function(_e, $, et) {
                    var tt = et(7583).String;
                    _e.exports = function(nt) {
                        try {
                            return tt(nt)
                        } catch {
                            return "Object"
                        }
                    }
                },
                8284: function(_e, $, et) {
                    var tt = et(7386)
                      , nt = 0
                      , rt = Math.random()
                      , it = tt(1.toString);
                    _e.exports = function(ot) {
                        return "Symbol(" + (ot === void 0 ? "" : ot) + ")_" + it(++nt + rt, 36)
                    }
                },
                7786: function(_e, $, et) {
                    var tt = et(8640);
                    _e.exports = tt && !Symbol.sham && typeof Symbol.iterator == "symbol"
                },
                7670: function(_e, $, et) {
                    var tt = et(8494)
                      , nt = et(6544);
                    _e.exports = tt && nt(function() {
                        return Object.defineProperty(function() {}, "prototype", {
                            value: 42,
                            writable: !1
                        }).prototype != 42
                    })
                },
                7520: function(_e, $, et) {
                    var tt = et(7583).TypeError;
                    _e.exports = function(nt, rt) {
                        if (nt < rt)
                            throw tt("Not enough arguments");
                        return nt
                    }
                },
                491: function(_e, $, et) {
                    var tt = et(3649);
                    $.f = tt
                },
                3649: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(7836)
                      , rt = et(2870)
                      , it = et(8284)
                      , ot = et(8640)
                      , st = et(7786)
                      , lt = nt("wks")
                      , ct = tt.Symbol
                      , dt = ct && ct.for
                      , pt = st ? ct : ct && ct.withoutSetter || it;
                    _e.exports = function(ht) {
                        if (!rt(lt, ht) || !ot && typeof lt[ht] != "string") {
                            var mt = "Symbol." + ht;
                            ot && rt(ct, ht) ? lt[ht] = ct[ht] : lt[ht] = st && dt ? dt(mt) : pt(mt)
                        }
                        return lt[ht]
                    }
                },
                1719: function(_e, $, et) {
                    var tt = et(7263)
                      , nt = et(7583)
                      , rt = et(2447)
                      , it = et(729)
                      , ot = et(7496)
                      , st = et(3478)
                      , lt = et(3590)
                      , ct = et(57)
                      , dt = et(4677)
                      , pt = et(1509)
                      , ht = et(4402)
                      , mt = et(4026)
                      , yt = et(2764)
                      , Et = et(3649)
                      , _t = et(1178)
                      , wt = Et("toStringTag")
                      , St = nt.Error
                      , Ct = [].push
                      , Nt = function(kt, Ut) {
                        var Jt, Pt = arguments.length > 2 ? arguments[2] : void 0, Xt = rt(Lt, this);
                        ot ? Jt = ot(new St, Xt ? it(this) : Lt) : (Jt = Xt ? this : lt(Lt),
                        ct(Jt, wt, "Error")),
                        Ut !== void 0 && ct(Jt, "message", yt(Ut)),
                        _t && ct(Jt, "stack", pt(Jt.stack, 1)),
                        ht(Jt, Pt);
                        var rn = [];
                        return mt(kt, Ct, {
                            that: rn
                        }),
                        ct(Jt, "errors", rn),
                        Jt
                    };
                    ot ? ot(Nt, St) : st(Nt, St, {
                        name: !0
                    });
                    var Lt = Nt.prototype = lt(St.prototype, {
                        constructor: dt(1, Nt),
                        message: dt(1, ""),
                        name: dt(1, "AggregateError")
                    });
                    tt({
                        global: !0
                    }, {
                        AggregateError: Nt
                    })
                },
                1646: function(_e, $, et) {
                    var tt = et(7263)
                      , nt = et(7583)
                      , rt = et(6544)
                      , it = et(4521)
                      , ot = et(794)
                      , st = et(1324)
                      , lt = et(1825)
                      , ct = et(5999)
                      , dt = et(4822)
                      , pt = et(9269)
                      , ht = et(3649)
                      , mt = et(4061)
                      , yt = ht("isConcatSpreadable")
                      , Et = 9007199254740991
                      , _t = "Maximum allowed index exceeded"
                      , wt = nt.TypeError
                      , St = mt >= 51 || !rt(function() {
                        var Lt = [];
                        return Lt[yt] = !1,
                        Lt.concat()[0] !== Lt
                    })
                      , Ct = pt("concat")
                      , Nt = function(Lt) {
                        if (!ot(Lt))
                            return !1;
                        var kt = Lt[yt];
                        return kt !== void 0 ? !!kt : it(Lt)
                    };
                    tt({
                        target: "Array",
                        proto: !0,
                        forced: !St || !Ct
                    }, {
                        concat: function(Lt) {
                            var kt, Ut, Jt, Pt, Xt, rn = st(this), zt = dt(rn, 0), xt = 0;
                            for (kt = -1,
                            Jt = arguments.length; kt < Jt; kt++)
                                if (Nt(Xt = kt === -1 ? rn : arguments[kt])) {
                                    if (xt + (Pt = lt(Xt)) > Et)
                                        throw wt(_t);
                                    for (Ut = 0; Ut < Pt; Ut++,
                                    xt++)
                                        Ut in Xt && ct(zt, xt, Xt[Ut])
                                } else {
                                    if (xt >= Et)
                                        throw wt(_t);
                                    ct(zt, xt++, Xt)
                                }
                            return zt.length = xt,
                            zt
                        }
                    })
                },
                5677: function(_e, $, et) {
                    var tt = et(2977)
                      , nt = et(6288)
                      , rt = et(339)
                      , it = et(2743)
                      , ot = et(4615).f
                      , st = et(9012)
                      , lt = et(6268)
                      , ct = et(8494)
                      , dt = "Array Iterator"
                      , pt = it.set
                      , ht = it.getterFor(dt);
                    _e.exports = st(Array, "Array", function(yt, Et) {
                        pt(this, {
                            type: dt,
                            target: tt(yt),
                            index: 0,
                            kind: Et
                        })
                    }, function() {
                        var yt = ht(this)
                          , Et = yt.target
                          , _t = yt.kind
                          , wt = yt.index++;
                        return !Et || wt >= Et.length ? (yt.target = void 0,
                        {
                            value: void 0,
                            done: !0
                        }) : _t == "keys" ? {
                            value: wt,
                            done: !1
                        } : _t == "values" ? {
                            value: Et[wt],
                            done: !1
                        } : {
                            value: [wt, Et[wt]],
                            done: !1
                        }
                    }, "values");
                    var mt = rt.Arguments = rt.Array;
                    if (nt("keys"),
                    nt("values"),
                    nt("entries"),
                    !lt && ct && mt.name !== "values")
                        try {
                            ot(mt, "name", {
                                value: "values"
                            })
                        } catch {}
                },
                6956: function(_e, $, et) {
                    var tt = et(7583);
                    et(8821)(tt.JSON, "JSON", !0)
                },
                5222: function(_e, $, et) {
                    et(8821)(Math, "Math", !0)
                },
                6394: function(_e, $, et) {
                    var tt = et(8191)
                      , nt = et(1270)
                      , rt = et(3060);
                    tt || nt(Object.prototype, "toString", rt, {
                        unsafe: !0
                    })
                },
                6969: function(_e, $, et) {
                    var tt = et(7263)
                      , nt = et(8262)
                      , rt = et(8257)
                      , it = et(5084)
                      , ot = et(544)
                      , st = et(4026);
                    tt({
                        target: "Promise",
                        stat: !0
                    }, {
                        allSettled: function(lt) {
                            var ct = this
                              , dt = it.f(ct)
                              , pt = dt.resolve
                              , ht = dt.reject
                              , mt = ot(function() {
                                var yt = rt(ct.resolve)
                                  , Et = []
                                  , _t = 0
                                  , wt = 1;
                                st(lt, function(St) {
                                    var Ct = _t++
                                      , Nt = !1;
                                    wt++,
                                    nt(yt, ct, St).then(function(Lt) {
                                        Nt || (Nt = !0,
                                        Et[Ct] = {
                                            status: "fulfilled",
                                            value: Lt
                                        },
                                        --wt || pt(Et))
                                    }, function(Lt) {
                                        Nt || (Nt = !0,
                                        Et[Ct] = {
                                            status: "rejected",
                                            reason: Lt
                                        },
                                        --wt || pt(Et))
                                    })
                                }),
                                --wt || pt(Et)
                            });
                            return mt.error && ht(mt.value),
                            dt.promise
                        }
                    })
                },
                2021: function(_e, $, et) {
                    var tt = et(7263)
                      , nt = et(8257)
                      , rt = et(5897)
                      , it = et(8262)
                      , ot = et(5084)
                      , st = et(544)
                      , lt = et(4026)
                      , ct = "No one promise resolved";
                    tt({
                        target: "Promise",
                        stat: !0
                    }, {
                        any: function(dt) {
                            var pt = this
                              , ht = rt("AggregateError")
                              , mt = ot.f(pt)
                              , yt = mt.resolve
                              , Et = mt.reject
                              , _t = st(function() {
                                var wt = nt(pt.resolve)
                                  , St = []
                                  , Ct = 0
                                  , Nt = 1
                                  , Lt = !1;
                                lt(dt, function(kt) {
                                    var Ut = Ct++
                                      , Jt = !1;
                                    Nt++,
                                    it(wt, pt, kt).then(function(Pt) {
                                        Jt || Lt || (Lt = !0,
                                        yt(Pt))
                                    }, function(Pt) {
                                        Jt || Lt || (Jt = !0,
                                        St[Ut] = Pt,
                                        --Nt || Et(new ht(St,ct)))
                                    })
                                }),
                                --Nt || Et(new ht(St,ct))
                            });
                            return _t.error && Et(_t.value),
                            mt.promise
                        }
                    })
                },
                8328: function(_e, $, et) {
                    var tt = et(7263)
                      , nt = et(6268)
                      , rt = et(783)
                      , it = et(6544)
                      , ot = et(5897)
                      , st = et(9212)
                      , lt = et(564)
                      , ct = et(5732)
                      , dt = et(1270);
                    if (tt({
                        target: "Promise",
                        proto: !0,
                        real: !0,
                        forced: !!rt && it(function() {
                            rt.prototype.finally.call({
                                then: function() {}
                            }, function() {})
                        })
                    }, {
                        finally: function(ht) {
                            var mt = lt(this, ot("Promise"))
                              , yt = st(ht);
                            return this.then(yt ? function(Et) {
                                return ct(mt, ht()).then(function() {
                                    return Et
                                })
                            }
                            : ht, yt ? function(Et) {
                                return ct(mt, ht()).then(function() {
                                    throw Et
                                })
                            }
                            : ht)
                        }
                    }),
                    !nt && st(rt)) {
                        var pt = ot("Promise").prototype.finally;
                        rt.prototype.finally !== pt && dt(rt.prototype, "finally", pt, {
                            unsafe: !0
                        })
                    }
                },
                5334: function(_e, $, et) {
                    var tt, nt, rt, it, ot = et(7263), st = et(6268), lt = et(7583), ct = et(5897), dt = et(8262), pt = et(783), ht = et(1270), mt = et(6893), yt = et(7496), Et = et(8821), _t = et(7730), wt = et(8257), St = et(9212), Ct = et(794), Nt = et(4761), Lt = et(9734), kt = et(4026), Ut = et(3616), Jt = et(564), Pt = et(8117).set, Xt = et(2095), rn = et(5732), zt = et(2716), xt = et(5084), $t = et(544), Dt = et(2723), jt = et(2743), Ft = et(4451), Ht = et(3649), qt = et(2274), Wt = et(5354), Mt = et(4061), Yt = Ht("species"), un = "Promise", hn = jt.getterFor(un), _n = jt.set, kn = jt.getterFor(un), Dn = pt && pt.prototype, jn = pt, Bn = Dn, Un = lt.TypeError, Hn = lt.document, cr = lt.process, Gn = xt.f, Mn = Gn, rr = !!(Hn && Hn.createEvent && lt.dispatchEvent), Zn = St(lt.PromiseRejectionEvent), pr = "unhandledrejection", Ur = !1, xr = Ft(un, function() {
                        var Gt = Lt(jn)
                          , fn = Gt !== String(jn);
                        if (!fn && Mt === 66 || st && !Bn.finally)
                            return !0;
                        if (Mt >= 51 && /native code/.test(Gt))
                            return !1;
                        var En = new jn(function(Tn) {
                            Tn(1)
                        }
                        )
                          , vn = function(Tn) {
                            Tn(function() {}, function() {})
                        };
                        return (En.constructor = {})[Yt] = vn,
                        !(Ur = En.then(function() {})instanceof vn) || !fn && qt && !Zn
                    }), wr = xr || !Ut(function(Gt) {
                        jn.all(Gt).catch(function() {})
                    }), Rn = function(Gt) {
                        var fn;
                        return !(!Ct(Gt) || !St(fn = Gt.then)) && fn
                    }, Vn = function(Gt, fn) {
                        var En, vn, Tn, sr = fn.value, lr = fn.state == 1, wn = lr ? Gt.ok : Gt.fail, Pn = Gt.resolve, Cn = Gt.reject, zn = Gt.domain;
                        try {
                            wn ? (lr || (fn.rejection === 2 && Cr(fn),
                            fn.rejection = 1),
                            wn === !0 ? En = sr : (zn && zn.enter(),
                            En = wn(sr),
                            zn && (zn.exit(),
                            Tn = !0)),
                            En === Gt.promise ? Cn(Un("Promise-chain cycle")) : (vn = Rn(En)) ? dt(vn, En, Pn, Cn) : Pn(En)) : Cn(sr)
                        } catch (ur) {
                            zn && !Tn && zn.exit(),
                            Cn(ur)
                        }
                    }, qn = function(Gt, fn) {
                        Gt.notified || (Gt.notified = !0,
                        Xt(function() {
                            for (var En, vn = Gt.reactions; En = vn.get(); )
                                Vn(En, Gt);
                            Gt.notified = !1,
                            fn && !Gt.rejection && or(Gt)
                        }))
                    }, dr = function(Gt, fn, En) {
                        var vn, Tn;
                        rr ? ((vn = Hn.createEvent("Event")).promise = fn,
                        vn.reason = En,
                        vn.initEvent(Gt, !1, !0),
                        lt.dispatchEvent(vn)) : vn = {
                            promise: fn,
                            reason: En
                        },
                        !Zn && (Tn = lt["on" + Gt]) ? Tn(vn) : Gt === pr && zt("Unhandled promise rejection", En)
                    }, or = function(Gt) {
                        dt(Pt, lt, function() {
                            var fn, En = Gt.facade, vn = Gt.value;
                            if (ir(Gt) && (fn = $t(function() {
                                Wt ? cr.emit("unhandledRejection", vn, En) : dr(pr, En, vn)
                            }),
                            Gt.rejection = Wt || ir(Gt) ? 2 : 1,
                            fn.error))
                                throw fn.value
                        })
                    }, ir = function(Gt) {
                        return Gt.rejection !== 1 && !Gt.parent
                    }, Cr = function(Gt) {
                        dt(Pt, lt, function() {
                            var fn = Gt.facade;
                            Wt ? cr.emit("rejectionHandled", fn) : dr("rejectionhandled", fn, Gt.value)
                        })
                    }, br = function(Gt, fn, En) {
                        return function(vn) {
                            Gt(fn, vn, En)
                        }
                    }, an = function(Gt, fn, En) {
                        Gt.done || (Gt.done = !0,
                        En && (Gt = En),
                        Gt.value = fn,
                        Gt.state = 2,
                        qn(Gt, !0))
                    }, Kt = function Gt(fn, En, vn) {
                        if (!fn.done) {
                            fn.done = !0,
                            vn && (fn = vn);
                            try {
                                if (fn.facade === En)
                                    throw Un("Promise can't be resolved itself");
                                var Tn = Rn(En);
                                Tn ? Xt(function() {
                                    var sr = {
                                        done: !1
                                    };
                                    try {
                                        dt(Tn, En, br(Gt, sr, fn), br(an, sr, fn))
                                    } catch (lr) {
                                        an(sr, lr, fn)
                                    }
                                }) : (fn.value = En,
                                fn.state = 1,
                                qn(fn, !1))
                            } catch (sr) {
                                an({
                                    done: !1
                                }, sr, fn)
                            }
                        }
                    };
                    if (xr && (Bn = (jn = function(Gt) {
                        Nt(this, Bn),
                        wt(Gt),
                        dt(tt, this);
                        var fn = hn(this);
                        try {
                            Gt(br(Kt, fn), br(an, fn))
                        } catch (En) {
                            an(fn, En)
                        }
                    }
                    ).prototype,
                    (tt = function(Gt) {
                        _n(this, {
                            type: un,
                            done: !1,
                            notified: !1,
                            parent: !1,
                            reactions: new Dt,
                            rejection: !1,
                            state: 0,
                            value: void 0
                        })
                    }
                    ).prototype = mt(Bn, {
                        then: function(Gt, fn) {
                            var En = kn(this)
                              , vn = Gn(Jt(this, jn));
                            return En.parent = !0,
                            vn.ok = !St(Gt) || Gt,
                            vn.fail = St(fn) && fn,
                            vn.domain = Wt ? cr.domain : void 0,
                            En.state == 0 ? En.reactions.add(vn) : Xt(function() {
                                Vn(vn, En)
                            }),
                            vn.promise
                        },
                        catch: function(Gt) {
                            return this.then(void 0, Gt)
                        }
                    }),
                    nt = function() {
                        var Gt = new tt
                          , fn = hn(Gt);
                        this.promise = Gt,
                        this.resolve = br(Kt, fn),
                        this.reject = br(an, fn)
                    }
                    ,
                    xt.f = Gn = function(Gt) {
                        return Gt === jn || Gt === rt ? new nt(Gt) : Mn(Gt)
                    }
                    ,
                    !st && St(pt) && Dn !== Object.prototype)) {
                        it = Dn.then,
                        Ur || (ht(Dn, "then", function(Gt, fn) {
                            var En = this;
                            return new jn(function(vn, Tn) {
                                dt(it, En, vn, Tn)
                            }
                            ).then(Gt, fn)
                        }, {
                            unsafe: !0
                        }),
                        ht(Dn, "catch", Bn.catch, {
                            unsafe: !0
                        }));
                        try {
                            delete Dn.constructor
                        } catch {}
                        yt && yt(Dn, Bn)
                    }
                    ot({
                        global: !0,
                        wrap: !0,
                        forced: xr
                    }, {
                        Promise: jn
                    }),
                    Et(jn, un, !1, !0),
                    _t(un),
                    rt = ct(un),
                    ot({
                        target: un,
                        stat: !0,
                        forced: xr
                    }, {
                        reject: function(Gt) {
                            var fn = Gn(this);
                            return dt(fn.reject, void 0, Gt),
                            fn.promise
                        }
                    }),
                    ot({
                        target: un,
                        stat: !0,
                        forced: st || xr
                    }, {
                        resolve: function(Gt) {
                            return rn(st && this === rt ? jn : this, Gt)
                        }
                    }),
                    ot({
                        target: un,
                        stat: !0,
                        forced: wr
                    }, {
                        all: function(Gt) {
                            var fn = this
                              , En = Gn(fn)
                              , vn = En.resolve
                              , Tn = En.reject
                              , sr = $t(function() {
                                var lr = wt(fn.resolve)
                                  , wn = []
                                  , Pn = 0
                                  , Cn = 1;
                                kt(Gt, function(zn) {
                                    var ur = Pn++
                                      , hr = !1;
                                    Cn++,
                                    dt(lr, fn, zn).then(function(Ir) {
                                        hr || (hr = !0,
                                        wn[ur] = Ir,
                                        --Cn || vn(wn))
                                    }, Tn)
                                }),
                                --Cn || vn(wn)
                            });
                            return sr.error && Tn(sr.value),
                            En.promise
                        },
                        race: function(Gt) {
                            var fn = this
                              , En = Gn(fn)
                              , vn = En.reject
                              , Tn = $t(function() {
                                var sr = wt(fn.resolve);
                                kt(Gt, function(lr) {
                                    dt(sr, fn, lr).then(En.resolve, vn)
                                })
                            });
                            return Tn.error && vn(Tn.value),
                            En.promise
                        }
                    })
                },
                2257: function(_e, $, et) {
                    var tt = et(7263)
                      , nt = et(7583)
                      , rt = et(8821);
                    tt({
                        global: !0
                    }, {
                        Reflect: {}
                    }),
                    rt(nt.Reflect, "Reflect", !0)
                },
                2129: function(_e, $, et) {
                    var tt = et(6389).charAt
                      , nt = et(8320)
                      , rt = et(2743)
                      , it = et(9012)
                      , ot = "String Iterator"
                      , st = rt.set
                      , lt = rt.getterFor(ot);
                    it(String, "String", function(ct) {
                        st(this, {
                            type: ot,
                            string: nt(ct),
                            index: 0
                        })
                    }, function() {
                        var ct, dt = lt(this), pt = dt.string, ht = dt.index;
                        return ht >= pt.length ? {
                            value: void 0,
                            done: !0
                        } : (ct = tt(pt, ht),
                        dt.index += ct.length,
                        {
                            value: ct,
                            done: !1
                        })
                    })
                },
                462: function(_e, $, et) {
                    et(2219)("asyncIterator")
                },
                8407: function(_e, $, et) {
                    var tt = et(7263)
                      , nt = et(8494)
                      , rt = et(7583)
                      , it = et(7386)
                      , ot = et(2870)
                      , st = et(9212)
                      , lt = et(2447)
                      , ct = et(8320)
                      , dt = et(4615).f
                      , pt = et(3478)
                      , ht = rt.Symbol
                      , mt = ht && ht.prototype;
                    if (nt && st(ht) && (!("description"in mt) || ht().description !== void 0)) {
                        var yt = {}
                          , Et = function() {
                            var kt = arguments.length < 1 || arguments[0] === void 0 ? void 0 : ct(arguments[0])
                              , Ut = lt(mt, this) ? new ht(kt) : kt === void 0 ? ht() : ht(kt);
                            return kt === "" && (yt[Ut] = !0),
                            Ut
                        };
                        pt(Et, ht),
                        Et.prototype = mt,
                        mt.constructor = Et;
                        var _t = String(ht("test")) == "Symbol(test)"
                          , wt = it(mt.toString)
                          , St = it(mt.valueOf)
                          , Ct = /^Symbol\((.*)\)[^)]+$/
                          , Nt = it("".replace)
                          , Lt = it("".slice);
                        dt(mt, "description", {
                            configurable: !0,
                            get: function() {
                                var kt = St(this)
                                  , Ut = wt(kt);
                                if (ot(yt, kt))
                                    return "";
                                var Jt = _t ? Lt(Ut, 7, -1) : Nt(Ut, Ct, "$1");
                                return Jt === "" ? void 0 : Jt
                            }
                        }),
                        tt({
                            global: !0,
                            forced: !0
                        }, {
                            Symbol: Et
                        })
                    }
                },
                2429: function(_e, $, et) {
                    et(2219)("hasInstance")
                },
                1172: function(_e, $, et) {
                    et(2219)("isConcatSpreadable")
                },
                8288: function(_e, $, et) {
                    et(2219)("iterator")
                },
                2004: function(_e, $, et) {
                    var tt = et(7263)
                      , nt = et(7583)
                      , rt = et(5897)
                      , it = et(1611)
                      , ot = et(8262)
                      , st = et(7386)
                      , lt = et(6268)
                      , ct = et(8494)
                      , dt = et(8640)
                      , pt = et(6544)
                      , ht = et(2870)
                      , mt = et(4521)
                      , yt = et(9212)
                      , Et = et(794)
                      , _t = et(2447)
                      , wt = et(5871)
                      , St = et(2569)
                      , Ct = et(1324)
                      , Nt = et(2977)
                      , Lt = et(8734)
                      , kt = et(8320)
                      , Ut = et(4677)
                      , Jt = et(3590)
                      , Pt = et(5432)
                      , Xt = et(9275)
                      , rn = et(3130)
                      , zt = et(4012)
                      , xt = et(6683)
                      , $t = et(4615)
                      , Dt = et(8728)
                      , jt = et(112)
                      , Ft = et(6917)
                      , Ht = et(1270)
                      , qt = et(7836)
                      , Wt = et(9137)
                      , Mt = et(4639)
                      , Yt = et(8284)
                      , un = et(3649)
                      , hn = et(491)
                      , _n = et(2219)
                      , kn = et(8821)
                      , Dn = et(2743)
                      , jn = et(4805).forEach
                      , Bn = Wt("hidden")
                      , Un = "Symbol"
                      , Hn = un("toPrimitive")
                      , cr = Dn.set
                      , Gn = Dn.getterFor(Un)
                      , Mn = Object.prototype
                      , rr = nt.Symbol
                      , Zn = rr && rr.prototype
                      , pr = nt.TypeError
                      , Ur = nt.QObject
                      , xr = rt("JSON", "stringify")
                      , wr = xt.f
                      , Rn = $t.f
                      , Vn = rn.f
                      , qn = jt.f
                      , dr = st([].push)
                      , or = qt("symbols")
                      , ir = qt("op-symbols")
                      , Cr = qt("string-to-symbol-registry")
                      , br = qt("symbol-to-string-registry")
                      , an = qt("wks")
                      , Kt = !Ur || !Ur.prototype || !Ur.prototype.findChild
                      , Gt = ct && pt(function() {
                        return Jt(Rn({}, "a", {
                            get: function() {
                                return Rn(this, "a", {
                                    value: 7
                                }).a
                            }
                        })).a != 7
                    }) ? function(Cn, zn, ur) {
                        var hr = wr(Mn, zn);
                        hr && delete Mn[zn],
                        Rn(Cn, zn, ur),
                        hr && Cn !== Mn && Rn(Mn, zn, hr)
                    }
                    : Rn
                      , fn = function(Cn, zn) {
                        var ur = or[Cn] = Jt(Zn);
                        return cr(ur, {
                            type: Un,
                            tag: Cn,
                            description: zn
                        }),
                        ct || (ur.description = zn),
                        ur
                    }
                      , En = function(Cn, zn, ur) {
                        Cn === Mn && En(ir, zn, ur),
                        St(Cn);
                        var hr = Lt(zn);
                        return St(ur),
                        ht(or, hr) ? (ur.enumerable ? (ht(Cn, Bn) && Cn[Bn][hr] && (Cn[Bn][hr] = !1),
                        ur = Jt(ur, {
                            enumerable: Ut(0, !1)
                        })) : (ht(Cn, Bn) || Rn(Cn, Bn, Ut(1, {})),
                        Cn[Bn][hr] = !0),
                        Gt(Cn, hr, ur)) : Rn(Cn, hr, ur)
                    }
                      , vn = function(Cn, zn) {
                        St(Cn);
                        var ur = Nt(zn)
                          , hr = Pt(ur).concat(wn(ur));
                        return jn(hr, function(Ir) {
                            ct && !ot(Tn, ur, Ir) || En(Cn, Ir, ur[Ir])
                        }),
                        Cn
                    }
                      , Tn = function(Cn) {
                        var zn = Lt(Cn)
                          , ur = ot(qn, this, zn);
                        return !(this === Mn && ht(or, zn) && !ht(ir, zn)) && (!(ur || !ht(this, zn) || !ht(or, zn) || ht(this, Bn) && this[Bn][zn]) || ur)
                    }
                      , sr = function(Cn, zn) {
                        var ur = Nt(Cn)
                          , hr = Lt(zn);
                        if (ur !== Mn || !ht(or, hr) || ht(ir, hr)) {
                            var Ir = wr(ur, hr);
                            return !Ir || !ht(or, hr) || ht(ur, Bn) && ur[Bn][hr] || (Ir.enumerable = !0),
                            Ir
                        }
                    }
                      , lr = function(Cn) {
                        var zn = Vn(Nt(Cn))
                          , ur = [];
                        return jn(zn, function(hr) {
                            ht(or, hr) || ht(Mt, hr) || dr(ur, hr)
                        }),
                        ur
                    }
                      , wn = function(Cn) {
                        var zn = Cn === Mn
                          , ur = Vn(zn ? ir : Nt(Cn))
                          , hr = [];
                        return jn(ur, function(Ir) {
                            !ht(or, Ir) || zn && !ht(Mn, Ir) || dr(hr, or[Ir])
                        }),
                        hr
                    };
                    if (dt || (rr = function() {
                        if (_t(Zn, this))
                            throw pr("Symbol is not a constructor");
                        var Cn = arguments.length && arguments[0] !== void 0 ? kt(arguments[0]) : void 0
                          , zn = Yt(Cn)
                          , ur = function hr(Ir) {
                            this === Mn && ot(hr, ir, Ir),
                            ht(this, Bn) && ht(this[Bn], zn) && (this[Bn][zn] = !1),
                            Gt(this, zn, Ut(1, Ir))
                        };
                        return ct && Kt && Gt(Mn, zn, {
                            configurable: !0,
                            set: ur
                        }),
                        fn(zn, Cn)
                    }
                    ,
                    Ht(Zn = rr.prototype, "toString", function() {
                        return Gn(this).tag
                    }),
                    Ht(rr, "withoutSetter", function(Cn) {
                        return fn(Yt(Cn), Cn)
                    }),
                    jt.f = Tn,
                    $t.f = En,
                    Dt.f = vn,
                    xt.f = sr,
                    Xt.f = rn.f = lr,
                    zt.f = wn,
                    hn.f = function(Cn) {
                        return fn(un(Cn), Cn)
                    }
                    ,
                    ct && (Rn(Zn, "description", {
                        configurable: !0,
                        get: function() {
                            return Gn(this).description
                        }
                    }),
                    lt || Ht(Mn, "propertyIsEnumerable", Tn, {
                        unsafe: !0
                    }))),
                    tt({
                        global: !0,
                        wrap: !0,
                        forced: !dt,
                        sham: !dt
                    }, {
                        Symbol: rr
                    }),
                    jn(Pt(an), function(Cn) {
                        _n(Cn)
                    }),
                    tt({
                        target: Un,
                        stat: !0,
                        forced: !dt
                    }, {
                        for: function(Cn) {
                            var zn = kt(Cn);
                            if (ht(Cr, zn))
                                return Cr[zn];
                            var ur = rr(zn);
                            return Cr[zn] = ur,
                            br[ur] = zn,
                            ur
                        },
                        keyFor: function(Cn) {
                            if (!wt(Cn))
                                throw pr(Cn + " is not a symbol");
                            if (ht(br, Cn))
                                return br[Cn]
                        },
                        useSetter: function() {
                            Kt = !0
                        },
                        useSimple: function() {
                            Kt = !1
                        }
                    }),
                    tt({
                        target: "Object",
                        stat: !0,
                        forced: !dt,
                        sham: !ct
                    }, {
                        create: function(Cn, zn) {
                            return zn === void 0 ? Jt(Cn) : vn(Jt(Cn), zn)
                        },
                        defineProperty: En,
                        defineProperties: vn,
                        getOwnPropertyDescriptor: sr
                    }),
                    tt({
                        target: "Object",
                        stat: !0,
                        forced: !dt
                    }, {
                        getOwnPropertyNames: lr,
                        getOwnPropertySymbols: wn
                    }),
                    tt({
                        target: "Object",
                        stat: !0,
                        forced: pt(function() {
                            zt.f(1)
                        })
                    }, {
                        getOwnPropertySymbols: function(Cn) {
                            return zt.f(Ct(Cn))
                        }
                    }),
                    xr && tt({
                        target: "JSON",
                        stat: !0,
                        forced: !dt || pt(function() {
                            var Cn = rr();
                            return xr([Cn]) != "[null]" || xr({
                                a: Cn
                            }) != "{}" || xr(Object(Cn)) != "{}"
                        })
                    }, {
                        stringify: function(Cn, zn, ur) {
                            var hr = Ft(arguments)
                              , Ir = zn;
                            if ((Et(zn) || Cn !== void 0) && !wt(Cn))
                                return mt(zn) || (zn = function(_o, Xr) {
                                    if (yt(Ir) && (Xr = ot(Ir, this, _o, Xr)),
                                    !wt(Xr))
                                        return Xr
                                }
                                ),
                                hr[1] = zn,
                                it(xr, null, hr)
                        }
                    }),
                    !Zn[Hn]) {
                        var Pn = Zn.valueOf;
                        Ht(Zn, Hn, function(Cn) {
                            return ot(Pn, this)
                        })
                    }
                    kn(rr, Un),
                    Mt[Bn] = !0
                },
                8201: function(_e, $, et) {
                    et(2219)("matchAll")
                },
                1274: function(_e, $, et) {
                    et(2219)("match")
                },
                6626: function(_e, $, et) {
                    et(2219)("replace")
                },
                3211: function(_e, $, et) {
                    et(2219)("search")
                },
                9952: function(_e, $, et) {
                    et(2219)("species")
                },
                15: function(_e, $, et) {
                    et(2219)("split")
                },
                9831: function(_e, $, et) {
                    et(2219)("toPrimitive")
                },
                7521: function(_e, $, et) {
                    et(2219)("toStringTag")
                },
                2972: function(_e, $, et) {
                    et(2219)("unscopables")
                },
                4655: function(_e, $, et) {
                    var tt = et(7583)
                      , nt = et(6778)
                      , rt = et(9307)
                      , it = et(5677)
                      , ot = et(57)
                      , st = et(3649)
                      , lt = st("iterator")
                      , ct = st("toStringTag")
                      , dt = it.values
                      , pt = function(mt, yt) {
                        if (mt) {
                            if (mt[lt] !== dt)
                                try {
                                    ot(mt, lt, dt)
                                } catch {
                                    mt[lt] = dt
                                }
                            if (mt[ct] || ot(mt, ct, yt),
                            nt[yt]) {
                                for (var Et in it)
                                    if (mt[Et] !== it[Et])
                                        try {
                                            ot(mt, Et, it[Et])
                                        } catch {
                                            mt[Et] = it[Et]
                                        }
                            }
                        }
                    };
                    for (var ht in nt)
                        pt(tt[ht] && tt[ht].prototype, ht);
                    pt(rt, "DOMTokenList")
                },
                8765: function(_e, $, et) {
                    var tt = et(5036);
                    et(4655),
                    _e.exports = tt
                },
                5441: function(_e, $, et) {
                    var tt = et(2582);
                    et(4655),
                    _e.exports = tt
                },
                7705: function(_e) {
                    _e.exports = function($) {
                        var et = [];
                        return et.toString = function() {
                            return this.map(function(tt) {
                                var nt = ""
                                  , rt = tt[5] !== void 0;
                                return tt[4] && (nt += "@supports (".concat(tt[4], ") {")),
                                tt[2] && (nt += "@media ".concat(tt[2], " {")),
                                rt && (nt += "@layer".concat(tt[5].length > 0 ? " ".concat(tt[5]) : "", " {")),
                                nt += $(tt),
                                rt && (nt += "}"),
                                tt[2] && (nt += "}"),
                                tt[4] && (nt += "}"),
                                nt
                            }).join("")
                        }
                        ,
                        et.i = function(tt, nt, rt, it, ot) {
                            typeof tt == "string" && (tt = [[null, tt, void 0]]);
                            var st = {};
                            if (rt)
                                for (var lt = 0; lt < this.length; lt++) {
                                    var ct = this[lt][0];
                                    ct != null && (st[ct] = !0)
                                }
                            for (var dt = 0; dt < tt.length; dt++) {
                                var pt = [].concat(tt[dt]);
                                rt && st[pt[0]] || (ot !== void 0 && (pt[5] === void 0 || (pt[1] = "@layer".concat(pt[5].length > 0 ? " ".concat(pt[5]) : "", " {").concat(pt[1], "}")),
                                pt[5] = ot),
                                nt && (pt[2] && (pt[1] = "@media ".concat(pt[2], " {").concat(pt[1], "}")),
                                pt[2] = nt),
                                it && (pt[4] ? (pt[1] = "@supports (".concat(pt[4], ") {").concat(pt[1], "}"),
                                pt[4] = it) : pt[4] = "".concat(it)),
                                et.push(pt))
                            }
                        }
                        ,
                        et
                    }
                },
                6738: function(_e) {
                    _e.exports = function($) {
                        return $[1]
                    }
                },
                8679: function(_e) {
                    var $ = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver
                      , et = window.WeakMap;
                    if (et === void 0) {
                        var tt = Object.defineProperty
                          , nt = Date.now() % 1e9;
                        (et = function() {
                            this.name = "__st" + (1e9 * Math.random() >>> 0) + nt++ + "__"
                        }
                        ).prototype = {
                            set: function(Lt, kt) {
                                var Ut = Lt[this.name];
                                return Ut && Ut[0] === Lt ? Ut[1] = kt : tt(Lt, this.name, {
                                    value: [Lt, kt],
                                    writable: !0
                                }),
                                this
                            },
                            get: function(Lt) {
                                var kt;
                                return (kt = Lt[this.name]) && kt[0] === Lt ? kt[1] : void 0
                            },
                            delete: function(Lt) {
                                var kt = Lt[this.name];
                                if (!kt)
                                    return !1;
                                var Ut = kt[0] === Lt;
                                return kt[0] = kt[1] = void 0,
                                Ut
                            },
                            has: function(Lt) {
                                var kt = Lt[this.name];
                                return !!kt && kt[0] === Lt
                            }
                        }
                    }
                    var rt = new et
                      , it = window.msSetImmediate;
                    if (!it) {
                        var ot = []
                          , st = String(Math.random());
                        window.addEventListener("message", function(Lt) {
                            if (Lt.data === st) {
                                var kt = ot;
                                ot = [],
                                kt.forEach(function(Ut) {
                                    Ut()
                                })
                            }
                        }),
                        it = function(Lt) {
                            ot.push(Lt),
                            window.postMessage(st, "*")
                        }
                    }
                    var lt = !1
                      , ct = [];
                    function dt() {
                        lt = !1;
                        var Lt = ct;
                        ct = [],
                        Lt.sort(function(Ut, Jt) {
                            return Ut.uid_ - Jt.uid_
                        });
                        var kt = !1;
                        Lt.forEach(function(Ut) {
                            var Jt = Ut.takeRecords();
                            (function(Pt) {
                                Pt.nodes_.forEach(function(Xt) {
                                    var rn = rt.get(Xt);
                                    rn && rn.forEach(function(zt) {
                                        zt.observer === Pt && zt.removeTransientObservers()
                                    })
                                })
                            }
                            )(Ut),
                            Jt.length && (Ut.callback_(Jt, Ut),
                            kt = !0)
                        }),
                        kt && dt()
                    }
                    function pt(Lt, kt) {
                        for (var Ut = Lt; Ut; Ut = Ut.parentNode) {
                            var Jt = rt.get(Ut);
                            if (Jt)
                                for (var Pt = 0; Pt < Jt.length; Pt++) {
                                    var Xt = Jt[Pt]
                                      , rn = Xt.options;
                                    if (Ut === Lt || rn.subtree) {
                                        var zt = kt(rn);
                                        zt && Xt.enqueue(zt)
                                    }
                                }
                        }
                    }
                    var ht, mt, yt = 0;
                    function Et(Lt) {
                        this.callback_ = Lt,
                        this.nodes_ = [],
                        this.records_ = [],
                        this.uid_ = ++yt
                    }
                    function _t(Lt, kt) {
                        this.type = Lt,
                        this.target = kt,
                        this.addedNodes = [],
                        this.removedNodes = [],
                        this.previousSibling = null,
                        this.nextSibling = null,
                        this.attributeName = null,
                        this.attributeNamespace = null,
                        this.oldValue = null
                    }
                    function wt(Lt, kt) {
                        return ht = new _t(Lt,kt)
                    }
                    function St(Lt) {
                        return mt || ((Ut = new _t((kt = ht).type,kt.target)).addedNodes = kt.addedNodes.slice(),
                        Ut.removedNodes = kt.removedNodes.slice(),
                        Ut.previousSibling = kt.previousSibling,
                        Ut.nextSibling = kt.nextSibling,
                        Ut.attributeName = kt.attributeName,
                        Ut.attributeNamespace = kt.attributeNamespace,
                        Ut.oldValue = kt.oldValue,
                        (mt = Ut).oldValue = Lt,
                        mt);
                        var kt, Ut
                    }
                    function Ct(Lt, kt) {
                        return Lt === kt ? Lt : mt && ((Ut = Lt) === mt || Ut === ht) ? mt : null;
                        var Ut
                    }
                    function Nt(Lt, kt, Ut) {
                        this.observer = Lt,
                        this.target = kt,
                        this.options = Ut,
                        this.transientObservedNodes = []
                    }
                    Et.prototype = {
                        observe: function(Lt, kt) {
                            var Ut;
                            if (Ut = Lt,
                            Lt = window.ShadowDOMPolyfill && window.ShadowDOMPolyfill.wrapIfNeeded(Ut) || Ut,
                            !kt.childList && !kt.attributes && !kt.characterData || kt.attributeOldValue && !kt.attributes || kt.attributeFilter && kt.attributeFilter.length && !kt.attributes || kt.characterDataOldValue && !kt.characterData)
                                throw new SyntaxError;
                            var Jt, Pt = rt.get(Lt);
                            Pt || rt.set(Lt, Pt = []);
                            for (var Xt = 0; Xt < Pt.length; Xt++)
                                if (Pt[Xt].observer === this) {
                                    (Jt = Pt[Xt]).removeListeners(),
                                    Jt.options = kt;
                                    break
                                }
                            Jt || (Jt = new Nt(this,Lt,kt),
                            Pt.push(Jt),
                            this.nodes_.push(Lt)),
                            Jt.addListeners()
                        },
                        disconnect: function() {
                            this.nodes_.forEach(function(Lt) {
                                for (var kt = rt.get(Lt), Ut = 0; Ut < kt.length; Ut++) {
                                    var Jt = kt[Ut];
                                    if (Jt.observer === this) {
                                        Jt.removeListeners(),
                                        kt.splice(Ut, 1);
                                        break
                                    }
                                }
                            }, this),
                            this.records_ = []
                        },
                        takeRecords: function() {
                            var Lt = this.records_;
                            return this.records_ = [],
                            Lt
                        }
                    },
                    Nt.prototype = {
                        enqueue: function(Lt) {
                            var kt, Ut = this.observer.records_, Jt = Ut.length;
                            if (Ut.length > 0) {
                                var Pt = Ct(Ut[Jt - 1], Lt);
                                if (Pt)
                                    return void (Ut[Jt - 1] = Pt)
                            } else
                                kt = this.observer,
                                ct.push(kt),
                                lt || (lt = !0,
                                it(dt));
                            Ut[Jt] = Lt
                        },
                        addListeners: function() {
                            this.addListeners_(this.target)
                        },
                        addListeners_: function(Lt) {
                            var kt = this.options;
                            kt.attributes && Lt.addEventListener("DOMAttrModified", this, !0),
                            kt.characterData && Lt.addEventListener("DOMCharacterDataModified", this, !0),
                            kt.childList && Lt.addEventListener("DOMNodeInserted", this, !0),
                            (kt.childList || kt.subtree) && Lt.addEventListener("DOMNodeRemoved", this, !0)
                        },
                        removeListeners: function() {
                            this.removeListeners_(this.target)
                        },
                        removeListeners_: function(Lt) {
                            var kt = this.options;
                            kt.attributes && Lt.removeEventListener("DOMAttrModified", this, !0),
                            kt.characterData && Lt.removeEventListener("DOMCharacterDataModified", this, !0),
                            kt.childList && Lt.removeEventListener("DOMNodeInserted", this, !0),
                            (kt.childList || kt.subtree) && Lt.removeEventListener("DOMNodeRemoved", this, !0)
                        },
                        addTransientObserver: function(Lt) {
                            if (Lt !== this.target) {
                                this.addListeners_(Lt),
                                this.transientObservedNodes.push(Lt);
                                var kt = rt.get(Lt);
                                kt || rt.set(Lt, kt = []),
                                kt.push(this)
                            }
                        },
                        removeTransientObservers: function() {
                            var Lt = this.transientObservedNodes;
                            this.transientObservedNodes = [],
                            Lt.forEach(function(kt) {
                                this.removeListeners_(kt);
                                for (var Ut = rt.get(kt), Jt = 0; Jt < Ut.length; Jt++)
                                    if (Ut[Jt] === this) {
                                        Ut.splice(Jt, 1);
                                        break
                                    }
                            }, this)
                        },
                        handleEvent: function(Lt) {
                            switch (Lt.stopImmediatePropagation(),
                            Lt.type) {
                            case "DOMAttrModified":
                                var kt = Lt.attrName
                                  , Ut = Lt.relatedNode.namespaceURI
                                  , Jt = Lt.target;
                                (Xt = new wt("attributes",Jt)).attributeName = kt,
                                Xt.attributeNamespace = Ut;
                                var Pt = null;
                                typeof MutationEvent < "u" && Lt.attrChange === MutationEvent.ADDITION || (Pt = Lt.prevValue),
                                pt(Jt, function(jt) {
                                    if (jt.attributes && (!jt.attributeFilter || !jt.attributeFilter.length || jt.attributeFilter.indexOf(kt) !== -1 || jt.attributeFilter.indexOf(Ut) !== -1))
                                        return jt.attributeOldValue ? St(Pt) : Xt
                                });
                                break;
                            case "DOMCharacterDataModified":
                                var Xt = wt("characterData", Jt = Lt.target);
                                Pt = Lt.prevValue,
                                pt(Jt, function(jt) {
                                    if (jt.characterData)
                                        return jt.characterDataOldValue ? St(Pt) : Xt
                                });
                                break;
                            case "DOMNodeRemoved":
                                this.addTransientObserver(Lt.target);
                            case "DOMNodeInserted":
                                Jt = Lt.relatedNode;
                                var rn, zt, xt = Lt.target;
                                Lt.type === "DOMNodeInserted" ? (rn = [xt],
                                zt = []) : (rn = [],
                                zt = [xt]);
                                var $t = xt.previousSibling
                                  , Dt = xt.nextSibling;
                                (Xt = wt("childList", Jt)).addedNodes = rn,
                                Xt.removedNodes = zt,
                                Xt.previousSibling = $t,
                                Xt.nextSibling = Dt,
                                pt(Jt, function(jt) {
                                    if (jt.childList)
                                        return Xt
                                })
                            }
                            ht = mt = void 0
                        }
                    },
                    $ || ($ = Et),
                    _e.exports = $
                },
                7588: function(_e) {
                    var $ = function(et) {
                        var tt, nt = Object.prototype, rt = nt.hasOwnProperty, it = typeof Symbol == "function" ? Symbol : {}, ot = it.iterator || "@@iterator", st = it.asyncIterator || "@@asyncIterator", lt = it.toStringTag || "@@toStringTag";
                        function ct(jt, Ft, Ht) {
                            return Object.defineProperty(jt, Ft, {
                                value: Ht,
                                enumerable: !0,
                                configurable: !0,
                                writable: !0
                            }),
                            jt[Ft]
                        }
                        try {
                            ct({}, "")
                        } catch {
                            ct = function(Ft, Ht, qt) {
                                return Ft[Ht] = qt
                            }
                        }
                        function dt(jt, Ft, Ht, qt) {
                            var Wt = Ft && Ft.prototype instanceof wt ? Ft : wt
                              , Mt = Object.create(Wt.prototype)
                              , Yt = new xt(qt || []);
                            return Mt._invoke = function(un, hn, _n) {
                                var kn = ht;
                                return function(Dn, jn) {
                                    if (kn === yt)
                                        throw new Error("Generator is already running");
                                    if (kn === Et) {
                                        if (Dn === "throw")
                                            throw jn;
                                        return Dt()
                                    }
                                    for (_n.method = Dn,
                                    _n.arg = jn; ; ) {
                                        var Bn = _n.delegate;
                                        if (Bn) {
                                            var Un = Xt(Bn, _n);
                                            if (Un) {
                                                if (Un === _t)
                                                    continue;
                                                return Un
                                            }
                                        }
                                        if (_n.method === "next")
                                            _n.sent = _n._sent = _n.arg;
                                        else if (_n.method === "throw") {
                                            if (kn === ht)
                                                throw kn = Et,
                                                _n.arg;
                                            _n.dispatchException(_n.arg)
                                        } else
                                            _n.method === "return" && _n.abrupt("return", _n.arg);
                                        kn = yt;
                                        var Hn = pt(un, hn, _n);
                                        if (Hn.type === "normal") {
                                            if (kn = _n.done ? Et : mt,
                                            Hn.arg === _t)
                                                continue;
                                            return {
                                                value: Hn.arg,
                                                done: _n.done
                                            }
                                        }
                                        Hn.type === "throw" && (kn = Et,
                                        _n.method = "throw",
                                        _n.arg = Hn.arg)
                                    }
                                }
                            }(jt, Ht, Yt),
                            Mt
                        }
                        function pt(jt, Ft, Ht) {
                            try {
                                return {
                                    type: "normal",
                                    arg: jt.call(Ft, Ht)
                                }
                            } catch (qt) {
                                return {
                                    type: "throw",
                                    arg: qt
                                }
                            }
                        }
                        et.wrap = dt;
                        var ht = "suspendedStart"
                          , mt = "suspendedYield"
                          , yt = "executing"
                          , Et = "completed"
                          , _t = {};
                        function wt() {}
                        function St() {}
                        function Ct() {}
                        var Nt = {};
                        ct(Nt, ot, function() {
                            return this
                        });
                        var Lt = Object.getPrototypeOf
                          , kt = Lt && Lt(Lt($t([])));
                        kt && kt !== nt && rt.call(kt, ot) && (Nt = kt);
                        var Ut = Ct.prototype = wt.prototype = Object.create(Nt);
                        function Jt(jt) {
                            ["next", "throw", "return"].forEach(function(Ft) {
                                ct(jt, Ft, function(Ht) {
                                    return this._invoke(Ft, Ht)
                                })
                            })
                        }
                        function Pt(jt, Ft) {
                            function Ht(Wt, Mt, Yt, un) {
                                var hn = pt(jt[Wt], jt, Mt);
                                if (hn.type !== "throw") {
                                    var _n = hn.arg
                                      , kn = _n.value;
                                    return kn && typeof kn == "object" && rt.call(kn, "__await") ? Ft.resolve(kn.__await).then(function(Dn) {
                                        Ht("next", Dn, Yt, un)
                                    }, function(Dn) {
                                        Ht("throw", Dn, Yt, un)
                                    }) : Ft.resolve(kn).then(function(Dn) {
                                        _n.value = Dn,
                                        Yt(_n)
                                    }, function(Dn) {
                                        return Ht("throw", Dn, Yt, un)
                                    })
                                }
                                un(hn.arg)
                            }
                            var qt;
                            this._invoke = function(Wt, Mt) {
                                function Yt() {
                                    return new Ft(function(un, hn) {
                                        Ht(Wt, Mt, un, hn)
                                    }
                                    )
                                }
                                return qt = qt ? qt.then(Yt, Yt) : Yt()
                            }
                        }
                        function Xt(jt, Ft) {
                            var Ht = jt.iterator[Ft.method];
                            if (Ht === tt) {
                                if (Ft.delegate = null,
                                Ft.method === "throw") {
                                    if (jt.iterator.return && (Ft.method = "return",
                                    Ft.arg = tt,
                                    Xt(jt, Ft),
                                    Ft.method === "throw"))
                                        return _t;
                                    Ft.method = "throw",
                                    Ft.arg = new TypeError("The iterator does not provide a 'throw' method")
                                }
                                return _t
                            }
                            var qt = pt(Ht, jt.iterator, Ft.arg);
                            if (qt.type === "throw")
                                return Ft.method = "throw",
                                Ft.arg = qt.arg,
                                Ft.delegate = null,
                                _t;
                            var Wt = qt.arg;
                            return Wt ? Wt.done ? (Ft[jt.resultName] = Wt.value,
                            Ft.next = jt.nextLoc,
                            Ft.method !== "return" && (Ft.method = "next",
                            Ft.arg = tt),
                            Ft.delegate = null,
                            _t) : Wt : (Ft.method = "throw",
                            Ft.arg = new TypeError("iterator result is not an object"),
                            Ft.delegate = null,
                            _t)
                        }
                        function rn(jt) {
                            var Ft = {
                                tryLoc: jt[0]
                            };
                            1 in jt && (Ft.catchLoc = jt[1]),
                            2 in jt && (Ft.finallyLoc = jt[2],
                            Ft.afterLoc = jt[3]),
                            this.tryEntries.push(Ft)
                        }
                        function zt(jt) {
                            var Ft = jt.completion || {};
                            Ft.type = "normal",
                            delete Ft.arg,
                            jt.completion = Ft
                        }
                        function xt(jt) {
                            this.tryEntries = [{
                                tryLoc: "root"
                            }],
                            jt.forEach(rn, this),
                            this.reset(!0)
                        }
                        function $t(jt) {
                            if (jt) {
                                var Ft = jt[ot];
                                if (Ft)
                                    return Ft.call(jt);
                                if (typeof jt.next == "function")
                                    return jt;
                                if (!isNaN(jt.length)) {
                                    var Ht = -1
                                      , qt = function Wt() {
                                        for (; ++Ht < jt.length; )
                                            if (rt.call(jt, Ht))
                                                return Wt.value = jt[Ht],
                                                Wt.done = !1,
                                                Wt;
                                        return Wt.value = tt,
                                        Wt.done = !0,
                                        Wt
                                    };
                                    return qt.next = qt
                                }
                            }
                            return {
                                next: Dt
                            }
                        }
                        function Dt() {
                            return {
                                value: tt,
                                done: !0
                            }
                        }
                        return St.prototype = Ct,
                        ct(Ut, "constructor", Ct),
                        ct(Ct, "constructor", St),
                        St.displayName = ct(Ct, lt, "GeneratorFunction"),
                        et.isGeneratorFunction = function(jt) {
                            var Ft = typeof jt == "function" && jt.constructor;
                            return !!Ft && (Ft === St || (Ft.displayName || Ft.name) === "GeneratorFunction")
                        }
                        ,
                        et.mark = function(jt) {
                            return Object.setPrototypeOf ? Object.setPrototypeOf(jt, Ct) : (jt.__proto__ = Ct,
                            ct(jt, lt, "GeneratorFunction")),
                            jt.prototype = Object.create(Ut),
                            jt
                        }
                        ,
                        et.awrap = function(jt) {
                            return {
                                __await: jt
                            }
                        }
                        ,
                        Jt(Pt.prototype),
                        ct(Pt.prototype, st, function() {
                            return this
                        }),
                        et.AsyncIterator = Pt,
                        et.async = function(jt, Ft, Ht, qt, Wt) {
                            Wt === void 0 && (Wt = Promise);
                            var Mt = new Pt(dt(jt, Ft, Ht, qt),Wt);
                            return et.isGeneratorFunction(Ft) ? Mt : Mt.next().then(function(Yt) {
                                return Yt.done ? Yt.value : Mt.next()
                            })
                        }
                        ,
                        Jt(Ut),
                        ct(Ut, lt, "Generator"),
                        ct(Ut, ot, function() {
                            return this
                        }),
                        ct(Ut, "toString", function() {
                            return "[object Generator]"
                        }),
                        et.keys = function(jt) {
                            var Ft = [];
                            for (var Ht in jt)
                                Ft.push(Ht);
                            return Ft.reverse(),
                            function qt() {
                                for (; Ft.length; ) {
                                    var Wt = Ft.pop();
                                    if (Wt in jt)
                                        return qt.value = Wt,
                                        qt.done = !1,
                                        qt
                                }
                                return qt.done = !0,
                                qt
                            }
                        }
                        ,
                        et.values = $t,
                        xt.prototype = {
                            constructor: xt,
                            reset: function(jt) {
                                if (this.prev = 0,
                                this.next = 0,
                                this.sent = this._sent = tt,
                                this.done = !1,
                                this.delegate = null,
                                this.method = "next",
                                this.arg = tt,
                                this.tryEntries.forEach(zt),
                                !jt)
                                    for (var Ft in this)
                                        Ft.charAt(0) === "t" && rt.call(this, Ft) && !isNaN(+Ft.slice(1)) && (this[Ft] = tt)
                            },
                            stop: function() {
                                this.done = !0;
                                var jt = this.tryEntries[0].completion;
                                if (jt.type === "throw")
                                    throw jt.arg;
                                return this.rval
                            },
                            dispatchException: function(jt) {
                                if (this.done)
                                    throw jt;
                                var Ft = this;
                                function Ht(hn, _n) {
                                    return Mt.type = "throw",
                                    Mt.arg = jt,
                                    Ft.next = hn,
                                    _n && (Ft.method = "next",
                                    Ft.arg = tt),
                                    !!_n
                                }
                                for (var qt = this.tryEntries.length - 1; qt >= 0; --qt) {
                                    var Wt = this.tryEntries[qt]
                                      , Mt = Wt.completion;
                                    if (Wt.tryLoc === "root")
                                        return Ht("end");
                                    if (Wt.tryLoc <= this.prev) {
                                        var Yt = rt.call(Wt, "catchLoc")
                                          , un = rt.call(Wt, "finallyLoc");
                                        if (Yt && un) {
                                            if (this.prev < Wt.catchLoc)
                                                return Ht(Wt.catchLoc, !0);
                                            if (this.prev < Wt.finallyLoc)
                                                return Ht(Wt.finallyLoc)
                                        } else if (Yt) {
                                            if (this.prev < Wt.catchLoc)
                                                return Ht(Wt.catchLoc, !0)
                                        } else {
                                            if (!un)
                                                throw new Error("try statement without catch or finally");
                                            if (this.prev < Wt.finallyLoc)
                                                return Ht(Wt.finallyLoc)
                                        }
                                    }
                                }
                            },
                            abrupt: function(jt, Ft) {
                                for (var Ht = this.tryEntries.length - 1; Ht >= 0; --Ht) {
                                    var qt = this.tryEntries[Ht];
                                    if (qt.tryLoc <= this.prev && rt.call(qt, "finallyLoc") && this.prev < qt.finallyLoc) {
                                        var Wt = qt;
                                        break
                                    }
                                }
                                Wt && (jt === "break" || jt === "continue") && Wt.tryLoc <= Ft && Ft <= Wt.finallyLoc && (Wt = null);
                                var Mt = Wt ? Wt.completion : {};
                                return Mt.type = jt,
                                Mt.arg = Ft,
                                Wt ? (this.method = "next",
                                this.next = Wt.finallyLoc,
                                _t) : this.complete(Mt)
                            },
                            complete: function(jt, Ft) {
                                if (jt.type === "throw")
                                    throw jt.arg;
                                return jt.type === "break" || jt.type === "continue" ? this.next = jt.arg : jt.type === "return" ? (this.rval = this.arg = jt.arg,
                                this.method = "return",
                                this.next = "end") : jt.type === "normal" && Ft && (this.next = Ft),
                                _t
                            },
                            finish: function(jt) {
                                for (var Ft = this.tryEntries.length - 1; Ft >= 0; --Ft) {
                                    var Ht = this.tryEntries[Ft];
                                    if (Ht.finallyLoc === jt)
                                        return this.complete(Ht.completion, Ht.afterLoc),
                                        zt(Ht),
                                        _t
                                }
                            },
                            catch: function(jt) {
                                for (var Ft = this.tryEntries.length - 1; Ft >= 0; --Ft) {
                                    var Ht = this.tryEntries[Ft];
                                    if (Ht.tryLoc === jt) {
                                        var qt = Ht.completion;
                                        if (qt.type === "throw") {
                                            var Wt = qt.arg;
                                            zt(Ht)
                                        }
                                        return Wt
                                    }
                                }
                                throw new Error("illegal catch attempt")
                            },
                            delegateYield: function(jt, Ft, Ht) {
                                return this.delegate = {
                                    iterator: $t(jt),
                                    resultName: Ft,
                                    nextLoc: Ht
                                },
                                this.method === "next" && (this.arg = tt),
                                _t
                            }
                        },
                        et
                    }(_e.exports);
                    try {
                        regeneratorRuntime = $
                    } catch {
                        typeof globalThis == "object" ? globalThis.regeneratorRuntime = $ : Function("r", "regeneratorRuntime = r")($)
                    }
                },
                8702: function(_e, $, et) {
                    et.d($, {
                        Z: function() {
                            return qt
                        }
                    });
                    var tt = et(4296)
                      , nt = et(6464)
                      , rt = et(6881)
                      , it = et(2942)
                      , ot = et(7003)
                      , st = et(3379)
                      , lt = et.n(st)
                      , ct = et(7795)
                      , dt = et.n(ct)
                      , pt = et(569)
                      , ht = et.n(pt)
                      , mt = et(3565)
                      , yt = et.n(mt)
                      , Et = et(9216)
                      , _t = et.n(Et)
                      , wt = et(4589)
                      , St = et.n(wt)
                      , Ct = et(5313)
                      , Nt = {};
                    Ct.Z && Ct.Z.locals && (Nt.locals = Ct.Z.locals);
                    var Lt, kt = 0, Ut = {};
                    Ut.styleTagTransform = St(),
                    Ut.setAttributes = yt(),
                    Ut.insert = ht().bind(null, "head"),
                    Ut.domAPI = dt(),
                    Ut.insertStyleElement = _t(),
                    Nt.use = function(Wt) {
                        return Ut.options = Wt || {},
                        kt++ || (Lt = lt()(Ct.Z, Ut)),
                        Nt
                    }
                    ,
                    Nt.unuse = function() {
                        kt > 0 && !--kt && (Lt(),
                        Lt = null)
                    }
                    ;
                    var Jt = Nt;
                    function Pt(Wt) {
                        var Mt, Yt;
                        return {
                            c: function() {
                                Mt = (0,
                                it.bi5)("svg"),
                                Yt = (0,
                                it.bi5)("path"),
                                (0,
                                it.Ljt)(Yt, "d", "M599.99999 832.000004h47.999999a24 24 0 0 0 23.999999-24V376.000013a24 24 0 0 0-23.999999-24h-47.999999a24 24 0 0 0-24 24v431.999991a24 24 0 0 0 24 24zM927.999983 160.000017h-164.819997l-67.999998-113.399998A95.999998 95.999998 0 0 0 612.819989 0.00002H411.179993a95.999998 95.999998 0 0 0-82.319998 46.599999L260.819996 160.000017H95.999999A31.999999 31.999999 0 0 0 64 192.000016v32a31.999999 31.999999 0 0 0 31.999999 31.999999h32v671.999987a95.999998 95.999998 0 0 0 95.999998 95.999998h575.999989a95.999998 95.999998 0 0 0 95.999998-95.999998V256.000015h31.999999a31.999999 31.999999 0 0 0 32-31.999999V192.000016a31.999999 31.999999 0 0 0-32-31.999999zM407.679993 101.820018A12 12 0 0 1 417.999993 96.000018h187.999996a12 12 0 0 1 10.3 5.82L651.219989 160.000017H372.779994zM799.999986 928.000002H223.999997V256.000015h575.999989z m-423.999992-95.999998h47.999999a24 24 0 0 0 24-24V376.000013a24 24 0 0 0-24-24h-47.999999a24 24 0 0 0-24 24v431.999991a24 24 0 0 0 24 24z"),
                                (0,
                                it.Ljt)(Mt, "class", "vc-icon-delete"),
                                (0,
                                it.Ljt)(Mt, "viewBox", "0 0 1024 1024"),
                                (0,
                                it.Ljt)(Mt, "width", "200"),
                                (0,
                                it.Ljt)(Mt, "height", "200")
                            },
                            m: function(un, hn) {
                                (0,
                                it.$Tr)(un, Mt, hn),
                                (0,
                                it.R3I)(Mt, Yt)
                            },
                            d: function(un) {
                                un && (0,
                                it.ogt)(Mt)
                            }
                        }
                    }
                    function Xt(Wt) {
                        var Mt, Yt, un;
                        return {
                            c: function() {
                                Mt = (0,
                                it.bi5)("svg"),
                                Yt = (0,
                                it.bi5)("path"),
                                un = (0,
                                it.bi5)("path"),
                                (0,
                                it.Ljt)(Yt, "d", "M874.154197 150.116875A511.970373 511.970373 0 1 0 1023.993986 511.991687a511.927744 511.927744 0 0 0-149.839789-361.874812z m-75.324866 648.382129A405.398688 405.398688 0 1 1 917.422301 511.991687a405.313431 405.313431 0 0 1-118.59297 286.507317z"),
                                (0,
                                it.Ljt)(un, "d", "M725.039096 299.274605a54.351559 54.351559 0 0 0-76.731613 0l-135.431297 135.431297L377.274375 299.274605a54.436817 54.436817 0 0 0-76.944756 76.987385l135.388668 135.431297-135.388668 135.473925a54.436817 54.436817 0 0 0 76.944756 76.987385l135.388668-135.431297 135.431297 135.473926a54.436817 54.436817 0 0 0 76.731613-76.987385l-135.388668-135.473926 135.388668-135.431296a54.479445 54.479445 0 0 0 0.213143-77.030014z"),
                                (0,
                                it.Ljt)(Mt, "viewBox", "0 0 1024 1024"),
                                (0,
                                it.Ljt)(Mt, "width", "200"),
                                (0,
                                it.Ljt)(Mt, "height", "200")
                            },
                            m: function(hn, _n) {
                                (0,
                                it.$Tr)(hn, Mt, _n),
                                (0,
                                it.R3I)(Mt, Yt),
                                (0,
                                it.R3I)(Mt, un)
                            },
                            d: function(hn) {
                                hn && (0,
                                it.ogt)(Mt)
                            }
                        }
                    }
                    function rn(Wt) {
                        var Mt, Yt;
                        return {
                            c: function() {
                                Mt = (0,
                                it.bi5)("svg"),
                                Yt = (0,
                                it.bi5)("path"),
                                (0,
                                it.Ljt)(Yt, "fill-rule", "evenodd"),
                                (0,
                                it.Ljt)(Yt, "d", "M5.75 1a.75.75 0 00-.75.75v3c0 .414.336.75.75.75h4.5a.75.75 0 00.75-.75v-3a.75.75 0 00-.75-.75h-4.5zm.75 3V2.5h3V4h-3zm-2.874-.467a.75.75 0 00-.752-1.298A1.75 1.75 0 002 3.75v9.5c0 .966.784 1.75 1.75 1.75h8.5A1.75 1.75 0 0014 13.25v-9.5a1.75 1.75 0 00-.874-1.515.75.75 0 10-.752 1.298.25.25 0 01.126.217v9.5a.25.25 0 01-.25.25h-8.5a.25.25 0 01-.25-.25v-9.5a.25.25 0 01.126-.217z"),
                                (0,
                                it.Ljt)(Mt, "class", "vc-icon-copy"),
                                (0,
                                it.Ljt)(Mt, "viewBox", "0 0 16 16")
                            },
                            m: function(un, hn) {
                                (0,
                                it.$Tr)(un, Mt, hn),
                                (0,
                                it.R3I)(Mt, Yt)
                            },
                            d: function(un) {
                                un && (0,
                                it.ogt)(Mt)
                            }
                        }
                    }
                    function zt(Wt) {
                        var Mt, Yt;
                        return {
                            c: function() {
                                Mt = (0,
                                it.bi5)("svg"),
                                Yt = (0,
                                it.bi5)("path"),
                                (0,
                                it.Ljt)(Yt, "fill-rule", "evenodd"),
                                (0,
                                it.Ljt)(Yt, "d", "M13.78 4.22a.75.75 0 010 1.06l-7.25 7.25a.75.75 0 01-1.06 0L2.22 9.28a.75.75 0 011.06-1.06L6 10.94l6.72-6.72a.75.75 0 011.06 0z"),
                                (0,
                                it.Ljt)(Mt, "class", "vc-icon-suc"),
                                (0,
                                it.Ljt)(Mt, "viewBox", "0 0 16 16")
                            },
                            m: function(un, hn) {
                                (0,
                                it.$Tr)(un, Mt, hn),
                                (0,
                                it.R3I)(Mt, Yt)
                            },
                            d: function(un) {
                                un && (0,
                                it.ogt)(Mt)
                            }
                        }
                    }
                    function xt(Wt) {
                        var Mt, Yt, un;
                        return {
                            c: function() {
                                Mt = (0,
                                it.bi5)("svg"),
                                Yt = (0,
                                it.bi5)("path"),
                                un = (0,
                                it.bi5)("path"),
                                (0,
                                it.Ljt)(Yt, "d", "M776.533333 1024 162.133333 1024C72.533333 1024 0 951.466667 0 861.866667L0 247.466667C0 157.866667 72.533333 85.333333 162.133333 85.333333L469.333333 85.333333c25.6 0 42.666667 17.066667 42.666667 42.666667s-17.066667 42.666667-42.666667 42.666667L162.133333 170.666667C119.466667 170.666667 85.333333 204.8 85.333333 247.466667l0 610.133333c0 42.666667 34.133333 76.8 76.8 76.8l610.133333 0c42.666667 0 76.8-34.133333 76.8-76.8L849.066667 554.666667c0-25.6 17.066667-42.666667 42.666667-42.666667s42.666667 17.066667 42.666667 42.666667l0 307.2C938.666667 951.466667 866.133333 1024 776.533333 1024z"),
                                (0,
                                it.Ljt)(un, "d", "M256 810.666667c-12.8 0-21.333333-4.266667-29.866667-12.8C217.6 789.333333 213.333333 772.266667 213.333333 759.466667l42.666667-213.333333c0-8.533333 4.266667-17.066667 12.8-21.333333l512-512c17.066667-17.066667 42.666667-17.066667 59.733333 0l170.666667 170.666667c17.066667 17.066667 17.066667 42.666667 0 59.733333l-512 512c-4.266667 4.266667-12.8 8.533333-21.333333 12.8l-213.333333 42.666667C260.266667 810.666667 260.266667 810.666667 256 810.666667zM337.066667 576l-25.6 136.533333 136.533333-25.6L921.6 213.333333 810.666667 102.4 337.066667 576z"),
                                (0,
                                it.Ljt)(Mt, "class", "vc-icon-edit"),
                                (0,
                                it.Ljt)(Mt, "viewBox", "0 0 1024 1024"),
                                (0,
                                it.Ljt)(Mt, "width", "200"),
                                (0,
                                it.Ljt)(Mt, "height", "200")
                            },
                            m: function(hn, _n) {
                                (0,
                                it.$Tr)(hn, Mt, _n),
                                (0,
                                it.R3I)(Mt, Yt),
                                (0,
                                it.R3I)(Mt, un)
                            },
                            d: function(hn) {
                                hn && (0,
                                it.ogt)(Mt)
                            }
                        }
                    }
                    function $t(Wt) {
                        var Mt, Yt;
                        return {
                            c: function() {
                                Mt = (0,
                                it.bi5)("svg"),
                                Yt = (0,
                                it.bi5)("path"),
                                (0,
                                it.Ljt)(Yt, "d", "M581.338005 987.646578c-2.867097 4.095853-4.573702 8.669555-8.191705 12.287558a83.214071 83.214071 0 0 1-60.959939 24.029001 83.214071 83.214071 0 0 1-61.028203-24.029001c-3.618003-3.618003-5.324608-8.191705-8.123441-12.15103L24.370323 569.050448a83.418864 83.418864 0 0 1 117.892289-117.89229l369.923749 369.92375L1308.829682 24.438587A83.418864 83.418864 0 0 1 1426.721971 142.194348L581.338005 987.646578z"),
                                (0,
                                it.Ljt)(Mt, "class", "vc-icon-don"),
                                (0,
                                it.Ljt)(Mt, "viewBox", "0 0 1501 1024"),
                                (0,
                                it.Ljt)(Mt, "width", "200"),
                                (0,
                                it.Ljt)(Mt, "height", "200")
                            },
                            m: function(un, hn) {
                                (0,
                                it.$Tr)(un, Mt, hn),
                                (0,
                                it.R3I)(Mt, Yt)
                            },
                            d: function(un) {
                                un && (0,
                                it.ogt)(Mt)
                            }
                        }
                    }
                    function Dt(Wt) {
                        var Mt, Yt;
                        return {
                            c: function() {
                                Mt = (0,
                                it.bi5)("svg"),
                                Yt = (0,
                                it.bi5)("path"),
                                (0,
                                it.Ljt)(Yt, "d", "M894.976 574.464q0 78.848-29.696 148.48t-81.408 123.392-121.856 88.064-151.04 41.472q-5.12 1.024-9.216 1.536t-9.216 0.512l-177.152 0q-17.408 0-34.304-6.144t-30.208-16.896-22.016-25.088-8.704-29.696 8.192-29.696 21.504-24.576 29.696-16.384 33.792-6.144l158.72 1.024q54.272 0 102.4-19.968t83.968-53.76 56.32-79.36 20.48-97.792q0-49.152-18.432-92.16t-50.688-76.8-75.264-54.784-93.184-26.112q-2.048 0-2.56 0.512t-2.56 0.512l-162.816 0 0 80.896q0 17.408-13.824 25.6t-44.544-10.24q-8.192-5.12-26.112-17.92t-41.984-30.208-50.688-36.864l-51.2-38.912q-15.36-12.288-26.624-22.016t-11.264-24.064q0-12.288 12.8-25.6t29.184-26.624q18.432-15.36 44.032-35.84t50.688-39.936 45.056-35.328 28.16-22.016q24.576-17.408 39.936-7.168t16.384 30.72l0 81.92 162.816 0q5.12 0 10.752 1.024t10.752 2.048q79.872 8.192 149.504 41.984t121.344 87.552 80.896 123.392 29.184 147.456z"),
                                (0,
                                it.Ljt)(Mt, "class", "vc-icon-cancel"),
                                (0,
                                it.Ljt)(Mt, "viewBox", "0 0 1024 1024"),
                                (0,
                                it.Ljt)(Mt, "width", "200"),
                                (0,
                                it.Ljt)(Mt, "height", "200")
                            },
                            m: function(un, hn) {
                                (0,
                                it.$Tr)(un, Mt, hn),
                                (0,
                                it.R3I)(Mt, Yt)
                            },
                            d: function(un) {
                                un && (0,
                                it.ogt)(Mt)
                            }
                        }
                    }
                    function jt(Wt) {
                        var Mt, Yt, un, hn, _n, kn, Dn, jn, Bn, Un = Wt[0] === "delete" && Pt(), Hn = Wt[0] === "clear" && Xt(), cr = Wt[0] === "copy" && rn(), Gn = Wt[0] === "success" && zt(), Mn = Wt[0] === "edit" && xt(), rr = Wt[0] === "done" && $t(), Zn = Wt[0] === "cancel" && Dt();
                        return {
                            c: function() {
                                Mt = (0,
                                it.bGB)("i"),
                                Un && Un.c(),
                                Yt = (0,
                                it.DhX)(),
                                Hn && Hn.c(),
                                un = (0,
                                it.DhX)(),
                                cr && cr.c(),
                                hn = (0,
                                it.DhX)(),
                                Gn && Gn.c(),
                                _n = (0,
                                it.DhX)(),
                                Mn && Mn.c(),
                                kn = (0,
                                it.DhX)(),
                                rr && rr.c(),
                                Dn = (0,
                                it.DhX)(),
                                Zn && Zn.c(),
                                (0,
                                it.Ljt)(Mt, "class", "vc-icon")
                            },
                            m: function(pr, Ur) {
                                (0,
                                it.$Tr)(pr, Mt, Ur),
                                Un && Un.m(Mt, null),
                                (0,
                                it.R3I)(Mt, Yt),
                                Hn && Hn.m(Mt, null),
                                (0,
                                it.R3I)(Mt, un),
                                cr && cr.m(Mt, null),
                                (0,
                                it.R3I)(Mt, hn),
                                Gn && Gn.m(Mt, null),
                                (0,
                                it.R3I)(Mt, _n),
                                Mn && Mn.m(Mt, null),
                                (0,
                                it.R3I)(Mt, kn),
                                rr && rr.m(Mt, null),
                                (0,
                                it.R3I)(Mt, Dn),
                                Zn && Zn.m(Mt, null),
                                jn || (Bn = (0,
                                it.oLt)(Mt, "click", Wt[1]),
                                jn = !0)
                            },
                            p: function(pr, Ur) {
                                Ur[0],
                                pr[0] === "delete" ? Un || ((Un = Pt()).c(),
                                Un.m(Mt, Yt)) : Un && (Un.d(1),
                                Un = null),
                                pr[0] === "clear" ? Hn || ((Hn = Xt()).c(),
                                Hn.m(Mt, un)) : Hn && (Hn.d(1),
                                Hn = null),
                                pr[0] === "copy" ? cr || ((cr = rn()).c(),
                                cr.m(Mt, hn)) : cr && (cr.d(1),
                                cr = null),
                                pr[0] === "success" ? Gn || ((Gn = zt()).c(),
                                Gn.m(Mt, _n)) : Gn && (Gn.d(1),
                                Gn = null),
                                pr[0] === "edit" ? Mn || ((Mn = xt()).c(),
                                Mn.m(Mt, kn)) : Mn && (Mn.d(1),
                                Mn = null),
                                pr[0] === "done" ? rr || ((rr = $t()).c(),
                                rr.m(Mt, Dn)) : rr && (rr.d(1),
                                rr = null),
                                pr[0] === "cancel" ? Zn || ((Zn = Dt()).c(),
                                Zn.m(Mt, null)) : Zn && (Zn.d(1),
                                Zn = null)
                            },
                            i: it.ZTd,
                            o: it.ZTd,
                            d: function(pr) {
                                pr && (0,
                                it.ogt)(Mt),
                                Un && Un.d(),
                                Hn && Hn.d(),
                                cr && cr.d(),
                                Gn && Gn.d(),
                                Mn && Mn.d(),
                                rr && rr.d(),
                                Zn && Zn.d(),
                                jn = !1,
                                Bn()
                            }
                        }
                    }
                    function Ft(Wt, Mt, Yt) {
                        var un = Mt.name;
                        return (0,
                        ot.H3)(function() {
                            Jt.use()
                        }),
                        (0,
                        ot.ev)(function() {
                            Jt.unuse()
                        }),
                        Wt.$$set = function(hn) {
                            "name"in hn && Yt(0, un = hn.name)
                        }
                        ,
                        [un, function(hn) {
                            it.cKT.call(this, Wt, hn)
                        }
                        ]
                    }
                    var Ht = function(Wt) {
                        function Mt(Yt) {
                            var un;
                            return un = Wt.call(this) || this,
                            (0,
                            it.S1n)((0,
                            nt.Z)(un), Yt, Ft, jt, it.N8, {
                                name: 0
                            }),
                            un
                        }
                        return (0,
                        rt.Z)(Mt, Wt),
                        (0,
                        tt.Z)(Mt, [{
                            key: "name",
                            get: function() {
                                return this.$$.ctx[0]
                            },
                            set: function(Yt) {
                                this.$$set({
                                    name: Yt
                                }),
                                (0,
                                it.yl1)()
                            }
                        }]),
                        Mt
                    }(it.f_C)
                      , qt = Ht
                },
                3903: function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
                    var _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(6464)
                      , _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(6881)
                      , svelte_internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2942)
                      , svelte__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(7003)
                      , _component_icon_icon_svelte__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(8702)
                      , _logTool__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(8665)
                      , _log_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5629)
                      , _logCommand_less__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(3411);
                    function get_each_context(_e, $, et) {
                        var tt = _e.slice();
                        return tt[28] = $[et],
                        tt
                    }
                    function create_if_block_2(_e) {
                        var $, et, tt;
                        return {
                            c: function() {
                                ($ = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("li")).textContent = "Close",
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)($, "class", "vc-cmd-prompted-hide")
                            },
                            m: function(nt, rt) {
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$Tr)(nt, $, rt),
                                et || (tt = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oLt)($, "click", _e[5]),
                                et = !0)
                            },
                            p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ZTd,
                            d: function(nt) {
                                nt && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ogt)($),
                                et = !1,
                                tt()
                            }
                        }
                    }
                    function create_else_block(_e) {
                        var $;
                        return {
                            c: function() {
                                ($ = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("li")).textContent = "No Prompted"
                            },
                            m: function(et, tt) {
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$Tr)(et, $, tt)
                            },
                            p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ZTd,
                            d: function(et) {
                                et && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ogt)($)
                            }
                        }
                    }
                    function create_each_block(_e) {
                        var $, et, tt, nt, rt = _e[28].text + "";
                        function it() {
                            return _e[14](_e[28])
                        }
                        return {
                            c: function() {
                                $ = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("li"),
                                et = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.fLW)(rt)
                            },
                            m: function(ot, st) {
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$Tr)(ot, $, st),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)($, et),
                                tt || (nt = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oLt)($, "click", it),
                                tt = !0)
                            },
                            p: function(ot, st) {
                                _e = ot,
                                8 & st && rt !== (rt = _e[28].text + "") && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.rTO)(et, rt)
                            },
                            d: function(ot) {
                                ot && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ogt)($),
                                tt = !1,
                                nt()
                            }
                        }
                    }
                    function create_if_block_1(_e) {
                        var $, et, tt, nt, rt;
                        return et = new _component_icon_icon_svelte__WEBPACK_IMPORTED_MODULE_2__.Z({
                            props: {
                                name: "clear"
                            }
                        }),
                        {
                            c: function() {
                                $ = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("div"),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.YCL)(et.$$.fragment),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)($, "class", "vc-cmd-clear-btn")
                            },
                            m: function(it, ot) {
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$Tr)(it, $, ot),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.yef)(et, $, null),
                                tt = !0,
                                nt || (rt = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oLt)($, "click", (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.AT7)(_e[17])),
                                nt = !0)
                            },
                            p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ZTd,
                            i: function(it) {
                                tt || ((0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(et.$$.fragment, it),
                                tt = !0)
                            },
                            o: function(it) {
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.etI)(et.$$.fragment, it),
                                tt = !1
                            },
                            d: function(it) {
                                it && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ogt)($),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.vpE)(et),
                                nt = !1,
                                rt()
                            }
                        }
                    }
                    function create_if_block(_e) {
                        var $, et, tt, nt, rt;
                        return et = new _component_icon_icon_svelte__WEBPACK_IMPORTED_MODULE_2__.Z({
                            props: {
                                name: "clear"
                            }
                        }),
                        {
                            c: function() {
                                $ = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("div"),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.YCL)(et.$$.fragment),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)($, "class", "vc-cmd-clear-btn")
                            },
                            m: function(it, ot) {
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$Tr)(it, $, ot),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.yef)(et, $, null),
                                tt = !0,
                                nt || (rt = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oLt)($, "click", (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.AT7)(_e[19])),
                                nt = !0)
                            },
                            p: svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ZTd,
                            i: function(it) {
                                tt || ((0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(et.$$.fragment, it),
                                tt = !0)
                            },
                            o: function(it) {
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.etI)(et.$$.fragment, it),
                                tt = !1
                            },
                            d: function(it) {
                                it && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ogt)($),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.vpE)(et),
                                nt = !1,
                                rt()
                            }
                        }
                    }
                    function create_fragment(_e) {
                        for (var $, et, tt, nt, rt, it, ot, st, lt, ct, dt, pt, ht, mt, yt, Et, _t, wt, St, Ct, Nt, Lt = _e[3].length > 0 && create_if_block_2(_e), kt = _e[3], Ut = [], Jt = 0; Jt < kt.length; Jt += 1)
                            Ut[Jt] = create_each_block(get_each_context(_e, kt, Jt));
                        var Pt = null;
                        kt.length || (Pt = create_else_block());
                        var Xt = _e[1].length > 0 && create_if_block_1(_e)
                          , rn = _e[4].length > 0 && create_if_block(_e);
                        return {
                            c: function() {
                                $ = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("form"),
                                et = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("ul"),
                                Lt && Lt.c(),
                                tt = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.DhX)();
                                for (var zt = 0; zt < Ut.length; zt += 1)
                                    Ut[zt].c();
                                Pt && Pt.c(),
                                nt = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.DhX)(),
                                rt = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("div"),
                                it = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("textarea"),
                                ot = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.DhX)(),
                                Xt && Xt.c(),
                                st = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.DhX)(),
                                (lt = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("button")).textContent = "OK",
                                ct = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.DhX)(),
                                dt = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("form"),
                                pt = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("ul"),
                                ht = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.DhX)(),
                                mt = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("div"),
                                yt = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("textarea"),
                                Et = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.DhX)(),
                                rn && rn.c(),
                                _t = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.DhX)(),
                                (wt = (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.bGB)("button")).textContent = "Filter",
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(et, "class", "vc-cmd-prompted"),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(et, "style", _e[2]),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(it, "class", "vc-cmd-input"),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(it, "placeholder", "command..."),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(rt, "class", "vc-cmd-input-wrap"),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(lt, "class", "vc-cmd-btn"),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(lt, "type", "submit"),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)($, "class", "vc-cmd"),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(pt, "class", "vc-cmd-prompted"),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(yt, "class", "vc-cmd-input"),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(yt, "placeholder", "filter..."),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(mt, "class", "vc-cmd-input-wrap"),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(wt, "class", "vc-cmd-btn"),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(wt, "type", "submit"),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(dt, "class", "vc-cmd vc-filter")
                            },
                            m: function(zt, xt) {
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$Tr)(zt, $, xt),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)($, et),
                                Lt && Lt.m(et, null),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)(et, tt);
                                for (var $t = 0; $t < Ut.length; $t += 1)
                                    Ut[$t].m(et, null);
                                Pt && Pt.m(et, null),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)($, nt),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)($, rt),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)(rt, it),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.BmG)(it, _e[1]),
                                _e[16](it),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)(rt, ot),
                                Xt && Xt.m(rt, null),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)($, st),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)($, lt),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$Tr)(zt, ct, xt),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.$Tr)(zt, dt, xt),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)(dt, pt),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)(dt, ht),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)(dt, mt),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)(mt, yt),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.BmG)(yt, _e[4]),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)(mt, Et),
                                rn && rn.m(mt, null),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)(dt, _t),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.R3I)(dt, wt),
                                St = !0,
                                Ct || (Nt = [(0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oLt)(it, "input", _e[15]), (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oLt)(it, "keydown", _e[10]), (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oLt)(it, "keyup", _e[11]), (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oLt)(it, "focus", _e[8]), (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oLt)(it, "blur", _e[9]), (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oLt)($, "submit", (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.AT7)(_e[12])), (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oLt)(yt, "input", _e[18]), (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.oLt)(dt, "submit", (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.AT7)(_e[13]))],
                                Ct = !0)
                            },
                            p: function(zt, xt) {
                                var $t = xt[0];
                                if (zt[3].length > 0 ? Lt ? Lt.p(zt, $t) : ((Lt = create_if_block_2(zt)).c(),
                                Lt.m(et, tt)) : Lt && (Lt.d(1),
                                Lt = null),
                                136 & $t) {
                                    var Dt;
                                    for (kt = zt[3],
                                    Dt = 0; Dt < kt.length; Dt += 1) {
                                        var jt = get_each_context(zt, kt, Dt);
                                        Ut[Dt] ? Ut[Dt].p(jt, $t) : (Ut[Dt] = create_each_block(jt),
                                        Ut[Dt].c(),
                                        Ut[Dt].m(et, null))
                                    }
                                    for (; Dt < Ut.length; Dt += 1)
                                        Ut[Dt].d(1);
                                    Ut.length = kt.length,
                                    !kt.length && Pt ? Pt.p(zt, $t) : kt.length ? Pt && (Pt.d(1),
                                    Pt = null) : ((Pt = create_else_block()).c(),
                                    Pt.m(et, null))
                                }
                                (!St || 4 & $t) && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ljt)(et, "style", zt[2]),
                                2 & $t && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.BmG)(it, zt[1]),
                                zt[1].length > 0 ? Xt ? (Xt.p(zt, $t),
                                2 & $t && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(Xt, 1)) : ((Xt = create_if_block_1(zt)).c(),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(Xt, 1),
                                Xt.m(rt, null)) : Xt && ((0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dvw)(),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.etI)(Xt, 1, 1, function() {
                                    Xt = null
                                }),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.gbL)()),
                                16 & $t && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.BmG)(yt, zt[4]),
                                zt[4].length > 0 ? rn ? (rn.p(zt, $t),
                                16 & $t && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(rn, 1)) : ((rn = create_if_block(zt)).c(),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(rn, 1),
                                rn.m(mt, null)) : rn && ((0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.dvw)(),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.etI)(rn, 1, 1, function() {
                                    rn = null
                                }),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.gbL)())
                            },
                            i: function(zt) {
                                St || ((0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(Xt),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.Ui)(rn),
                                St = !0)
                            },
                            o: function(zt) {
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.etI)(Xt),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.etI)(rn),
                                St = !1
                            },
                            d: function(zt) {
                                zt && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ogt)($),
                                Lt && Lt.d(),
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.RMB)(Ut, zt),
                                Pt && Pt.d(),
                                _e[16](null),
                                Xt && Xt.d(),
                                zt && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ogt)(ct),
                                zt && (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.ogt)(dt),
                                rn && rn.d(),
                                Ct = !1,
                                (0,
                                svelte_internal__WEBPACK_IMPORTED_MODULE_0__.j7q)(Nt)
                            }
                        }
                    }
                    function instance($$self, $$props, $$invalidate) {
                        var module = _log_model__WEBPACK_IMPORTED_MODULE_3__.W.getSingleton(_log_model__WEBPACK_IMPORTED_MODULE_3__.W, "VConsoleLogModel"), cachedObjKeys = {}, dispatch = (0,
                        svelte__WEBPACK_IMPORTED_MODULE_1__.x)(), cmdElement, cmdValue = "", promptedStyle = "", promptedList = [], filterValue = "";
                        (0,
                        svelte__WEBPACK_IMPORTED_MODULE_1__.H3)(function() {
                            _logCommand_less__WEBPACK_IMPORTED_MODULE_4__.Z.use()
                        }),
                        (0,
                        svelte__WEBPACK_IMPORTED_MODULE_1__.ev)(function() {
                            _logCommand_less__WEBPACK_IMPORTED_MODULE_4__.Z.unuse()
                        });
                        var evalCommand = function(_e) {
                            module.evalCommand(_e)
                        }
                          , moveCursorToPos = function(_e, $) {
                            _e.setSelectionRange && setTimeout(function() {
                                _e.setSelectionRange($, $)
                            }, 1)
                        }
                          , clearPromptedList = function() {
                            $$invalidate(2, promptedStyle = "display: none;"),
                            $$invalidate(3, promptedList = [])
                        }
                          , updatePromptedList = function updatePromptedList(identifier) {
                            if (cmdValue !== "") {
                                identifier || (identifier = (0,
                                _logTool__WEBPACK_IMPORTED_MODULE_5__.oj)(cmdValue));
                                var objName = "window"
                                  , keyName = cmdValue;
                                if (identifier.front.text !== "." && identifier.front.text !== "[" || (objName = identifier.front.before,
                                keyName = identifier.back.text !== "" ? identifier.back.before : identifier.front.after),
                                keyName = keyName.replace(/(^['"]+)|(['"']+$)/g, ""),
                                !cachedObjKeys[objName])
                                    try {
                                        cachedObjKeys[objName] = Object.getOwnPropertyNames(eval("(" + objName + ")")).sort()
                                    } catch (_e) {}
                                try {
                                    if (cachedObjKeys[objName])
                                        for (var i = 0; i < cachedObjKeys[objName].length && !(promptedList.length >= 100); i++) {
                                            var key = String(cachedObjKeys[objName][i])
                                              , keyPattern = new RegExp("^" + keyName,"i");
                                            if (keyPattern.test(key)) {
                                                var completeCmd = objName;
                                                identifier.front.text === "." || identifier.front.text === "" ? completeCmd += "." + key : identifier.front.text === "[" && (completeCmd += "['" + key + "']"),
                                                promptedList.push({
                                                    text: key,
                                                    value: completeCmd
                                                })
                                            }
                                        }
                                } catch (_e) {}
                                if (promptedList.length > 0) {
                                    var m = Math.min(200, 31 * (promptedList.length + 1));
                                    $$invalidate(2, promptedStyle = "display: block; height: " + m + "px; margin-top: " + (-m - 2) + "px;"),
                                    $$invalidate(3, promptedList)
                                } else
                                    clearPromptedList()
                            } else
                                clearPromptedList()
                        }
                          , autoCompleteBrackets = function(_e, $) {
                            if (!($ === 8 || $ === 46) && _e.front.after === "")
                                switch (_e.front.text) {
                                case "[":
                                    return $$invalidate(1, cmdValue += "]"),
                                    void moveCursorToPos(cmdElement, cmdValue.length - 1);
                                case "(":
                                    return $$invalidate(1, cmdValue += ")"),
                                    void moveCursorToPos(cmdElement, cmdValue.length - 1);
                                case "{":
                                    return $$invalidate(1, cmdValue += "}"),
                                    void moveCursorToPos(cmdElement, cmdValue.length - 1)
                                }
                        }
                          , dispatchFilterEvent = function() {
                            dispatch("filterText", {
                                filterText: filterValue
                            })
                        }
                          , onTapClearText = function(_e) {
                            _e === "cmd" ? ($$invalidate(1, cmdValue = ""),
                            clearPromptedList()) : _e === "filter" && ($$invalidate(4, filterValue = ""),
                            dispatchFilterEvent())
                        }
                          , onTapPromptedItem = function onTapPromptedItem(item) {
                            var type = "";
                            try {
                                type = eval("typeof " + item.value)
                            } catch (_e) {}
                            $$invalidate(1, cmdValue = item.value + (type === "function" ? "()" : "")),
                            clearPromptedList()
                        }
                          , onCmdFocus = function() {
                            updatePromptedList()
                        }
                          , onCmdBlur = function() {}
                          , onCmdKeyDown = function(_e) {
                            _e.keyCode === 13 && (_e.preventDefault(),
                            onCmdSubmit())
                        }
                          , onCmdKeyUp = function(_e) {
                            $$invalidate(3, promptedList = []);
                            var $ = (0,
                            _logTool__WEBPACK_IMPORTED_MODULE_5__.oj)(_e.target.value);
                            autoCompleteBrackets($, _e.keyCode),
                            updatePromptedList($)
                        }
                          , onCmdSubmit = function() {
                            cmdValue !== "" && evalCommand(cmdValue),
                            clearPromptedList()
                        }
                          , onFilterSubmit = function(_e) {
                            dispatchFilterEvent()
                        }
                          , click_handler = function(_e) {
                            return onTapPromptedItem(_e)
                        };
                        function textarea0_input_handler() {
                            cmdValue = this.value,
                            $$invalidate(1, cmdValue)
                        }
                        function textarea0_binding(_e) {
                            svelte_internal__WEBPACK_IMPORTED_MODULE_0__.VnY[_e ? "unshift" : "push"](function() {
                                $$invalidate(0, cmdElement = _e)
                            })
                        }
                        var click_handler_1 = function() {
                            return onTapClearText("cmd")
                        };
                        function textarea1_input_handler() {
                            filterValue = this.value,
                            $$invalidate(4, filterValue)
                        }
                        var click_handler_2 = function() {
                            return onTapClearText("filter")
                        };
                        return [cmdElement, cmdValue, promptedStyle, promptedList, filterValue, clearPromptedList, onTapClearText, onTapPromptedItem, onCmdFocus, onCmdBlur, onCmdKeyDown, onCmdKeyUp, onCmdSubmit, onFilterSubmit, click_handler, textarea0_input_handler, textarea0_binding, click_handler_1, textarea1_input_handler, click_handler_2]
                    }
                    var LogCommand = function(_e) {
                        function $(et) {
                            var tt;
                            return tt = _e.call(this) || this,
                            (0,
                            svelte_internal__WEBPACK_IMPORTED_MODULE_0__.S1n)((0,
                            _babel_runtime_helpers_assertThisInitialized__WEBPACK_IMPORTED_MODULE_7__.Z)(tt), et, instance, create_fragment, svelte_internal__WEBPACK_IMPORTED_MODULE_0__.N8, {}),
                            tt
                        }
                        return (0,
                        _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_6__.Z)($, _e),
                        $
                    }(svelte_internal__WEBPACK_IMPORTED_MODULE_0__.f_C);
                    __webpack_exports__.Z = LogCommand
                },
                4687: function(_e, $, et) {
                    et.d($, {
                        x: function() {
                            return nt
                        }
                    });
                    var tt = et(3313)
                      , nt = function() {
                        var rt = (0,
                        tt.fZ)({
                            updateTime: 0
                        })
                          , it = rt.subscribe
                          , ot = rt.set
                          , st = rt.update;
                        return {
                            subscribe: it,
                            set: ot,
                            update: st,
                            updateTime: function() {
                                st(function(lt) {
                                    return lt.updateTime = Date.now(),
                                    lt
                                })
                            }
                        }
                    }()
                },
                643: function(_e, $, et) {
                    et.d($, {
                        N: function() {
                            return tt
                        }
                    });
                    var tt = function() {
                        function nt() {
                            this._onDataUpdateCallbacks = []
                        }
                        return nt.getSingleton = function(rt, it) {
                            return it || (it = rt.toString()),
                            nt.singleton[it] || (nt.singleton[it] = new rt),
                            nt.singleton[it]
                        }
                        ,
                        nt
                    }();
                    tt.singleton = {}
                },
                5103: function(_e, $, et) {
                    function tt(Yt) {
                        var un = Yt > 0 ? new Date(Yt) : new Date
                          , hn = un.getDate() < 10 ? "0" + un.getDate() : un.getDate()
                          , _n = un.getMonth() < 9 ? "0" + (un.getMonth() + 1) : un.getMonth() + 1
                          , kn = un.getFullYear()
                          , Dn = un.getHours() < 10 ? "0" + un.getHours() : un.getHours()
                          , jn = un.getMinutes() < 10 ? "0" + un.getMinutes() : un.getMinutes()
                          , Bn = un.getSeconds() < 10 ? "0" + un.getSeconds() : un.getSeconds()
                          , Un = un.getMilliseconds() < 10 ? "0" + un.getMilliseconds() : un.getMilliseconds();
                        return Un < 100 && (Un = "0" + Un),
                        {
                            time: +un,
                            year: kn,
                            month: _n,
                            day: hn,
                            hour: Dn,
                            minute: jn,
                            second: Bn,
                            millisecond: Un
                        }
                    }
                    function nt(Yt) {
                        return Object.prototype.toString.call(Yt) === "[object Number]"
                    }
                    function rt(Yt) {
                        return typeof Yt == "bigint"
                    }
                    function it(Yt) {
                        return typeof Yt == "string"
                    }
                    function ot(Yt) {
                        return Object.prototype.toString.call(Yt) === "[object Array]"
                    }
                    function st(Yt) {
                        return typeof Yt == "boolean"
                    }
                    function lt(Yt) {
                        return Yt === void 0
                    }
                    function ct(Yt) {
                        return Yt === null
                    }
                    function dt(Yt) {
                        return typeof Yt == "symbol"
                    }
                    function pt(Yt) {
                        return !(Object.prototype.toString.call(Yt) !== "[object Object]" && (nt(Yt) || rt(Yt) || it(Yt) || st(Yt) || ot(Yt) || ct(Yt) || ht(Yt) || lt(Yt) || dt(Yt)))
                    }
                    function ht(Yt) {
                        return typeof Yt == "function"
                    }
                    function mt(Yt) {
                        return typeof HTMLElement == "object" ? Yt instanceof HTMLElement : Yt && typeof Yt == "object" && Yt !== null && Yt.nodeType === 1 && typeof Yt.nodeName == "string"
                    }
                    function yt(Yt) {
                        var un = Object.prototype.toString.call(Yt);
                        return un === "[object Window]" || un === "[object DOMWindow]" || un === "[object global]"
                    }
                    function Et(Yt) {
                        return Yt != null && typeof Yt != "string" && typeof Yt != "boolean" && typeof Yt != "number" && typeof Yt != "function" && typeof Yt != "symbol" && typeof Yt != "bigint" && typeof Symbol < "u" && typeof Yt[Symbol.iterator] == "function"
                    }
                    function _t(Yt) {
                        return Object.prototype.toString.call(Yt).replace(/\[object (.*)\]/, "$1")
                    }
                    et.d($, {
                        C4: function() {
                            return rt
                        },
                        DV: function() {
                            return St
                        },
                        FJ: function() {
                            return yt
                        },
                        Ft: function() {
                            return ct
                        },
                        HD: function() {
                            return it
                        },
                        H_: function() {
                            return Wt
                        },
                        KL: function() {
                            return Xt
                        },
                        Kn: function() {
                            return pt
                        },
                        MH: function() {
                            return $t
                        },
                        PO: function() {
                            return Ct
                        },
                        QI: function() {
                            return qt
                        },
                        QK: function() {
                            return Dt
                        },
                        TW: function() {
                            return Et
                        },
                        _3: function() {
                            return tt
                        },
                        _D: function() {
                            return jt
                        },
                        cF: function() {
                            return Ht
                        },
                        hZ: function() {
                            return Pt
                        },
                        hj: function() {
                            return nt
                        },
                        id: function() {
                            return rn
                        },
                        jn: function() {
                            return st
                        },
                        kJ: function() {
                            return ot
                        },
                        kK: function() {
                            return mt
                        },
                        mf: function() {
                            return ht
                        },
                        o8: function() {
                            return lt
                        },
                        po: function() {
                            return Ft
                        },
                        qr: function() {
                            return xt
                        },
                        qt: function() {
                            return Mt
                        },
                        rE: function() {
                            return kt
                        },
                        yk: function() {
                            return dt
                        },
                        zl: function() {
                            return _t
                        }
                    });
                    var wt = /(function|class) ([^ \{\()}]{1,})[\(| ]/;
                    function St(Yt) {
                        var un;
                        if (Yt == null)
                            return "";
                        var hn = wt.exec((Yt == null || (un = Yt.constructor) == null ? void 0 : un.toString()) || "");
                        return hn && hn.length > 1 ? hn[2] : ""
                    }
                    function Ct(Yt) {
                        var un, hn = Object.prototype.hasOwnProperty;
                        if (!Yt || typeof Yt != "object" || Yt.nodeType || yt(Yt))
                            return !1;
                        try {
                            if (Yt.constructor && !hn.call(Yt, "constructor") && !hn.call(Yt.constructor.prototype, "isPrototypeOf"))
                                return !1
                        } catch {
                            return !1
                        }
                        for (un in Yt)
                            ;
                        return un === void 0 || hn.call(Yt, un)
                    }
                    var Nt = /[\n\t]/g
                      , Lt = function(Yt) {
                        return {
                            "\n": "\\n",
                            "	": "\\t"
                        }[Yt]
                    };
                    function kt(Yt) {
                        return typeof Yt != "string" ? Yt : String(Yt).replace(Nt, Lt)
                    }
                    var Ut = function(Yt, un) {
                        un === void 0 && (un = 0);
                        var hn = "";
                        return it(Yt) ? (un > 0 && (Yt = rn(Yt, un)),
                        hn += '"' + kt(Yt) + '"') : dt(Yt) ? hn += String(Yt).replace(/^Symbol\((.*)\)$/i, 'Symbol("$1")') : ht(Yt) ? hn += (Yt.name || "function") + "()" : rt(Yt) ? hn += String(Yt) + "n" : hn += String(Yt),
                        hn
                    }
                      , Jt = function Yt(un, hn, _n) {
                        if (_n === void 0 && (_n = 0),
                        pt(un) || ot(un))
                            if (hn.circularFinder(un)) {
                                var kn = "";
                                if (ot(un))
                                    kn = "(Circular Array)";
                                else if (pt(un)) {
                                    var Dn;
                                    kn = "(Circular " + (((Dn = un.constructor) == null ? void 0 : Dn.name) || "Object") + ")"
                                }
                                hn.ret += hn.standardJSON ? '"' + kn + '"' : kn
                            } else {
                                var jn = ""
                                  , Bn = "";
                                if (hn.pretty) {
                                    for (var Un = 0; Un <= _n; Un++)
                                        jn += "  ";
                                    Bn = `
`
                                }
                                var Hn = "{"
                                  , cr = "}";
                                ot(un) && (Hn = "[",
                                cr = "]"),
                                hn.ret += Hn + Bn;
                                for (var Gn = $t(un), Mn = 0; Mn < Gn.length; Mn++) {
                                    var rr = Gn[Mn];
                                    hn.ret += jn;
                                    try {
                                        ot(un) || (pt(rr) || ot(rr) || dt(rr) ? hn.ret += Object.prototype.toString.call(rr) : it(rr) && hn.standardJSON ? hn.ret += '"' + rr + '"' : hn.ret += rr,
                                        hn.ret += ": ")
                                    } catch {
                                        continue
                                    }
                                    try {
                                        var Zn = un[rr];
                                        if (ot(Zn))
                                            hn.maxDepth > -1 && _n >= hn.maxDepth ? hn.ret += "Array(" + Zn.length + ")" : Yt(Zn, hn, _n + 1);
                                        else if (pt(Zn)) {
                                            var pr;
                                            hn.maxDepth > -1 && _n >= hn.maxDepth ? hn.ret += (((pr = Zn.constructor) == null ? void 0 : pr.name) || "Object") + " {}" : Yt(Zn, hn, _n + 1)
                                        } else
                                            hn.ret += Ut(Zn, hn.keyMaxLen)
                                    } catch {
                                        hn.ret += hn.standardJSON ? '"(PARSE_ERROR)"' : "(PARSE_ERROR)"
                                    }
                                    if (hn.keyMaxLen > 0 && hn.ret.length >= 10 * hn.keyMaxLen) {
                                        hn.ret += ", (...)";
                                        break
                                    }
                                    Mn < Gn.length - 1 && (hn.ret += ", "),
                                    hn.ret += Bn
                                }
                                hn.ret += jn.substring(0, jn.length - 2) + cr
                            }
                        else
                            hn.ret += Ut(un, hn.keyMaxLen)
                    };
                    function Pt(Yt, un) {
                        un === void 0 && (un = {
                            maxDepth: -1,
                            keyMaxLen: -1,
                            pretty: !1,
                            standardJSON: !1
                        });
                        var hn, _n = Object.assign({
                            ret: "",
                            maxDepth: -1,
                            keyMaxLen: -1,
                            pretty: !1,
                            standardJSON: !1,
                            circularFinder: (hn = new WeakSet,
                            function(kn) {
                                if (typeof kn == "object" && kn !== null) {
                                    if (hn.has(kn))
                                        return !0;
                                    hn.add(kn)
                                }
                                return !1
                            }
                            )
                        }, un);
                        return Jt(Yt, _n),
                        _n.ret
                    }
                    function Xt(Yt) {
                        return Yt <= 0 ? "" : Yt >= 1e6 ? (Yt / 1e3 / 1e3).toFixed(1) + " MB" : Yt >= 1e3 ? (Yt / 1e3).toFixed(1) + " KB" : Yt + " B"
                    }
                    function rn(Yt, un) {
                        return Yt.length > un && (Yt = Yt.substring(0, un) + "...(" + Xt(function(hn) {
                            try {
                                return encodeURI(hn).split(/%(?:u[0-9A-F]{2})?[0-9A-F]{2}|./).length - 1
                            } catch {
                                return 0
                            }
                        }(Yt)) + ")"),
                        Yt
                    }
                    var zt = function(Yt, un) {
                        return String(Yt).localeCompare(String(un), void 0, {
                            numeric: !0,
                            sensitivity: "base"
                        })
                    };
                    function xt(Yt) {
                        return Yt.sort(zt)
                    }
                    function $t(Yt) {
                        return pt(Yt) || ot(Yt) ? Object.keys(Yt) : []
                    }
                    function Dt(Yt) {
                        var un = $t(Yt)
                          , hn = function(_n) {
                            return pt(_n) || ot(_n) ? Object.getOwnPropertyNames(_n) : []
                        }(Yt);
                        return hn.filter(function(_n) {
                            return un.indexOf(_n) === -1
                        })
                    }
                    function jt(Yt) {
                        return pt(Yt) || ot(Yt) ? Object.getOwnPropertySymbols(Yt) : []
                    }
                    function Ft(Yt, un) {
                        window.localStorage && (Yt = "vConsole_" + Yt,
                        localStorage.setItem(Yt, un))
                    }
                    function Ht(Yt) {
                        if (window.localStorage)
                            return Yt = "vConsole_" + Yt,
                            localStorage.getItem(Yt)
                    }
                    function qt(Yt) {
                        return Yt === void 0 && (Yt = ""),
                        "__vc_" + Yt + Math.random().toString(36).substring(2, 8)
                    }
                    function Wt() {
                        return typeof window < "u" && !!window.__wxConfig && !!window.wx && !!window.__virtualDOM__
                    }
                    function Mt(Yt) {
                        if (Wt() && typeof window.wx[Yt] == "function")
                            try {
                                for (var un, hn = arguments.length, _n = new Array(hn > 1 ? hn - 1 : 0), kn = 1; kn < hn; kn++)
                                    _n[kn - 1] = arguments[kn];
                                var Dn = (un = window.wx[Yt]).call.apply(un, [window.wx].concat(_n));
                                return Dn
                            } catch {
                                return
                            }
                    }
                },
                5629: function(_e, $, et) {
                    et.d($, {
                        W: function() {
                            return mt
                        }
                    });
                    var tt = et(8270)
                      , nt = et(6881)
                      , rt = et(5103)
                      , it = et(643)
                      , ot = et(4687)
                      , st = et(8665)
                      , lt = et(9923);
                    function ct(yt, Et) {
                        var _t = Object.keys(yt);
                        if (Object.getOwnPropertySymbols) {
                            var wt = Object.getOwnPropertySymbols(yt);
                            Et && (wt = wt.filter(function(St) {
                                return Object.getOwnPropertyDescriptor(yt, St).enumerable
                            })),
                            _t.push.apply(_t, wt)
                        }
                        return _t
                    }
                    function dt(yt) {
                        for (var Et = 1; Et < arguments.length; Et++) {
                            var _t = arguments[Et] != null ? arguments[Et] : {};
                            Et % 2 ? ct(Object(_t), !0).forEach(function(wt) {
                                (0,
                                tt.Z)(yt, wt, _t[wt])
                            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(yt, Object.getOwnPropertyDescriptors(_t)) : ct(Object(_t)).forEach(function(wt) {
                                Object.defineProperty(yt, wt, Object.getOwnPropertyDescriptor(_t, wt))
                            })
                        }
                        return yt
                    }
                    function pt(yt, Et) {
                        var _t = typeof Symbol < "u" && yt[Symbol.iterator] || yt["@@iterator"];
                        if (_t)
                            return (_t = _t.call(yt)).next.bind(_t);
                        if (Array.isArray(yt) || (_t = function(St, Ct) {
                            if (St) {
                                if (typeof St == "string")
                                    return ht(St, Ct);
                                var Nt = Object.prototype.toString.call(St).slice(8, -1);
                                if (Nt === "Object" && St.constructor && (Nt = St.constructor.name),
                                Nt === "Map" || Nt === "Set")
                                    return Array.from(St);
                                if (Nt === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Nt))
                                    return ht(St, Ct)
                            }
                        }(yt)) || Et) {
                            _t && (yt = _t);
                            var wt = 0;
                            return function() {
                                return wt >= yt.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: yt[wt++]
                                }
                            }
                        }
                        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                    }
                    function ht(yt, Et) {
                        (Et == null || Et > yt.length) && (Et = yt.length);
                        for (var _t = 0, wt = new Array(Et); _t < Et; _t++)
                            wt[_t] = yt[_t];
                        return wt
                    }
                    var mt = function(yt) {
                        function Et() {
                            for (var wt, St = arguments.length, Ct = new Array(St), Nt = 0; Nt < St; Nt++)
                                Ct[Nt] = arguments[Nt];
                            return (wt = yt.call.apply(yt, [this].concat(Ct)) || this).LOG_METHODS = ["log", "info", "warn", "debug", "error"],
                            wt.ADDED_LOG_PLUGIN_ID = [],
                            wt.maxLogNumber = 1e3,
                            wt.logCounter = 0,
                            wt.groupLevel = 0,
                            wt.groupLabelCollapsedStack = [],
                            wt.pluginPattern = void 0,
                            wt.logQueue = [],
                            wt.flushLogScheduled = !1,
                            wt.origConsole = {},
                            wt
                        }
                        (0,
                        nt.Z)(Et, yt);
                        var _t = Et.prototype;
                        return _t.bindPlugin = function(wt) {
                            return !(this.ADDED_LOG_PLUGIN_ID.indexOf(wt) > -1) && (this.ADDED_LOG_PLUGIN_ID.length === 0 && this.mockConsole(),
                            lt.O.create(wt),
                            this.ADDED_LOG_PLUGIN_ID.push(wt),
                            this.pluginPattern = new RegExp("^\\[(" + this.ADDED_LOG_PLUGIN_ID.join("|") + ")\\]$","i"),
                            !0)
                        }
                        ,
                        _t.unbindPlugin = function(wt) {
                            var St = this.ADDED_LOG_PLUGIN_ID.indexOf(wt);
                            return St !== -1 && (this.ADDED_LOG_PLUGIN_ID.splice(St, 1),
                            lt.O.delete(wt),
                            this.ADDED_LOG_PLUGIN_ID.length === 0 && this.unmockConsole(),
                            !0)
                        }
                        ,
                        _t.mockConsole = function() {
                            var wt = this;
                            typeof this.origConsole.log != "function" && (window.console ? (this.LOG_METHODS.map(function(St) {
                                wt.origConsole[St] = window.console[St]
                            }),
                            this.origConsole.time = window.console.time,
                            this.origConsole.timeEnd = window.console.timeEnd,
                            this.origConsole.clear = window.console.clear,
                            this.origConsole.group = window.console.group,
                            this.origConsole.groupCollapsed = window.console.groupCollapsed,
                            this.origConsole.groupEnd = window.console.groupEnd) : window.console = {},
                            this._mockConsoleLog(),
                            this._mockConsoleTime(),
                            this._mockConsoleGroup(),
                            this._mockConsoleClear(),
                            window._vcOrigConsole = this.origConsole)
                        }
                        ,
                        _t._mockConsoleLog = function() {
                            var wt = this;
                            this.LOG_METHODS.map(function(St) {
                                window.console[St] = (function() {
                                    for (var Ct = arguments.length, Nt = new Array(Ct), Lt = 0; Lt < Ct; Lt++)
                                        Nt[Lt] = arguments[Lt];
                                    wt.addLog({
                                        type: St,
                                        origData: Nt || []
                                    })
                                }
                                ).bind(window.console)
                            })
                        }
                        ,
                        _t._mockConsoleTime = function() {
                            var wt = this
                              , St = {};
                            window.console.time = (function(Ct) {
                                Ct === void 0 && (Ct = ""),
                                St[Ct] = Date.now()
                            }
                            ).bind(window.console),
                            window.console.timeEnd = (function(Ct) {
                                Ct === void 0 && (Ct = "");
                                var Nt = St[Ct]
                                  , Lt = 0;
                                Nt && (Lt = Date.now() - Nt,
                                delete St[Ct]),
                                wt.addLog({
                                    type: "log",
                                    origData: [Ct + ": " + Lt + "ms"]
                                })
                            }
                            ).bind(window.console)
                        }
                        ,
                        _t._mockConsoleGroup = function() {
                            var wt = this
                              , St = function(Ct) {
                                return (function(Nt) {
                                    Nt === void 0 && (Nt = "console.group");
                                    var Lt = Symbol(Nt);
                                    wt.groupLabelCollapsedStack.push({
                                        label: Lt,
                                        collapsed: Ct
                                    }),
                                    wt.addLog({
                                        type: "log",
                                        origData: [Nt],
                                        isGroupHeader: Ct ? 2 : 1,
                                        isGroupCollapsed: !1
                                    }, {
                                        noOrig: !0
                                    }),
                                    wt.groupLevel++,
                                    Ct ? wt.origConsole.groupCollapsed(Nt) : wt.origConsole.group(Nt)
                                }
                                ).bind(window.console)
                            };
                            window.console.group = St(!1),
                            window.console.groupCollapsed = St(!0),
                            window.console.groupEnd = (function() {
                                wt.groupLabelCollapsedStack.pop(),
                                wt.groupLevel = Math.max(0, wt.groupLevel - 1),
                                wt.origConsole.groupEnd()
                            }
                            ).bind(window.console)
                        }
                        ,
                        _t._mockConsoleClear = function() {
                            var wt = this;
                            window.console.clear = (function() {
                                wt.resetGroup(),
                                wt.clearLog();
                                for (var St = arguments.length, Ct = new Array(St), Nt = 0; Nt < St; Nt++)
                                    Ct[Nt] = arguments[Nt];
                                wt.callOriginalConsole.apply(wt, ["clear"].concat(Ct))
                            }
                            ).bind(window.console)
                        }
                        ,
                        _t.unmockConsole = function() {
                            for (var wt in this.origConsole)
                                window.console[wt] = this.origConsole[wt],
                                delete this.origConsole[wt];
                            window._vcOrigConsole && delete window._vcOrigConsole
                        }
                        ,
                        _t.callOriginalConsole = function(wt) {
                            if (typeof this.origConsole[wt] == "function") {
                                for (var St = arguments.length, Ct = new Array(St > 1 ? St - 1 : 0), Nt = 1; Nt < St; Nt++)
                                    Ct[Nt - 1] = arguments[Nt];
                                this.origConsole[wt].apply(window.console, Ct)
                            }
                        }
                        ,
                        _t.resetGroup = function() {
                            for (; this.groupLevel > 0; )
                                ;
                        }
                        ,
                        _t.clearLog = function() {
                            var wt = lt.O.getAll();
                            for (var St in wt)
                                this.clearPluginLog(St)
                        }
                        ,
                        _t.clearPluginLog = function(wt) {
                            var St = this.logQueue;
                            this.logQueue = [];
                            for (var Ct, Nt = pt(St); !(Ct = Nt()).done; ) {
                                var Lt = Ct.value;
                                this._extractPluginIdByLog(Lt) !== wt && this.logQueue.push(Lt)
                            }
                            lt.O.get(wt).update(function(kt) {
                                return kt.logList.length = 0,
                                kt
                            }),
                            ot.x.updateTime()
                        }
                        ,
                        _t.addLog = function(wt, St) {
                            wt === void 0 && (wt = {
                                type: "log",
                                origData: [],
                                isGroupHeader: 0,
                                isGroupCollapsed: !1
                            });
                            var Ct = this.groupLabelCollapsedStack[this.groupLabelCollapsedStack.length - 2]
                              , Nt = this.groupLabelCollapsedStack[this.groupLabelCollapsedStack.length - 1]
                              , Lt = {
                                _id: rt.QI(),
                                type: wt.type,
                                cmdType: St == null ? void 0 : St.cmdType,
                                toggle: {},
                                date: Date.now(),
                                data: (0,
                                st.b1)(wt.origData || []),
                                repeated: 0,
                                groupLabel: Nt == null ? void 0 : Nt.label,
                                groupLevel: this.groupLevel,
                                groupHeader: wt.isGroupHeader,
                                groupCollapsed: wt.isGroupHeader ? !(Ct == null || !Ct.collapsed) : !(Nt == null || !Nt.collapsed)
                            };
                            this._signalLog(Lt),
                            St != null && St.noOrig || this.callOriginalConsole.apply(this, [wt.type].concat(wt.origData))
                        }
                        ,
                        _t.evalCommand = function(wt) {
                            this.addLog({
                                type: "log",
                                origData: [wt]
                            }, {
                                cmdType: "input"
                            });
                            var St = void 0;
                            try {
                                St = eval.call(window, "(" + wt + ")")
                            } catch {
                                try {
                                    St = eval.call(window, wt)
                                } catch {}
                            }
                            this.addLog({
                                type: "log",
                                origData: [St]
                            }, {
                                cmdType: "output"
                            })
                        }
                        ,
                        _t._signalLog = function(wt) {
                            var St = this;
                            this.flushLogScheduled || (this.flushLogScheduled = !0,
                            window.requestAnimationFrame(function() {
                                St.flushLogScheduled = !1,
                                St._flushLogs()
                            })),
                            this.logQueue.push(wt)
                        }
                        ,
                        _t._flushLogs = function() {
                            var wt = this
                              , St = this.logQueue;
                            this.logQueue = [];
                            for (var Ct, Nt = {}, Lt = pt(St); !(Ct = Lt()).done; ) {
                                var kt = Ct.value
                                  , Ut = this._extractPluginIdByLog(kt);
                                (Nt[Ut] = Nt[Ut] || []).push(kt)
                            }
                            for (var Jt = function(rn) {
                                var zt = Nt[rn];
                                lt.O.get(rn).update(function(xt) {
                                    for (var $t, Dt = [].concat(xt.logList), jt = pt(zt); !($t = jt()).done; ) {
                                        var Ft = $t.value;
                                        wt._isRepeatedLog(Dt, Ft) ? wt._updateLastLogRepeated(Dt) : Dt.push(Ft)
                                    }
                                    return {
                                        logList: Dt = wt._limitLogListLength(Dt)
                                    }
                                })
                            }, Pt = 0, Xt = Object.keys(Nt); Pt < Xt.length; Pt++)
                                Jt(Xt[Pt]);
                            ot.x.updateTime()
                        }
                        ,
                        _t._extractPluginIdByLog = function(wt) {
                            var St, Ct = "default", Nt = (St = wt.data[0]) == null ? void 0 : St.origData;
                            if (rt.HD(Nt)) {
                                var Lt = Nt.match(this.pluginPattern);
                                if (Lt !== null && Lt.length > 1) {
                                    var kt = Lt[1].toLowerCase();
                                    this.ADDED_LOG_PLUGIN_ID.indexOf(kt) > -1 && (Ct = kt,
                                    wt.data.shift())
                                }
                            }
                            return Ct
                        }
                        ,
                        _t._isRepeatedLog = function(wt, St) {
                            var Ct = wt[wt.length - 1];
                            if (!Ct)
                                return !1;
                            var Nt = !1;
                            if (St.type === Ct.type && St.cmdType === Ct.cmdType && St.data.length === Ct.data.length) {
                                Nt = !0;
                                for (var Lt = 0; Lt < St.data.length; Lt++)
                                    if (St.data[Lt].origData !== Ct.data[Lt].origData) {
                                        Nt = !1;
                                        break
                                    }
                            }
                            return Nt
                        }
                        ,
                        _t._updateLastLogRepeated = function(wt) {
                            var St = wt[wt.length - 1]
                              , Ct = St.repeated ? St.repeated + 1 : 2;
                            return wt[wt.length - 1] = dt(dt({}, St), {}, {
                                repeated: Ct
                            }),
                            wt
                        }
                        ,
                        _t._limitLogListLength = function(wt) {
                            var St = wt.length
                              , Ct = this.maxLogNumber;
                            return St > Ct ? wt.slice(St - Ct, St) : wt
                        }
                        ,
                        Et
                    }(it.N)
                },
                9923: function(_e, $, et) {
                    et.d($, {
                        O: function() {
                            return nt
                        }
                    });
                    var tt = et(3313)
                      , nt = function() {
                        function rt() {}
                        return rt.create = function(it) {
                            return this.storeMap[it] || (this.storeMap[it] = (0,
                            tt.fZ)({
                                logList: []
                            })),
                            this.storeMap[it]
                        }
                        ,
                        rt.delete = function(it) {
                            this.storeMap[it] && delete this.storeMap[it]
                        }
                        ,
                        rt.get = function(it) {
                            return this.storeMap[it]
                        }
                        ,
                        rt.getRaw = function(it) {
                            return (0,
                            tt.U2)(this.storeMap[it])
                        }
                        ,
                        rt.getAll = function() {
                            return this.storeMap
                        }
                        ,
                        rt
                    }();
                    nt.storeMap = {}
                },
                8665: function(_e, $, et) {
                    et.d($, {
                        HX: function() {
                            return ct
                        },
                        LH: function() {
                            return rt
                        },
                        Tg: function() {
                            return ht
                        },
                        b1: function() {
                            return pt
                        },
                        oj: function() {
                            return lt
                        }
                    });
                    var tt = et(5103)
                      , nt = function(mt) {
                        var yt = tt.hZ(mt, {
                            maxDepth: 0
                        })
                          , Et = yt.substring(0, 36)
                          , _t = tt.DV(mt);
                        return yt.length > 36 && (Et += "..."),
                        _t = tt.rE(_t + " " + Et)
                    }
                      , rt = function(mt, yt) {
                        yt === void 0 && (yt = !0);
                        var Et = "undefined"
                          , _t = mt;
                        return mt instanceof ht ? (Et = "uninvocatable",
                        _t = "(...)") : tt.kJ(mt) ? (Et = "array",
                        _t = nt(mt)) : tt.Kn(mt) ? (Et = "object",
                        _t = nt(mt)) : tt.HD(mt) ? (Et = "string",
                        _t = tt.rE(mt),
                        yt && (_t = '"' + _t + '"')) : tt.hj(mt) ? (Et = "number",
                        _t = String(mt)) : tt.C4(mt) ? (Et = "bigint",
                        _t = String(mt) + "n") : tt.jn(mt) ? (Et = "boolean",
                        _t = String(mt)) : tt.Ft(mt) ? (Et = "null",
                        _t = "null") : tt.o8(mt) ? (Et = "undefined",
                        _t = "undefined") : tt.mf(mt) ? (Et = "function",
                        _t = (mt.name || "function") + "()") : tt.yk(mt) && (Et = "symbol",
                        _t = String(mt)),
                        {
                            text: _t,
                            valueType: Et
                        }
                    }
                      , it = [".", "[", "(", "{", "}"]
                      , ot = ["]", ")", "}"]
                      , st = function(mt, yt, Et) {
                        Et === void 0 && (Et = 0);
                        for (var _t = {
                            text: "",
                            pos: -1,
                            before: "",
                            after: ""
                        }, wt = mt.length - 1; wt >= Et; wt--) {
                            var St = yt.indexOf(mt[wt]);
                            if (St > -1) {
                                _t.text = yt[St],
                                _t.pos = wt,
                                _t.before = mt.substring(Et, wt),
                                _t.after = mt.substring(wt + 1, mt.length);
                                break
                            }
                        }
                        return _t
                    }
                      , lt = function(mt) {
                        var yt = st(mt, it, 0);
                        return {
                            front: yt,
                            back: st(mt, ot, yt.pos + 1)
                        }
                    }
                      , ct = function(mt, yt) {
                        if (yt === "")
                            return !0;
                        for (var Et = 0; Et < mt.data.length; Et++)
                            if (typeof mt.data[Et].origData == "string" && mt.data[Et].origData.indexOf(yt) > -1)
                                return !0;
                        return !1
                    }
                      , dt = /(\%[csdo] )|( \%[csdo])/g
                      , pt = function(mt) {
                        if (dt.lastIndex = 0,
                        tt.HD(mt[0]) && dt.test(mt[0])) {
                            for (var yt, Et = [].concat(mt), _t = Et.shift().split(dt).filter(function(Xt) {
                                return Xt !== void 0 && Xt !== ""
                            }), wt = Et, St = [], Ct = !1, Nt = ""; _t.length > 0; ) {
                                var Lt = _t.shift();
                                if (/ ?\%c ?/.test(Lt) ? wt.length > 0 ? typeof (Nt = wt.shift()) != "string" && (Nt = "") : (yt = Lt,
                                Nt = "",
                                Ct = !0) : / ?\%[sd] ?/.test(Lt) ? (yt = wt.length > 0 ? tt.Kn(wt[0]) ? tt.DV(wt.shift()) : String(wt.shift()) : Lt,
                                Ct = !0) : / ?\%o ?/.test(Lt) ? (yt = wt.length > 0 ? wt.shift() : Lt,
                                Ct = !0) : (yt = Lt,
                                Ct = !0),
                                Ct) {
                                    var kt = {
                                        origData: yt
                                    };
                                    Nt && (kt.style = Nt),
                                    St.push(kt),
                                    Ct = !1,
                                    yt = void 0,
                                    Nt = ""
                                }
                            }
                            for (var Ut = 0; Ut < wt.length; Ut++)
                                St.push({
                                    origData: wt[Ut]
                                });
                            return St
                        }
                        for (var Jt = [], Pt = 0; Pt < mt.length; Pt++)
                            Jt.push({
                                origData: mt[Pt]
                            });
                        return Jt
                    }
                      , ht = function() {}
                },
                5313: function(_e, $, et) {
                    var tt = et(6738)
                      , nt = et.n(tt)
                      , rt = et(7705)
                      , it = et.n(rt)()(nt());
                    it.push([_e.id, `.vc-icon {
  word-break: normal;
  white-space: normal;
  overflow: visible;
}
.vc-icon svg {
  fill: var(--VC-FG-2);
  height: 1em;
  width: 1em;
  vertical-align: -0.11em;
}
.vc-icon .vc-icon-delete {
  vertical-align: -0.11em;
}
.vc-icon .vc-icon-copy {
  height: 1.1em;
  width: 1.1em;
  vertical-align: -0.16em;
}
.vc-icon .vc-icon-suc {
  fill: var(--VC-TEXTGREEN);
  height: 1.1em;
  width: 1.1em;
  vertical-align: -0.16em;
}
`, ""]),
                    $.Z = it
                },
                1142: function(_e, $, et) {
                    var tt = et(6738)
                      , nt = et.n(tt)
                      , rt = et(7705)
                      , it = et.n(rt)()(nt());
                    it.push([_e.id, `.vc-scroller-viewport {
  position: relative;
  overflow: hidden;
  height: 100%;
}
.vc-scroller-contents {
  min-height: 100%;
  will-change: transform;
}
.vc-scroller-items {
  will-change: height;
  position: relative;
}
.vc-scroller-item {
  display: none;
  position: absolute;
  left: 0;
  right: 0;
}
.vc-scroller-viewport.static .vc-scroller-item {
  display: block;
  position: static;
}
.vc-scroller-scrollbar-track {
  width: 4px;
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  padding: 1px;
}
.vc-scroller-scrollbar-thumb {
  position: relative;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  border-radius: 999px;
}
`, ""]),
                    $.Z = it
                },
                3283: function(_e, $, et) {
                    var tt = et(6738)
                      , nt = et.n(tt)
                      , rt = et(7705)
                      , it = et.n(rt)()(nt());
                    it.push([_e.id, `#__vconsole {
  --VC-BG-0: #ededed;
  --VC-BG-1: #f7f7f7;
  --VC-BG-2: #fff;
  --VC-BG-3: #f7f7f7;
  --VC-BG-4: #4c4c4c;
  --VC-BG-5: #fff;
  --VC-BG-6: rgba(0, 0, 0, 0.1);
  --VC-FG-0: rgba(0, 0, 0, 0.9);
  --VC-FG-HALF: rgba(0, 0, 0, 0.9);
  --VC-FG-1: rgba(0, 0, 0, 0.5);
  --VC-FG-2: rgba(0, 0, 0, 0.3);
  --VC-FG-3: rgba(0, 0, 0, 0.1);
  --VC-RED: #fa5151;
  --VC-ORANGE: #fa9d3b;
  --VC-YELLOW: #ffc300;
  --VC-GREEN: #91d300;
  --VC-LIGHTGREEN: #95ec69;
  --VC-BRAND: #07c160;
  --VC-BLUE: #10aeff;
  --VC-INDIGO: #1485ee;
  --VC-PURPLE: #6467f0;
  --VC-LINK: #576b95;
  --VC-TEXTGREEN: #06ae56;
  --VC-FG: black;
  --VC-BG: white;
  --VC-BG-COLOR-ACTIVE: #ececec;
  --VC-WARN-BG: #fff3cc;
  --VC-WARN-BORDER: #ffe799;
  --VC-ERROR-BG: #fedcdc;
  --VC-ERROR-BORDER: #fdb9b9;
  --VC-DOM-TAG-NAME-COLOR: #881280;
  --VC-DOM-ATTRIBUTE-NAME-COLOR: #994500;
  --VC-DOM-ATTRIBUTE-VALUE-COLOR: #1a1aa6;
  --VC-CODE-KEY-FG: #881391;
  --VC-CODE-PRIVATE-KEY-FG: #cfa1d3;
  --VC-CODE-FUNC-FG: #0d22aa;
  --VC-CODE-NUMBER-FG: #1c00cf;
  --VC-CODE-STR-FG: #c41a16;
  --VC-CODE-NULL-FG: #808080;
  color: var(--VC-FG-0);
  font-size: 13px;
  font-family: Helvetica Neue, Helvetica, Arial, sans-serif;
  -webkit-user-select: auto;
  /* global */
}
#__vconsole .vc-max-height {
  max-height: 19.23076923em;
}
#__vconsole .vc-max-height-line {
  max-height: 6.30769231em;
}
#__vconsole .vc-min-height {
  min-height: 3.07692308em;
}
#__vconsole dd,
#__vconsole dl,
#__vconsole pre {
  margin: 0;
}
#__vconsole pre {
  white-space: pre-wrap;
}
#__vconsole i {
  font-style: normal;
}
.vc-table {
  height: 100%;
}
.vc-table .vc-table-row {
  line-height: 1.5;
  display: -webkit-box;
  display: -webkit-flex;
  display: -moz-box;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-orient: horizontal;
  -webkit-box-direction: normal;
  -webkit-flex-direction: row;
  -moz-box-orient: horizontal;
  -moz-box-direction: normal;
  -ms-flex-direction: row;
  flex-direction: row;
  -webkit-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  flex-wrap: wrap;
  overflow: hidden;
  border-bottom: 1px solid var(--VC-FG-3);
}
.vc-table .vc-table-row.vc-left-border {
  border-left: 1px solid var(--VC-FG-3);
}
.vc-table .vc-table-row-icon {
  margin-left: 4px;
}
.vc-table .vc-table-col {
  -webkit-box-flex: 1;
  -webkit-flex: 1;
  -moz-box-flex: 1;
  -ms-flex: 1;
  flex: 1;
  padding: 0.23076923em 0.30769231em;
  border-left: 1px solid var(--VC-FG-3);
  overflow: auto;
}
.vc-table .vc-table-col:first-child {
  border: none;
}
.vc-table .vc-table-col-value {
  white-space: pre-wrap;
  word-break: break-word;
  /*white-space: nowrap;
    text-overflow: ellipsis;*/
  -webkit-overflow-scrolling: touch;
}
.vc-table .vc-small .vc-table-col {
  padding: 0 0.30769231em;
  font-size: 0.92307692em;
}
.vc-table .vc-table-col-2 {
  -webkit-box-flex: 2;
  -webkit-flex: 2;
  -moz-box-flex: 2;
  -ms-flex: 2;
  flex: 2;
}
.vc-table .vc-table-col-3 {
  -webkit-box-flex: 3;
  -webkit-flex: 3;
  -moz-box-flex: 3;
  -ms-flex: 3;
  flex: 3;
}
.vc-table .vc-table-col-4 {
  -webkit-box-flex: 4;
  -webkit-flex: 4;
  -moz-box-flex: 4;
  -ms-flex: 4;
  flex: 4;
}
.vc-table .vc-table-col-5 {
  -webkit-box-flex: 5;
  -webkit-flex: 5;
  -moz-box-flex: 5;
  -ms-flex: 5;
  flex: 5;
}
.vc-table .vc-table-col-6 {
  -webkit-box-flex: 6;
  -webkit-flex: 6;
  -moz-box-flex: 6;
  -ms-flex: 6;
  flex: 6;
}
.vc-table .vc-table-row-error {
  border-color: var(--VC-ERROR-BORDER);
  background-color: var(--VC-ERROR-BG);
}
.vc-table .vc-table-row-error .vc-table-col {
  color: var(--VC-RED);
  border-color: var(--VC-ERROR-BORDER);
}
.vc-table .vc-table-col-title {
  font-weight: bold;
}
.vc-table .vc-table-action {
  display: flex;
  justify-content: space-evenly;
}
.vc-table .vc-table-action .vc-icon {
  flex: 1;
  text-align: center;
  display: block;
}
.vc-table .vc-table-action .vc-icon:hover {
  background: var(--VC-BG-3);
}
.vc-table .vc-table-action .vc-icon:active {
  background: var(--VC-BG-1);
}
.vc-table .vc-table-input {
  width: 100%;
  border: none;
  color: var(--VC-FG-0);
  background-color: var(--VC-BG-6);
  height: 3.53846154em;
}
.vc-table .vc-table-input:focus {
  background-color: var(--VC-FG-2);
}
@media (prefers-color-scheme: dark) {
  #__vconsole:not([data-theme="light"]) {
    --VC-BG-0: #191919;
    --VC-BG-1: #1f1f1f;
    --VC-BG-2: #232323;
    --VC-BG-3: #2f2f2f;
    --VC-BG-4: #606060;
    --VC-BG-5: #2c2c2c;
    --VC-BG-6: rgba(255, 255, 255, 0.2);
    --VC-FG-0: rgba(255, 255, 255, 0.8);
    --VC-FG-HALF: rgba(255, 255, 255, 0.6);
    --VC-FG-1: rgba(255, 255, 255, 0.5);
    --VC-FG-2: rgba(255, 255, 255, 0.3);
    --VC-FG-3: rgba(255, 255, 255, 0.05);
    --VC-RED: #fa5151;
    --VC-ORANGE: #c87d2f;
    --VC-YELLOW: #cc9c00;
    --VC-GREEN: #74a800;
    --VC-LIGHTGREEN: #28b561;
    --VC-BRAND: #07c160;
    --VC-BLUE: #10aeff;
    --VC-INDIGO: #1196ff;
    --VC-PURPLE: #8183ff;
    --VC-LINK: #7d90a9;
    --VC-TEXTGREEN: #259c5c;
    --VC-FG: white;
    --VC-BG: black;
    --VC-BG-COLOR-ACTIVE: #282828;
    --VC-WARN-BG: #332700;
    --VC-WARN-BORDER: #664e00;
    --VC-ERROR-BG: #321010;
    --VC-ERROR-BORDER: #642020;
    --VC-DOM-TAG-NAME-COLOR: #5DB0D7;
    --VC-DOM-ATTRIBUTE-NAME-COLOR: #9BBBDC;
    --VC-DOM-ATTRIBUTE-VALUE-COLOR: #f29766;
    --VC-CODE-KEY-FG: #e36eec;
    --VC-CODE-PRIVATE-KEY-FG: #f4c5f7;
    --VC-CODE-FUNC-FG: #556af2;
    --VC-CODE-NUMBER-FG: #9980ff;
    --VC-CODE-STR-FG: #e93f3b;
    --VC-CODE-NULL-FG: #808080;
  }
}
#__vconsole[data-theme="dark"] {
  --VC-BG-0: #191919;
  --VC-BG-1: #1f1f1f;
  --VC-BG-2: #232323;
  --VC-BG-3: #2f2f2f;
  --VC-BG-4: #606060;
  --VC-BG-5: #2c2c2c;
  --VC-BG-6: rgba(255, 255, 255, 0.2);
  --VC-FG-0: rgba(255, 255, 255, 0.8);
  --VC-FG-HALF: rgba(255, 255, 255, 0.6);
  --VC-FG-1: rgba(255, 255, 255, 0.5);
  --VC-FG-2: rgba(255, 255, 255, 0.3);
  --VC-FG-3: rgba(255, 255, 255, 0.05);
  --VC-RED: #fa5151;
  --VC-ORANGE: #c87d2f;
  --VC-YELLOW: #cc9c00;
  --VC-GREEN: #74a800;
  --VC-LIGHTGREEN: #28b561;
  --VC-BRAND: #07c160;
  --VC-BLUE: #10aeff;
  --VC-INDIGO: #1196ff;
  --VC-PURPLE: #8183ff;
  --VC-LINK: #7d90a9;
  --VC-TEXTGREEN: #259c5c;
  --VC-FG: white;
  --VC-BG: black;
  --VC-BG-COLOR-ACTIVE: #282828;
  --VC-WARN-BG: #332700;
  --VC-WARN-BORDER: #664e00;
  --VC-ERROR-BG: #321010;
  --VC-ERROR-BORDER: #642020;
  --VC-DOM-TAG-NAME-COLOR: #5DB0D7;
  --VC-DOM-ATTRIBUTE-NAME-COLOR: #9BBBDC;
  --VC-DOM-ATTRIBUTE-VALUE-COLOR: #f29766;
  --VC-CODE-KEY-FG: #e36eec;
  --VC-CODE-PRIVATE-KEY-FG: #f4c5f7;
  --VC-CODE-FUNC-FG: #556af2;
  --VC-CODE-NUMBER-FG: #9980ff;
  --VC-CODE-STR-FG: #e93f3b;
  --VC-CODE-NULL-FG: #808080;
}
.vc-tabbar {
  border-bottom: 1px solid var(--VC-FG-3);
  overflow-x: auto;
  height: 3em;
  width: auto;
  white-space: nowrap;
}
.vc-tabbar .vc-tab {
  display: inline-block;
  line-height: 3em;
  padding: 0 1.15384615em;
  border-right: 1px solid var(--VC-FG-3);
  text-decoration: none;
  color: var(--VC-FG-0);
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
}
.vc-tabbar .vc-tab:active {
  background-color: rgba(0, 0, 0, 0.15);
}
.vc-tabbar .vc-tab.vc-actived {
  background-color: var(--VC-BG-1);
}
.vc-toolbar {
  border-top: 1px solid var(--VC-FG-3);
  line-height: 3em;
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0;
  display: -webkit-box;
  display: -webkit-flex;
  display: -moz-box;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-orient: horizontal;
  -webkit-box-direction: normal;
  -webkit-flex-direction: row;
  -moz-box-orient: horizontal;
  -moz-box-direction: normal;
  -ms-flex-direction: row;
  flex-direction: row;
}
.vc-toolbar .vc-tool {
  display: none;
  font-style: normal;
  text-decoration: none;
  color: var(--VC-FG-0);
  width: 50%;
  -webkit-box-flex: 1;
  -webkit-flex: 1;
  -moz-box-flex: 1;
  -ms-flex: 1;
  flex: 1;
  text-align: center;
  position: relative;
  -webkit-touch-callout: none;
}
.vc-toolbar .vc-tool.vc-toggle,
.vc-toolbar .vc-tool.vc-global-tool {
  display: block;
}
.vc-toolbar .vc-tool:active {
  background-color: rgba(0, 0, 0, 0.15);
}
.vc-toolbar .vc-tool:after {
  content: " ";
  position: absolute;
  top: 0.53846154em;
  bottom: 0.53846154em;
  right: 0;
  border-left: 1px solid var(--VC-FG-3);
}
.vc-toolbar .vc-tool-last:after {
  border: none;
}
.vc-topbar {
  background-color: var(--VC-BG-1);
  display: -webkit-box;
  display: -webkit-flex;
  display: -moz-box;
  display: -ms-flexbox;
  display: flex;
  -webkit-box-orient: horizontal;
  -webkit-box-direction: normal;
  -webkit-flex-direction: row;
  -moz-box-orient: horizontal;
  -moz-box-direction: normal;
  -ms-flex-direction: row;
  flex-direction: row;
  -webkit-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  flex-wrap: wrap;
  width: 100%;
}
.vc-topbar .vc-toptab {
  display: none;
  -webkit-box-flex: 1;
  -webkit-flex: 1;
  -moz-box-flex: 1;
  -ms-flex: 1;
  flex: 1;
  line-height: 2.30769231em;
  padding: 0 1.15384615em;
  border-bottom: 1px solid var(--VC-FG-3);
  text-decoration: none;
  text-align: center;
  color: var(--VC-FG-0);
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
}
.vc-topbar .vc-toptab.vc-toggle {
  display: block;
}
.vc-topbar .vc-toptab:active {
  background-color: rgba(0, 0, 0, 0.15);
}
.vc-topbar .vc-toptab.vc-actived {
  border-bottom: 1px solid var(--VC-INDIGO);
}
.vc-mask {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(0, 0, 0, 0);
  z-index: 10001;
  -webkit-transition: background 0.3s;
  transition: background 0.3s;
  -webkit-tap-highlight-color: transparent;
  overflow-y: scroll;
}
.vc-panel {
  display: none;
  position: fixed;
  min-height: 85%;
  left: 0;
  right: 0;
  bottom: -100%;
  z-index: 10002;
  background-color: var(--VC-BG-0);
  transition: bottom 0.3s;
}
.vc-toggle .vc-switch {
  display: none;
}
.vc-toggle .vc-mask {
  background: rgba(0, 0, 0, 0.6);
  display: block;
}
.vc-toggle .vc-panel {
  bottom: 0;
}
.vc-content {
  background-color: var(--VC-BG-2);
  overflow-x: hidden;
  overflow-y: auto;
  position: absolute;
  top: 3.07692308em;
  left: 0;
  right: 0;
  bottom: 3.07692308em;
  -webkit-overflow-scrolling: touch;
  margin-bottom: constant(safe-area-inset-bottom);
  margin-bottom: env(safe-area-inset-bottom);
}
.vc-content.vc-has-topbar {
  top: 5.46153846em;
}
.vc-plugin-box {
  display: none;
  position: relative;
  min-height: 100%;
}
.vc-plugin-box.vc-fixed-height {
  height: 100%;
}
.vc-plugin-box.vc-actived {
  display: block;
}
.vc-plugin-content {
  display: flex;
  width: 100%;
  height: 100%;
  overflow-y: auto;
  flex-direction: column;
  -webkit-tap-highlight-color: transparent;
}
.vc-plugin-content:empty:before {
  content: "Empty";
  color: var(--VC-FG-1);
  position: absolute;
  top: 45%;
  left: 0;
  right: 0;
  bottom: 0;
  font-size: 1.15384615em;
  text-align: center;
}
.vc-plugin-empty {
  color: var(--VC-FG-1);
  font-size: 1.15384615em;
  height: 100%;
  width: 100%;
  padding: 1.15384615em 0;
  text-align: center;
  display: flex;
  flex-direction: column;
  justify-content: center;
}
@supports (bottom: constant(safe-area-inset-bottom)) or (bottom: env(safe-area-inset-bottom)) {
  .vc-toolbar,
  .vc-switch {
    bottom: constant(safe-area-inset-bottom);
    bottom: env(safe-area-inset-bottom);
  }
}
`, ""]),
                    $.Z = it
                },
                7558: function(_e, $, et) {
                    var tt = et(6738)
                      , nt = et.n(tt)
                      , rt = et(7705)
                      , it = et.n(rt)()(nt());
                    it.push([_e.id, `.vc-switch {
  display: block;
  position: fixed;
  right: 0.76923077em;
  bottom: 0.76923077em;
  color: #FFF;
  background-color: var(--VC-BRAND);
  line-height: 1;
  font-size: 1.07692308em;
  padding: 0.61538462em 1.23076923em;
  z-index: 10000;
  border-radius: 0.30769231em;
  box-shadow: 0 0 0.61538462em rgba(0, 0, 0, 0.4);
}
`, ""]),
                    $.Z = it
                },
                5670: function(_e, $, et) {
                    var tt = et(6738)
                      , nt = et.n(tt)
                      , rt = et(7705)
                      , it = et.n(rt)()(nt());
                    it.push([_e.id, `/* color */
.vcelm-node {
  color: var(--VC-DOM-TAG-NAME-COLOR);
}
.vcelm-k {
  color: var(--VC-DOM-ATTRIBUTE-NAME-COLOR);
}
.vcelm-v {
  color: var(--VC-DOM-ATTRIBUTE-VALUE-COLOR);
}
.vcelm-l.vc-actived > .vcelm-node {
  background-color: var(--VC-FG-3);
}
/* layout */
.vcelm-l {
  padding-left: 8px;
  position: relative;
  word-wrap: break-word;
  line-height: 1.2;
}
/*.vcelm-l.vcelm-noc {
  padding-left: 0;
}*/
.vcelm-l .vcelm-node:active {
  background-color: var(--VC-BG-COLOR-ACTIVE);
}
.vcelm-l.vcelm-noc .vcelm-node:active {
  background-color: transparent;
}
.vcelm-t {
  white-space: pre-wrap;
  word-wrap: break-word;
}
/* level */
/* arrow */
.vcelm-l:before {
  content: "";
  display: block;
  position: absolute;
  top: 6px;
  left: 3px;
  width: 0;
  height: 0;
  border: transparent solid 3px;
  border-left-color: var(--VC-FG-1);
}
.vcelm-l.vc-toggle:before {
  display: block;
  top: 6px;
  left: 0;
  border-top-color: var(--VC-FG-1);
  border-left-color: transparent;
}
.vcelm-l.vcelm-noc:before {
  display: none;
}
`, ""]),
                    $.Z = it
                },
                3327: function(_e, $, et) {
                    var tt = et(6738)
                      , nt = et.n(tt)
                      , rt = et(7705)
                      , it = et.n(rt)()(nt());
                    it.push([_e.id, "", ""]),
                    $.Z = it
                },
                1130: function(_e, $, et) {
                    var tt = et(6738)
                      , nt = et.n(tt)
                      , rt = et(7705)
                      , it = et.n(rt)()(nt());
                    it.push([_e.id, `.vc-cmd {
  height: 3.07692308em;
  border-top: 1px solid var(--VC-FG-3);
  display: flex;
  flex-direction: row;
}
.vc-cmd.vc-filter {
  bottom: 0;
}
.vc-cmd-input-wrap {
  display: flex;
  align-items: center;
  flex: 1;
  position: relative;
  height: 2.15384615em;
  padding: 0.46153846em 0.61538462em;
}
.vc-cmd-input {
  width: 100%;
  border: none;
  resize: none;
  outline: none;
  padding: 0;
  font-size: 0.92307692em;
  background-color: transparent;
  color: var(--VC-FG-0);
}
.vc-cmd-input::-webkit-input-placeholder {
  line-height: 2.15384615em;
}
.vc-cmd-btn {
  width: 3.07692308em;
  border: none;
  background-color: var(--VC-BG-0);
  color: var(--VC-FG-0);
  outline: none;
  -webkit-touch-callout: none;
  font-size: 1em;
}
.vc-cmd-clear-btn {
  flex: 1 3.07692308em;
  text-align: center;
  line-height: 3.07692308em;
}
.vc-cmd-btn:active,
.vc-cmd-clear-btn:active {
  background-color: var(--VC-BG-COLOR-ACTIVE);
}
.vc-cmd-prompted {
  position: absolute;
  left: 0.46153846em;
  right: 0.46153846em;
  background-color: var(--VC-BG-3);
  border: 1px solid var(--VC-FG-3);
  overflow-x: scroll;
  display: none;
}
.vc-cmd-prompted li {
  list-style: none;
  line-height: 30px;
  padding: 0 0.46153846em;
  border-bottom: 1px solid var(--VC-FG-3);
}
.vc-cmd-prompted li:active {
  background-color: var(--VC-BG-COLOR-ACTIVE);
}
.vc-cmd-prompted-hide {
  text-align: center;
}
`, ""]),
                    $.Z = it
                },
                7147: function(_e, $, et) {
                    var tt = et(6738)
                      , nt = et.n(tt)
                      , rt = et(7705)
                      , it = et.n(rt)()(nt());
                    it.push([_e.id, `.vc-log-row {
  margin: 0;
  padding: 0.46153846em 0.61538462em;
  overflow: hidden;
  line-height: 1.3;
  border-bottom: 1px solid var(--VC-FG-3);
  word-break: break-word;
  position: relative;
  display: flex;
}
.vc-log-info {
  color: var(--VC-PURPLE);
}
.vc-log-debug {
  color: var(--VC-YELLOW);
}
.vc-log-warn {
  color: var(--VC-ORANGE);
  border-color: var(--VC-WARN-BORDER);
  background-color: var(--VC-WARN-BG);
}
.vc-log-error {
  color: var(--VC-RED);
  border-color: var(--VC-ERROR-BORDER);
  background-color: var(--VC-ERROR-BG);
}
.vc-logrow-icon {
  margin-left: auto;
}
.vc-log-padding {
  width: 1.53846154em;
  border-left: 1px solid var(--VC-FG-3);
}
.vc-log-group .vc-log-content {
  font-weight: bold;
}
.vc-log-group-toggle {
  padding-left: 0.76923077em;
}
.vc-log-group-toggle {
  display: block;
  font-style: italic;
  padding-left: 0.76923077em;
  position: relative;
}
.vc-log-group-toggle:active {
  background-color: var(--VC-BG-COLOR-ACTIVE);
}
.vc-log-group > .vc-log-group-toggle::before {
  content: "";
  position: absolute;
  top: 0.30769231em;
  left: 0.15384615em;
  width: 0;
  height: 0;
  border: transparent solid 0.30769231em;
  border-left-color: var(--VC-FG-1);
}
.vc-log-group.vc-toggle > .vc-log-group-toggle::before {
  top: 0.46153846em;
  left: 0;
  border-top-color: var(--VC-FG-1);
  border-left-color: transparent;
}
.vc-log-time {
  width: 6.15384615em;
  color: #777;
}
.vc-log-repeat i {
  margin-right: 0.30769231em;
  padding: 0 6.5px;
  color: #D7E0EF;
  background-color: #42597F;
  border-radius: 8.66666667px;
}
.vc-log-error .vc-log-repeat i {
  color: #901818;
  background-color: var(--VC-RED);
}
.vc-log-warn .vc-log-repeat i {
  color: #987D20;
  background-color: #F4BD02;
}
.vc-log-content {
  flex: 1;
}
.vc-log-input,
.vc-log-output {
  padding-left: 0.92307692em;
}
.vc-log-input:before,
.vc-log-output:before {
  content: "";
  position: absolute;
  top: 0.15384615em;
  left: 0;
  font-size: 1.23076923em;
  color: #6A5ACD;
}
.vc-log-output:before {
  content: "";
}
`, ""]),
                    $.Z = it
                },
                1237: function(_e, $, et) {
                    var tt = et(6738)
                      , nt = et.n(tt)
                      , rt = et(7705)
                      , it = et.n(rt)()(nt());
                    it.push([_e.id, `.vc-log-tree {
  display: block;
  overflow: auto;
  position: relative;
  -webkit-overflow-scrolling: touch;
}
.vc-log-tree-node {
  display: block;
  font-style: italic;
  padding-left: 0.76923077em;
  position: relative;
}
.vc-log-tree.vc-is-tree > .vc-log-tree-node:active {
  background-color: var(--VC-BG-COLOR-ACTIVE);
}
.vc-log-tree.vc-is-tree > .vc-log-tree-node::before {
  content: "";
  position: absolute;
  top: 0.30769231em;
  left: 0.15384615em;
  width: 0;
  height: 0;
  border: transparent solid 0.30769231em;
  border-left-color: var(--VC-FG-1);
}
.vc-log-tree.vc-is-tree.vc-toggle > .vc-log-tree-node::before {
  top: 0.46153846em;
  left: 0;
  border-top-color: var(--VC-FG-1);
  border-left-color: transparent;
}
.vc-log-tree-child {
  margin-left: 0.76923077em;
}
.vc-log-tree-loadmore {
  text-decoration: underline;
  padding-left: 1.84615385em;
  position: relative;
  color: var(--VC-CODE-FUNC-FG);
}
.vc-log-tree-loadmore::before {
  content: "";
  position: absolute;
  top: -0.15384615em;
  left: 0.76923077em;
  font-size: 1.23076923em;
  color: var(--VC-CODE-FUNC-FG);
}
.vc-log-tree-loadmore:active {
  background-color: var(--VC-BG-COLOR-ACTIVE);
}
`, ""]),
                    $.Z = it
                },
                845: function(_e, $, et) {
                    var tt = et(6738)
                      , nt = et.n(tt)
                      , rt = et(7705)
                      , it = et.n(rt)()(nt());
                    it.push([_e.id, `.vc-log-key {
  color: var(--VC-CODE-KEY-FG);
}
.vc-log-key-private {
  color: var(--VC-CODE-PRIVATE-KEY-FG);
}
.vc-log-val {
  white-space: pre-line;
}
.vc-log-val-function {
  color: var(--VC-CODE-FUNC-FG);
  font-style: italic !important;
}
.vc-log-val-bigint {
  color: var(--VC-CODE-FUNC-FG);
}
.vc-log-val-number,
.vc-log-val-boolean {
  color: var(--VC-CODE-NUMBER-FG);
}
.vc-log-val-string {
  white-space: pre-wrap;
}
.vc-log-val-string.vc-log-val-haskey {
  color: var(--VC-CODE-STR-FG);
  white-space: normal;
}
.vc-log-val-null,
.vc-log-val-undefined,
.vc-log-val-uninvocatable {
  color: var(--VC-CODE-NULL-FG);
}
.vc-log-val-symbol {
  color: var(--VC-CODE-STR-FG);
}
`, ""]),
                    $.Z = it
                },
                8747: function(_e, $, et) {
                    var tt = et(6738)
                      , nt = et.n(tt)
                      , rt = et(7705)
                      , it = et.n(rt)()(nt());
                    it.push([_e.id, `.vc-group .vc-group-preview {
  -webkit-touch-callout: none;
}
.vc-group .vc-group-preview:active {
  background-color: var(--VC-BG-COLOR-ACTIVE);
}
.vc-group .vc-group-detail {
  display: none;
  padding: 0 0 0.76923077em 1.53846154em;
  border-bottom: 1px solid var(--VC-FG-3);
}
.vc-group.vc-actived .vc-group-detail {
  display: block;
  background-color: var(--VC-BG-1);
}
.vc-group.vc-actived .vc-table-row {
  background-color: var(--VC-BG-2);
}
.vc-group.vc-actived .vc-group-preview {
  background-color: var(--VC-BG-1);
}
`, ""]),
                    $.Z = it
                },
                3411: function(_e, $, et) {
                    var tt = et(3379)
                      , nt = et.n(tt)
                      , rt = et(7795)
                      , it = et.n(rt)
                      , ot = et(569)
                      , st = et.n(ot)
                      , lt = et(3565)
                      , ct = et.n(lt)
                      , dt = et(9216)
                      , pt = et.n(dt)
                      , ht = et(4589)
                      , mt = et.n(ht)
                      , yt = et(1130)
                      , Et = {};
                    yt.Z && yt.Z.locals && (Et.locals = yt.Z.locals);
                    var _t, wt = 0, St = {};
                    St.styleTagTransform = mt(),
                    St.setAttributes = ct(),
                    St.insert = st().bind(null, "head"),
                    St.domAPI = it(),
                    St.insertStyleElement = pt(),
                    Et.use = function(Ct) {
                        return St.options = Ct || {},
                        wt++ || (_t = nt()(yt.Z, St)),
                        Et
                    }
                    ,
                    Et.unuse = function() {
                        wt > 0 && !--wt && (_t(),
                        _t = null)
                    }
                    ,
                    $.Z = Et
                },
                3379: function(_e) {
                    var $ = [];
                    function et(rt) {
                        for (var it = -1, ot = 0; ot < $.length; ot++)
                            if ($[ot].identifier === rt) {
                                it = ot;
                                break
                            }
                        return it
                    }
                    function tt(rt, it) {
                        for (var ot = {}, st = [], lt = 0; lt < rt.length; lt++) {
                            var ct = rt[lt]
                              , dt = it.base ? ct[0] + it.base : ct[0]
                              , pt = ot[dt] || 0
                              , ht = "".concat(dt, " ").concat(pt);
                            ot[dt] = pt + 1;
                            var mt = et(ht)
                              , yt = {
                                css: ct[1],
                                media: ct[2],
                                sourceMap: ct[3],
                                supports: ct[4],
                                layer: ct[5]
                            };
                            if (mt !== -1)
                                $[mt].references++,
                                $[mt].updater(yt);
                            else {
                                var Et = nt(yt, it);
                                it.byIndex = lt,
                                $.splice(lt, 0, {
                                    identifier: ht,
                                    updater: Et,
                                    references: 1
                                })
                            }
                            st.push(ht)
                        }
                        return st
                    }
                    function nt(rt, it) {
                        var ot = it.domAPI(it);
                        return ot.update(rt),
                        function(st) {
                            if (st) {
                                if (st.css === rt.css && st.media === rt.media && st.sourceMap === rt.sourceMap && st.supports === rt.supports && st.layer === rt.layer)
                                    return;
                                ot.update(rt = st)
                            } else
                                ot.remove()
                        }
                    }
                    _e.exports = function(rt, it) {
                        var ot = tt(rt = rt || [], it = it || {});
                        return function(st) {
                            st = st || [];
                            for (var lt = 0; lt < ot.length; lt++) {
                                var ct = et(ot[lt]);
                                $[ct].references--
                            }
                            for (var dt = tt(st, it), pt = 0; pt < ot.length; pt++) {
                                var ht = et(ot[pt]);
                                $[ht].references === 0 && ($[ht].updater(),
                                $.splice(ht, 1))
                            }
                            ot = dt
                        }
                    }
                },
                569: function(_e) {
                    var $ = {};
                    _e.exports = function(et, tt) {
                        var nt = function(rt) {
                            if ($[rt] === void 0) {
                                var it = document.querySelector(rt);
                                if (window.HTMLIFrameElement && it instanceof window.HTMLIFrameElement)
                                    try {
                                        it = it.contentDocument.head
                                    } catch {
                                        it = null
                                    }
                                $[rt] = it
                            }
                            return $[rt]
                        }(et);
                        if (!nt)
                            throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
                        nt.appendChild(tt)
                    }
                },
                9216: function(_e) {
                    _e.exports = function($) {
                        var et = document.createElement("style");
                        return $.setAttributes(et, $.attributes),
                        $.insert(et, $.options),
                        et
                    }
                },
                3565: function(_e, $, et) {
                    _e.exports = function(tt) {
                        var nt = et.nc;
                        nt && tt.setAttribute("nonce", nt)
                    }
                },
                7795: function(_e) {
                    _e.exports = function($) {
                        var et = $.insertStyleElement($);
                        return {
                            update: function(tt) {
                                (function(nt, rt, it) {
                                    var ot = "";
                                    it.supports && (ot += "@supports (".concat(it.supports, ") {")),
                                    it.media && (ot += "@media ".concat(it.media, " {"));
                                    var st = it.layer !== void 0;
                                    st && (ot += "@layer".concat(it.layer.length > 0 ? " ".concat(it.layer) : "", " {")),
                                    ot += it.css,
                                    st && (ot += "}"),
                                    it.media && (ot += "}"),
                                    it.supports && (ot += "}");
                                    var lt = it.sourceMap;
                                    lt && typeof btoa < "u" && (ot += `
/*# sourceMappingURL=data:application/json;base64,`.concat(btoa(unescape(encodeURIComponent(JSON.stringify(lt)))), " */")),
                                    rt.styleTagTransform(ot, nt, rt.options)
                                }
                                )(et, $, tt)
                            },
                            remove: function() {
                                (function(tt) {
                                    if (tt.parentNode === null)
                                        return !1;
                                    tt.parentNode.removeChild(tt)
                                }
                                )(et)
                            }
                        }
                    }
                },
                4589: function(_e) {
                    _e.exports = function($, et) {
                        if (et.styleSheet)
                            et.styleSheet.cssText = $;
                        else {
                            for (; et.firstChild; )
                                et.removeChild(et.firstChild);
                            et.appendChild(document.createTextNode($))
                        }
                    }
                },
                6464: function(_e, $, et) {
                    function tt(nt) {
                        if (nt === void 0)
                            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return nt
                    }
                    et.d($, {
                        Z: function() {
                            return tt
                        }
                    })
                },
                4296: function(_e, $, et) {
                    function tt(rt, it) {
                        for (var ot = 0; ot < it.length; ot++) {
                            var st = it[ot];
                            st.enumerable = st.enumerable || !1,
                            st.configurable = !0,
                            "value"in st && (st.writable = !0),
                            Object.defineProperty(rt, st.key, st)
                        }
                    }
                    function nt(rt, it, ot) {
                        return it && tt(rt.prototype, it),
                        ot && tt(rt, ot),
                        Object.defineProperty(rt, "prototype", {
                            writable: !1
                        }),
                        rt
                    }
                    et.d($, {
                        Z: function() {
                            return nt
                        }
                    })
                },
                8270: function(_e, $, et) {
                    function tt(nt, rt, it) {
                        return rt in nt ? Object.defineProperty(nt, rt, {
                            value: it,
                            enumerable: !0,
                            configurable: !0,
                            writable: !0
                        }) : nt[rt] = it,
                        nt
                    }
                    et.d($, {
                        Z: function() {
                            return tt
                        }
                    })
                },
                6881: function(_e, $, et) {
                    et.d($, {
                        Z: function() {
                            return nt
                        }
                    });
                    var tt = et(2717);
                    function nt(rt, it) {
                        rt.prototype = Object.create(it.prototype),
                        rt.prototype.constructor = rt,
                        (0,
                        tt.Z)(rt, it)
                    }
                },
                2717: function(_e, $, et) {
                    function tt(nt, rt) {
                        return tt = Object.setPrototypeOf || function(it, ot) {
                            return it.__proto__ = ot,
                            it
                        }
                        ,
                        tt(nt, rt)
                    }
                    et.d($, {
                        Z: function() {
                            return tt
                        }
                    })
                },
                7003: function(_e, $, et) {
                    et.d($, {
                        H3: function() {
                            return tt.H3E
                        },
                        ev: function() {
                            return tt.evW
                        },
                        x: function() {
                            return tt.xa3
                        }
                    });
                    var tt = et(2942)
                },
                2942: function(_e, $, et) {
                    et.d($, {
                        f_C: function() {
                            return lr
                        },
                        hjT: function() {
                            return pr
                        },
                        R3I: function() {
                            return Nt
                        },
                        Ljt: function() {
                            return jt
                        },
                        akz: function() {
                            return Gt
                        },
                        VnY: function() {
                            return Un
                        },
                        cKT: function() {
                            return jn
                        },
                        gbL: function() {
                            return or
                        },
                        FIv: function() {
                            return ht
                        },
                        XGm: function() {
                            return St
                        },
                        xa3: function() {
                            return Dn
                        },
                        YCL: function() {
                            return fn
                        },
                        nuO: function() {
                            return mt
                        },
                        vpE: function() {
                            return vn
                        },
                        RMB: function() {
                            return Ut
                        },
                        ogt: function() {
                            return kt
                        },
                        bGB: function() {
                            return Jt
                        },
                        cSb: function() {
                            return zt
                        },
                        yl1: function() {
                            return wr
                        },
                        VOJ: function() {
                            return wt
                        },
                        u2N: function() {
                            return Et
                        },
                        $XI: function() {
                            return pt
                        },
                        lig: function() {
                            return br
                        },
                        dvw: function() {
                            return dr
                        },
                        S1n: function() {
                            return sr
                        },
                        $Tr: function() {
                            return Lt
                        },
                        sBU: function() {
                            return ot
                        },
                        oLt: function() {
                            return xt
                        },
                        yef: function() {
                            return En
                        },
                        ZTd: function() {
                            return tt
                        },
                        AqN: function() {
                            return lt
                        },
                        evW: function() {
                            return kn
                        },
                        H3E: function() {
                            return _n
                        },
                        cly: function() {
                            return an
                        },
                        AT7: function() {
                            return $t
                        },
                        j7q: function() {
                            return it
                        },
                        N8: function() {
                            return st
                        },
                        rTO: function() {
                            return Ft
                        },
                        BmG: function() {
                            return Ht
                        },
                        fxP: function() {
                            return Ct
                        },
                        czc: function() {
                            return qt
                        },
                        DhX: function() {
                            return rn
                        },
                        XET: function() {
                            return Dt
                        },
                        LdU: function() {
                            return dt
                        },
                        bi5: function() {
                            return Pt
                        },
                        fLW: function() {
                            return Xt
                        },
                        VHj: function() {
                            return Wt
                        },
                        Ui: function() {
                            return ir
                        },
                        etI: function() {
                            return Cr
                        },
                        GQg: function() {
                            return Kt
                        },
                        kmG: function() {
                            return _t
                        }
                    }),
                    et(2717),
                    et(6881);
                    function tt() {}
                    function nt(wn) {
                        return wn()
                    }
                    function rt() {
                        return Object.create(null)
                    }
                    function it(wn) {
                        wn.forEach(nt)
                    }
                    function ot(wn) {
                        return typeof wn == "function"
                    }
                    function st(wn, Pn) {
                        return wn != wn ? Pn == Pn : wn !== Pn || wn && typeof wn == "object" || typeof wn == "function"
                    }
                    function lt(wn, Pn) {
                        return wn != wn ? Pn == Pn : wn !== Pn
                    }
                    function ct(wn) {
                        return Object.keys(wn).length === 0
                    }
                    function dt(wn) {
                        if (wn == null)
                            return tt;
                        for (var Pn = arguments.length, Cn = new Array(Pn > 1 ? Pn - 1 : 0), zn = 1; zn < Pn; zn++)
                            Cn[zn - 1] = arguments[zn];
                        var ur = wn.subscribe.apply(wn, Cn);
                        return ur.unsubscribe ? function() {
                            return ur.unsubscribe()
                        }
                        : ur
                    }
                    function pt(wn) {
                        var Pn;
                        return dt(wn, function(Cn) {
                            return Pn = Cn
                        })(),
                        Pn
                    }
                    function ht(wn, Pn, Cn) {
                        wn.$$.on_destroy.push(dt(Pn, Cn))
                    }
                    function mt(wn, Pn, Cn, zn) {
                        if (wn) {
                            var ur = yt(wn, Pn, Cn, zn);
                            return wn[0](ur)
                        }
                    }
                    function yt(wn, Pn, Cn, zn) {
                        return wn[1] && zn ? function(ur, hr) {
                            for (var Ir in hr)
                                ur[Ir] = hr[Ir];
                            return ur
                        }(Cn.ctx.slice(), wn[1](zn(Pn))) : Cn.ctx
                    }
                    function Et(wn, Pn, Cn, zn) {
                        if (wn[2] && zn) {
                            var ur = wn[2](zn(Cn));
                            if (Pn.dirty === void 0)
                                return ur;
                            if (typeof ur == "object") {
                                for (var hr = [], Ir = Math.max(Pn.dirty.length, ur.length), _o = 0; _o < Ir; _o += 1)
                                    hr[_o] = Pn.dirty[_o] | ur[_o];
                                return hr
                            }
                            return Pn.dirty | ur
                        }
                        return Pn.dirty
                    }
                    function _t(wn, Pn, Cn, zn, ur, hr) {
                        if (ur) {
                            var Ir = yt(Pn, Cn, zn, hr);
                            wn.p(Ir, ur)
                        }
                    }
                    function wt(wn) {
                        if (wn.ctx.length > 32) {
                            for (var Pn = [], Cn = wn.ctx.length / 32, zn = 0; zn < Cn; zn++)
                                Pn[zn] = -1;
                            return Pn
                        }
                        return -1
                    }
                    function St(wn) {
                        var Pn = {};
                        for (var Cn in wn)
                            Pn[Cn] = !0;
                        return Pn
                    }
                    function Ct(wn, Pn, Cn) {
                        return wn.set(Cn),
                        Pn
                    }
                    function Nt(wn, Pn) {
                        wn.appendChild(Pn)
                    }
                    function Lt(wn, Pn, Cn) {
                        wn.insertBefore(Pn, Cn || null)
                    }
                    function kt(wn) {
                        wn.parentNode.removeChild(wn)
                    }
                    function Ut(wn, Pn) {
                        for (var Cn = 0; Cn < wn.length; Cn += 1)
                            wn[Cn] && wn[Cn].d(Pn)
                    }
                    function Jt(wn) {
                        return document.createElement(wn)
                    }
                    function Pt(wn) {
                        return document.createElementNS("http://www.w3.org/2000/svg", wn)
                    }
                    function Xt(wn) {
                        return document.createTextNode(wn)
                    }
                    function rn() {
                        return Xt(" ")
                    }
                    function zt() {
                        return Xt("")
                    }
                    function xt(wn, Pn, Cn, zn) {
                        return wn.addEventListener(Pn, Cn, zn),
                        function() {
                            return wn.removeEventListener(Pn, Cn, zn)
                        }
                    }
                    function $t(wn) {
                        return function(Pn) {
                            return Pn.preventDefault(),
                            wn.call(this, Pn)
                        }
                    }
                    function Dt(wn) {
                        return function(Pn) {
                            return Pn.stopPropagation(),
                            wn.call(this, Pn)
                        }
                    }
                    function jt(wn, Pn, Cn) {
                        Cn == null ? wn.removeAttribute(Pn) : wn.getAttribute(Pn) !== Cn && wn.setAttribute(Pn, Cn)
                    }
                    function Ft(wn, Pn) {
                        Pn = "" + Pn,
                        wn.wholeText !== Pn && (wn.data = Pn)
                    }
                    function Ht(wn, Pn) {
                        wn.value = Pn ?? ""
                    }
                    function qt(wn, Pn, Cn, zn) {
                        Cn === null ? wn.style.removeProperty(Pn) : wn.style.setProperty(Pn, Cn, zn ? "important" : "")
                    }
                    function Wt(wn, Pn, Cn) {
                        wn.classList[Cn ? "add" : "remove"](Pn)
                    }
                    function Mt(wn, Pn, Cn) {
                        Cn === void 0 && (Cn = !1);
                        var zn = document.createEvent("CustomEvent");
                        return zn.initCustomEvent(wn, Cn, !1, Pn),
                        zn
                    }
                    var Yt;
                    function un(wn) {
                        Yt = wn
                    }
                    function hn() {
                        if (!Yt)
                            throw new Error("Function called outside component initialization");
                        return Yt
                    }
                    function _n(wn) {
                        hn().$$.on_mount.push(wn)
                    }
                    function kn(wn) {
                        hn().$$.on_destroy.push(wn)
                    }
                    function Dn() {
                        var wn = hn();
                        return function(Pn, Cn) {
                            var zn = wn.$$.callbacks[Pn];
                            if (zn) {
                                var ur = Mt(Pn, Cn);
                                zn.slice().forEach(function(hr) {
                                    hr.call(wn, ur)
                                })
                            }
                        }
                    }
                    function jn(wn, Pn) {
                        var Cn = this
                          , zn = wn.$$.callbacks[Pn.type];
                        zn && zn.slice().forEach(function(ur) {
                            return ur.call(Cn, Pn)
                        })
                    }
                    var Bn = []
                      , Un = []
                      , Hn = []
                      , cr = []
                      , Gn = Promise.resolve()
                      , Mn = !1;
                    function rr() {
                        Mn || (Mn = !0,
                        Gn.then(wr))
                    }
                    function Zn(wn) {
                        Hn.push(wn)
                    }
                    function pr(wn) {
                        cr.push(wn)
                    }
                    var Ur = new Set
                      , xr = 0;
                    function wr() {
                        var wn = Yt;
                        do {
                            for (; xr < Bn.length; ) {
                                var Pn = Bn[xr];
                                xr++,
                                un(Pn),
                                Rn(Pn.$$)
                            }
                            for (un(null),
                            Bn.length = 0,
                            xr = 0; Un.length; )
                                Un.pop()();
                            for (var Cn = 0; Cn < Hn.length; Cn += 1) {
                                var zn = Hn[Cn];
                                Ur.has(zn) || (Ur.add(zn),
                                zn())
                            }
                            Hn.length = 0
                        } while (Bn.length);
                        for (; cr.length; )
                            cr.pop()();
                        Mn = !1,
                        Ur.clear(),
                        un(wn)
                    }
                    function Rn(wn) {
                        if (wn.fragment !== null) {
                            wn.update(),
                            it(wn.before_update);
                            var Pn = wn.dirty;
                            wn.dirty = [-1],
                            wn.fragment && wn.fragment.p(wn.ctx, Pn),
                            wn.after_update.forEach(Zn)
                        }
                    }
                    var Vn, qn = new Set;
                    function dr() {
                        Vn = {
                            r: 0,
                            c: [],
                            p: Vn
                        }
                    }
                    function or() {
                        Vn.r || it(Vn.c),
                        Vn = Vn.p
                    }
                    function ir(wn, Pn) {
                        wn && wn.i && (qn.delete(wn),
                        wn.i(Pn))
                    }
                    function Cr(wn, Pn, Cn, zn) {
                        if (wn && wn.o) {
                            if (qn.has(wn))
                                return;
                            qn.add(wn),
                            Vn.c.push(function() {
                                qn.delete(wn),
                                zn && (Cn && wn.d(1),
                                zn())
                            }),
                            wn.o(Pn)
                        }
                    }
                    var br = typeof window < "u" ? window : globalThis;
                    function an(wn, Pn) {
                        Cr(wn, 1, 1, function() {
                            Pn.delete(wn.key)
                        })
                    }
                    function Kt(wn, Pn, Cn, zn, ur, hr, Ir, _o, Xr, jr, zs, bo) {
                        for (var Jr = wn.length, Zo = hr.length, ro = Jr, go = {}; ro--; )
                            go[wn[ro].key] = ro;
                        var Sl = []
                          , xo = new Map
                          , To = new Map;
                        for (ro = Zo; ro--; ) {
                            var Cl = bo(ur, hr, ro)
                              , mo = Cn(Cl)
                              , Ro = Ir.get(mo);
                            Ro ? zn && Ro.p(Cl, Pn) : (Ro = jr(mo, Cl)).c(),
                            xo.set(mo, Sl[ro] = Ro),
                            mo in go && To.set(mo, Math.abs(ro - go[mo]))
                        }
                        var lu = new Set
                          , yo = new Set;
                        function Io(Ss) {
                            ir(Ss, 1),
                            Ss.m(_o, zs),
                            Ir.set(Ss.key, Ss),
                            zs = Ss.first,
                            Zo--
                        }
                        for (; Jr && Zo; ) {
                            var ws = Sl[Zo - 1]
                              , Os = wn[Jr - 1]
                              , Ws = ws.key
                              , Hs = Os.key;
                            ws === Os ? (zs = ws.first,
                            Jr--,
                            Zo--) : xo.has(Hs) ? !Ir.has(Ws) || lu.has(Ws) ? Io(ws) : yo.has(Hs) ? Jr-- : To.get(Ws) > To.get(Hs) ? (yo.add(Ws),
                            Io(ws)) : (lu.add(Hs),
                            Jr--) : (Xr(Os, Ir),
                            Jr--)
                        }
                        for (; Jr--; ) {
                            var xs = wn[Jr];
                            xo.has(xs.key) || Xr(xs, Ir)
                        }
                        for (; Zo; )
                            Io(Sl[Zo - 1]);
                        return Sl
                    }
                    function Gt(wn, Pn, Cn) {
                        var zn = wn.$$.props[Pn];
                        zn !== void 0 && (wn.$$.bound[zn] = Cn,
                        Cn(wn.$$.ctx[zn]))
                    }
                    function fn(wn) {
                        wn && wn.c()
                    }
                    function En(wn, Pn, Cn, zn) {
                        var ur = wn.$$
                          , hr = ur.fragment
                          , Ir = ur.on_mount
                          , _o = ur.on_destroy
                          , Xr = ur.after_update;
                        hr && hr.m(Pn, Cn),
                        zn || Zn(function() {
                            var jr = Ir.map(nt).filter(ot);
                            _o ? _o.push.apply(_o, jr) : it(jr),
                            wn.$$.on_mount = []
                        }),
                        Xr.forEach(Zn)
                    }
                    function vn(wn, Pn) {
                        var Cn = wn.$$;
                        Cn.fragment !== null && (it(Cn.on_destroy),
                        Cn.fragment && Cn.fragment.d(Pn),
                        Cn.on_destroy = Cn.fragment = null,
                        Cn.ctx = [])
                    }
                    function Tn(wn, Pn) {
                        wn.$$.dirty[0] === -1 && (Bn.push(wn),
                        rr(),
                        wn.$$.dirty.fill(0)),
                        wn.$$.dirty[Pn / 31 | 0] |= 1 << Pn % 31
                    }
                    function sr(wn, Pn, Cn, zn, ur, hr, Ir, _o) {
                        _o === void 0 && (_o = [-1]);
                        var Xr = Yt;
                        un(wn);
                        var jr = wn.$$ = {
                            fragment: null,
                            ctx: null,
                            props: hr,
                            update: tt,
                            not_equal: ur,
                            bound: rt(),
                            on_mount: [],
                            on_destroy: [],
                            on_disconnect: [],
                            before_update: [],
                            after_update: [],
                            context: new Map(Pn.context || (Xr ? Xr.$$.context : [])),
                            callbacks: rt(),
                            dirty: _o,
                            skip_bound: !1,
                            root: Pn.target || Xr.$$.root
                        };
                        Ir && Ir(jr.root);
                        var zs, bo = !1;
                        if (jr.ctx = Cn ? Cn(wn, Pn.props || {}, function(Zo, ro) {
                            var go = !(arguments.length <= 2) && arguments.length - 2 ? arguments.length <= 2 ? void 0 : arguments[2] : ro;
                            return jr.ctx && ur(jr.ctx[Zo], jr.ctx[Zo] = go) && (!jr.skip_bound && jr.bound[Zo] && jr.bound[Zo](go),
                            bo && Tn(wn, Zo)),
                            ro
                        }) : [],
                        jr.update(),
                        bo = !0,
                        it(jr.before_update),
                        jr.fragment = !!zn && zn(jr.ctx),
                        Pn.target) {
                            if (Pn.hydrate) {
                                var Jr = (zs = Pn.target,
                                Array.from(zs.childNodes));
                                jr.fragment && jr.fragment.l(Jr),
                                Jr.forEach(kt)
                            } else
                                jr.fragment && jr.fragment.c();
                            Pn.intro && ir(wn.$$.fragment),
                            En(wn, Pn.target, Pn.anchor, Pn.customElement),
                            wr()
                        }
                        un(Xr)
                    }
                    var lr = function() {
                        function wn() {}
                        var Pn = wn.prototype;
                        return Pn.$destroy = function() {
                            vn(this, 1),
                            this.$destroy = tt
                        }
                        ,
                        Pn.$on = function(Cn, zn) {
                            var ur = this.$$.callbacks[Cn] || (this.$$.callbacks[Cn] = []);
                            return ur.push(zn),
                            function() {
                                var hr = ur.indexOf(zn);
                                hr !== -1 && ur.splice(hr, 1)
                            }
                        }
                        ,
                        Pn.$set = function(Cn) {
                            this.$$set && !ct(Cn) && (this.$$.skip_bound = !0,
                            this.$$set(Cn),
                            this.$$.skip_bound = !1)
                        }
                        ,
                        wn
                    }()
                },
                3313: function(_e, $, et) {
                    et.d($, {
                        U2: function() {
                            return tt.$XI
                        },
                        fZ: function() {
                            return ot
                        }
                    });
                    var tt = et(2942);
                    function nt(st, lt) {
                        var ct = typeof Symbol < "u" && st[Symbol.iterator] || st["@@iterator"];
                        if (ct)
                            return (ct = ct.call(st)).next.bind(ct);
                        if (Array.isArray(st) || (ct = function(pt, ht) {
                            if (pt) {
                                if (typeof pt == "string")
                                    return rt(pt, ht);
                                var mt = Object.prototype.toString.call(pt).slice(8, -1);
                                if (mt === "Object" && pt.constructor && (mt = pt.constructor.name),
                                mt === "Map" || mt === "Set")
                                    return Array.from(pt);
                                if (mt === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(mt))
                                    return rt(pt, ht)
                            }
                        }(st)) || lt) {
                            ct && (st = ct);
                            var dt = 0;
                            return function() {
                                return dt >= st.length ? {
                                    done: !0
                                } : {
                                    done: !1,
                                    value: st[dt++]
                                }
                            }
                        }
                        throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                    }
                    function rt(st, lt) {
                        (lt == null || lt > st.length) && (lt = st.length);
                        for (var ct = 0, dt = new Array(lt); ct < lt; ct++)
                            dt[ct] = st[ct];
                        return dt
                    }
                    var it = [];
                    function ot(st, lt) {
                        var ct;
                        lt === void 0 && (lt = tt.ZTd);
                        var dt = new Set;
                        function pt(ht) {
                            if ((0,
                            tt.N8)(st, ht) && (st = ht,
                            ct)) {
                                for (var mt, yt = !it.length, Et = nt(dt); !(mt = Et()).done; ) {
                                    var _t = mt.value;
                                    _t[1](),
                                    it.push(_t, st)
                                }
                                if (yt) {
                                    for (var wt = 0; wt < it.length; wt += 2)
                                        it[wt][0](it[wt + 1]);
                                    it.length = 0
                                }
                            }
                        }
                        return {
                            set: pt,
                            update: function(ht) {
                                pt(ht(st))
                            },
                            subscribe: function(ht, mt) {
                                mt === void 0 && (mt = tt.ZTd);
                                var yt = [ht, mt];
                                return dt.add(yt),
                                dt.size === 1 && (ct = lt(pt) || tt.ZTd),
                                ht(st),
                                function() {
                                    dt.delete(yt),
                                    dt.size === 0 && (ct(),
                                    ct = null)
                                }
                            }
                        }
                    }
                }
            }
              , __webpack_module_cache__ = {};
            function __webpack_require__(_e) {
                var $ = __webpack_module_cache__[_e];
                if ($ !== void 0)
                    return $.exports;
                var et = __webpack_module_cache__[_e] = {
                    id: _e,
                    exports: {}
                };
                return __webpack_modules__[_e](et, et.exports, __webpack_require__),
                et.exports
            }
            __webpack_require__.n = function(_e) {
                var $ = _e && _e.__esModule ? function() {
                    return _e.default
                }
                : function() {
                    return _e
                }
                ;
                return __webpack_require__.d($, {
                    a: $
                }),
                $
            }
            ,
            __webpack_require__.d = function(_e, $) {
                for (var et in $)
                    __webpack_require__.o($, et) && !__webpack_require__.o(_e, et) && Object.defineProperty(_e, et, {
                        enumerable: !0,
                        get: $[et]
                    })
            }
            ,
            __webpack_require__.g = function() {
                if (typeof globalThis == "object")
                    return globalThis;
                try {
                    return this || new Function("return this")()
                } catch {
                    if (typeof window == "object")
                        return window
                }
            }(),
            __webpack_require__.o = function(_e, $) {
                return Object.prototype.hasOwnProperty.call(_e, $)
            }
            ;
            var __webpack_exports__ = {};
            return function() {
                __webpack_require__.d(__webpack_exports__, {
                    default: function() {
                        return Xu
                    }
                }),
                __webpack_require__(5441),
                __webpack_require__(8765);
                var _e = __webpack_require__(4296)
                  , $ = __webpack_require__(5103)
                  , et = {
                    one: function(At, Tt) {
                        Tt === void 0 && (Tt = document);
                        try {
                            return Tt.querySelector(At) || void 0
                        } catch {
                            return
                        }
                    },
                    all: function(At, Tt) {
                        Tt === void 0 && (Tt = document);
                        try {
                            var vt = Tt.querySelectorAll(At);
                            return [].slice.call(vt)
                        } catch {
                            return []
                        }
                    },
                    addClass: function(At, Tt) {
                        if (At)
                            for (var vt = (0,
                            $.kJ)(At) ? At : [At], bt = 0; bt < vt.length; bt++) {
                                var Rt = (vt[bt].className || "").split(" ");
                                Rt.indexOf(Tt) > -1 || (Rt.push(Tt),
                                vt[bt].className = Rt.join(" "))
                            }
                    },
                    removeClass: function(At, Tt) {
                        if (At)
                            for (var vt = (0,
                            $.kJ)(At) ? At : [At], bt = 0; bt < vt.length; bt++) {
                                for (var Rt = vt[bt].className.split(" "), It = 0; It < Rt.length; It++)
                                    Rt[It] == Tt && (Rt[It] = "");
                                vt[bt].className = Rt.join(" ").trim()
                            }
                    },
                    hasClass: function(At, Tt) {
                        return !(!At || !At.classList) && At.classList.contains(Tt)
                    },
                    bind: function(At, Tt, vt, bt) {
                        bt === void 0 && (bt = !1),
                        At && ((0,
                        $.kJ)(At) ? At : [At]).forEach(function(Rt) {
                            Rt.addEventListener(Tt, vt, !!bt)
                        })
                    },
                    delegate: function(At, Tt, vt, bt) {
                        At && At.addEventListener(Tt, function(Rt) {
                            var It = et.all(vt, At);
                            if (It)
                                e: for (var Bt = 0; Bt < It.length; Bt++)
                                    for (var Zt = Rt.target; Zt; ) {
                                        if (Zt == It[Bt]) {
                                            bt.call(Zt, Rt, Zt);
                                            break e
                                        }
                                        if ((Zt = Zt.parentNode) == At)
                                            break
                                    }
                        }, !1)
                    },
                    removeChildren: function(At) {
                        for (; At.firstChild; )
                            At.removeChild(At.lastChild);
                        return At
                    }
                }
                  , tt = et
                  , nt = __webpack_require__(6464)
                  , rt = __webpack_require__(6881)
                  , it = __webpack_require__(2942)
                  , ot = __webpack_require__(7003)
                  , st = __webpack_require__(3379)
                  , lt = __webpack_require__.n(st)
                  , ct = __webpack_require__(7795)
                  , dt = __webpack_require__.n(ct)
                  , pt = __webpack_require__(569)
                  , ht = __webpack_require__.n(pt)
                  , mt = __webpack_require__(3565)
                  , yt = __webpack_require__.n(mt)
                  , Et = __webpack_require__(9216)
                  , _t = __webpack_require__.n(Et)
                  , wt = __webpack_require__(4589)
                  , St = __webpack_require__.n(wt)
                  , Ct = __webpack_require__(7558)
                  , Nt = {};
                Ct.Z && Ct.Z.locals && (Nt.locals = Ct.Z.locals);
                var Lt, kt = 0, Ut = {};
                Ut.styleTagTransform = St(),
                Ut.setAttributes = yt(),
                Ut.insert = ht().bind(null, "head"),
                Ut.domAPI = dt(),
                Ut.insertStyleElement = _t(),
                Nt.use = function(At) {
                    return Ut.options = At || {},
                    kt++ || (Lt = lt()(Ct.Z, Ut)),
                    Nt
                }
                ,
                Nt.unuse = function() {
                    kt > 0 && !--kt && (Lt(),
                    Lt = null)
                }
                ;
                var Jt = Nt;
                function Pt(At) {
                    var Tt, vt, bt, Rt;
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.fLW)("vConsole"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-switch"),
                            (0,
                            it.czc)(Tt, "right", At[2].x + "px"),
                            (0,
                            it.czc)(Tt, "bottom", At[2].y + "px"),
                            (0,
                            it.czc)(Tt, "display", At[0] ? "block" : "none")
                        },
                        m: function(It, Bt) {
                            (0,
                            it.$Tr)(It, Tt, Bt),
                            (0,
                            it.R3I)(Tt, vt),
                            At[8](Tt),
                            bt || (Rt = [(0,
                            it.oLt)(Tt, "touchstart", At[3], {
                                passive: !1
                            }), (0,
                            it.oLt)(Tt, "touchend", At[4], {
                                passive: !1
                            }), (0,
                            it.oLt)(Tt, "touchmove", At[5], {
                                passive: !1
                            }), (0,
                            it.oLt)(Tt, "click", At[7])],
                            bt = !0)
                        },
                        p: function(It, Bt) {
                            var Zt = Bt[0];
                            4 & Zt && (0,
                            it.czc)(Tt, "right", It[2].x + "px"),
                            4 & Zt && (0,
                            it.czc)(Tt, "bottom", It[2].y + "px"),
                            1 & Zt && (0,
                            it.czc)(Tt, "display", It[0] ? "block" : "none")
                        },
                        i: it.ZTd,
                        o: it.ZTd,
                        d: function(It) {
                            It && (0,
                            it.ogt)(Tt),
                            At[8](null),
                            bt = !1,
                            (0,
                            it.j7q)(Rt)
                        }
                    }
                }
                function Xt(At, Tt, vt) {
                    var bt, Rt = Tt.show, It = Rt === void 0 || Rt, Bt = Tt.position, Zt = Bt === void 0 ? {
                        x: 0,
                        y: 0
                    } : Bt, tn = {
                        hasMoved: !1,
                        x: 0,
                        y: 0,
                        startX: 0,
                        startY: 0,
                        endX: 0,
                        endY: 0
                    }, dn = {
                        x: 0,
                        y: 0
                    };
                    (0,
                    ot.H3)(function() {
                        Jt.use()
                    }),
                    (0,
                    ot.ev)(function() {
                        Jt.unuse()
                    });
                    var mn = function(yn, On) {
                        var An = Sn(yn, On);
                        yn = An[0],
                        On = An[1],
                        tn.x = yn,
                        tn.y = On,
                        vt(2, dn.x = yn, dn),
                        vt(2, dn.y = On, dn),
                        $.po("switch_x", yn + ""),
                        $.po("switch_y", On + "")
                    }
                      , Sn = function(yn, On) {
                        var An = Math.max(document.documentElement.offsetWidth, window.innerWidth)
                          , Nn = Math.max(document.documentElement.offsetHeight, window.innerHeight);
                        return yn + bt.offsetWidth > An && (yn = An - bt.offsetWidth),
                        On + bt.offsetHeight > Nn && (On = Nn - bt.offsetHeight),
                        yn < 0 && (yn = 0),
                        On < 20 && (On = 20),
                        [yn, On]
                    };
                    return At.$$set = function(yn) {
                        "show"in yn && vt(0, It = yn.show),
                        "position"in yn && vt(6, Zt = yn.position)
                    }
                    ,
                    At.$$.update = function() {
                        66 & At.$$.dirty && bt && mn(Zt.x, Zt.y)
                    }
                    ,
                    [It, bt, dn, function(yn) {
                        tn.startX = yn.touches[0].pageX,
                        tn.startY = yn.touches[0].pageY,
                        tn.hasMoved = !1
                    }
                    , function(yn) {
                        tn.hasMoved && (tn.startX = 0,
                        tn.startY = 0,
                        tn.hasMoved = !1,
                        mn(tn.endX, tn.endY))
                    }
                    , function(yn) {
                        if (!(yn.touches.length <= 0)) {
                            var On = yn.touches[0].pageX - tn.startX
                              , An = yn.touches[0].pageY - tn.startY
                              , Nn = Math.floor(tn.x - On)
                              , Fn = Math.floor(tn.y - An)
                              , Qn = Sn(Nn, Fn);
                            Nn = Qn[0],
                            Fn = Qn[1],
                            vt(2, dn.x = Nn, dn),
                            vt(2, dn.y = Fn, dn),
                            tn.endX = Nn,
                            tn.endY = Fn,
                            tn.hasMoved = !0,
                            yn.preventDefault()
                        }
                    }
                    , Zt, function(yn) {
                        it.cKT.call(this, At, yn)
                    }
                    , function(yn) {
                        it.VnY[yn ? "unshift" : "push"](function() {
                            vt(1, bt = yn)
                        })
                    }
                    ]
                }
                var rn = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, Xt, Pt, it.N8, {
                            show: 0,
                            position: 6
                        }),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    (0,
                    _e.Z)(Tt, [{
                        key: "show",
                        get: function() {
                            return this.$$.ctx[0]
                        },
                        set: function(vt) {
                            this.$$set({
                                show: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "position",
                        get: function() {
                            return this.$$.ctx[6]
                        },
                        set: function(vt) {
                            this.$$set({
                                position: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }]),
                    Tt
                }(it.f_C)
                  , zt = rn;
                function xt(At) {
                    var Tt, vt;
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            (0,
                            it.Ljt)(Tt, "id", vt = "__vc_plug_" + At[0]),
                            (0,
                            it.Ljt)(Tt, "class", "vc-plugin-box"),
                            (0,
                            it.VHj)(Tt, "vc-fixed-height", At[1]),
                            (0,
                            it.VHj)(Tt, "vc-actived", At[2])
                        },
                        m: function(bt, Rt) {
                            (0,
                            it.$Tr)(bt, Tt, Rt),
                            At[6](Tt)
                        },
                        p: function(bt, Rt) {
                            var It = Rt[0];
                            1 & It && vt !== (vt = "__vc_plug_" + bt[0]) && (0,
                            it.Ljt)(Tt, "id", vt),
                            2 & It && (0,
                            it.VHj)(Tt, "vc-fixed-height", bt[1]),
                            4 & It && (0,
                            it.VHj)(Tt, "vc-actived", bt[2])
                        },
                        i: it.ZTd,
                        o: it.ZTd,
                        d: function(bt) {
                            bt && (0,
                            it.ogt)(Tt),
                            At[6](null)
                        }
                    }
                }
                function $t(At, Tt, vt) {
                    var bt = Tt.pluginId
                      , Rt = bt === void 0 ? "" : bt
                      , It = Tt.fixedHeight
                      , Bt = It !== void 0 && It
                      , Zt = Tt.actived
                      , tn = Zt !== void 0 && Zt
                      , dn = Tt.content
                      , mn = dn === void 0 ? void 0 : dn
                      , Sn = void 0
                      , yn = void 0;
                    return At.$$set = function(On) {
                        "pluginId"in On && vt(0, Rt = On.pluginId),
                        "fixedHeight"in On && vt(1, Bt = On.fixedHeight),
                        "actived"in On && vt(2, tn = On.actived),
                        "content"in On && vt(4, mn = On.content)
                    }
                    ,
                    At.$$.update = function() {
                        57 & At.$$.dirty && yn !== Rt && mn && Sn && (vt(5, yn = Rt),
                        vt(3, Sn.innerHTML = "", Sn),
                        (0,
                        $.HD)(mn) ? vt(3, Sn.innerHTML = mn, Sn) : (0,
                        $.kK)(mn) && Sn.appendChild(mn))
                    }
                    ,
                    [Rt, Bt, tn, Sn, mn, yn, function(On) {
                        it.VnY[On ? "unshift" : "push"](function() {
                            vt(3, Sn = On),
                            vt(5, yn),
                            vt(0, Rt),
                            vt(4, mn)
                        })
                    }
                    ]
                }
                var Dt = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, $t, xt, it.N8, {
                            pluginId: 0,
                            fixedHeight: 1,
                            actived: 2,
                            content: 4
                        }),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    (0,
                    _e.Z)(Tt, [{
                        key: "pluginId",
                        get: function() {
                            return this.$$.ctx[0]
                        },
                        set: function(vt) {
                            this.$$set({
                                pluginId: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "fixedHeight",
                        get: function() {
                            return this.$$.ctx[1]
                        },
                        set: function(vt) {
                            this.$$set({
                                fixedHeight: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "actived",
                        get: function() {
                            return this.$$.ctx[2]
                        },
                        set: function(vt) {
                            this.$$set({
                                actived: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "content",
                        get: function() {
                            return this.$$.ctx[4]
                        },
                        set: function(vt) {
                            this.$$set({
                                content: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }]),
                    Tt
                }(it.f_C)
                  , jt = Dt
                  , Ft = __webpack_require__(4687)
                  , Ht = __webpack_require__(3283)
                  , qt = {};
                Ht.Z && Ht.Z.locals && (qt.locals = Ht.Z.locals);
                var Wt, Mt = 0, Yt = {};
                Yt.styleTagTransform = St(),
                Yt.setAttributes = yt(),
                Yt.insert = ht().bind(null, "head"),
                Yt.domAPI = dt(),
                Yt.insertStyleElement = _t(),
                qt.use = function(At) {
                    return Yt.options = At || {},
                    Mt++ || (Wt = lt()(Ht.Z, Yt)),
                    qt
                }
                ,
                qt.unuse = function() {
                    Mt > 0 && !--Mt && (Wt(),
                    Wt = null)
                }
                ;
                var un = qt;
                function hn(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[39] = Tt[vt][0],
                    bt[40] = Tt[vt][1],
                    bt
                }
                function _n(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[43] = Tt[vt],
                    bt[45] = vt,
                    bt
                }
                function kn(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[39] = Tt[vt][0],
                    bt[40] = Tt[vt][1],
                    bt
                }
                function Dn(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[39] = Tt[vt][0],
                    bt[40] = Tt[vt][1],
                    bt
                }
                function jn(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[43] = Tt[vt],
                    bt[45] = vt,
                    bt
                }
                function Bn(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[39] = Tt[vt][0],
                    bt[40] = Tt[vt][1],
                    bt
                }
                function Un(At) {
                    var Tt, vt, bt, Rt, It, Bt = At[40].name + "";
                    function Zt() {
                        return At[25](At[40])
                    }
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("a"),
                            vt = (0,
                            it.fLW)(Bt),
                            (0,
                            it.Ljt)(Tt, "class", "vc-tab"),
                            (0,
                            it.Ljt)(Tt, "id", bt = "__vc_tab_" + At[40].id),
                            (0,
                            it.VHj)(Tt, "vc-actived", At[40].id === At[2])
                        },
                        m: function(tn, dn) {
                            (0,
                            it.$Tr)(tn, Tt, dn),
                            (0,
                            it.R3I)(Tt, vt),
                            Rt || (It = (0,
                            it.oLt)(Tt, "click", Zt),
                            Rt = !0)
                        },
                        p: function(tn, dn) {
                            At = tn,
                            8 & dn[0] && Bt !== (Bt = At[40].name + "") && (0,
                            it.rTO)(vt, Bt),
                            8 & dn[0] && bt !== (bt = "__vc_tab_" + At[40].id) && (0,
                            it.Ljt)(Tt, "id", bt),
                            12 & dn[0] && (0,
                            it.VHj)(Tt, "vc-actived", At[40].id === At[2])
                        },
                        d: function(tn) {
                            tn && (0,
                            it.ogt)(Tt),
                            Rt = !1,
                            It()
                        }
                    }
                }
                function Hn(At) {
                    var Tt, vt = At[40].hasTabPanel && Un(At);
                    return {
                        c: function() {
                            vt && vt.c(),
                            Tt = (0,
                            it.cSb)()
                        },
                        m: function(bt, Rt) {
                            vt && vt.m(bt, Rt),
                            (0,
                            it.$Tr)(bt, Tt, Rt)
                        },
                        p: function(bt, Rt) {
                            bt[40].hasTabPanel ? vt ? vt.p(bt, Rt) : ((vt = Un(bt)).c(),
                            vt.m(Tt.parentNode, Tt)) : vt && (vt.d(1),
                            vt = null)
                        },
                        d: function(bt) {
                            vt && vt.d(bt),
                            bt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function cr(At) {
                    var Tt, vt, bt, Rt, It, Bt = At[43].name + "";
                    function Zt() {
                        for (var tn, dn = arguments.length, mn = new Array(dn), Sn = 0; Sn < dn; Sn++)
                            mn[Sn] = arguments[Sn];
                        return (tn = At)[26].apply(tn, [At[40], At[45]].concat(mn))
                    }
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("i"),
                            vt = (0,
                            it.fLW)(Bt),
                            (0,
                            it.Ljt)(Tt, "class", bt = "vc-toptab vc-topbar-" + At[40].id + " " + At[43].className),
                            (0,
                            it.VHj)(Tt, "vc-toggle", At[40].id === At[2]),
                            (0,
                            it.VHj)(Tt, "vc-actived", At[43].actived)
                        },
                        m: function(tn, dn) {
                            (0,
                            it.$Tr)(tn, Tt, dn),
                            (0,
                            it.R3I)(Tt, vt),
                            Rt || (It = (0,
                            it.oLt)(Tt, "click", Zt),
                            Rt = !0)
                        },
                        p: function(tn, dn) {
                            At = tn,
                            8 & dn[0] && Bt !== (Bt = At[43].name + "") && (0,
                            it.rTO)(vt, Bt),
                            8 & dn[0] && bt !== (bt = "vc-toptab vc-topbar-" + At[40].id + " " + At[43].className) && (0,
                            it.Ljt)(Tt, "class", bt),
                            12 & dn[0] && (0,
                            it.VHj)(Tt, "vc-toggle", At[40].id === At[2]),
                            8 & dn[0] && (0,
                            it.VHj)(Tt, "vc-actived", At[43].actived)
                        },
                        d: function(tn) {
                            tn && (0,
                            it.ogt)(Tt),
                            Rt = !1,
                            It()
                        }
                    }
                }
                function Gn(At) {
                    for (var Tt, vt = At[40].topbarList, bt = [], Rt = 0; Rt < vt.length; Rt += 1)
                        bt[Rt] = cr(jn(At, vt, Rt));
                    return {
                        c: function() {
                            for (var It = 0; It < bt.length; It += 1)
                                bt[It].c();
                            Tt = (0,
                            it.cSb)()
                        },
                        m: function(It, Bt) {
                            for (var Zt = 0; Zt < bt.length; Zt += 1)
                                bt[Zt].m(It, Bt);
                            (0,
                            it.$Tr)(It, Tt, Bt)
                        },
                        p: function(It, Bt) {
                            if (8204 & Bt[0]) {
                                var Zt;
                                for (vt = It[40].topbarList,
                                Zt = 0; Zt < vt.length; Zt += 1) {
                                    var tn = jn(It, vt, Zt);
                                    bt[Zt] ? bt[Zt].p(tn, Bt) : (bt[Zt] = cr(tn),
                                    bt[Zt].c(),
                                    bt[Zt].m(Tt.parentNode, Tt))
                                }
                                for (; Zt < bt.length; Zt += 1)
                                    bt[Zt].d(1);
                                bt.length = vt.length
                            }
                        },
                        d: function(It) {
                            (0,
                            it.RMB)(bt, It),
                            It && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function Mn(At) {
                    var Tt, vt, bt, Rt = jt;
                    function It(Bt) {
                        var Zt;
                        return {
                            props: {
                                pluginId: Bt[40].id,
                                fixedHeight: (Zt = Bt[40].tabOptions) == null ? void 0 : Zt.fixedHeight,
                                actived: Bt[40].id === Bt[2],
                                content: Bt[40].content
                            }
                        }
                    }
                    return Rt && (Tt = new Rt(It(At))),
                    {
                        c: function() {
                            Tt && (0,
                            it.YCL)(Tt.$$.fragment),
                            vt = (0,
                            it.cSb)()
                        },
                        m: function(Bt, Zt) {
                            Tt && (0,
                            it.yef)(Tt, Bt, Zt),
                            (0,
                            it.$Tr)(Bt, vt, Zt),
                            bt = !0
                        },
                        p: function(Bt, Zt) {
                            var tn, dn = {};
                            if (8 & Zt[0] && (dn.pluginId = Bt[40].id),
                            8 & Zt[0] && (dn.fixedHeight = (tn = Bt[40].tabOptions) == null ? void 0 : tn.fixedHeight),
                            12 & Zt[0] && (dn.actived = Bt[40].id === Bt[2]),
                            8 & Zt[0] && (dn.content = Bt[40].content),
                            Rt !== (Rt = jt)) {
                                if (Tt) {
                                    (0,
                                    it.dvw)();
                                    var mn = Tt;
                                    (0,
                                    it.etI)(mn.$$.fragment, 1, 0, function() {
                                        (0,
                                        it.vpE)(mn, 1)
                                    }),
                                    (0,
                                    it.gbL)()
                                }
                                Rt ? (Tt = new Rt(It(Bt)),
                                (0,
                                it.YCL)(Tt.$$.fragment),
                                (0,
                                it.Ui)(Tt.$$.fragment, 1),
                                (0,
                                it.yef)(Tt, vt.parentNode, vt)) : Tt = null
                            } else
                                Rt && Tt.$set(dn)
                        },
                        i: function(Bt) {
                            bt || (Tt && (0,
                            it.Ui)(Tt.$$.fragment, Bt),
                            bt = !0)
                        },
                        o: function(Bt) {
                            Tt && (0,
                            it.etI)(Tt.$$.fragment, Bt),
                            bt = !1
                        },
                        d: function(Bt) {
                            Bt && (0,
                            it.ogt)(vt),
                            Tt && (0,
                            it.vpE)(Tt, Bt)
                        }
                    }
                }
                function rr(At) {
                    var Tt, vt, bt, Rt, It, Bt = At[43].name + "";
                    function Zt() {
                        for (var tn, dn = arguments.length, mn = new Array(dn), Sn = 0; Sn < dn; Sn++)
                            mn[Sn] = arguments[Sn];
                        return (tn = At)[28].apply(tn, [At[40], At[45]].concat(mn))
                    }
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("i"),
                            vt = (0,
                            it.fLW)(Bt),
                            (0,
                            it.Ljt)(Tt, "class", bt = "vc-tool vc-tool-" + At[40].id),
                            (0,
                            it.VHj)(Tt, "vc-global-tool", At[43].global),
                            (0,
                            it.VHj)(Tt, "vc-toggle", At[40].id === At[2])
                        },
                        m: function(tn, dn) {
                            (0,
                            it.$Tr)(tn, Tt, dn),
                            (0,
                            it.R3I)(Tt, vt),
                            Rt || (It = (0,
                            it.oLt)(Tt, "click", Zt),
                            Rt = !0)
                        },
                        p: function(tn, dn) {
                            At = tn,
                            8 & dn[0] && Bt !== (Bt = At[43].name + "") && (0,
                            it.rTO)(vt, Bt),
                            8 & dn[0] && bt !== (bt = "vc-tool vc-tool-" + At[40].id) && (0,
                            it.Ljt)(Tt, "class", bt),
                            8 & dn[0] && (0,
                            it.VHj)(Tt, "vc-global-tool", At[43].global),
                            12 & dn[0] && (0,
                            it.VHj)(Tt, "vc-toggle", At[40].id === At[2])
                        },
                        d: function(tn) {
                            tn && (0,
                            it.ogt)(Tt),
                            Rt = !1,
                            It()
                        }
                    }
                }
                function Zn(At) {
                    for (var Tt, vt = At[40].toolbarList, bt = [], Rt = 0; Rt < vt.length; Rt += 1)
                        bt[Rt] = rr(_n(At, vt, Rt));
                    return {
                        c: function() {
                            for (var It = 0; It < bt.length; It += 1)
                                bt[It].c();
                            Tt = (0,
                            it.cSb)()
                        },
                        m: function(It, Bt) {
                            for (var Zt = 0; Zt < bt.length; Zt += 1)
                                bt[Zt].m(It, Bt);
                            (0,
                            it.$Tr)(It, Tt, Bt)
                        },
                        p: function(It, Bt) {
                            if (16396 & Bt[0]) {
                                var Zt;
                                for (vt = It[40].toolbarList,
                                Zt = 0; Zt < vt.length; Zt += 1) {
                                    var tn = _n(It, vt, Zt);
                                    bt[Zt] ? bt[Zt].p(tn, Bt) : (bt[Zt] = rr(tn),
                                    bt[Zt].c(),
                                    bt[Zt].m(Tt.parentNode, Tt))
                                }
                                for (; Zt < bt.length; Zt += 1)
                                    bt[Zt].d(1);
                                bt.length = vt.length
                            }
                        },
                        d: function(It) {
                            (0,
                            it.RMB)(bt, It),
                            It && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function pr(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt, tn, dn, mn, Sn, yn, On, An, Nn, Fn, Qn, er, fr, Nr, Rr;
                    function _i(Sr) {
                        At[23](Sr)
                    }
                    function eo(Sr) {
                        At[24](Sr)
                    }
                    var Gr = {};
                    At[0] !== void 0 && (Gr.show = At[0]),
                    At[1] !== void 0 && (Gr.position = At[1]),
                    vt = new zt({
                        props: Gr
                    }),
                    it.VnY.push(function() {
                        return (0,
                        it.akz)(vt, "show", _i)
                    }),
                    it.VnY.push(function() {
                        return (0,
                        it.akz)(vt, "position", eo)
                    }),
                    vt.$on("click", At[10]);
                    for (var Ar = Object.entries(At[3]), Or = [], Fr = 0; Fr < Ar.length; Fr += 1)
                        Or[Fr] = Hn(Bn(At, Ar, Fr));
                    for (var Vo = Object.entries(At[3]), lo = [], to = 0; to < Vo.length; to += 1)
                        lo[to] = Gn(Dn(At, Vo, to));
                    for (var Kr = Object.entries(At[3]), mr = [], _r = 0; _r < Kr.length; _r += 1)
                        mr[_r] = Mn(kn(At, Kr, _r));
                    for (var vo = function(Sr) {
                        return (0,
                        it.etI)(mr[Sr], 1, 1, function() {
                            mr[Sr] = null
                        })
                    }, ar = Object.entries(At[3]), $r = [], Vr = 0; Vr < ar.length; Vr += 1)
                        $r[Vr] = Zn(hn(At, ar, Vr));
                    return {
                        c: function() {
                            var Sr, Wr;
                            Tt = (0,
                            it.bGB)("div"),
                            (0,
                            it.YCL)(vt.$$.fragment),
                            It = (0,
                            it.DhX)(),
                            Bt = (0,
                            it.bGB)("div"),
                            Zt = (0,
                            it.DhX)(),
                            tn = (0,
                            it.bGB)("div"),
                            dn = (0,
                            it.bGB)("div");
                            for (var Po = 0; Po < Or.length; Po += 1)
                                Or[Po].c();
                            mn = (0,
                            it.DhX)(),
                            Sn = (0,
                            it.bGB)("div");
                            for (var Wo = 0; Wo < lo.length; Wo += 1)
                                lo[Wo].c();
                            yn = (0,
                            it.DhX)(),
                            On = (0,
                            it.bGB)("div");
                            for (var es = 0; es < mr.length; es += 1)
                                mr[es].c();
                            An = (0,
                            it.DhX)(),
                            Nn = (0,
                            it.bGB)("div");
                            for (var so = 0; so < $r.length; so += 1)
                                $r[so].c();
                            Fn = (0,
                            it.DhX)(),
                            (Qn = (0,
                            it.bGB)("i")).textContent = "Hide",
                            (0,
                            it.Ljt)(Bt, "class", "vc-mask"),
                            (0,
                            it.czc)(Bt, "display", At[8] ? "block" : "none"),
                            (0,
                            it.Ljt)(dn, "class", "vc-tabbar"),
                            (0,
                            it.Ljt)(Sn, "class", "vc-topbar"),
                            (0,
                            it.Ljt)(On, "class", "vc-content"),
                            (0,
                            it.VHj)(On, "vc-has-topbar", ((Sr = At[3][At[2]]) == null || (Wr = Sr.topbarList) == null ? void 0 : Wr.length) > 0),
                            (0,
                            it.Ljt)(Qn, "class", "vc-tool vc-global-tool vc-tool-last vc-hide"),
                            (0,
                            it.Ljt)(Nn, "class", "vc-toolbar"),
                            (0,
                            it.Ljt)(tn, "class", "vc-panel"),
                            (0,
                            it.czc)(tn, "display", At[7] ? "block" : "none"),
                            (0,
                            it.Ljt)(Tt, "id", "__vconsole"),
                            (0,
                            it.Ljt)(Tt, "style", er = At[5] ? "font-size:" + At[5] + ";" : ""),
                            (0,
                            it.Ljt)(Tt, "data-theme", At[4]),
                            (0,
                            it.VHj)(Tt, "vc-toggle", At[6])
                        },
                        m: function(Sr, Wr) {
                            (0,
                            it.$Tr)(Sr, Tt, Wr),
                            (0,
                            it.yef)(vt, Tt, null),
                            (0,
                            it.R3I)(Tt, It),
                            (0,
                            it.R3I)(Tt, Bt),
                            (0,
                            it.R3I)(Tt, Zt),
                            (0,
                            it.R3I)(Tt, tn),
                            (0,
                            it.R3I)(tn, dn);
                            for (var Po = 0; Po < Or.length; Po += 1)
                                Or[Po].m(dn, null);
                            (0,
                            it.R3I)(tn, mn),
                            (0,
                            it.R3I)(tn, Sn);
                            for (var Wo = 0; Wo < lo.length; Wo += 1)
                                lo[Wo].m(Sn, null);
                            (0,
                            it.R3I)(tn, yn),
                            (0,
                            it.R3I)(tn, On);
                            for (var es = 0; es < mr.length; es += 1)
                                mr[es].m(On, null);
                            At[27](On),
                            (0,
                            it.R3I)(tn, An),
                            (0,
                            it.R3I)(tn, Nn);
                            for (var so = 0; so < $r.length; so += 1)
                                $r[so].m(Nn, null);
                            (0,
                            it.R3I)(Nn, Fn),
                            (0,
                            it.R3I)(Nn, Qn),
                            fr = !0,
                            Nr || (Rr = [(0,
                            it.oLt)(Bt, "click", At[11]), (0,
                            it.oLt)(On, "touchstart", At[15]), (0,
                            it.oLt)(On, "touchmove", At[16]), (0,
                            it.oLt)(On, "touchend", At[17]), (0,
                            it.oLt)(On, "scroll", At[18]), (0,
                            it.oLt)(Qn, "click", At[11]), (0,
                            it.oLt)(Tt, "touchstart", At[19].touchStart, {
                                passive: !1,
                                capture: !0
                            }), (0,
                            it.oLt)(Tt, "touchmove", At[19].touchMove, {
                                passive: !1,
                                capture: !0
                            }), (0,
                            it.oLt)(Tt, "touchend", At[19].touchEnd, {
                                passive: !1,
                                capture: !0
                            })],
                            Nr = !0)
                        },
                        p: function(Sr, Wr) {
                            var Po, Wo, es = {};
                            if (!bt && 1 & Wr[0] && (bt = !0,
                            es.show = Sr[0],
                            (0,
                            it.hjT)(function() {
                                return bt = !1
                            })),
                            !Rt && 2 & Wr[0] && (Rt = !0,
                            es.position = Sr[1],
                            (0,
                            it.hjT)(function() {
                                return Rt = !1
                            })),
                            vt.$set(es),
                            (!fr || 256 & Wr[0]) && (0,
                            it.czc)(Bt, "display", Sr[8] ? "block" : "none"),
                            4108 & Wr[0]) {
                                var so;
                                for (Ar = Object.entries(Sr[3]),
                                so = 0; so < Ar.length; so += 1) {
                                    var gs = Bn(Sr, Ar, so);
                                    Or[so] ? Or[so].p(gs, Wr) : (Or[so] = Hn(gs),
                                    Or[so].c(),
                                    Or[so].m(dn, null))
                                }
                                for (; so < Or.length; so += 1)
                                    Or[so].d(1);
                                Or.length = Ar.length
                            }
                            if (8204 & Wr[0]) {
                                var Do;
                                for (Vo = Object.entries(Sr[3]),
                                Do = 0; Do < Vo.length; Do += 1) {
                                    var Bo = Dn(Sr, Vo, Do);
                                    lo[Do] ? lo[Do].p(Bo, Wr) : (lo[Do] = Gn(Bo),
                                    lo[Do].c(),
                                    lo[Do].m(Sn, null))
                                }
                                for (; Do < lo.length; Do += 1)
                                    lo[Do].d(1);
                                lo.length = Vo.length
                            }
                            if (12 & Wr[0]) {
                                var Uo;
                                for (Kr = Object.entries(Sr[3]),
                                Uo = 0; Uo < Kr.length; Uo += 1) {
                                    var Ts = kn(Sr, Kr, Uo);
                                    mr[Uo] ? (mr[Uo].p(Ts, Wr),
                                    (0,
                                    it.Ui)(mr[Uo], 1)) : (mr[Uo] = Mn(Ts),
                                    mr[Uo].c(),
                                    (0,
                                    it.Ui)(mr[Uo], 1),
                                    mr[Uo].m(On, null))
                                }
                                for ((0,
                                it.dvw)(),
                                Uo = Kr.length; Uo < mr.length; Uo += 1)
                                    vo(Uo);
                                (0,
                                it.gbL)()
                            }
                            if (12 & Wr[0] && (0,
                            it.VHj)(On, "vc-has-topbar", ((Po = Sr[3][Sr[2]]) == null || (Wo = Po.topbarList) == null ? void 0 : Wo.length) > 0),
                            16396 & Wr[0]) {
                                var Go;
                                for (ar = Object.entries(Sr[3]),
                                Go = 0; Go < ar.length; Go += 1) {
                                    var Rs = hn(Sr, ar, Go);
                                    $r[Go] ? $r[Go].p(Rs, Wr) : ($r[Go] = Zn(Rs),
                                    $r[Go].c(),
                                    $r[Go].m(Nn, Fn))
                                }
                                for (; Go < $r.length; Go += 1)
                                    $r[Go].d(1);
                                $r.length = ar.length
                            }
                            (!fr || 128 & Wr[0]) && (0,
                            it.czc)(tn, "display", Sr[7] ? "block" : "none"),
                            (!fr || 32 & Wr[0] && er !== (er = Sr[5] ? "font-size:" + Sr[5] + ";" : "")) && (0,
                            it.Ljt)(Tt, "style", er),
                            (!fr || 16 & Wr[0]) && (0,
                            it.Ljt)(Tt, "data-theme", Sr[4]),
                            64 & Wr[0] && (0,
                            it.VHj)(Tt, "vc-toggle", Sr[6])
                        },
                        i: function(Sr) {
                            if (!fr) {
                                (0,
                                it.Ui)(vt.$$.fragment, Sr);
                                for (var Wr = 0; Wr < Kr.length; Wr += 1)
                                    (0,
                                    it.Ui)(mr[Wr]);
                                fr = !0
                            }
                        },
                        o: function(Sr) {
                            (0,
                            it.etI)(vt.$$.fragment, Sr),
                            mr = mr.filter(Boolean);
                            for (var Wr = 0; Wr < mr.length; Wr += 1)
                                (0,
                                it.etI)(mr[Wr]);
                            fr = !1
                        },
                        d: function(Sr) {
                            Sr && (0,
                            it.ogt)(Tt),
                            (0,
                            it.vpE)(vt),
                            (0,
                            it.RMB)(Or, Sr),
                            (0,
                            it.RMB)(lo, Sr),
                            (0,
                            it.RMB)(mr, Sr),
                            At[27](null),
                            (0,
                            it.RMB)($r, Sr),
                            Nr = !1,
                            (0,
                            it.j7q)(Rr)
                        }
                    }
                }
                function Ur(At, Tt, vt) {
                    var bt, Rt, It = Tt.theme, Bt = It === void 0 ? "" : It, Zt = Tt.disableScrolling, tn = Zt !== void 0 && Zt, dn = Tt.show, mn = dn !== void 0 && dn, Sn = Tt.showSwitchButton, yn = Sn === void 0 || Sn, On = Tt.switchButtonPosition, An = On === void 0 ? {
                        x: 0,
                        y: 0
                    } : On, Nn = Tt.activedPluginId, Fn = Nn === void 0 ? "" : Nn, Qn = Tt.pluginList, er = Qn === void 0 ? {} : Qn, fr = (0,
                    ot.x)(), Nr = !1, Rr = "", _i = !1, eo = !1, Gr = !1, Ar = !0, Or = 0, Fr = null, Vo = {};
                    (0,
                    ot.H3)(function() {
                        var ar = document.querySelectorAll('[name="viewport"]');
                        if (ar && ar[0]) {
                            var $r = (ar[ar.length - 1].getAttribute("content") || "").match(/initial\-scale\=\d+(\.\d+)?/)
                              , Vr = $r ? parseFloat($r[0].split("=")[1]) : 1;
                            Vr !== 1 && vt(5, Rr = Math.floor(1 / Vr * 13) + "px")
                        }
                        un.use && un.use(),
                        bt = Ft.x.subscribe(function(Sr) {
                            mn && Or !== Sr.updateTime && (Or = Sr.updateTime,
                            lo())
                        })
                    }),
                    (0,
                    ot.ev)(function() {
                        un.unuse && un.unuse(),
                        bt && bt()
                    });
                    var lo = function() {
                        !tn && Ar && Rt && vt(9, Rt.scrollTop = Rt.scrollHeight - Rt.offsetHeight, Rt)
                    }
                      , to = function(ar) {
                        ar !== Fn && (vt(2, Fn = ar),
                        fr("changePanel", {
                            pluginId: ar
                        }),
                        setTimeout(function() {
                            Rt && vt(9, Rt.scrollTop = Vo[Fn] || 0, Rt)
                        }, 0))
                    }
                      , Kr = function(ar, $r, Vr) {
                        var Sr = er[$r].topbarList[Vr]
                          , Wr = !0;
                        if ($.mf(Sr.onClick) && (Wr = Sr.onClick.call(ar.target, ar, Sr.data)),
                        Wr !== !1) {
                            for (var Po = 0; Po < er[$r].topbarList.length; Po++)
                                vt(3, er[$r].topbarList[Po].actived = Vr === Po, er);
                            vt(3, er)
                        }
                    }
                      , mr = function(ar, $r, Vr) {
                        var Sr = er[$r].toolbarList[Vr];
                        $.mf(Sr.onClick) && Sr.onClick.call(ar.target, ar, Sr.data)
                    }
                      , _r = {
                        tapTime: 700,
                        tapBoundary: 10,
                        lastTouchStartTime: 0,
                        touchstartX: 0,
                        touchstartY: 0,
                        touchHasMoved: !1,
                        targetElem: null
                    }
                      , vo = {
                        touchStart: function(ar) {
                            if (_r.lastTouchStartTime === 0) {
                                var $r = ar.targetTouches[0];
                                _r.touchstartX = $r.pageX,
                                _r.touchstartY = $r.pageY,
                                _r.lastTouchStartTime = ar.timeStamp,
                                _r.targetElem = ar.target.nodeType === Node.TEXT_NODE ? ar.target.parentNode : ar.target
                            }
                        },
                        touchMove: function(ar) {
                            var $r = ar.changedTouches[0];
                            (Math.abs($r.pageX - _r.touchstartX) > _r.tapBoundary || Math.abs($r.pageY - _r.touchstartY) > _r.tapBoundary) && (_r.touchHasMoved = !0)
                        },
                        touchEnd: function(ar) {
                            if (_r.touchHasMoved === !1 && ar.timeStamp - _r.lastTouchStartTime < _r.tapTime && _r.targetElem != null) {
                                var $r = !1;
                                switch (_r.targetElem.tagName.toLowerCase()) {
                                case "textarea":
                                    $r = !0;
                                    break;
                                case "select":
                                    $r = !_r.targetElem.disabled && !_r.targetElem.readOnly;
                                    break;
                                case "input":
                                    switch (_r.targetElem.type) {
                                    case "button":
                                    case "checkbox":
                                    case "file":
                                    case "image":
                                    case "radio":
                                    case "submit":
                                        $r = !1;
                                        break;
                                    default:
                                        $r = !_r.targetElem.disabled && !_r.targetElem.readOnly
                                    }
                                }
                                $r ? _r.targetElem.focus() : ar.preventDefault();
                                var Vr = ar.changedTouches[0]
                                  , Sr = new MouseEvent("click",{
                                    bubbles: !0,
                                    cancelable: !0,
                                    view: window,
                                    screenX: Vr.screenX,
                                    screenY: Vr.screenY,
                                    clientX: Vr.clientX,
                                    clientY: Vr.clientY
                                });
                                _r.targetElem.dispatchEvent(Sr)
                            }
                            _r.lastTouchStartTime = 0,
                            _r.touchHasMoved = !1,
                            _r.targetElem = null
                        }
                    };
                    return At.$$set = function(ar) {
                        "theme"in ar && vt(4, Bt = ar.theme),
                        "disableScrolling"in ar && vt(20, tn = ar.disableScrolling),
                        "show"in ar && vt(21, mn = ar.show),
                        "showSwitchButton"in ar && vt(0, yn = ar.showSwitchButton),
                        "switchButtonPosition"in ar && vt(1, An = ar.switchButtonPosition),
                        "activedPluginId"in ar && vt(2, Fn = ar.activedPluginId),
                        "pluginList"in ar && vt(3, er = ar.pluginList)
                    }
                    ,
                    At.$$.update = function() {
                        6291456 & At.$$.dirty[0] && (mn === !0 ? (vt(7, eo = !0),
                        vt(8, Gr = !0),
                        Fr && clearTimeout(Fr),
                        vt(22, Fr = setTimeout(function() {
                            vt(6, _i = !0),
                            lo()
                        }, 10))) : (vt(6, _i = !1),
                        Fr && clearTimeout(Fr),
                        vt(22, Fr = setTimeout(function() {
                            vt(7, eo = !1),
                            vt(8, Gr = !1)
                        }, 330))))
                    }
                    ,
                    [yn, An, Fn, er, Bt, Rr, _i, eo, Gr, Rt, function(ar) {
                        fr("show", {
                            show: !0
                        })
                    }
                    , function(ar) {
                        fr("show", {
                            show: !1
                        })
                    }
                    , to, Kr, mr, function(ar) {
                        if (!(ar.target.tagName === "INPUT" || ar.target.tagName === "TEXTAREA")) {
                            var $r = !1;
                            if (typeof window.getComputedStyle == "function") {
                                var Vr = window.getComputedStyle(ar.target);
                                Vr.overflow !== "auto" && Vr.overflow !== "initial" && Vr.overflow !== "scroll" || ($r = !0)
                            }
                            if (!$r) {
                                var Sr = Rt.scrollTop
                                  , Wr = Rt.scrollHeight
                                  , Po = Sr + Rt.offsetHeight;
                                Sr === 0 ? (vt(9, Rt.scrollTop = 1, Rt),
                                Rt.scrollTop === 0 && (Nr = !0)) : Po === Wr && (vt(9, Rt.scrollTop = Sr - 1, Rt),
                                Rt.scrollTop === Sr && (Nr = !0))
                            }
                        }
                    }
                    , function(ar) {
                        Nr && ar.preventDefault()
                    }
                    , function(ar) {
                        Nr = !1
                    }
                    , function(ar) {
                        mn && (Ar = Rt.scrollTop + Rt.offsetHeight >= Rt.scrollHeight - 50,
                        Vo[Fn] = Rt.scrollTop)
                    }
                    , vo, tn, mn, Fr, function(ar) {
                        vt(0, yn = ar)
                    }
                    , function(ar) {
                        vt(1, An = ar)
                    }
                    , function(ar) {
                        return to(ar.id)
                    }
                    , function(ar, $r, Vr) {
                        return Kr(Vr, ar.id, $r)
                    }
                    , function(ar) {
                        it.VnY[ar ? "unshift" : "push"](function() {
                            vt(9, Rt = ar)
                        })
                    }
                    , function(ar, $r, Vr) {
                        return mr(Vr, ar.id, $r)
                    }
                    ]
                }
                var xr = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, Ur, pr, it.N8, {
                            theme: 4,
                            disableScrolling: 20,
                            show: 21,
                            showSwitchButton: 0,
                            switchButtonPosition: 1,
                            activedPluginId: 2,
                            pluginList: 3
                        }, null, [-1, -1]),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    (0,
                    _e.Z)(Tt, [{
                        key: "theme",
                        get: function() {
                            return this.$$.ctx[4]
                        },
                        set: function(vt) {
                            this.$$set({
                                theme: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "disableScrolling",
                        get: function() {
                            return this.$$.ctx[20]
                        },
                        set: function(vt) {
                            this.$$set({
                                disableScrolling: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "show",
                        get: function() {
                            return this.$$.ctx[21]
                        },
                        set: function(vt) {
                            this.$$set({
                                show: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "showSwitchButton",
                        get: function() {
                            return this.$$.ctx[0]
                        },
                        set: function(vt) {
                            this.$$set({
                                showSwitchButton: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "switchButtonPosition",
                        get: function() {
                            return this.$$.ctx[1]
                        },
                        set: function(vt) {
                            this.$$set({
                                switchButtonPosition: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "activedPluginId",
                        get: function() {
                            return this.$$.ctx[2]
                        },
                        set: function(vt) {
                            this.$$set({
                                activedPluginId: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "pluginList",
                        get: function() {
                            return this.$$.ctx[3]
                        },
                        set: function(vt) {
                            this.$$set({
                                pluginList: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }]),
                    Tt
                }(it.f_C)
                  , wr = xr
                  , Rn = function() {
                    function At(vt, bt) {
                        bt === void 0 && (bt = "newPlugin"),
                        this.isReady = !1,
                        this.eventMap = new Map,
                        this.exporter = void 0,
                        this._id = void 0,
                        this._name = void 0,
                        this._vConsole = void 0,
                        this.id = vt,
                        this.name = bt,
                        this.isReady = !1
                    }
                    var Tt = At.prototype;
                    return Tt.on = function(vt, bt) {
                        return this.eventMap.set(vt, bt),
                        this
                    }
                    ,
                    Tt.onRemove = function() {
                        this.unbindExporter()
                    }
                    ,
                    Tt.trigger = function(vt, bt) {
                        var Rt = this.eventMap.get(vt);
                        if (typeof Rt == "function")
                            Rt.call(this, bt);
                        else {
                            var It = "on" + vt.charAt(0).toUpperCase() + vt.slice(1);
                            typeof this[It] == "function" && this[It].call(this, bt)
                        }
                        return this
                    }
                    ,
                    Tt.bindExporter = function() {
                        if (this._vConsole && this.exporter) {
                            var vt = this.id === "default" ? "log" : this.id;
                            this._vConsole[vt] = this.exporter
                        }
                    }
                    ,
                    Tt.unbindExporter = function() {
                        var vt = this.id === "default" ? "log" : this.id;
                        this._vConsole && this._vConsole[vt] && (this._vConsole[vt] = void 0)
                    }
                    ,
                    Tt.getUniqueID = function(vt) {
                        return vt === void 0 && (vt = ""),
                        (0,
                        $.QI)(vt)
                    }
                    ,
                    (0,
                    _e.Z)(At, [{
                        key: "id",
                        get: function() {
                            return this._id
                        },
                        set: function(vt) {
                            if (typeof vt != "string")
                                throw "[vConsole] Plugin ID must be a string.";
                            if (!vt)
                                throw "[vConsole] Plugin ID cannot be empty.";
                            this._id = vt.toLowerCase()
                        }
                    }, {
                        key: "name",
                        get: function() {
                            return this._name
                        },
                        set: function(vt) {
                            if (typeof vt != "string")
                                throw "[vConsole] Plugin name must be a string.";
                            if (!vt)
                                throw "[vConsole] Plugin name cannot be empty.";
                            this._name = vt
                        }
                    }, {
                        key: "vConsole",
                        get: function() {
                            return this._vConsole || void 0
                        },
                        set: function(vt) {
                            if (!vt)
                                throw "[vConsole] vConsole cannot be empty";
                            this._vConsole = vt,
                            this.bindExporter()
                        }
                    }]),
                    At
                }()
                  , Vn = function(At) {
                    function Tt(bt, Rt, It, Bt) {
                        var Zt;
                        return (Zt = At.call(this, bt, Rt) || this).CompClass = void 0,
                        Zt.compInstance = void 0,
                        Zt.initialProps = void 0,
                        Zt.CompClass = It,
                        Zt.initialProps = Bt,
                        Zt
                    }
                    (0,
                    rt.Z)(Tt, At);
                    var vt = Tt.prototype;
                    return vt.onReady = function() {
                        this.isReady = !0
                    }
                    ,
                    vt.onRenderTab = function(bt) {
                        var Rt = document.createElement("div")
                          , It = this.compInstance = new this.CompClass({
                            target: Rt,
                            props: this.initialProps
                        });
                        bt(Rt.firstElementChild, It.options)
                    }
                    ,
                    vt.onRemove = function() {
                        At.prototype.onRemove && At.prototype.onRemove.call(this),
                        this.compInstance && this.compInstance.$destroy()
                    }
                    ,
                    Tt
                }(Rn)
                  , qn = __webpack_require__(8665)
                  , dr = __webpack_require__(9923)
                  , or = __webpack_require__(8702);
                function ir(At) {
                    var Tt, vt;
                    return (Tt = new or.Z({
                        props: {
                            name: At[0] ? "success" : "copy"
                        }
                    })).$on("click", At[1]),
                    {
                        c: function() {
                            (0,
                            it.YCL)(Tt.$$.fragment)
                        },
                        m: function(bt, Rt) {
                            (0,
                            it.yef)(Tt, bt, Rt),
                            vt = !0
                        },
                        p: function(bt, Rt) {
                            var It = {};
                            1 & Rt[0] && (It.name = bt[0] ? "success" : "copy"),
                            Tt.$set(It)
                        },
                        i: function(bt) {
                            vt || ((0,
                            it.Ui)(Tt.$$.fragment, bt),
                            vt = !0)
                        },
                        o: function(bt) {
                            (0,
                            it.etI)(Tt.$$.fragment, bt),
                            vt = !1
                        },
                        d: function(bt) {
                            (0,
                            it.vpE)(Tt, bt)
                        }
                    }
                }
                function Cr(At, Tt, vt) {
                    var bt = Tt.content
                      , Rt = bt === void 0 ? "" : bt
                      , It = Tt.handler
                      , Bt = It === void 0 ? void 0 : It
                      , Zt = {
                        target: document.documentElement
                    }
                      , tn = !1;
                    return At.$$set = function(dn) {
                        "content"in dn && vt(2, Rt = dn.content),
                        "handler"in dn && vt(3, Bt = dn.handler)
                    }
                    ,
                    [tn, function(dn) {
                        (function(mn, Sn) {
                            var yn = (Sn === void 0 ? {} : Sn).target
                              , On = yn === void 0 ? document.body : yn
                              , An = document.createElement("textarea")
                              , Nn = document.activeElement;
                            An.value = mn,
                            An.setAttribute("readonly", ""),
                            An.style.contain = "strict",
                            An.style.position = "absolute",
                            An.style.left = "-9999px",
                            An.style.fontSize = "12pt";
                            var Fn = document.getSelection()
                              , Qn = !1;
                            Fn.rangeCount > 0 && (Qn = Fn.getRangeAt(0)),
                            On.append(An),
                            An.select(),
                            An.selectionStart = 0,
                            An.selectionEnd = mn.length;
                            var er = !1;
                            try {
                                er = document.execCommand("copy")
                            } catch {}
                            An.remove(),
                            Qn && (Fn.removeAllRanges(),
                            Fn.addRange(Qn)),
                            Nn && Nn.focus()
                        }
                        )($.mf(Bt) ? Bt(Rt) || "" : $.Kn(Rt) || $.kJ(Rt) ? $.hZ(Rt, {
                            maxDepth: 10,
                            keyMaxLen: 1e4,
                            pretty: !1,
                            standardJSON: !0
                        }) : Rt, Zt),
                        vt(0, tn = !0),
                        setTimeout(function() {
                            vt(0, tn = !1)
                        }, 600)
                    }
                    , Rt, Bt]
                }
                var br = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, Cr, ir, it.N8, {
                            content: 2,
                            handler: 3
                        }),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    (0,
                    _e.Z)(Tt, [{
                        key: "content",
                        get: function() {
                            return this.$$.ctx[2]
                        },
                        set: function(vt) {
                            this.$$set({
                                content: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "handler",
                        get: function() {
                            return this.$$.ctx[3]
                        },
                        set: function(vt) {
                            this.$$set({
                                handler: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }]),
                    Tt
                }(it.f_C)
                  , an = br
                  , Kt = __webpack_require__(845)
                  , Gt = {};
                Kt.Z && Kt.Z.locals && (Gt.locals = Kt.Z.locals);
                var fn, En = 0, vn = {};
                vn.styleTagTransform = St(),
                vn.setAttributes = yt(),
                vn.insert = ht().bind(null, "head"),
                vn.domAPI = dt(),
                vn.insertStyleElement = _t(),
                Gt.use = function(At) {
                    return vn.options = At || {},
                    En++ || (fn = lt()(Kt.Z, vn)),
                    Gt
                }
                ,
                Gt.unuse = function() {
                    En > 0 && !--En && (fn(),
                    fn = null)
                }
                ;
                var Tn = Gt;
                function sr(At) {
                    var Tt, vt, bt, Rt = $.rE(At[1]) + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("i"),
                            vt = (0,
                            it.fLW)(Rt),
                            bt = (0,
                            it.fLW)(":"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-log-key"),
                            (0,
                            it.VHj)(Tt, "vc-log-key-symbol", At[2] === "symbol"),
                            (0,
                            it.VHj)(Tt, "vc-log-key-private", At[2] === "private")
                        },
                        m: function(It, Bt) {
                            (0,
                            it.$Tr)(It, Tt, Bt),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.$Tr)(It, bt, Bt)
                        },
                        p: function(It, Bt) {
                            2 & Bt && Rt !== (Rt = $.rE(It[1]) + "") && (0,
                            it.rTO)(vt, Rt),
                            4 & Bt && (0,
                            it.VHj)(Tt, "vc-log-key-symbol", It[2] === "symbol"),
                            4 & Bt && (0,
                            it.VHj)(Tt, "vc-log-key-private", It[2] === "private")
                        },
                        d: function(It) {
                            It && (0,
                            it.ogt)(Tt),
                            It && (0,
                            it.ogt)(bt)
                        }
                    }
                }
                function lr(At) {
                    var Tt, vt, bt, Rt, It = At[1] !== void 0 && sr(At);
                    return {
                        c: function() {
                            It && It.c(),
                            Tt = (0,
                            it.DhX)(),
                            vt = (0,
                            it.bGB)("i"),
                            bt = (0,
                            it.fLW)(At[3]),
                            (0,
                            it.Ljt)(vt, "class", Rt = "vc-log-val vc-log-val-" + At[4]),
                            (0,
                            it.Ljt)(vt, "style", At[0]),
                            (0,
                            it.VHj)(vt, "vc-log-val-haskey", At[1] !== void 0)
                        },
                        m: function(Bt, Zt) {
                            It && It.m(Bt, Zt),
                            (0,
                            it.$Tr)(Bt, Tt, Zt),
                            (0,
                            it.$Tr)(Bt, vt, Zt),
                            (0,
                            it.R3I)(vt, bt)
                        },
                        p: function(Bt, Zt) {
                            var tn = Zt[0];
                            Bt[1] !== void 0 ? It ? It.p(Bt, tn) : ((It = sr(Bt)).c(),
                            It.m(Tt.parentNode, Tt)) : It && (It.d(1),
                            It = null),
                            8 & tn && (0,
                            it.rTO)(bt, Bt[3]),
                            16 & tn && Rt !== (Rt = "vc-log-val vc-log-val-" + Bt[4]) && (0,
                            it.Ljt)(vt, "class", Rt),
                            1 & tn && (0,
                            it.Ljt)(vt, "style", Bt[0]),
                            18 & tn && (0,
                            it.VHj)(vt, "vc-log-val-haskey", Bt[1] !== void 0)
                        },
                        i: it.ZTd,
                        o: it.ZTd,
                        d: function(Bt) {
                            It && It.d(Bt),
                            Bt && (0,
                            it.ogt)(Tt),
                            Bt && (0,
                            it.ogt)(vt)
                        }
                    }
                }
                function wn(At, Tt, vt) {
                    var bt = Tt.origData
                      , Rt = Tt.style
                      , It = Rt === void 0 ? "" : Rt
                      , Bt = Tt.dataKey
                      , Zt = Bt === void 0 ? void 0 : Bt
                      , tn = Tt.keyType
                      , dn = tn === void 0 ? "" : tn
                      , mn = ""
                      , Sn = ""
                      , yn = !1;
                    return (0,
                    ot.H3)(function() {
                        Tn.use()
                    }),
                    (0,
                    ot.ev)(function() {
                        Tn.unuse()
                    }),
                    At.$$set = function(On) {
                        "origData"in On && vt(5, bt = On.origData),
                        "style"in On && vt(0, It = On.style),
                        "dataKey"in On && vt(1, Zt = On.dataKey),
                        "keyType"in On && vt(2, dn = On.keyType)
                    }
                    ,
                    At.$$.update = function() {
                        if (122 & At.$$.dirty) {
                            vt(6, yn = Zt !== void 0);
                            var On = (0,
                            qn.LH)(bt, yn);
                            vt(4, Sn = On.valueType),
                            vt(3, mn = On.text),
                            yn || Sn !== "string" || vt(3, mn = mn.replace(/\\n/g, `
`).replace(/\\t/g, "    "))
                        }
                    }
                    ,
                    [It, Zt, dn, mn, Sn, bt, yn]
                }
                var Pn = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, wn, lr, it.AqN, {
                            origData: 5,
                            style: 0,
                            dataKey: 1,
                            keyType: 2
                        }),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    (0,
                    _e.Z)(Tt, [{
                        key: "origData",
                        get: function() {
                            return this.$$.ctx[5]
                        },
                        set: function(vt) {
                            this.$$set({
                                origData: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "style",
                        get: function() {
                            return this.$$.ctx[0]
                        },
                        set: function(vt) {
                            this.$$set({
                                style: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "dataKey",
                        get: function() {
                            return this.$$.ctx[1]
                        },
                        set: function(vt) {
                            this.$$set({
                                dataKey: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "keyType",
                        get: function() {
                            return this.$$.ctx[2]
                        },
                        set: function(vt) {
                            this.$$set({
                                keyType: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }]),
                    Tt
                }(it.f_C)
                  , Cn = Pn
                  , zn = __webpack_require__(1237)
                  , ur = {};
                zn.Z && zn.Z.locals && (ur.locals = zn.Z.locals);
                var hr, Ir = 0, _o = {};
                _o.styleTagTransform = St(),
                _o.setAttributes = yt(),
                _o.insert = ht().bind(null, "head"),
                _o.domAPI = dt(),
                _o.insertStyleElement = _t(),
                ur.use = function(At) {
                    return _o.options = At || {},
                    Ir++ || (hr = lt()(zn.Z, _o)),
                    ur
                }
                ,
                ur.unuse = function() {
                    Ir > 0 && !--Ir && (hr(),
                    hr = null)
                }
                ;
                var Xr = ur;
                function jr(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[19] = Tt[vt],
                    bt[21] = vt,
                    bt
                }
                function zs(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[19] = Tt[vt],
                    bt
                }
                function bo(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[19] = Tt[vt],
                    bt[21] = vt,
                    bt
                }
                function Jr(At) {
                    for (var Tt, vt, bt, Rt, It, Bt, Zt, tn = [], dn = new Map, mn = [], Sn = new Map, yn = [], On = new Map, An = At[7], Nn = function(mr) {
                        return mr[19]
                    }, Fn = 0; Fn < An.length; Fn += 1) {
                        var Qn = bo(At, An, Fn)
                          , er = Nn(Qn);
                        dn.set(er, tn[Fn] = ro(er, Qn))
                    }
                    for (var fr = At[11] < At[7].length && go(At), Nr = At[9], Rr = function(mr) {
                        return mr[19]
                    }, _i = 0; _i < Nr.length; _i += 1) {
                        var eo = zs(At, Nr, _i)
                          , Gr = Rr(eo);
                        Sn.set(Gr, mn[_i] = Sl(Gr, eo))
                    }
                    for (var Ar = At[8], Or = function(mr) {
                        return mr[19]
                    }, Fr = 0; Fr < Ar.length; Fr += 1) {
                        var Vo = jr(At, Ar, Fr)
                          , lo = Or(Vo);
                        On.set(lo, yn[Fr] = To(lo, Vo))
                    }
                    var to = At[12] < At[8].length && Cl(At)
                      , Kr = At[10] && mo(At);
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div");
                            for (var mr = 0; mr < tn.length; mr += 1)
                                tn[mr].c();
                            vt = (0,
                            it.DhX)(),
                            fr && fr.c(),
                            bt = (0,
                            it.DhX)();
                            for (var _r = 0; _r < mn.length; _r += 1)
                                mn[_r].c();
                            Rt = (0,
                            it.DhX)();
                            for (var vo = 0; vo < yn.length; vo += 1)
                                yn[vo].c();
                            It = (0,
                            it.DhX)(),
                            to && to.c(),
                            Bt = (0,
                            it.DhX)(),
                            Kr && Kr.c(),
                            (0,
                            it.Ljt)(Tt, "class", "vc-log-tree-child")
                        },
                        m: function(mr, _r) {
                            (0,
                            it.$Tr)(mr, Tt, _r);
                            for (var vo = 0; vo < tn.length; vo += 1)
                                tn[vo].m(Tt, null);
                            (0,
                            it.R3I)(Tt, vt),
                            fr && fr.m(Tt, null),
                            (0,
                            it.R3I)(Tt, bt);
                            for (var ar = 0; ar < mn.length; ar += 1)
                                mn[ar].m(Tt, null);
                            (0,
                            it.R3I)(Tt, Rt);
                            for (var $r = 0; $r < yn.length; $r += 1)
                                yn[$r].m(Tt, null);
                            (0,
                            it.R3I)(Tt, It),
                            to && to.m(Tt, null),
                            (0,
                            it.R3I)(Tt, Bt),
                            Kr && Kr.m(Tt, null),
                            Zt = !0
                        },
                        p: function(mr, _r) {
                            67721 & _r && (An = mr[7],
                            (0,
                            it.dvw)(),
                            tn = (0,
                            it.GQg)(tn, _r, Nn, 1, mr, An, dn, Tt, it.cly, ro, vt, bo),
                            (0,
                            it.gbL)()),
                            mr[11] < mr[7].length ? fr ? fr.p(mr, _r) : ((fr = go(mr)).c(),
                            fr.m(Tt, bt)) : fr && (fr.d(1),
                            fr = null),
                            66057 & _r && (Nr = mr[9],
                            (0,
                            it.dvw)(),
                            mn = (0,
                            it.GQg)(mn, _r, Rr, 1, mr, Nr, Sn, Tt, it.cly, Sl, Rt, zs),
                            (0,
                            it.gbL)()),
                            69897 & _r && (Ar = mr[8],
                            (0,
                            it.dvw)(),
                            yn = (0,
                            it.GQg)(yn, _r, Or, 1, mr, Ar, On, Tt, it.cly, To, It, jr),
                            (0,
                            it.gbL)()),
                            mr[12] < mr[8].length ? to ? to.p(mr, _r) : ((to = Cl(mr)).c(),
                            to.m(Tt, Bt)) : to && (to.d(1),
                            to = null),
                            mr[10] ? Kr ? (Kr.p(mr, _r),
                            1024 & _r && (0,
                            it.Ui)(Kr, 1)) : ((Kr = mo(mr)).c(),
                            (0,
                            it.Ui)(Kr, 1),
                            Kr.m(Tt, null)) : Kr && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(Kr, 1, 1, function() {
                                Kr = null
                            }),
                            (0,
                            it.gbL)())
                        },
                        i: function(mr) {
                            if (!Zt) {
                                for (var _r = 0; _r < An.length; _r += 1)
                                    (0,
                                    it.Ui)(tn[_r]);
                                for (var vo = 0; vo < Nr.length; vo += 1)
                                    (0,
                                    it.Ui)(mn[vo]);
                                for (var ar = 0; ar < Ar.length; ar += 1)
                                    (0,
                                    it.Ui)(yn[ar]);
                                (0,
                                it.Ui)(Kr),
                                Zt = !0
                            }
                        },
                        o: function(mr) {
                            for (var _r = 0; _r < tn.length; _r += 1)
                                (0,
                                it.etI)(tn[_r]);
                            for (var vo = 0; vo < mn.length; vo += 1)
                                (0,
                                it.etI)(mn[vo]);
                            for (var ar = 0; ar < yn.length; ar += 1)
                                (0,
                                it.etI)(yn[ar]);
                            (0,
                            it.etI)(Kr),
                            Zt = !1
                        },
                        d: function(mr) {
                            mr && (0,
                            it.ogt)(Tt);
                            for (var _r = 0; _r < tn.length; _r += 1)
                                tn[_r].d();
                            fr && fr.d();
                            for (var vo = 0; vo < mn.length; vo += 1)
                                mn[vo].d();
                            for (var ar = 0; ar < yn.length; ar += 1)
                                yn[ar].d();
                            to && to.d(),
                            Kr && Kr.d()
                        }
                    }
                }
                function Zo(At) {
                    var Tt, vt;
                    return Tt = new yo({
                        props: {
                            origData: At[16](At[19]),
                            dataKey: At[19],
                            keyPath: At[3] + "." + At[19],
                            toggle: At[0]
                        }
                    }),
                    {
                        c: function() {
                            (0,
                            it.YCL)(Tt.$$.fragment)
                        },
                        m: function(bt, Rt) {
                            (0,
                            it.yef)(Tt, bt, Rt),
                            vt = !0
                        },
                        p: function(bt, Rt) {
                            var It = {};
                            128 & Rt && (It.origData = bt[16](bt[19])),
                            128 & Rt && (It.dataKey = bt[19]),
                            136 & Rt && (It.keyPath = bt[3] + "." + bt[19]),
                            1 & Rt && (It.toggle = bt[0]),
                            Tt.$set(It)
                        },
                        i: function(bt) {
                            vt || ((0,
                            it.Ui)(Tt.$$.fragment, bt),
                            vt = !0)
                        },
                        o: function(bt) {
                            (0,
                            it.etI)(Tt.$$.fragment, bt),
                            vt = !1
                        },
                        d: function(bt) {
                            (0,
                            it.vpE)(Tt, bt)
                        }
                    }
                }
                function ro(At, Tt) {
                    var vt, bt, Rt, It = Tt[21] < Tt[11] && Zo(Tt);
                    return {
                        key: At,
                        first: null,
                        c: function() {
                            vt = (0,
                            it.cSb)(),
                            It && It.c(),
                            bt = (0,
                            it.cSb)(),
                            this.first = vt
                        },
                        m: function(Bt, Zt) {
                            (0,
                            it.$Tr)(Bt, vt, Zt),
                            It && It.m(Bt, Zt),
                            (0,
                            it.$Tr)(Bt, bt, Zt),
                            Rt = !0
                        },
                        p: function(Bt, Zt) {
                            (Tt = Bt)[21] < Tt[11] ? It ? (It.p(Tt, Zt),
                            2176 & Zt && (0,
                            it.Ui)(It, 1)) : ((It = Zo(Tt)).c(),
                            (0,
                            it.Ui)(It, 1),
                            It.m(bt.parentNode, bt)) : It && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(It, 1, 1, function() {
                                It = null
                            }),
                            (0,
                            it.gbL)())
                        },
                        i: function(Bt) {
                            Rt || ((0,
                            it.Ui)(It),
                            Rt = !0)
                        },
                        o: function(Bt) {
                            (0,
                            it.etI)(It),
                            Rt = !1
                        },
                        d: function(Bt) {
                            Bt && (0,
                            it.ogt)(vt),
                            It && It.d(Bt),
                            Bt && (0,
                            it.ogt)(bt)
                        }
                    }
                }
                function go(At) {
                    var Tt, vt, bt, Rt, It = At[14](At[7].length - At[11]) + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.fLW)(It),
                            (0,
                            it.Ljt)(Tt, "class", "vc-log-tree-loadmore")
                        },
                        m: function(Bt, Zt) {
                            (0,
                            it.$Tr)(Bt, Tt, Zt),
                            (0,
                            it.R3I)(Tt, vt),
                            bt || (Rt = (0,
                            it.oLt)(Tt, "click", At[17]),
                            bt = !0)
                        },
                        p: function(Bt, Zt) {
                            2176 & Zt && It !== (It = Bt[14](Bt[7].length - Bt[11]) + "") && (0,
                            it.rTO)(vt, It)
                        },
                        d: function(Bt) {
                            Bt && (0,
                            it.ogt)(Tt),
                            bt = !1,
                            Rt()
                        }
                    }
                }
                function Sl(At, Tt) {
                    var vt, bt, Rt;
                    return bt = new yo({
                        props: {
                            origData: Tt[16](Tt[19]),
                            dataKey: String(Tt[19]),
                            keyType: "symbol",
                            keyPath: Tt[3] + "[" + String(Tt[19]) + "]",
                            toggle: Tt[0]
                        }
                    }),
                    {
                        key: At,
                        first: null,
                        c: function() {
                            vt = (0,
                            it.cSb)(),
                            (0,
                            it.YCL)(bt.$$.fragment),
                            this.first = vt
                        },
                        m: function(It, Bt) {
                            (0,
                            it.$Tr)(It, vt, Bt),
                            (0,
                            it.yef)(bt, It, Bt),
                            Rt = !0
                        },
                        p: function(It, Bt) {
                            Tt = It;
                            var Zt = {};
                            512 & Bt && (Zt.origData = Tt[16](Tt[19])),
                            512 & Bt && (Zt.dataKey = String(Tt[19])),
                            520 & Bt && (Zt.keyPath = Tt[3] + "[" + String(Tt[19]) + "]"),
                            1 & Bt && (Zt.toggle = Tt[0]),
                            bt.$set(Zt)
                        },
                        i: function(It) {
                            Rt || ((0,
                            it.Ui)(bt.$$.fragment, It),
                            Rt = !0)
                        },
                        o: function(It) {
                            (0,
                            it.etI)(bt.$$.fragment, It),
                            Rt = !1
                        },
                        d: function(It) {
                            It && (0,
                            it.ogt)(vt),
                            (0,
                            it.vpE)(bt, It)
                        }
                    }
                }
                function xo(At) {
                    var Tt, vt;
                    return Tt = new yo({
                        props: {
                            origData: At[16](At[19]),
                            dataKey: At[19],
                            keyType: "private",
                            keyPath: At[3] + "." + At[19],
                            toggle: At[0]
                        }
                    }),
                    {
                        c: function() {
                            (0,
                            it.YCL)(Tt.$$.fragment)
                        },
                        m: function(bt, Rt) {
                            (0,
                            it.yef)(Tt, bt, Rt),
                            vt = !0
                        },
                        p: function(bt, Rt) {
                            var It = {};
                            256 & Rt && (It.origData = bt[16](bt[19])),
                            256 & Rt && (It.dataKey = bt[19]),
                            264 & Rt && (It.keyPath = bt[3] + "." + bt[19]),
                            1 & Rt && (It.toggle = bt[0]),
                            Tt.$set(It)
                        },
                        i: function(bt) {
                            vt || ((0,
                            it.Ui)(Tt.$$.fragment, bt),
                            vt = !0)
                        },
                        o: function(bt) {
                            (0,
                            it.etI)(Tt.$$.fragment, bt),
                            vt = !1
                        },
                        d: function(bt) {
                            (0,
                            it.vpE)(Tt, bt)
                        }
                    }
                }
                function To(At, Tt) {
                    var vt, bt, Rt, It = Tt[21] < Tt[12] && xo(Tt);
                    return {
                        key: At,
                        first: null,
                        c: function() {
                            vt = (0,
                            it.cSb)(),
                            It && It.c(),
                            bt = (0,
                            it.cSb)(),
                            this.first = vt
                        },
                        m: function(Bt, Zt) {
                            (0,
                            it.$Tr)(Bt, vt, Zt),
                            It && It.m(Bt, Zt),
                            (0,
                            it.$Tr)(Bt, bt, Zt),
                            Rt = !0
                        },
                        p: function(Bt, Zt) {
                            (Tt = Bt)[21] < Tt[12] ? It ? (It.p(Tt, Zt),
                            4352 & Zt && (0,
                            it.Ui)(It, 1)) : ((It = xo(Tt)).c(),
                            (0,
                            it.Ui)(It, 1),
                            It.m(bt.parentNode, bt)) : It && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(It, 1, 1, function() {
                                It = null
                            }),
                            (0,
                            it.gbL)())
                        },
                        i: function(Bt) {
                            Rt || ((0,
                            it.Ui)(It),
                            Rt = !0)
                        },
                        o: function(Bt) {
                            (0,
                            it.etI)(It),
                            Rt = !1
                        },
                        d: function(Bt) {
                            Bt && (0,
                            it.ogt)(vt),
                            It && It.d(Bt),
                            Bt && (0,
                            it.ogt)(bt)
                        }
                    }
                }
                function Cl(At) {
                    var Tt, vt, bt, Rt, It = At[14](At[8].length - At[12]) + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.fLW)(It),
                            (0,
                            it.Ljt)(Tt, "class", "vc-log-tree-loadmore")
                        },
                        m: function(Bt, Zt) {
                            (0,
                            it.$Tr)(Bt, Tt, Zt),
                            (0,
                            it.R3I)(Tt, vt),
                            bt || (Rt = (0,
                            it.oLt)(Tt, "click", At[18]),
                            bt = !0)
                        },
                        p: function(Bt, Zt) {
                            4352 & Zt && It !== (It = Bt[14](Bt[8].length - Bt[12]) + "") && (0,
                            it.rTO)(vt, It)
                        },
                        d: function(Bt) {
                            Bt && (0,
                            it.ogt)(Tt),
                            bt = !1,
                            Rt()
                        }
                    }
                }
                function mo(At) {
                    var Tt, vt;
                    return Tt = new yo({
                        props: {
                            origData: At[16]("__proto__"),
                            dataKey: "__proto__",
                            keyType: "private",
                            keyPath: At[3] + ".__proto__",
                            toggle: At[0]
                        }
                    }),
                    {
                        c: function() {
                            (0,
                            it.YCL)(Tt.$$.fragment)
                        },
                        m: function(bt, Rt) {
                            (0,
                            it.yef)(Tt, bt, Rt),
                            vt = !0
                        },
                        p: function(bt, Rt) {
                            var It = {};
                            8 & Rt && (It.keyPath = bt[3] + ".__proto__"),
                            1 & Rt && (It.toggle = bt[0]),
                            Tt.$set(It)
                        },
                        i: function(bt) {
                            vt || ((0,
                            it.Ui)(Tt.$$.fragment, bt),
                            vt = !0)
                        },
                        o: function(bt) {
                            (0,
                            it.etI)(Tt.$$.fragment, bt),
                            vt = !1
                        },
                        d: function(bt) {
                            (0,
                            it.vpE)(Tt, bt)
                        }
                    }
                }
                function Ro(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt;
                    bt = new Cn({
                        props: {
                            origData: At[1],
                            dataKey: At[2],
                            keyType: At[4]
                        }
                    });
                    var tn = At[6] && At[5] && Jr(At);
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("div"),
                            (0,
                            it.YCL)(bt.$$.fragment),
                            Rt = (0,
                            it.DhX)(),
                            tn && tn.c(),
                            (0,
                            it.Ljt)(vt, "class", "vc-log-tree-node"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-log-tree"),
                            (0,
                            it.Ljt)(Tt, "data-keypath", At[3]),
                            (0,
                            it.VHj)(Tt, "vc-toggle", At[5]),
                            (0,
                            it.VHj)(Tt, "vc-is-tree", At[6])
                        },
                        m: function(dn, mn) {
                            (0,
                            it.$Tr)(dn, Tt, mn),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.yef)(bt, vt, null),
                            (0,
                            it.R3I)(Tt, Rt),
                            tn && tn.m(Tt, null),
                            It = !0,
                            Bt || (Zt = (0,
                            it.oLt)(vt, "click", (0,
                            it.XET)(At[15])),
                            Bt = !0)
                        },
                        p: function(dn, mn) {
                            var Sn = mn[0]
                              , yn = {};
                            2 & Sn && (yn.origData = dn[1]),
                            4 & Sn && (yn.dataKey = dn[2]),
                            16 & Sn && (yn.keyType = dn[4]),
                            bt.$set(yn),
                            dn[6] && dn[5] ? tn ? (tn.p(dn, Sn),
                            96 & Sn && (0,
                            it.Ui)(tn, 1)) : ((tn = Jr(dn)).c(),
                            (0,
                            it.Ui)(tn, 1),
                            tn.m(Tt, null)) : tn && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(tn, 1, 1, function() {
                                tn = null
                            }),
                            (0,
                            it.gbL)()),
                            (!It || 8 & Sn) && (0,
                            it.Ljt)(Tt, "data-keypath", dn[3]),
                            32 & Sn && (0,
                            it.VHj)(Tt, "vc-toggle", dn[5]),
                            64 & Sn && (0,
                            it.VHj)(Tt, "vc-is-tree", dn[6])
                        },
                        i: function(dn) {
                            It || ((0,
                            it.Ui)(bt.$$.fragment, dn),
                            (0,
                            it.Ui)(tn),
                            It = !0)
                        },
                        o: function(dn) {
                            (0,
                            it.etI)(bt.$$.fragment, dn),
                            (0,
                            it.etI)(tn),
                            It = !1
                        },
                        d: function(dn) {
                            dn && (0,
                            it.ogt)(Tt),
                            (0,
                            it.vpE)(bt),
                            tn && tn.d(),
                            Bt = !1,
                            Zt()
                        }
                    }
                }
                function lu(At, Tt, vt) {
                    var bt, Rt, It, Bt = Tt.origData, Zt = Tt.dataKey, tn = Zt === void 0 ? void 0 : Zt, dn = Tt.keyPath, mn = dn === void 0 ? "" : dn, Sn = Tt.keyType, yn = Sn === void 0 ? "" : Sn, On = Tt.toggle, An = On === void 0 ? {} : On, Nn = !1, Fn = !1, Qn = !1, er = 50, fr = 50;
                    (0,
                    ot.H3)(function() {
                        Xr.use()
                    }),
                    (0,
                    ot.ev)(function() {
                        Xr.unuse()
                    });
                    var Nr = function(Rr) {
                        Rr === "enum" ? vt(11, er += 50) : Rr === "nonEnum" && vt(12, fr += 50)
                    };
                    return At.$$set = function(Rr) {
                        "origData"in Rr && vt(1, Bt = Rr.origData),
                        "dataKey"in Rr && vt(2, tn = Rr.dataKey),
                        "keyPath"in Rr && vt(3, mn = Rr.keyPath),
                        "keyType"in Rr && vt(4, yn = Rr.keyType),
                        "toggle"in Rr && vt(0, An = Rr.toggle)
                    }
                    ,
                    At.$$.update = function() {
                        1003 & At.$$.dirty && (vt(5, Nn = An[mn] || !1),
                        vt(6, Fn = !(Bt instanceof qn.Tg) && ($.kJ(Bt) || $.Kn(Bt))),
                        Fn && Nn && (vt(7, bt = bt || $.qr($.MH(Bt))),
                        vt(8, Rt = Rt || $.qr($.QK(Bt))),
                        vt(9, It = It || $._D(Bt)),
                        vt(10, Qn = $.Kn(Bt) && Rt.indexOf("__proto__") === -1)))
                    }
                    ,
                    [An, Bt, tn, mn, yn, Nn, Fn, bt, Rt, It, Qn, er, fr, Nr, function(Rr) {
                        return "(..." + Rr + " Key" + (Rr > 1 ? "s" : "") + " Left)"
                    }
                    , function() {
                        vt(5, Nn = !Nn),
                        vt(0, An[mn] = Nn, An)
                    }
                    , function(Rr) {
                        try {
                            return Bt[Rr]
                        } catch {
                            return new qn.Tg
                        }
                    }
                    , function() {
                        return Nr("enum")
                    }
                    , function() {
                        return Nr("nonEnum")
                    }
                    ]
                }
                var yo = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, lu, Ro, it.AqN, {
                            origData: 1,
                            dataKey: 2,
                            keyPath: 3,
                            keyType: 4,
                            toggle: 0
                        }),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    (0,
                    _e.Z)(Tt, [{
                        key: "origData",
                        get: function() {
                            return this.$$.ctx[1]
                        },
                        set: function(vt) {
                            this.$$set({
                                origData: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "dataKey",
                        get: function() {
                            return this.$$.ctx[2]
                        },
                        set: function(vt) {
                            this.$$set({
                                dataKey: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "keyPath",
                        get: function() {
                            return this.$$.ctx[3]
                        },
                        set: function(vt) {
                            this.$$set({
                                keyPath: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "keyType",
                        get: function() {
                            return this.$$.ctx[4]
                        },
                        set: function(vt) {
                            this.$$set({
                                keyType: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "toggle",
                        get: function() {
                            return this.$$.ctx[0]
                        },
                        set: function(vt) {
                            this.$$set({
                                toggle: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }]),
                    Tt
                }(it.f_C)
                  , Io = yo
                  , ws = __webpack_require__(7147)
                  , Os = {};
                ws.Z && ws.Z.locals && (Os.locals = ws.Z.locals);
                var Ws, Hs = 0, xs = {};
                xs.styleTagTransform = St(),
                xs.setAttributes = yt(),
                xs.insert = ht().bind(null, "head"),
                xs.domAPI = dt(),
                xs.insertStyleElement = _t(),
                Os.use = function(At) {
                    return xs.options = At || {},
                    Hs++ || (Ws = lt()(ws.Z, xs)),
                    Os
                }
                ,
                Os.unuse = function() {
                    Hs > 0 && !--Hs && (Ws(),
                    Ws = null)
                }
                ;
                var Ss = Os;
                function Nu(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[9] = Tt[vt],
                    bt[11] = vt,
                    bt
                }
                function $l(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[12] = Tt[vt],
                    bt
                }
                function Mu(At) {
                    for (var Tt, vt, bt, Rt, It, Bt, Zt, tn, dn, mn, Sn, yn, On, An = [], Nn = new Map, Fn = At[0].groupLevel && Pu(At), Qn = At[2] > 0 && cu(), er = At[1] && uu(At), fr = At[0].repeated && du(At), Nr = At[0].data, Rr = function(Ar) {
                        return Ar[11]
                    }, _i = 0; _i < Nr.length; _i += 1) {
                        var eo = Nu(At, Nr, _i)
                          , Gr = Rr(eo);
                        Nn.set(Gr, An[_i] = Bu(Gr, eo))
                    }
                    return dn = new an({
                        props: {
                            handler: At[6]
                        }
                    }),
                    {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            Fn && Fn.c(),
                            vt = (0,
                            it.DhX)(),
                            Qn && Qn.c(),
                            bt = (0,
                            it.DhX)(),
                            er && er.c(),
                            Rt = (0,
                            it.DhX)(),
                            fr && fr.c(),
                            It = (0,
                            it.DhX)(),
                            Bt = (0,
                            it.bGB)("div");
                            for (var Ar = 0; Ar < An.length; Ar += 1)
                                An[Ar].c();
                            Zt = (0,
                            it.DhX)(),
                            tn = (0,
                            it.bGB)("div"),
                            (0,
                            it.YCL)(dn.$$.fragment),
                            (0,
                            it.Ljt)(Bt, "class", "vc-log-content"),
                            (0,
                            it.Ljt)(tn, "class", "vc-logrow-icon"),
                            (0,
                            it.Ljt)(Tt, "class", mn = "vc-log-row vc-log-" + At[0].type),
                            (0,
                            it.VHj)(Tt, "vc-log-input", At[0].cmdType === "input"),
                            (0,
                            it.VHj)(Tt, "vc-log-output", At[0].cmdType === "output"),
                            (0,
                            it.VHj)(Tt, "vc-log-group", At[2] > 0),
                            (0,
                            it.VHj)(Tt, "vc-toggle", At[2] === 1)
                        },
                        m: function(Ar, Or) {
                            (0,
                            it.$Tr)(Ar, Tt, Or),
                            Fn && Fn.m(Tt, null),
                            (0,
                            it.R3I)(Tt, vt),
                            Qn && Qn.m(Tt, null),
                            (0,
                            it.R3I)(Tt, bt),
                            er && er.m(Tt, null),
                            (0,
                            it.R3I)(Tt, Rt),
                            fr && fr.m(Tt, null),
                            (0,
                            it.R3I)(Tt, It),
                            (0,
                            it.R3I)(Tt, Bt);
                            for (var Fr = 0; Fr < An.length; Fr += 1)
                                An[Fr].m(Bt, null);
                            (0,
                            it.R3I)(Tt, Zt),
                            (0,
                            it.R3I)(Tt, tn),
                            (0,
                            it.yef)(dn, tn, null),
                            Sn = !0,
                            yn || (On = (0,
                            it.oLt)(Tt, "click", At[5]),
                            yn = !0)
                        },
                        p: function(Ar, Or) {
                            Ar[0].groupLevel ? Fn ? Fn.p(Ar, Or) : ((Fn = Pu(Ar)).c(),
                            Fn.m(Tt, vt)) : Fn && (Fn.d(1),
                            Fn = null),
                            Ar[2] > 0 ? Qn || ((Qn = cu()).c(),
                            Qn.m(Tt, bt)) : Qn && (Qn.d(1),
                            Qn = null),
                            Ar[1] ? er ? er.p(Ar, Or) : ((er = uu(Ar)).c(),
                            er.m(Tt, Rt)) : er && (er.d(1),
                            er = null),
                            Ar[0].repeated ? fr ? fr.p(Ar, Or) : ((fr = du(Ar)).c(),
                            fr.m(Tt, It)) : fr && (fr.d(1),
                            fr = null),
                            17 & Or && (Nr = Ar[0].data,
                            (0,
                            it.dvw)(),
                            An = (0,
                            it.GQg)(An, Or, Rr, 1, Ar, Nr, Nn, Bt, it.cly, Bu, null, Nu),
                            (0,
                            it.gbL)()),
                            (!Sn || 1 & Or && mn !== (mn = "vc-log-row vc-log-" + Ar[0].type)) && (0,
                            it.Ljt)(Tt, "class", mn),
                            1 & Or && (0,
                            it.VHj)(Tt, "vc-log-input", Ar[0].cmdType === "input"),
                            1 & Or && (0,
                            it.VHj)(Tt, "vc-log-output", Ar[0].cmdType === "output"),
                            5 & Or && (0,
                            it.VHj)(Tt, "vc-log-group", Ar[2] > 0),
                            5 & Or && (0,
                            it.VHj)(Tt, "vc-toggle", Ar[2] === 1)
                        },
                        i: function(Ar) {
                            if (!Sn) {
                                for (var Or = 0; Or < Nr.length; Or += 1)
                                    (0,
                                    it.Ui)(An[Or]);
                                (0,
                                it.Ui)(dn.$$.fragment, Ar),
                                Sn = !0
                            }
                        },
                        o: function(Ar) {
                            for (var Or = 0; Or < An.length; Or += 1)
                                (0,
                                it.etI)(An[Or]);
                            (0,
                            it.etI)(dn.$$.fragment, Ar),
                            Sn = !1
                        },
                        d: function(Ar) {
                            Ar && (0,
                            it.ogt)(Tt),
                            Fn && Fn.d(),
                            Qn && Qn.d(),
                            er && er.d(),
                            fr && fr.d();
                            for (var Or = 0; Or < An.length; Or += 1)
                                An[Or].d();
                            (0,
                            it.vpE)(dn),
                            yn = !1,
                            On()
                        }
                    }
                }
                function Pu(At) {
                    for (var Tt, vt = new Array(At[0].groupLevel), bt = [], Rt = 0; Rt < vt.length; Rt += 1)
                        bt[Rt] = Du($l(At, vt, Rt));
                    return {
                        c: function() {
                            for (var It = 0; It < bt.length; It += 1)
                                bt[It].c();
                            Tt = (0,
                            it.cSb)()
                        },
                        m: function(It, Bt) {
                            for (var Zt = 0; Zt < bt.length; Zt += 1)
                                bt[Zt].m(It, Bt);
                            (0,
                            it.$Tr)(It, Tt, Bt)
                        },
                        p: function(It, Bt) {
                            if (1 & Bt) {
                                var Zt;
                                for (vt = new Array(It[0].groupLevel),
                                Zt = 0; Zt < vt.length; Zt += 1) {
                                    var tn = $l(It, vt, Zt);
                                    bt[Zt] ? bt[Zt].p(tn, Bt) : (bt[Zt] = Du(),
                                    bt[Zt].c(),
                                    bt[Zt].m(Tt.parentNode, Tt))
                                }
                                for (; Zt < bt.length; Zt += 1)
                                    bt[Zt].d(1);
                                bt.length = vt.length
                            }
                        },
                        d: function(It) {
                            (0,
                            it.RMB)(bt, It),
                            It && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function Du(At) {
                    var Tt;
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("i"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-log-padding")
                        },
                        m: function(vt, bt) {
                            (0,
                            it.$Tr)(vt, Tt, bt)
                        },
                        p: it.ZTd,
                        d: function(vt) {
                            vt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function cu(At) {
                    var Tt;
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-log-group-toggle")
                        },
                        m: function(vt, bt) {
                            (0,
                            it.$Tr)(vt, Tt, bt)
                        },
                        d: function(vt) {
                            vt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function uu(At) {
                    var Tt, vt;
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.fLW)(At[3]),
                            (0,
                            it.Ljt)(Tt, "class", "vc-log-time")
                        },
                        m: function(bt, Rt) {
                            (0,
                            it.$Tr)(bt, Tt, Rt),
                            (0,
                            it.R3I)(Tt, vt)
                        },
                        p: function(bt, Rt) {
                            8 & Rt && (0,
                            it.rTO)(vt, bt[3])
                        },
                        d: function(bt) {
                            bt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function du(At) {
                    var Tt, vt, bt, Rt = At[0].repeated + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("i"),
                            bt = (0,
                            it.fLW)(Rt),
                            (0,
                            it.Ljt)(Tt, "class", "vc-log-repeat")
                        },
                        m: function(It, Bt) {
                            (0,
                            it.$Tr)(It, Tt, Bt),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(vt, bt)
                        },
                        p: function(It, Bt) {
                            1 & Bt && Rt !== (Rt = It[0].repeated + "") && (0,
                            it.rTO)(bt, Rt)
                        },
                        d: function(It) {
                            It && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function gp(At) {
                    var Tt, vt;
                    return Tt = new Cn({
                        props: {
                            origData: At[9].origData,
                            style: At[9].style
                        }
                    }),
                    {
                        c: function() {
                            (0,
                            it.YCL)(Tt.$$.fragment)
                        },
                        m: function(bt, Rt) {
                            (0,
                            it.yef)(Tt, bt, Rt),
                            vt = !0
                        },
                        p: function(bt, Rt) {
                            var It = {};
                            1 & Rt && (It.origData = bt[9].origData),
                            1 & Rt && (It.style = bt[9].style),
                            Tt.$set(It)
                        },
                        i: function(bt) {
                            vt || ((0,
                            it.Ui)(Tt.$$.fragment, bt),
                            vt = !0)
                        },
                        o: function(bt) {
                            (0,
                            it.etI)(Tt.$$.fragment, bt),
                            vt = !1
                        },
                        d: function(bt) {
                            (0,
                            it.vpE)(Tt, bt)
                        }
                    }
                }
                function mp(At) {
                    var Tt, vt;
                    return Tt = new Io({
                        props: {
                            origData: At[9].origData,
                            keyPath: String(At[11]),
                            toggle: At[0].toggle
                        }
                    }),
                    {
                        c: function() {
                            (0,
                            it.YCL)(Tt.$$.fragment)
                        },
                        m: function(bt, Rt) {
                            (0,
                            it.yef)(Tt, bt, Rt),
                            vt = !0
                        },
                        p: function(bt, Rt) {
                            var It = {};
                            1 & Rt && (It.origData = bt[9].origData),
                            1 & Rt && (It.keyPath = String(bt[11])),
                            1 & Rt && (It.toggle = bt[0].toggle),
                            Tt.$set(It)
                        },
                        i: function(bt) {
                            vt || ((0,
                            it.Ui)(Tt.$$.fragment, bt),
                            vt = !0)
                        },
                        o: function(bt) {
                            (0,
                            it.etI)(Tt.$$.fragment, bt),
                            vt = !1
                        },
                        d: function(bt) {
                            (0,
                            it.vpE)(Tt, bt)
                        }
                    }
                }
                function Bu(At, Tt) {
                    var vt, bt, Rt, It, Bt, Zt, tn = [mp, gp], dn = [];
                    function mn(Sn, yn) {
                        return 1 & yn && (bt = null),
                        bt == null && (bt = !!Sn[4](Sn[9].origData)),
                        bt ? 0 : 1
                    }
                    return Rt = mn(Tt, -1),
                    It = dn[Rt] = tn[Rt](Tt),
                    {
                        key: At,
                        first: null,
                        c: function() {
                            vt = (0,
                            it.cSb)(),
                            It.c(),
                            Bt = (0,
                            it.cSb)(),
                            this.first = vt
                        },
                        m: function(Sn, yn) {
                            (0,
                            it.$Tr)(Sn, vt, yn),
                            dn[Rt].m(Sn, yn),
                            (0,
                            it.$Tr)(Sn, Bt, yn),
                            Zt = !0
                        },
                        p: function(Sn, yn) {
                            var On = Rt;
                            (Rt = mn(Tt = Sn, yn)) === On ? dn[Rt].p(Tt, yn) : ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(dn[On], 1, 1, function() {
                                dn[On] = null
                            }),
                            (0,
                            it.gbL)(),
                            (It = dn[Rt]) ? It.p(Tt, yn) : (It = dn[Rt] = tn[Rt](Tt)).c(),
                            (0,
                            it.Ui)(It, 1),
                            It.m(Bt.parentNode, Bt))
                        },
                        i: function(Sn) {
                            Zt || ((0,
                            it.Ui)(It),
                            Zt = !0)
                        },
                        o: function(Sn) {
                            (0,
                            it.etI)(It),
                            Zt = !1
                        },
                        d: function(Sn) {
                            Sn && (0,
                            it.ogt)(vt),
                            dn[Rt].d(Sn),
                            Sn && (0,
                            it.ogt)(Bt)
                        }
                    }
                }
                function yp(At) {
                    var Tt, vt, bt = At[0] && Mu(At);
                    return {
                        c: function() {
                            bt && bt.c(),
                            Tt = (0,
                            it.cSb)()
                        },
                        m: function(Rt, It) {
                            bt && bt.m(Rt, It),
                            (0,
                            it.$Tr)(Rt, Tt, It),
                            vt = !0
                        },
                        p: function(Rt, It) {
                            var Bt = It[0];
                            Rt[0] ? bt ? (bt.p(Rt, Bt),
                            1 & Bt && (0,
                            it.Ui)(bt, 1)) : ((bt = Mu(Rt)).c(),
                            (0,
                            it.Ui)(bt, 1),
                            bt.m(Tt.parentNode, Tt)) : bt && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(bt, 1, 1, function() {
                                bt = null
                            }),
                            (0,
                            it.gbL)())
                        },
                        i: function(Rt) {
                            vt || ((0,
                            it.Ui)(bt),
                            vt = !0)
                        },
                        o: function(Rt) {
                            (0,
                            it.etI)(bt),
                            vt = !1
                        },
                        d: function(Rt) {
                            bt && bt.d(Rt),
                            Rt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function Uu(At, Tt, vt) {
                    var bt = Tt.log
                      , Rt = Tt.showTimestamps
                      , It = Rt !== void 0 && Rt
                      , Bt = Tt.groupHeader
                      , Zt = Bt === void 0 ? 0 : Bt
                      , tn = (0,
                    ot.x)()
                      , dn = ""
                      , mn = function(Sn, yn) {
                        var On = "000" + Sn;
                        return On.substring(On.length - yn)
                    };
                    return (0,
                    ot.H3)(function() {
                        Ss.use()
                    }),
                    (0,
                    ot.ev)(function() {
                        Ss.unuse()
                    }),
                    At.$$set = function(Sn) {
                        "log"in Sn && vt(0, bt = Sn.log),
                        "showTimestamps"in Sn && vt(1, It = Sn.showTimestamps),
                        "groupHeader"in Sn && vt(2, Zt = Sn.groupHeader)
                    }
                    ,
                    At.$$.update = function() {
                        if (3 & At.$$.dirty && It) {
                            var Sn = new Date(bt.date);
                            vt(3, dn = mn(Sn.getHours(), 2) + ":" + mn(Sn.getMinutes(), 2) + ":" + mn(Sn.getSeconds(), 2) + ":" + mn(Sn.getMilliseconds(), 3))
                        }
                    }
                    ,
                    [bt, It, Zt, dn, function(Sn) {
                        return !(Sn instanceof qn.Tg) && ($.kJ(Sn) || $.Kn(Sn))
                    }
                    , function() {
                        Zt > 0 && tn("groupCollapsed", {
                            groupLabel: bt.groupLabel,
                            groupHeader: Zt === 1 ? 2 : 1,
                            isGroupCollapsed: Zt === 1
                        })
                    }
                    , function() {
                        var Sn = [];
                        try {
                            for (var yn = 0; yn < bt.data.length; yn++)
                                $.HD(bt.data[yn].origData) || $.hj(bt.data[yn].origData) ? Sn.push(bt.data[yn].origData) : Sn.push($.hZ(bt.data[yn].origData, {
                                    maxDepth: 10,
                                    keyMaxLen: 1e4,
                                    pretty: !1,
                                    standardJSON: !0
                                }))
                        } catch {}
                        return Sn.join(" ")
                    }
                    ]
                }
                var P0 = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, Uu, yp, it.AqN, {
                            log: 0,
                            showTimestamps: 1,
                            groupHeader: 2
                        }),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    (0,
                    _e.Z)(Tt, [{
                        key: "log",
                        get: function() {
                            return this.$$.ctx[0]
                        },
                        set: function(vt) {
                            this.$$set({
                                log: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "showTimestamps",
                        get: function() {
                            return this.$$.ctx[1]
                        },
                        set: function(vt) {
                            this.$$set({
                                showTimestamps: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "groupHeader",
                        get: function() {
                            return this.$$.ctx[2]
                        },
                        set: function(vt) {
                            this.$$set({
                                groupHeader: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }]),
                    Tt
                }(it.f_C)
                  , D0 = P0
                  , Gm = __webpack_require__(3903)
                  , Kp = __webpack_require__(3327)
                  , ju = {};
                Kp.Z && Kp.Z.locals && (ju.locals = Kp.Z.locals);
                var Fu, Vp = 0, fu = {};
                fu.styleTagTransform = St(),
                fu.setAttributes = yt(),
                fu.insert = ht().bind(null, "head"),
                fu.domAPI = dt(),
                fu.insertStyleElement = _t(),
                ju.use = function(At) {
                    return fu.options = At || {},
                    Vp++ || (Fu = lt()(Kp.Z, fu)),
                    ju
                }
                ,
                ju.unuse = function() {
                    Vp > 0 && !--Vp && (Fu(),
                    Fu = null)
                }
                ;
                var Km = ju
                  , B0 = __webpack_require__(4264)
                  , Eo = __webpack_require__.n(B0)
                  , Ky = function() {
                    function At(vt) {
                        vt([{
                            contentRect: {
                                height: 30
                            }
                        }], this)
                    }
                    var Tt = At.prototype;
                    return Tt.disconnect = function() {}
                    ,
                    Tt.observe = function(vt, bt) {}
                    ,
                    Tt.unobserve = function(vt) {}
                    ,
                    At
                }()
                  , Yp = function() {
                    return typeof window.ResizeObserver == "function"
                }
                  , qp = function() {
                    return window.ResizeObserver || Ky
                };
                function Vm(At) {
                    var Tt, vt, bt = At[6].default, Rt = (0,
                    it.nuO)(bt, At, At[5], null);
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            Rt && Rt.c(),
                            (0,
                            it.Ljt)(Tt, "class", "vc-scroller-item"),
                            (0,
                            it.czc)(Tt, "display", At[0] ? "block" : "none", !1),
                            (0,
                            it.czc)(Tt, "top", At[3] ? At[1] + "px" : "auto", !1)
                        },
                        m: function(It, Bt) {
                            (0,
                            it.$Tr)(It, Tt, Bt),
                            Rt && Rt.m(Tt, null),
                            At[7](Tt),
                            vt = !0
                        },
                        p: function(It, Bt) {
                            var Zt = Bt[0];
                            Rt && Rt.p && (!vt || 32 & Zt) && (0,
                            it.kmG)(Rt, bt, It, It[5], vt ? (0,
                            it.u2N)(bt, It[5], Zt, null) : (0,
                            it.VOJ)(It[5]), null),
                            1 & Zt && (0,
                            it.czc)(Tt, "display", It[0] ? "block" : "none", !1),
                            2 & Zt && (0,
                            it.czc)(Tt, "top", It[3] ? It[1] + "px" : "auto", !1)
                        },
                        i: function(It) {
                            vt || ((0,
                            it.Ui)(Rt, It),
                            vt = !0)
                        },
                        o: function(It) {
                            (0,
                            it.etI)(Rt, It),
                            vt = !1
                        },
                        d: function(It) {
                            It && (0,
                            it.ogt)(Tt),
                            Rt && Rt.d(It),
                            At[7](null)
                        }
                    }
                }
                function zu(At, Tt, vt) {
                    var bt, Rt = Tt.$$slots, It = Rt === void 0 ? {} : Rt, Bt = Tt.$$scope, Zt = Tt.show, tn = Zt === void 0 ? !Yp() : Zt, dn = Tt.top, mn = Tt.onResize, Sn = mn === void 0 ? function() {}
                    : mn, yn = null, On = Yp();
                    return (0,
                    ot.H3)(function() {
                        if (tn && Sn(bt.getBoundingClientRect().height),
                        On) {
                            var An = qp();
                            (yn = new An(function(Nn) {
                                var Fn = Nn[0];
                                tn && Sn(Fn.contentRect.height)
                            }
                            )).observe(bt)
                        }
                    }),
                    (0,
                    ot.ev)(function() {
                        On && yn.disconnect()
                    }),
                    At.$$set = function(An) {
                        "show"in An && vt(0, tn = An.show),
                        "top"in An && vt(1, dn = An.top),
                        "onResize"in An && vt(4, Sn = An.onResize),
                        "$$scope"in An && vt(5, Bt = An.$$scope)
                    }
                    ,
                    [tn, dn, bt, On, Sn, Bt, It, function(An) {
                        it.VnY[An ? "unshift" : "push"](function() {
                            vt(2, bt = An)
                        })
                    }
                    ]
                }
                var U0 = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, zu, Vm, it.N8, {
                            show: 0,
                            top: 1,
                            onResize: 4
                        }),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    (0,
                    _e.Z)(Tt, [{
                        key: "show",
                        get: function() {
                            return this.$$.ctx[0]
                        },
                        set: function(vt) {
                            this.$$set({
                                show: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "top",
                        get: function() {
                            return this.$$.ctx[1]
                        },
                        set: function(vt) {
                            this.$$set({
                                top: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "onResize",
                        get: function() {
                            return this.$$.ctx[4]
                        },
                        set: function(vt) {
                            this.$$set({
                                onResize: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }]),
                    Tt
                }(it.f_C)
                  , j0 = U0
                  , Vy = function() {
                    function At() {
                        this._x = 0,
                        this._endX = 0,
                        this._v = 0,
                        this._startTime = 0,
                        this._endTime = 0
                    }
                    var Tt = At.prototype;
                    return Tt.set = function(vt, bt, Rt, It) {
                        this._x = vt,
                        this._endX = bt,
                        this._v = (bt - vt) / Rt,
                        this._startTime = It || Date.now(),
                        this._endTime = this._startTime + Rt
                    }
                    ,
                    Tt.x = function(vt) {
                        if (this.done(vt))
                            return this._endX;
                        var bt = vt - this._startTime;
                        return this._x + this._v * bt
                    }
                    ,
                    Tt.dx = function(vt) {
                        return this.done(vt) ? 0 : this._v
                    }
                    ,
                    Tt.done = function(vt) {
                        return vt >= this._endTime
                    }
                    ,
                    At
                }()
                  , F0 = function() {
                    function At(vt) {
                        this._drag = void 0,
                        this._dragLog = void 0,
                        this._x = 0,
                        this._v = 0,
                        this._startTime = 0,
                        this._drag = vt,
                        this._dragLog = Math.log(vt)
                    }
                    var Tt = At.prototype;
                    return Tt.set = function(vt, bt, Rt) {
                        this._x = vt,
                        this._v = bt,
                        this._startTime = Rt || Date.now()
                    }
                    ,
                    Tt.x = function(vt) {
                        var bt = (vt - this._startTime) / 1e3;
                        return this._x + this._v * Math.pow(this._drag, bt) / this._dragLog - this._v / this._dragLog
                    }
                    ,
                    Tt.dx = function(vt) {
                        var bt = (vt - this._startTime) / 1e3;
                        return this._v * Math.pow(this._drag, bt)
                    }
                    ,
                    Tt.done = function(vt) {
                        return Math.abs(this.dx(vt)) < 3
                    }
                    ,
                    At
                }()
                  , Ym = function(At, Tt) {
                    return At > Tt - .1 && At < Tt + .1
                }
                  , qm = function(At) {
                    return Ym(At, 0)
                }
                  , z0 = function() {
                    function At(vt, bt, Rt) {
                        this._solver = void 0,
                        this._solution = void 0,
                        this._endPosition = void 0,
                        this._startTime = void 0,
                        this._solver = function(It, Bt, Zt) {
                            var tn = Zt
                              , dn = It
                              , mn = Bt
                              , Sn = tn * tn - 4 * dn * mn;
                            if (Sn == 0) {
                                var yn = -tn / (2 * dn);
                                return function(Qn, er) {
                                    var fr = Qn
                                      , Nr = er / (yn * Qn);
                                    return {
                                        x: function(Rr) {
                                            return (fr + Nr * Rr) * Math.pow(Math.E, yn * Rr)
                                        },
                                        dx: function(Rr) {
                                            return (yn * (fr + Nr * Rr) + Nr) * Math.pow(Math.E, yn * Rr)
                                        }
                                    }
                                }
                            }
                            if (Sn > 0) {
                                var On = (-tn - Math.sqrt(Sn)) / (2 * dn)
                                  , An = (-tn + Math.sqrt(Sn)) / (2 * dn);
                                return function(Qn, er) {
                                    var fr = (er - On * Qn) / (An - On)
                                      , Nr = Qn - fr;
                                    return {
                                        x: function(Rr) {
                                            return Nr * Math.pow(Math.E, On * Rr) + fr * Math.pow(Math.E, An * Rr)
                                        },
                                        dx: function(Rr) {
                                            return Nr * On * Math.pow(Math.E, On * Rr) + fr * An * Math.pow(Math.E, An * Rr)
                                        }
                                    }
                                }
                            }
                            var Nn = Math.sqrt(4 * dn * mn - tn * tn) / (2 * dn)
                              , Fn = -tn / 2 * dn;
                            return function(Qn, er) {
                                var fr = Qn
                                  , Nr = (er - Fn * Qn) / Nn;
                                return {
                                    x: function(Rr) {
                                        return Math.pow(Math.E, Fn * Rr) * (fr * Math.cos(Nn * Rr) + Nr * Math.sin(Nn * Rr))
                                    },
                                    dx: function(Rr) {
                                        var _i = Math.pow(Math.E, Fn * Rr)
                                          , eo = Math.cos(Nn * Rr)
                                          , Gr = Math.sin(Nn * Rr);
                                        return _i * (Nr * Nn * eo - fr * Nn * Gr) + Fn * _i * (Nr * Gr + fr * eo)
                                    }
                                }
                            }
                        }(vt, bt, Rt),
                        this._solution = null,
                        this._endPosition = 0,
                        this._startTime = 0
                    }
                    var Tt = At.prototype;
                    return Tt.x = function(vt) {
                        if (!this._solution)
                            return 0;
                        var bt = (vt - this._startTime) / 1e3;
                        return this._endPosition + this._solution.x(bt)
                    }
                    ,
                    Tt.dx = function(vt) {
                        if (!this._solution)
                            return 0;
                        var bt = (vt - this._startTime) / 1e3;
                        return this._solution.dx(bt)
                    }
                    ,
                    Tt.set = function(vt, bt, Rt, It) {
                        It || (It = Date.now()),
                        this._endPosition = vt,
                        bt == vt && qm(Rt) || (this._solution = this._solver(bt - vt, Rt),
                        this._startTime = It)
                    }
                    ,
                    Tt.done = function(vt) {
                        return vt || (vt = Date.now()),
                        Ym(this.x(vt), this._endPosition) && qm(this.dx(vt))
                    }
                    ,
                    At
                }()
                  , Yy = function() {
                    function At(vt, bt) {
                        this._enableSpring = bt,
                        this._getExtend = void 0,
                        this._friction = new F0(.05),
                        this._spring = new z0(1,90,20),
                        this._toEdge = !1,
                        this._getExtend = vt
                    }
                    var Tt = At.prototype;
                    return Tt.set = function(vt, bt, Rt) {
                        if (Rt === void 0 && (Rt = Date.now()),
                        this._friction.set(vt, bt, Rt),
                        vt > 0 && bt >= 0)
                            this._toEdge = !0,
                            this._enableSpring && this._spring.set(0, vt, bt, Rt);
                        else {
                            var It = this._getExtend();
                            vt < -It && bt <= 0 ? (this._toEdge = !0,
                            this._enableSpring && this._spring.set(-It, vt, bt, Rt)) : this._toEdge = !1
                        }
                    }
                    ,
                    Tt.x = function(vt) {
                        if (this._enableSpring && this._toEdge)
                            return this._spring.x(vt);
                        var bt = this._friction.x(vt)
                          , Rt = this._friction.dx(vt);
                        if (bt > 0 && Rt >= 0) {
                            if (this._toEdge = !0,
                            !this._enableSpring)
                                return 0;
                            this._spring.set(0, bt, Rt, vt)
                        } else {
                            var It = this._getExtend();
                            if (bt < -It && Rt <= 0) {
                                if (this._toEdge = !0,
                                !this._enableSpring)
                                    return -It;
                                this._spring.set(-It, bt, Rt, vt)
                            }
                        }
                        return bt
                    }
                    ,
                    Tt.dx = function(vt) {
                        return this._toEdge ? this._enableSpring ? this._spring.dx(vt) : 0 : this._friction.dx(vt)
                    }
                    ,
                    Tt.done = function(vt) {
                        return this._toEdge ? !this._enableSpring || this._spring.done(vt) : this._friction.done(vt)
                    }
                    ,
                    At
                }();
                function Zm(At, Tt) {
                    var vt, bt;
                    return function Rt() {
                        if (!bt) {
                            var It = Date.now();
                            Tt(It),
                            At.done(It) || (vt = requestAnimationFrame(Rt))
                        }
                    }(),
                    {
                        cancel: function() {
                            cancelAnimationFrame(vt),
                            bt = !0
                        }
                    }
                }
                var qy = function() {
                    function At(vt, bt) {
                        this._updatePosition = bt,
                        this._scrollModel = void 0,
                        this._linearModel = void 0,
                        this._startPosition = 0,
                        this._position = 0,
                        this._animate = null,
                        this._getExtent = void 0,
                        this._getExtent = vt,
                        this._scrollModel = new Yy(vt,!1),
                        this._linearModel = new Vy
                    }
                    var Tt = At.prototype;
                    return Tt.onTouchStart = function() {
                        var vt = this._position;
                        if (vt > 0)
                            vt *= 0;
                        else {
                            var bt = this._getExtent();
                            vt < -bt && (vt = 0 * (vt + bt) - bt)
                        }
                        this._startPosition = this._position = vt,
                        this._animate && (this._animate.cancel(),
                        this._animate = null),
                        this._updatePosition(-vt)
                    }
                    ,
                    Tt.onTouchMove = function(vt, bt) {
                        var Rt = bt + this._startPosition;
                        if (Rt > 0)
                            Rt *= 0;
                        else {
                            var It = this._getExtent();
                            Rt < -It && (Rt = 0 * (Rt + It) - It)
                        }
                        this._position = Rt,
                        this._updatePosition(-Rt)
                    }
                    ,
                    Tt.onTouchEnd = function(vt, bt, Rt, It) {
                        var Bt = this
                          , Zt = bt + this._startPosition;
                        if (Zt > 0)
                            Zt *= 0;
                        else {
                            var tn = this._getExtent();
                            Zt < -tn && (Zt = 0 * (Zt + tn) - tn)
                        }
                        if (this._position = Zt,
                        this._updatePosition(-Zt),
                        !(Math.abs(bt) <= .1 && Math.abs(It) <= .1)) {
                            var dn = this._scrollModel;
                            dn.set(Zt, It),
                            this._animate = Zm(dn, function(mn) {
                                var Sn = Bt._position = dn.x(mn);
                                Bt._updatePosition(-Sn)
                            })
                        }
                    }
                    ,
                    Tt.onTouchCancel = function() {
                        var vt = this
                          , bt = this._position;
                        if (bt > 0)
                            bt *= 0;
                        else {
                            var Rt = this._getExtent();
                            bt < -Rt && (bt = 0 * (bt + Rt) - Rt)
                        }
                        this._position = bt;
                        var It = this._scrollModel;
                        It.set(bt, 0),
                        this._animate = Zm(It, function(Bt) {
                            var Zt = vt._position = It.x(Bt);
                            vt._updatePosition(-Zt)
                        })
                    }
                    ,
                    Tt.onWheel = function(vt, bt) {
                        var Rt = this._position - bt;
                        if (this._animate && (this._animate.cancel(),
                        this._animate = null),
                        Rt > 0)
                            Rt = 0;
                        else {
                            var It = this._getExtent();
                            Rt < -It && (Rt = -It)
                        }
                        this._position = Rt,
                        this._updatePosition(-Rt)
                    }
                    ,
                    Tt.getPosition = function() {
                        return -this._position
                    }
                    ,
                    Tt.updatePosition = function(vt) {
                        var bt = -vt - this._position;
                        this._startPosition += bt,
                        this._position += bt;
                        var Rt = this._position;
                        this._updatePosition(-Rt);
                        var It = this._scrollModel
                          , Bt = Date.now();
                        if (!It.done(Bt)) {
                            var Zt = It.dx(Bt);
                            It.set(Rt, Zt, Bt)
                        }
                    }
                    ,
                    Tt.scrollTo = function(vt, bt) {
                        var Rt = this;
                        if (this._animate && (this._animate.cancel(),
                        this._animate = null),
                        bt > 0) {
                            var It = this._linearModel;
                            It.set(this._position, -vt, bt),
                            this._animate = Zm(this._linearModel, function(Bt) {
                                var Zt = Rt._position = It.x(Bt);
                                Rt._updatePosition(-Zt)
                            })
                        } else
                            this._updatePosition(vt)
                    }
                    ,
                    At
                }();
                function W0(At, Tt) {
                    var vt = typeof Symbol < "u" && At[Symbol.iterator] || At["@@iterator"];
                    if (vt)
                        return (vt = vt.call(At)).next.bind(vt);
                    if (Array.isArray(At) || (vt = function(Rt, It) {
                        if (Rt) {
                            if (typeof Rt == "string")
                                return H0(Rt, It);
                            var Bt = Object.prototype.toString.call(Rt).slice(8, -1);
                            if (Bt === "Object" && Rt.constructor && (Bt = Rt.constructor.name),
                            Bt === "Map" || Bt === "Set")
                                return Array.from(Rt);
                            if (Bt === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Bt))
                                return H0(Rt, It)
                        }
                    }(At)) || Tt) {
                        vt && (At = vt);
                        var bt = 0;
                        return function() {
                            return bt >= At.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: At[bt++]
                            }
                        }
                    }
                    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                }
                function H0(At, Tt) {
                    (Tt == null || Tt > At.length) && (Tt = At.length);
                    for (var vt = 0, bt = new Array(Tt); vt < Tt; vt++)
                        bt[vt] = At[vt];
                    return bt
                }
                var Zy = function(At) {
                    var Tt = null
                      , vt = !1
                      , bt = function Rt() {
                        vt = !1,
                        At(),
                        Tt = requestAnimationFrame(function() {
                            Tt = null,
                            vt && Rt()
                        })
                    };
                    return {
                        trigger: function() {
                            Tt === null ? bt() : vt = !0
                        },
                        cancel: function() {
                            Tt && (cancelAnimationFrame(Tt),
                            vt = !1,
                            Tt = null)
                        }
                    }
                }
                  , Xy = function() {
                    function At(Tt) {
                        var vt = this;
                        this._handler = Tt,
                        this._touchId = null,
                        this._startX = 0,
                        this._startY = 0,
                        this._historyX = [],
                        this._historyY = [],
                        this._historyTime = [],
                        this._wheelDeltaX = 0,
                        this._wheelDeltaY = 0,
                        this._onTouchMove = function() {
                            var bt = vt._historyX[vt._historyX.length - 1]
                              , Rt = vt._historyY[vt._historyY.length - 1];
                            vt._handler.onTouchMove(bt, Rt)
                        }
                        ,
                        this._onWheel = Zy(function() {
                            var bt = vt._wheelDeltaX
                              , Rt = vt._wheelDeltaY;
                            vt._wheelDeltaX = 0,
                            vt._wheelDeltaY = 0,
                            vt._handler.onWheel(bt, Rt)
                        }),
                        this.handleTouchStart = function(bt) {
                            var Rt;
                            if (((Rt = bt.target.dataset) == null ? void 0 : Rt.scrollable) !== "1") {
                                bt.preventDefault();
                                var It = bt.touches[0];
                                vt._touchId = It.identifier,
                                vt._startX = It.pageX,
                                vt._startY = It.pageY,
                                vt._historyX = [0],
                                vt._historyY = [0],
                                vt._historyTime = [Date.now()],
                                vt._handler.onTouchStart()
                            }
                        }
                        ,
                        this.handleTouchMove = function(bt) {
                            var Rt;
                            if (((Rt = bt.target.dataset) == null ? void 0 : Rt.scrollable) !== "1") {
                                bt.preventDefault();
                                var It = vt._getTouchDelta(bt);
                                It !== null && (vt._historyX.push(It.x),
                                vt._historyY.push(It.y),
                                vt._historyTime.push(Date.now()),
                                vt._onTouchMove())
                            }
                        }
                        ,
                        this.handleTouchEnd = function(bt) {
                            var Rt;
                            if (((Rt = bt.target.dataset) == null ? void 0 : Rt.scrollable) !== "1") {
                                bt.preventDefault();
                                var It = vt._getTouchDelta(bt);
                                if (It !== null) {
                                    for (var Bt = 0, Zt = 0, tn = Date.now(), dn = It.y, mn = It.x, Sn = vt._historyTime, yn = Sn.length - 1; yn > 0; yn -= 1) {
                                        var On = tn - Sn[yn];
                                        if (On > 30) {
                                            Bt = 1e3 * (mn - vt._historyX[yn]) / On,
                                            Zt = 1e3 * (dn - vt._historyY[yn]) / On;
                                            break
                                        }
                                    }
                                    vt._touchId = null,
                                    vt._handler.onTouchEnd(It.x, It.y, Bt, Zt)
                                }
                            }
                        }
                        ,
                        this.handleTouchCancel = function(bt) {
                            var Rt;
                            ((Rt = bt.target.dataset) == null ? void 0 : Rt.scrollable) !== "1" && (bt.preventDefault(),
                            vt._getTouchDelta(bt) !== null && (vt._touchId = null,
                            vt._handler.onTouchCancel()))
                        }
                        ,
                        this.handleWheel = function(bt) {
                            var Rt;
                            ((Rt = bt.target.dataset) == null ? void 0 : Rt.scrollable) !== "1" && (bt.preventDefault(),
                            vt._wheelDeltaX += bt.deltaX,
                            vt._wheelDeltaY += bt.deltaY,
                            vt._onWheel.trigger())
                        }
                    }
                    return At.prototype._getTouchDelta = function(Tt) {
                        if (this._touchId === null)
                            return null;
                        for (var vt, bt = W0(Tt.changedTouches); !(vt = bt()).done; ) {
                            var Rt = vt.value;
                            if (Rt.identifier === this._touchId)
                                return {
                                    x: Rt.pageX - this._startX,
                                    y: Rt.pageY - this._startY
                                }
                        }
                        return null
                    }
                    ,
                    At
                }()
                  , Zp = __webpack_require__(1142)
                  , pu = {};
                Zp.Z && Zp.Z.locals && (pu.locals = Zp.Z.locals);
                var Xm, Qm = 0, hu = {};
                hu.styleTagTransform = St(),
                hu.setAttributes = yt(),
                hu.insert = ht().bind(null, "head"),
                hu.domAPI = dt(),
                hu.insertStyleElement = _t(),
                pu.use = function(At) {
                    return hu.options = At || {},
                    Qm++ || (Xm = lt()(Zp.Z, hu)),
                    pu
                }
                ,
                pu.unuse = function() {
                    Qm > 0 && !--Qm && (Xm(),
                    Xm = null)
                }
                ;
                var G0 = pu
                  , Qy = function() {
                    var At = []
                      , Tt = []
                      , vt = 0
                      , bt = 0
                      , Rt = 0
                      , It = 0
                      , Bt = 0;
                    return function(Zt, tn, dn) {
                        if (Rt === Zt && It === tn && Bt === dn)
                            return At;
                        var mn = Tt.length
                          , Sn = tn <= bt ? Math.max(0, Math.min(tn, Math.max(vt, Math.min(bt - 1, dn - mn)))) : tn
                          , yn = vt <= dn ? Math.max(dn, Math.min(Zt, Math.max(vt + 1, Math.min(bt, Sn + mn)))) : dn;
                        if (mn === 0 || yn - Sn < mn) {
                            for (var On = At.length = Tt.length = dn - tn, An = 0; An < On; An += 1)
                                Tt[An] = An,
                                At[An] = {
                                    key: An,
                                    index: An + tn,
                                    show: !0
                                };
                            return vt = tn,
                            bt = dn,
                            Rt = Zt,
                            It = tn,
                            Bt = dn,
                            At
                        }
                        var Nn = 0
                          , Fn = 0
                          , Qn = 0
                          , er = 0;
                        bt < Sn || yn < vt ? (Qn = Sn,
                        er = Sn + mn) : vt < Sn ? (Fn = Sn - vt,
                        Qn = Sn,
                        er = Sn + mn) : yn < bt ? (Fn = mn - (bt - yn),
                        Qn = yn - mn,
                        er = yn) : Sn <= vt && bt <= yn && (Qn = vt,
                        er = bt);
                        for (var fr = Sn; fr < tn; fr += 1,
                        Nn += 1) {
                            var Nr = Tt[(Fn + Nn) % mn]
                              , Rr = At[fr - Sn];
                            Rr.key = Nr,
                            Rr.index = fr,
                            Rr.show = !1
                        }
                        for (var _i = tn, eo = 0; _i < dn; _i += 1) {
                            var Gr = void 0;
                            Qn <= _i && _i < er ? (Gr = Tt[(Fn + Nn) % mn],
                            Nn += 1) : (Gr = mn + eo,
                            eo += 1);
                            var Ar = _i - Sn;
                            if (Ar < At.length) {
                                var Or = At[Ar];
                                Or.key = Gr,
                                Or.index = _i,
                                Or.show = !0
                            } else
                                At.push({
                                    key: Gr,
                                    index: _i,
                                    show: !0
                                })
                        }
                        for (var Fr = dn; Fr < yn; Fr += 1,
                        Nn += 1) {
                            var Vo = Tt[(Fn + Nn) % mn]
                              , lo = At[Fr - Sn];
                            lo.key = Vo,
                            lo.index = Fr,
                            lo.show = !1
                        }
                        for (var to = 0; to < At.length; to += 1)
                            Tt[to] = At[to].key;
                        return At.sort(function(Kr, mr) {
                            return Kr.key - mr.key
                        }),
                        vt = Sn,
                        bt = yn,
                        Rt = Zt,
                        It = tn,
                        Bt = dn,
                        At
                    }
                }
                  , No = it.lig.Map
                  , Oo = function(At) {
                    return {}
                }
                  , K0 = function(At) {
                    return {}
                }
                  , Jy = function(At) {
                    return {}
                }
                  , V0 = function(At) {
                    return {}
                };
                function Y0(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[53] = Tt[vt],
                    bt[55] = vt,
                    bt
                }
                var e1 = function(At) {
                    return {
                        item: 1025 & At[0]
                    }
                }
                  , q0 = function(At) {
                    return {
                        item: At[0][At[53].index]
                    }
                }
                  , Z0 = function(At) {
                    return {}
                }
                  , X0 = function(At) {
                    return {}
                };
                function rs(At) {
                    var Tt, vt, bt = At[24].header, Rt = (0,
                    it.nuO)(bt, At, At[31], X0);
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            Rt && Rt.c(),
                            (0,
                            it.Ljt)(Tt, "class", "vc-scroller-header")
                        },
                        m: function(It, Bt) {
                            (0,
                            it.$Tr)(It, Tt, Bt),
                            Rt && Rt.m(Tt, null),
                            At[25](Tt),
                            vt = !0
                        },
                        p: function(It, Bt) {
                            Rt && Rt.p && (!vt || 1 & Bt[1]) && (0,
                            it.kmG)(Rt, bt, It, It[31], vt ? (0,
                            it.u2N)(bt, It[31], Bt, Z0) : (0,
                            it.VOJ)(It[31]), X0)
                        },
                        i: function(It) {
                            vt || ((0,
                            it.Ui)(Rt, It),
                            vt = !0)
                        },
                        o: function(It) {
                            (0,
                            it.etI)(Rt, It),
                            vt = !1
                        },
                        d: function(It) {
                            It && (0,
                            it.ogt)(Tt),
                            Rt && Rt.d(It),
                            At[25](null)
                        }
                    }
                }
                function Jm(At) {
                    var Tt, vt = At[24].empty, bt = (0,
                    it.nuO)(vt, At, At[31], V0);
                    return {
                        c: function() {
                            bt && bt.c()
                        },
                        m: function(Rt, It) {
                            bt && bt.m(Rt, It),
                            Tt = !0
                        },
                        p: function(Rt, It) {
                            bt && bt.p && (!Tt || 1 & It[1]) && (0,
                            it.kmG)(bt, vt, Rt, Rt[31], Tt ? (0,
                            it.u2N)(vt, Rt[31], It, Jy) : (0,
                            it.VOJ)(Rt[31]), V0)
                        },
                        i: function(Rt) {
                            Tt || ((0,
                            it.Ui)(bt, Rt),
                            Tt = !0)
                        },
                        o: function(Rt) {
                            (0,
                            it.etI)(bt, Rt),
                            Tt = !1
                        },
                        d: function(Rt) {
                            bt && bt.d(Rt)
                        }
                    }
                }
                function gu(At) {
                    for (var Tt, vt, bt = [], Rt = new No, It = At[10], Bt = function(mn) {
                        return mn[53].key
                    }, Zt = 0; Zt < It.length; Zt += 1) {
                        var tn = Y0(At, It, Zt)
                          , dn = Bt(tn);
                        Rt.set(dn, bt[Zt] = Xp(dn, tn))
                    }
                    return {
                        c: function() {
                            for (var mn = 0; mn < bt.length; mn += 1)
                                bt[mn].c();
                            Tt = (0,
                            it.cSb)()
                        },
                        m: function(mn, Sn) {
                            for (var yn = 0; yn < bt.length; yn += 1)
                                bt[yn].m(mn, Sn);
                            (0,
                            it.$Tr)(mn, Tt, Sn),
                            vt = !0
                        },
                        p: function(mn, Sn) {
                            17921 & Sn[0] | 1 & Sn[1] && (It = mn[10],
                            (0,
                            it.dvw)(),
                            bt = (0,
                            it.GQg)(bt, Sn, Bt, 1, mn, It, Rt, Tt.parentNode, it.cly, Xp, Tt, Y0),
                            (0,
                            it.gbL)())
                        },
                        i: function(mn) {
                            if (!vt) {
                                for (var Sn = 0; Sn < It.length; Sn += 1)
                                    (0,
                                    it.Ui)(bt[Sn]);
                                vt = !0
                            }
                        },
                        o: function(mn) {
                            for (var Sn = 0; Sn < bt.length; Sn += 1)
                                (0,
                                it.etI)(bt[Sn]);
                            vt = !1
                        },
                        d: function(mn) {
                            for (var Sn = 0; Sn < bt.length; Sn += 1)
                                bt[Sn].d(mn);
                            mn && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function Q0(At) {
                    var Tt, vt, bt = At[24].item, Rt = (0,
                    it.nuO)(bt, At, At[31], q0), It = Rt || function(Bt) {
                        var Zt;
                        return {
                            c: function() {
                                Zt = (0,
                                it.fLW)("Missing template")
                            },
                            m: function(tn, dn) {
                                (0,
                                it.$Tr)(tn, Zt, dn)
                            },
                            d: function(tn) {
                                tn && (0,
                                it.ogt)(Zt)
                            }
                        }
                    }();
                    return {
                        c: function() {
                            It && It.c(),
                            Tt = (0,
                            it.DhX)()
                        },
                        m: function(Bt, Zt) {
                            It && It.m(Bt, Zt),
                            (0,
                            it.$Tr)(Bt, Tt, Zt),
                            vt = !0
                        },
                        p: function(Bt, Zt) {
                            Rt && Rt.p && (!vt || 1025 & Zt[0] | 1 & Zt[1]) && (0,
                            it.kmG)(Rt, bt, Bt, Bt[31], vt ? (0,
                            it.u2N)(bt, Bt[31], Zt, e1) : (0,
                            it.VOJ)(Bt[31]), q0)
                        },
                        i: function(Bt) {
                            vt || ((0,
                            it.Ui)(It, Bt),
                            vt = !0)
                        },
                        o: function(Bt) {
                            (0,
                            it.etI)(It, Bt),
                            vt = !1
                        },
                        d: function(Bt) {
                            It && It.d(Bt),
                            Bt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function Xp(At, Tt) {
                    var vt, bt, Rt;
                    function It() {
                        for (var Bt, Zt = arguments.length, tn = new Array(Zt), dn = 0; dn < Zt; dn++)
                            tn[dn] = arguments[dn];
                        return (Bt = Tt)[26].apply(Bt, [Tt[53]].concat(tn))
                    }
                    return bt = new j0({
                        props: {
                            show: Tt[53].show,
                            top: Tt[9][Tt[53].index],
                            onResize: It,
                            $$slots: {
                                default: [Q0]
                            },
                            $$scope: {
                                ctx: Tt
                            }
                        }
                    }),
                    {
                        key: At,
                        first: null,
                        c: function() {
                            vt = (0,
                            it.cSb)(),
                            (0,
                            it.YCL)(bt.$$.fragment),
                            this.first = vt
                        },
                        m: function(Bt, Zt) {
                            (0,
                            it.$Tr)(Bt, vt, Zt),
                            (0,
                            it.yef)(bt, Bt, Zt),
                            Rt = !0
                        },
                        p: function(Bt, Zt) {
                            Tt = Bt;
                            var tn = {};
                            1024 & Zt[0] && (tn.show = Tt[53].show),
                            1536 & Zt[0] && (tn.top = Tt[9][Tt[53].index]),
                            1024 & Zt[0] && (tn.onResize = It),
                            1025 & Zt[0] | 1 & Zt[1] && (tn.$$scope = {
                                dirty: Zt,
                                ctx: Tt
                            }),
                            bt.$set(tn)
                        },
                        i: function(Bt) {
                            Rt || ((0,
                            it.Ui)(bt.$$.fragment, Bt),
                            Rt = !0)
                        },
                        o: function(Bt) {
                            (0,
                            it.etI)(bt.$$.fragment, Bt),
                            Rt = !1
                        },
                        d: function(Bt) {
                            Bt && (0,
                            it.ogt)(vt),
                            (0,
                            it.vpE)(bt, Bt)
                        }
                    }
                }
                function ks(At) {
                    var Tt, vt, bt = At[24].footer, Rt = (0,
                    it.nuO)(bt, At, At[31], K0);
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            Rt && Rt.c(),
                            (0,
                            it.Ljt)(Tt, "class", "vc-scroller-footer")
                        },
                        m: function(It, Bt) {
                            (0,
                            it.$Tr)(It, Tt, Bt),
                            Rt && Rt.m(Tt, null),
                            At[28](Tt),
                            vt = !0
                        },
                        p: function(It, Bt) {
                            Rt && Rt.p && (!vt || 1 & Bt[1]) && (0,
                            it.kmG)(Rt, bt, It, It[31], vt ? (0,
                            it.u2N)(bt, It[31], Bt, Oo) : (0,
                            it.VOJ)(It[31]), K0)
                        },
                        i: function(It) {
                            vt || ((0,
                            it.Ui)(Rt, It),
                            vt = !0)
                        },
                        o: function(It) {
                            (0,
                            it.etI)(Rt, It),
                            vt = !1
                        },
                        d: function(It) {
                            It && (0,
                            it.ogt)(Tt),
                            Rt && Rt.d(It),
                            At[28](null)
                        }
                    }
                }
                function e0(At) {
                    var Tt, vt, bt = At[7] + "%", Rt = At[8] + "%";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("div"),
                            (0,
                            it.Ljt)(vt, "class", "vc-scroller-scrollbar-thumb"),
                            (0,
                            it.czc)(vt, "height", bt, !1),
                            (0,
                            it.czc)(vt, "top", Rt, !1),
                            (0,
                            it.Ljt)(Tt, "class", "vc-scroller-scrollbar-track"),
                            (0,
                            it.czc)(Tt, "display", At[7] < 100 ? "block" : "none", !1)
                        },
                        m: function(It, Bt) {
                            (0,
                            it.$Tr)(It, Tt, Bt),
                            (0,
                            it.R3I)(Tt, vt)
                        },
                        p: function(It, Bt) {
                            128 & Bt[0] && bt !== (bt = It[7] + "%") && (0,
                            it.czc)(vt, "height", bt, !1),
                            256 & Bt[0] && Rt !== (Rt = It[8] + "%") && (0,
                            it.czc)(vt, "top", Rt, !1),
                            128 & Bt[0] && (0,
                            it.czc)(Tt, "display", It[7] < 100 ? "block" : "none", !1)
                        },
                        d: function(It) {
                            It && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function J0(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt, tn, dn, mn, Sn, yn = At[15].header && rs(At), On = [gu, Jm], An = [];
                    function Nn(er, fr) {
                        return er[0].length ? 0 : 1
                    }
                    It = Nn(At),
                    Bt = An[It] = On[It](At);
                    var Fn = At[15].footer && ks(At)
                      , Qn = At[1] && e0(At);
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("div"),
                            yn && yn.c(),
                            bt = (0,
                            it.DhX)(),
                            Rt = (0,
                            it.bGB)("div"),
                            Bt.c(),
                            Zt = (0,
                            it.DhX)(),
                            Fn && Fn.c(),
                            tn = (0,
                            it.DhX)(),
                            Qn && Qn.c(),
                            (0,
                            it.Ljt)(Rt, "class", "vc-scroller-items"),
                            (0,
                            it.Ljt)(vt, "class", "vc-scroller-contents"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-scroller-viewport"),
                            (0,
                            it.VHj)(Tt, "static", !At[13])
                        },
                        m: function(er, fr) {
                            (0,
                            it.$Tr)(er, Tt, fr),
                            (0,
                            it.R3I)(Tt, vt),
                            yn && yn.m(vt, null),
                            (0,
                            it.R3I)(vt, bt),
                            (0,
                            it.R3I)(vt, Rt),
                            An[It].m(Rt, null),
                            At[27](Rt),
                            (0,
                            it.R3I)(vt, Zt),
                            Fn && Fn.m(vt, null),
                            At[29](vt),
                            (0,
                            it.R3I)(Tt, tn),
                            Qn && Qn.m(Tt, null),
                            At[30](Tt),
                            dn = !0,
                            mn || (Sn = [(0,
                            it.oLt)(Tt, "touchstart", function() {
                                (0,
                                it.sBU)(At[13] ? At[11].handleTouchStart : At[12]) && (At[13] ? At[11].handleTouchStart : At[12]).apply(this, arguments)
                            }), (0,
                            it.oLt)(Tt, "touchmove", function() {
                                (0,
                                it.sBU)(At[13] ? At[11].handleTouchMove : At[12]) && (At[13] ? At[11].handleTouchMove : At[12]).apply(this, arguments)
                            }), (0,
                            it.oLt)(Tt, "touchend", function() {
                                (0,
                                it.sBU)(At[13] ? At[11].handleTouchEnd : At[12]) && (At[13] ? At[11].handleTouchEnd : At[12]).apply(this, arguments)
                            }), (0,
                            it.oLt)(Tt, "touchcancel", function() {
                                (0,
                                it.sBU)(At[13] ? At[11].handleTouchCancel : At[12]) && (At[13] ? At[11].handleTouchCancel : At[12]).apply(this, arguments)
                            }), (0,
                            it.oLt)(Tt, "wheel", function() {
                                (0,
                                it.sBU)(At[13] ? At[11].handleWheel : At[12]) && (At[13] ? At[11].handleWheel : At[12]).apply(this, arguments)
                            })],
                            mn = !0)
                        },
                        p: function(er, fr) {
                            (At = er)[15].header ? yn ? (yn.p(At, fr),
                            32768 & fr[0] && (0,
                            it.Ui)(yn, 1)) : ((yn = rs(At)).c(),
                            (0,
                            it.Ui)(yn, 1),
                            yn.m(vt, bt)) : yn && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(yn, 1, 1, function() {
                                yn = null
                            }),
                            (0,
                            it.gbL)());
                            var Nr = It;
                            (It = Nn(At)) === Nr ? An[It].p(At, fr) : ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(An[Nr], 1, 1, function() {
                                An[Nr] = null
                            }),
                            (0,
                            it.gbL)(),
                            (Bt = An[It]) ? Bt.p(At, fr) : (Bt = An[It] = On[It](At)).c(),
                            (0,
                            it.Ui)(Bt, 1),
                            Bt.m(Rt, null)),
                            At[15].footer ? Fn ? (Fn.p(At, fr),
                            32768 & fr[0] && (0,
                            it.Ui)(Fn, 1)) : ((Fn = ks(At)).c(),
                            (0,
                            it.Ui)(Fn, 1),
                            Fn.m(vt, null)) : Fn && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(Fn, 1, 1, function() {
                                Fn = null
                            }),
                            (0,
                            it.gbL)()),
                            At[1] ? Qn ? Qn.p(At, fr) : ((Qn = e0(At)).c(),
                            Qn.m(Tt, null)) : Qn && (Qn.d(1),
                            Qn = null)
                        },
                        i: function(er) {
                            dn || ((0,
                            it.Ui)(yn),
                            (0,
                            it.Ui)(Bt),
                            (0,
                            it.Ui)(Fn),
                            dn = !0)
                        },
                        o: function(er) {
                            (0,
                            it.etI)(yn),
                            (0,
                            it.etI)(Bt),
                            (0,
                            it.etI)(Fn),
                            dn = !1
                        },
                        d: function(er) {
                            er && (0,
                            it.ogt)(Tt),
                            yn && yn.d(),
                            An[It].d(),
                            At[27](null),
                            Fn && Fn.d(),
                            At[29](null),
                            Qn && Qn.d(),
                            At[30](null),
                            mn = !1,
                            (0,
                            it.j7q)(Sn)
                        }
                    }
                }
                function ey(At, Tt, vt) {
                    var bt, Rt, It, Bt, Zt, tn, dn, mn = Tt.$$slots, Sn = mn === void 0 ? {} : mn, yn = Tt.$$scope, On = (0,
                    it.XGm)(Sn), An = this && this.__awaiter || function(yr, qr, Hr, Lr) {
                        return new (Hr || (Hr = Promise))(function(co, $o) {
                            function Ho(Ao) {
                                try {
                                    cs(Lr.next(Ao))
                                } catch (vs) {
                                    $o(vs)
                                }
                            }
                            function ys(Ao) {
                                try {
                                    cs(Lr.throw(Ao))
                                } catch (vs) {
                                    $o(vs)
                                }
                            }
                            function cs(Ao) {
                                var vs;
                                Ao.done ? co(Ao.value) : (vs = Ao.value,
                                vs instanceof Hr ? vs : new Hr(function(jo) {
                                    jo(vs)
                                }
                                )).then(Ho, ys)
                            }
                            cs((Lr = Lr.apply(yr, qr || [])).next())
                        }
                        )
                    }
                    , Nn = Tt.items, Fn = Tt.itemKey, Qn = Fn === void 0 ? void 0 : Fn, er = Tt.itemHeight, fr = er === void 0 ? void 0 : er, Nr = Tt.buffer, Rr = Nr === void 0 ? 200 : Nr, _i = Tt.stickToBottom, eo = _i !== void 0 && _i, Gr = Tt.scrollbar, Ar = Gr !== void 0 && Gr, Or = Tt.start, Fr = Or === void 0 ? 0 : Or, Vo = Tt.end, lo = Vo === void 0 ? 0 : Vo, to = 0, Kr = 0, mr = 0, _r = 0, vo = 100, ar = 0, $r = [], Vr = [], Sr = [], Wr = Qy(), Po = function() {
                        return Math.max(0, _r + to + Kr - mr)
                    }, Wo = !0, es = !1, so = [], gs = !1, Do = !1, Bo = Yp(), Uo = function(yr, qr) {
                        var Hr;
                        (0,
                        ot.H3)(function() {
                            var Lr = yr();
                            if (Lr) {
                                qr(Lr.getBoundingClientRect().height),
                                Hr && Hr.disconnect();
                                var co = qp();
                                (Hr = new co(function($o) {
                                    var Ho = $o[0];
                                    qr(Ho.contentRect.height)
                                }
                                )).observe(Lr)
                            } else
                                qr(0),
                                Hr && (Hr.disconnect(),
                                Hr = null)
                        }),
                        (0,
                        ot.ev)(function() {
                            Hr && (Hr.disconnect(),
                            Hr = null)
                        })
                    }, Ts = function() {
                        var yr = tn.getPosition()
                          , qr = 100 / (_r + to + Kr);
                        vt(8, ar = yr * qr),
                        vt(7, vo = mr * qr)
                    }, Go = function(yr) {
                        var qr = Po();
                        (yr || tn.getPosition() > qr) && tn.updatePosition(qr)
                    }, Rs = function(yr) {
                        (function(qr, Hr, Lr) {
                            for (var co = new Map, $o = 0; $o < so.length; $o += 1) {
                                var Ho = so[$o]
                                  , ys = Qn === void 0 ? Ho : Ho[Qn];
                                co.set(ys, $r[$o])
                            }
                            vt(9, Vr.length = $r.length = qr.length, Vr);
                            for (var cs = 0, Ao = 0; Ao < qr.length; Ao += 1) {
                                var vs = qr[Ao]
                                  , jo = Qn === void 0 ? vs : vs[Qn];
                                co.has(jo) ? $r[Ao] = co.get(jo) : $r[Ao] = Lr,
                                vt(9, Vr[Ao] = cs, Vr),
                                cs += $r[Ao]
                            }
                            _r = Math.max(cs, Hr - to - Kr),
                            so = qr,
                            Bo ? (ms(qr, tn.getPosition(), Hr),
                            vt(6, Zt.style.height = _r + "px", Zt),
                            Go(Wo && eo),
                            Ts()) : ms(qr, 0, 9e6)
                        }
                        )(yr, mr, fr)
                    };
                    function ms(yr, qr, Hr) {
                        for (var Lr = 0, co = 0; Lr < yr.length && co + $r[Lr] < qr - Rr; )
                            co += $r[Lr],
                            Lr += 1;
                        for (vt(16, Fr = Lr); Lr < yr.length && Hr && co < qr + Hr + Rr; )
                            co += $r[Lr],
                            Lr += 1;
                        vt(17, lo = Lr),
                        vt(10, Sr = Wr(yr.length, Fr, lo))
                    }
                    var Eu = function(yr, qr) {
                        return An(void 0, void 0, void 0, Eo().mark(function Hr() {
                            var Lr, co, $o, Ho;
                            return Eo().wrap(function(ys) {
                                for (; ; )
                                    switch (ys.prev = ys.next) {
                                    case 0:
                                        if ($r[yr] !== qr && mr !== 0) {
                                            ys.next = 2;
                                            break
                                        }
                                        return ys.abrupt("return");
                                    case 2:
                                        for (Lr = $r[yr],
                                        $r[yr] = qr,
                                        co = Nn.length,
                                        $o = yr; $o < co - 1; $o += 1)
                                            vt(9, Vr[$o + 1] = Vr[$o] + $r[$o], Vr);
                                        return _r = Math.max(Vr[co - 1] + $r[co - 1], mr - to - Kr),
                                        Ho = tn.getPosition(),
                                        es = !0,
                                        Vr[yr] + Lr < Ho ? tn.updatePosition(Ho + qr - Lr) : Go(Wo && eo),
                                        ys.next = 12,
                                        new Promise(function(cs) {
                                            return setTimeout(cs, 0)
                                        }
                                        );
                                    case 12:
                                        ms(Nn, tn.getPosition(), mr),
                                        vt(6, Zt.style.height = _r + "px", Zt),
                                        Ts();
                                    case 15:
                                    case "end":
                                        return ys.stop()
                                    }
                            }, Hr)
                        }))
                    };
                    (0,
                    ot.H3)(function() {
                        vt(23, gs = !0),
                        G0.use()
                    }),
                    (0,
                    ot.ev)(function() {
                        G0.unuse()
                    }),
                    Bo && (Bo && (tn = tn || new qy(Po,function(yr) {
                        return An(void 0, void 0, void 0, Eo().mark(function qr() {
                            var Hr;
                            return Eo().wrap(function(Lr) {
                                for (; ; )
                                    switch (Lr.prev = Lr.next) {
                                    case 0:
                                        if (Hr = Po(),
                                        Wo = Math.abs(yr - Hr) <= 1,
                                        vt(5, Bt.style.transform = "translateY(" + -yr + "px) translateZ(0)", Bt),
                                        Ts(),
                                        !es) {
                                            Lr.next = 8;
                                            break
                                        }
                                        es = !1,
                                        Lr.next = 11;
                                        break;
                                    case 8:
                                        return Lr.next = 10,
                                        new Promise(function(co) {
                                            return setTimeout(co, 0)
                                        }
                                        );
                                    case 10:
                                        ms(Nn, yr, mr);
                                    case 11:
                                    case "end":
                                        return Lr.stop()
                                    }
                            }, qr)
                        }))
                    }
                    ),
                    vt(11, dn = dn || new Xy(tn))),
                    !Do && Bo && (Uo(function() {
                        return It
                    }, function(yr) {
                        return An(void 0, void 0, void 0, Eo().mark(function qr() {
                            var Hr, Lr;
                            return Eo().wrap(function(co) {
                                for (; ; )
                                    switch (co.prev = co.next) {
                                    case 0:
                                        if (mr !== yr) {
                                            co.next = 2;
                                            break
                                        }
                                        return co.abrupt("return");
                                    case 2:
                                        for (mr = yr,
                                        Hr = 0,
                                        Lr = 0; Lr < Nn.length; Lr += 1)
                                            Hr += $r[Lr];
                                        return _r = Math.max(Hr, mr - Kr),
                                        vt(6, Zt.style.height = _r + "px", Zt),
                                        co.next = 9,
                                        new Promise(function($o) {
                                            return setTimeout($o, 0)
                                        }
                                        );
                                    case 9:
                                        Rs(Nn),
                                        ms(Nn, tn.getPosition(), mr),
                                        mr !== 0 && Go(Wo && eo),
                                        Ts();
                                    case 13:
                                    case "end":
                                        return co.stop()
                                    }
                            }, qr)
                        }))
                    }),
                    Uo(function() {
                        return Rt
                    }, function(yr) {
                        if (Kr !== yr) {
                            Kr = yr;
                            for (var qr = 0, Hr = 0; Hr < Nn.length; Hr += 1)
                                qr += $r[Hr];
                            _r = Math.max(qr, mr - to - Kr),
                            vt(6, Zt.style.height = _r + "px", Zt),
                            mr !== 0 && Go(Wo && eo),
                            Ts()
                        }
                    }),
                    Uo(function() {
                        return bt
                    }, function(yr) {
                        to !== yr && (to = yr,
                        Rs(Nn),
                        Ts())
                    })));
                    var Ap = {
                        scrollTo: function(yr) {
                            if (Bo) {
                                var qr = Vr[Math.max(0, Math.min(Nn.length - 1, yr))]
                                  , Hr = Math.min(Po(), qr)
                                  , Lr = Math.min(Math.floor(500 * Math.abs(tn.getPosition() - Hr) / 2e3), 500);
                                tn.scrollTo(Hr, Lr)
                            }
                        }
                    };
                    return At.$$set = function(yr) {
                        "items"in yr && vt(0, Nn = yr.items),
                        "itemKey"in yr && vt(18, Qn = yr.itemKey),
                        "itemHeight"in yr && vt(19, fr = yr.itemHeight),
                        "buffer"in yr && vt(20, Rr = yr.buffer),
                        "stickToBottom"in yr && vt(21, eo = yr.stickToBottom),
                        "scrollbar"in yr && vt(1, Ar = yr.scrollbar),
                        "start"in yr && vt(16, Fr = yr.start),
                        "end"in yr && vt(17, lo = yr.end),
                        "$$scope"in yr && vt(31, yn = yr.$$scope)
                    }
                    ,
                    At.$$.update = function() {
                        8388609 & At.$$.dirty[0] && gs && (Bo || vt(4, It.parentElement.style.height = "auto", It),
                        Rs(Nn),
                        Do = !0)
                    }
                    ,
                    [Nn, Ar, bt, Rt, It, Bt, Zt, vo, ar, Vr, Sr, dn, function() {}
                    , Bo, Eu, On, Fr, lo, Qn, fr, Rr, eo, Ap, gs, Sn, function(yr) {
                        it.VnY[yr ? "unshift" : "push"](function() {
                            vt(2, bt = yr)
                        })
                    }
                    , function(yr, qr) {
                        return Eu(yr.index, qr)
                    }
                    , function(yr) {
                        it.VnY[yr ? "unshift" : "push"](function() {
                            vt(6, Zt = yr)
                        })
                    }
                    , function(yr) {
                        it.VnY[yr ? "unshift" : "push"](function() {
                            vt(3, Rt = yr)
                        })
                    }
                    , function(yr) {
                        it.VnY[yr ? "unshift" : "push"](function() {
                            vt(5, Bt = yr)
                        })
                    }
                    , function(yr) {
                        it.VnY[yr ? "unshift" : "push"](function() {
                            vt(4, It = yr),
                            vt(23, gs),
                            vt(13, Bo),
                            vt(0, Nn)
                        })
                    }
                    , yn]
                }
                var ty = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, ey, J0, it.N8, {
                            items: 0,
                            itemKey: 18,
                            itemHeight: 19,
                            buffer: 20,
                            stickToBottom: 21,
                            scrollbar: 1,
                            start: 16,
                            end: 17,
                            handler: 22
                        }, null, [-1, -1]),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    (0,
                    _e.Z)(Tt, [{
                        key: "items",
                        get: function() {
                            return this.$$.ctx[0]
                        },
                        set: function(vt) {
                            this.$$set({
                                items: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "itemKey",
                        get: function() {
                            return this.$$.ctx[18]
                        },
                        set: function(vt) {
                            this.$$set({
                                itemKey: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "itemHeight",
                        get: function() {
                            return this.$$.ctx[19]
                        },
                        set: function(vt) {
                            this.$$set({
                                itemHeight: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "buffer",
                        get: function() {
                            return this.$$.ctx[20]
                        },
                        set: function(vt) {
                            this.$$set({
                                buffer: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "stickToBottom",
                        get: function() {
                            return this.$$.ctx[21]
                        },
                        set: function(vt) {
                            this.$$set({
                                stickToBottom: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "scrollbar",
                        get: function() {
                            return this.$$.ctx[1]
                        },
                        set: function(vt) {
                            this.$$set({
                                scrollbar: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "start",
                        get: function() {
                            return this.$$.ctx[16]
                        },
                        set: function(vt) {
                            this.$$set({
                                start: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "end",
                        get: function() {
                            return this.$$.ctx[17]
                        },
                        set: function(vt) {
                            this.$$set({
                                end: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "handler",
                        get: function() {
                            return this.$$.ctx[22]
                        }
                    }]),
                    Tt
                }(it.f_C)
                  , t0 = ty;
                function ny(At) {
                    var Tt;
                    return {
                        c: function() {
                            (Tt = (0,
                            it.bGB)("div")).textContent = "Empty",
                            (0,
                            it.Ljt)(Tt, "slot", "empty"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-plugin-empty")
                        },
                        m: function(vt, bt) {
                            (0,
                            it.$Tr)(vt, Tt, bt)
                        },
                        p: it.ZTd,
                        d: function(vt) {
                            vt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function Ls(At) {
                    var Tt, vt;
                    return (Tt = new D0({
                        props: {
                            slot: "item",
                            log: At[16],
                            showTimestamps: At[1],
                            groupHeader: At[16].groupHeader
                        }
                    })).$on("groupCollapsed", At[6]),
                    {
                        c: function() {
                            (0,
                            it.YCL)(Tt.$$.fragment)
                        },
                        m: function(bt, Rt) {
                            (0,
                            it.yef)(Tt, bt, Rt),
                            vt = !0
                        },
                        p: function(bt, Rt) {
                            var It = {};
                            65536 & Rt && (It.log = bt[16]),
                            2 & Rt && (It.showTimestamps = bt[1]),
                            65536 & Rt && (It.groupHeader = bt[16].groupHeader),
                            Tt.$set(It)
                        },
                        i: function(bt) {
                            vt || ((0,
                            it.Ui)(Tt.$$.fragment, bt),
                            vt = !0)
                        },
                        o: function(bt) {
                            (0,
                            it.etI)(Tt.$$.fragment, bt),
                            vt = !1
                        },
                        d: function(bt) {
                            (0,
                            it.vpE)(Tt, bt)
                        }
                    }
                }
                function ry(At) {
                    var Tt, vt;
                    return (Tt = new Gm.Z({})).$on("filterText", At[5]),
                    {
                        c: function() {
                            (0,
                            it.YCL)(Tt.$$.fragment)
                        },
                        m: function(bt, Rt) {
                            (0,
                            it.yef)(Tt, bt, Rt),
                            vt = !0
                        },
                        p: it.ZTd,
                        i: function(bt) {
                            vt || ((0,
                            it.Ui)(Tt.$$.fragment, bt),
                            vt = !0)
                        },
                        o: function(bt) {
                            (0,
                            it.etI)(Tt.$$.fragment, bt),
                            vt = !1
                        },
                        d: function(bt) {
                            (0,
                            it.vpE)(Tt, bt)
                        }
                    }
                }
                function Gs(At) {
                    var Tt, vt, bt = At[0] && ry(At);
                    return {
                        c: function() {
                            bt && bt.c(),
                            Tt = (0,
                            it.cSb)()
                        },
                        m: function(Rt, It) {
                            bt && bt.m(Rt, It),
                            (0,
                            it.$Tr)(Rt, Tt, It),
                            vt = !0
                        },
                        p: function(Rt, It) {
                            Rt[0] ? bt ? (bt.p(Rt, It),
                            1 & It && (0,
                            it.Ui)(bt, 1)) : ((bt = ry(Rt)).c(),
                            (0,
                            it.Ui)(bt, 1),
                            bt.m(Tt.parentNode, Tt)) : bt && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(bt, 1, 1, function() {
                                bt = null
                            }),
                            (0,
                            it.gbL)())
                        },
                        i: function(Rt) {
                            vt || ((0,
                            it.Ui)(bt),
                            vt = !0)
                        },
                        o: function(Rt) {
                            (0,
                            it.etI)(bt),
                            vt = !1
                        },
                        d: function(Rt) {
                            bt && bt.d(Rt),
                            Rt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function t1(At) {
                    var Tt, vt, bt, Rt;
                    function It(Zt) {
                        At[15](Zt)
                    }
                    var Bt = {
                        items: At[4],
                        itemKey: "_id",
                        itemHeight: 30,
                        buffer: 100,
                        stickToBottom: !0,
                        scrollbar: !0,
                        $$slots: {
                            footer: [Gs],
                            item: [Ls, function(Zt) {
                                return {
                                    16: Zt.item
                                }
                            }
                            , function(Zt) {
                                return Zt.item ? 65536 : 0
                            }
                            ],
                            empty: [ny]
                        },
                        $$scope: {
                            ctx: At
                        }
                    };
                    return At[3] !== void 0 && (Bt.handler = At[3]),
                    vt = new t0({
                        props: Bt
                    }),
                    it.VnY.push(function() {
                        return (0,
                        it.akz)(vt, "handler", It)
                    }),
                    {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            (0,
                            it.YCL)(vt.$$.fragment),
                            (0,
                            it.Ljt)(Tt, "class", "vc-plugin-content"),
                            (0,
                            it.VHj)(Tt, "vc-logs-has-cmd", At[0])
                        },
                        m: function(Zt, tn) {
                            (0,
                            it.$Tr)(Zt, Tt, tn),
                            (0,
                            it.yef)(vt, Tt, null),
                            Rt = !0
                        },
                        p: function(Zt, tn) {
                            var dn = tn[0]
                              , mn = {};
                            16 & dn && (mn.items = Zt[4]),
                            196611 & dn && (mn.$$scope = {
                                dirty: dn,
                                ctx: Zt
                            }),
                            !bt && 8 & dn && (bt = !0,
                            mn.handler = Zt[3],
                            (0,
                            it.hjT)(function() {
                                return bt = !1
                            })),
                            vt.$set(mn),
                            1 & dn && (0,
                            it.VHj)(Tt, "vc-logs-has-cmd", Zt[0])
                        },
                        i: function(Zt) {
                            Rt || ((0,
                            it.Ui)(vt.$$.fragment, Zt),
                            Rt = !0)
                        },
                        o: function(Zt) {
                            (0,
                            it.etI)(vt.$$.fragment, Zt),
                            Rt = !1
                        },
                        d: function(Zt) {
                            Zt && (0,
                            it.ogt)(Tt),
                            (0,
                            it.vpE)(vt)
                        }
                    }
                }
                function iy(At, Tt, vt) {
                    var bt, Rt = it.ZTd;
                    At.$$.on_destroy.push(function() {
                        return Rt()
                    });
                    var It, Bt, Zt = Tt.pluginId, tn = Zt === void 0 ? "default" : Zt, dn = Tt.showCmd, mn = dn !== void 0 && dn, Sn = Tt.filterType, yn = Sn === void 0 ? "all" : Sn, On = Tt.showTimestamps, An = On !== void 0 && On, Nn = !1, Fn = "", Qn = [];
                    return (0,
                    ot.H3)(function() {
                        Km.use()
                    }),
                    (0,
                    ot.ev)(function() {
                        Km.unuse()
                    }),
                    At.$$set = function(er) {
                        "pluginId"in er && vt(7, tn = er.pluginId),
                        "showCmd"in er && vt(0, mn = er.showCmd),
                        "filterType"in er && vt(8, yn = er.filterType),
                        "showTimestamps"in er && vt(1, An = er.showTimestamps)
                    }
                    ,
                    At.$$.update = function() {
                        29056 & At.$$.dirty && (Nn || (vt(2, It = dr.O.get(tn)),
                        Rt(),
                        Rt = (0,
                        it.LdU)(It, function(er) {
                            return vt(14, bt = er)
                        }),
                        vt(12, Nn = !0)),
                        vt(4, Qn = bt.logList.filter(function(er) {
                            return (yn === "all" || yn === er.type) && (Fn === "" || (0,
                            qn.HX)(er, Fn)) && !er.groupCollapsed
                        })))
                    }
                    ,
                    [mn, An, It, Bt, Qn, function(er) {
                        vt(13, Fn = er.detail.filterText || "")
                    }
                    , function(er) {
                        var fr = er.detail.groupLabel
                          , Nr = er.detail.groupHeader
                          , Rr = er.detail.isGroupCollapsed;
                        It.update(function(_i) {
                            return _i.logList.forEach(function(eo) {
                                eo.groupLabel === fr && (eo.groupHeader > 0 ? eo.groupHeader = Nr : eo.groupCollapsed = Rr)
                            }),
                            _i
                        })
                    }
                    , tn, yn, function() {
                        Bt.scrollTo(0)
                    }
                    , function() {
                        Bt.scrollTo(Qn.length - 1)
                    }
                    , {
                        fixedHeight: !0
                    }, Nn, Fn, bt, function(er) {
                        vt(3, Bt = er)
                    }
                    ]
                }
                var Kl = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, iy, t1, it.N8, {
                            pluginId: 7,
                            showCmd: 0,
                            filterType: 8,
                            showTimestamps: 1,
                            scrollToTop: 9,
                            scrollToBottom: 10,
                            options: 11
                        }),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    (0,
                    _e.Z)(Tt, [{
                        key: "pluginId",
                        get: function() {
                            return this.$$.ctx[7]
                        },
                        set: function(vt) {
                            this.$$set({
                                pluginId: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "showCmd",
                        get: function() {
                            return this.$$.ctx[0]
                        },
                        set: function(vt) {
                            this.$$set({
                                showCmd: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "filterType",
                        get: function() {
                            return this.$$.ctx[8]
                        },
                        set: function(vt) {
                            this.$$set({
                                filterType: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "showTimestamps",
                        get: function() {
                            return this.$$.ctx[1]
                        },
                        set: function(vt) {
                            this.$$set({
                                showTimestamps: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }, {
                        key: "scrollToTop",
                        get: function() {
                            return this.$$.ctx[9]
                        }
                    }, {
                        key: "scrollToBottom",
                        get: function() {
                            return this.$$.ctx[10]
                        }
                    }, {
                        key: "options",
                        get: function() {
                            return this.$$.ctx[11]
                        }
                    }]),
                    Tt
                }(it.f_C)
                  , Qp = Kl
                  , Wu = __webpack_require__(5629)
                  , Mo = function() {
                    function At(Tt) {
                        this.model = void 0,
                        this.pluginId = void 0,
                        this.pluginId = Tt
                    }
                    return At.prototype.destroy = function() {
                        this.model = void 0
                    }
                    ,
                    At
                }()
                  , Vl = function(At) {
                    function Tt() {
                        for (var bt, Rt = arguments.length, It = new Array(Rt), Bt = 0; Bt < Rt; Bt++)
                            It[Bt] = arguments[Bt];
                        return (bt = At.call.apply(At, [this].concat(It)) || this).model = Wu.W.getSingleton(Wu.W, "VConsoleLogModel"),
                        bt
                    }
                    (0,
                    rt.Z)(Tt, At);
                    var vt = Tt.prototype;
                    return vt.log = function() {
                        for (var bt = arguments.length, Rt = new Array(bt), It = 0; It < bt; It++)
                            Rt[It] = arguments[It];
                        this.addLog.apply(this, ["log"].concat(Rt))
                    }
                    ,
                    vt.info = function() {
                        for (var bt = arguments.length, Rt = new Array(bt), It = 0; It < bt; It++)
                            Rt[It] = arguments[It];
                        this.addLog.apply(this, ["info"].concat(Rt))
                    }
                    ,
                    vt.debug = function() {
                        for (var bt = arguments.length, Rt = new Array(bt), It = 0; It < bt; It++)
                            Rt[It] = arguments[It];
                        this.addLog.apply(this, ["debug"].concat(Rt))
                    }
                    ,
                    vt.warn = function() {
                        for (var bt = arguments.length, Rt = new Array(bt), It = 0; It < bt; It++)
                            Rt[It] = arguments[It];
                        this.addLog.apply(this, ["warn"].concat(Rt))
                    }
                    ,
                    vt.error = function() {
                        for (var bt = arguments.length, Rt = new Array(bt), It = 0; It < bt; It++)
                            Rt[It] = arguments[It];
                        this.addLog.apply(this, ["error"].concat(Rt))
                    }
                    ,
                    vt.clear = function() {
                        this.model && this.model.clearPluginLog(this.pluginId)
                    }
                    ,
                    vt.addLog = function(bt) {
                        if (this.model) {
                            for (var Rt = arguments.length, It = new Array(Rt > 1 ? Rt - 1 : 0), Bt = 1; Bt < Rt; Bt++)
                                It[Bt - 1] = arguments[Bt];
                            It.unshift("[" + this.pluginId + "]"),
                            this.model.addLog({
                                type: bt,
                                origData: It
                            }, {
                                noOrig: !0
                            })
                        }
                    }
                    ,
                    Tt
                }(Mo)
                  , vp = function(At) {
                    function Tt(bt, Rt) {
                        var It;
                        return (It = At.call(this, bt, Rt, Qp, {
                            pluginId: bt,
                            filterType: "all"
                        }) || this).model = Wu.W.getSingleton(Wu.W, "VConsoleLogModel"),
                        It.isReady = !1,
                        It.isShow = !1,
                        It.isInBottom = !0,
                        It.model.bindPlugin(bt),
                        It.exporter = new Vl(bt),
                        It
                    }
                    (0,
                    rt.Z)(Tt, At);
                    var vt = Tt.prototype;
                    return vt.onReady = function() {
                        var bt, Rt;
                        At.prototype.onReady.call(this),
                        this.model.maxLogNumber = Number((bt = this.vConsole.option.log) == null ? void 0 : bt.maxLogNumber) || 1e3,
                        this.compInstance.showTimestamps = !((Rt = this.vConsole.option.log) == null || !Rt.showTimestamps)
                    }
                    ,
                    vt.onRemove = function() {
                        At.prototype.onRemove.call(this),
                        this.model.unbindPlugin(this.id)
                    }
                    ,
                    vt.onAddTopBar = function(bt) {
                        for (var Rt = this, It = ["All", "Log", "Info", "Warn", "Error"], Bt = [], Zt = 0; Zt < It.length; Zt++)
                            Bt.push({
                                name: It[Zt],
                                data: {
                                    type: It[Zt].toLowerCase()
                                },
                                actived: Zt === 0,
                                className: "",
                                onClick: function(tn, dn) {
                                    if (dn.type === Rt.compInstance.filterType)
                                        return !1;
                                    Rt.compInstance.filterType = dn.type
                                }
                            });
                        Bt[0].className = "vc-actived",
                        bt(Bt)
                    }
                    ,
                    vt.onAddTool = function(bt) {
                        var Rt = this;
                        bt([{
                            name: "Clear",
                            global: !1,
                            onClick: function(It) {
                                Rt.model.clearPluginLog(Rt.id),
                                Rt.vConsole.triggerEvent("clearLog")
                            }
                        }, {
                            name: "Top",
                            global: !1,
                            onClick: function(It) {
                                Rt.compInstance.scrollToTop()
                            }
                        }, {
                            name: "Bottom",
                            global: !1,
                            onClick: function(It) {
                                Rt.compInstance.scrollToBottom()
                            }
                        }])
                    }
                    ,
                    vt.onUpdateOption = function() {
                        var bt, Rt, It, Bt;
                        ((bt = this.vConsole.option.log) == null ? void 0 : bt.maxLogNumber) !== this.model.maxLogNumber && (this.model.maxLogNumber = Number((It = this.vConsole.option.log) == null ? void 0 : It.maxLogNumber) || 1e3),
                        !((Rt = this.vConsole.option.log) == null || !Rt.showTimestamps) !== this.compInstance.showTimestamps && (this.compInstance.showTimestamps = !((Bt = this.vConsole.option.log) == null || !Bt.showTimestamps))
                    }
                    ,
                    Tt
                }(Vn)
                  , oy = function(At) {
                    function Tt() {
                        for (var bt, Rt = arguments.length, It = new Array(Rt), Bt = 0; Bt < Rt; Bt++)
                            It[Bt] = arguments[Bt];
                        return (bt = At.call.apply(At, [this].concat(It)) || this).onErrorHandler = void 0,
                        bt.resourceErrorHandler = void 0,
                        bt.rejectionHandler = void 0,
                        bt
                    }
                    (0,
                    rt.Z)(Tt, At);
                    var vt = Tt.prototype;
                    return vt.onReady = function() {
                        At.prototype.onReady.call(this),
                        this.bindErrors(),
                        this.compInstance.showCmd = !0
                    }
                    ,
                    vt.onRemove = function() {
                        At.prototype.onRemove.call(this),
                        this.unbindErrors()
                    }
                    ,
                    vt.bindErrors = function() {
                        $.FJ(window) && $.mf(window.addEventListener) && (this.catchWindowOnError(),
                        this.catchResourceError(),
                        this.catchUnhandledRejection())
                    }
                    ,
                    vt.unbindErrors = function() {
                        $.FJ(window) && $.mf(window.addEventListener) && (window.removeEventListener("error", this.onErrorHandler),
                        window.removeEventListener("error", this.resourceErrorHandler),
                        window.removeEventListener("unhandledrejection", this.rejectionHandler))
                    }
                    ,
                    vt.catchWindowOnError = function() {
                        var bt = this;
                        this.onErrorHandler = this.onErrorHandler ? this.onErrorHandler : function(Rt) {
                            var It = Rt.message;
                            Rt.filename && (It += "\\n\\t" + Rt.filename.replace(location.origin, ""),
                            (Rt.lineno || Rt.colno) && (It += ":" + Rt.lineno + ":" + Rt.colno)),
                            It += "\\n" + (!!Rt.error && !!Rt.error.stack && Rt.error.stack.toString() || ""),
                            bt.model.addLog({
                                type: "error",
                                origData: [It]
                            }, {
                                noOrig: !0
                            })
                        }
                        ,
                        window.removeEventListener("error", this.onErrorHandler),
                        window.addEventListener("error", this.onErrorHandler)
                    }
                    ,
                    vt.catchResourceError = function() {
                        var bt = this;
                        this.resourceErrorHandler = this.resourceErrorHandler ? this.resourceErrorHandler : function(Rt) {
                            var It = Rt.target;
                            if (["link", "video", "script", "img", "audio"].indexOf(It.localName) > -1) {
                                var Bt = It.href || It.src || It.currentSrc;
                                bt.model.addLog({
                                    type: "error",
                                    origData: ["GET <" + It.localName + "> error: " + Bt]
                                }, {
                                    noOrig: !0
                                })
                            }
                        }
                        ,
                        window.removeEventListener("error", this.resourceErrorHandler),
                        window.addEventListener("error", this.resourceErrorHandler, !0)
                    }
                    ,
                    vt.catchUnhandledRejection = function() {
                        var bt = this;
                        this.rejectionHandler = this.rejectionHandler ? this.rejectionHandler : function(Rt) {
                            var It = Rt && Rt.reason
                              , Bt = "Uncaught (in promise) "
                              , Zt = [Bt, It];
                            It instanceof Error && (Zt = [Bt, {
                                name: It.name,
                                message: It.message,
                                stack: It.stack
                            }]),
                            bt.model.addLog({
                                type: "error",
                                origData: Zt
                            }, {
                                noOrig: !0
                            })
                        }
                        ,
                        window.removeEventListener("unhandledrejection", this.rejectionHandler),
                        window.addEventListener("unhandledrejection", this.rejectionHandler)
                    }
                    ,
                    Tt
                }(vp)
                  , Jp = function(At) {
                    function Tt() {
                        return At.apply(this, arguments) || this
                    }
                    (0,
                    rt.Z)(Tt, At);
                    var vt = Tt.prototype;
                    return vt.onReady = function() {
                        At.prototype.onReady.call(this),
                        this.printSystemInfo()
                    }
                    ,
                    vt.printSystemInfo = function() {
                        var bt = navigator.userAgent
                          , Rt = []
                          , It = bt.match(/MicroMessenger\/([\d\.]+)/i)
                          , Bt = It && It[1] ? It[1] : null;
                        location.host;
                        var Zt = bt.match(/(ipod).*\s([\d_]+)/i)
                          , tn = bt.match(/(ipad).*\s([\d_]+)/i)
                          , dn = bt.match(/(iphone)\sos\s([\d_]+)/i)
                          , mn = bt.match(/(android)\s([\d\.]+)/i)
                          , Sn = bt.match(/(Mac OS X)\s([\d_]+)/i);
                        Rt = [],
                        mn ? Rt.push("Android " + mn[2]) : dn ? Rt.push("iPhone, iOS " + dn[2].replace(/_/g, ".")) : tn ? Rt.push("iPad, iOS " + tn[2].replace(/_/g, ".")) : Zt ? Rt.push("iPod, iOS " + Zt[2].replace(/_/g, ".")) : Sn && Rt.push("Mac, MacOS " + Sn[2].replace(/_/g, ".")),
                        Bt && Rt.push("WeChat " + Bt);
                        var yn = bt.toLowerCase().match(/ nettype\/([^ ]+)/g);
                        yn && yn[0] && (Rt = [(yn = yn[0].split("/"))[1]]),
                        setTimeout(function() {
                            var On = window.performance || window.msPerformance || window.webkitPerformance;
                            if (On && On.timing) {
                                var An = On.timing;
                                An.navigationStart,
                                An.navigationStart && An.domainLookupStart,
                                An.domainLookupEnd && An.domainLookupStart,
                                An.connectEnd && An.connectStart && (An.connectEnd && An.secureConnectionStart),
                                An.responseStart && An.requestStart,
                                An.responseEnd && An.responseStart,
                                An.domComplete && An.domLoading && (An.domContentLoadedEventStart && An.domLoading),
                                An.loadEventEnd && An.loadEventStart,
                                An.navigationStart && An.loadEventEnd
                            }
                        }, 0)
                    }
                    ,
                    Tt
                }(vp)
                  , os = __webpack_require__(3313)
                  , sy = __webpack_require__(643);
                function n0(At, Tt) {
                    var vt = typeof Symbol < "u" && At[Symbol.iterator] || At["@@iterator"];
                    if (vt)
                        return (vt = vt.call(At)).next.bind(vt);
                    if (Array.isArray(At) || (vt = function(Rt, It) {
                        if (Rt) {
                            if (typeof Rt == "string")
                                return r0(Rt, It);
                            var Bt = Object.prototype.toString.call(Rt).slice(8, -1);
                            if (Bt === "Object" && Rt.constructor && (Bt = Rt.constructor.name),
                            Bt === "Map" || Bt === "Set")
                                return Array.from(Rt);
                            if (Bt === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Bt))
                                return r0(Rt, It)
                        }
                    }(At)) || Tt) {
                        vt && (At = vt);
                        var bt = 0;
                        return function() {
                            return bt >= At.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: At[bt++]
                            }
                        }
                    }
                    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                }
                function r0(At, Tt) {
                    (Tt == null || Tt > At.length) && (Tt = At.length);
                    for (var vt = 0, bt = new Array(Tt); vt < Tt; vt++)
                        bt[vt] = At[vt];
                    return bt
                }
                var _p = function(At, Tt) {
                    Tt === void 0 && (Tt = {}),
                    $.Kn(Tt) || (Tt = {});
                    var vt = At ? At.split("?") : [];
                    if (vt.shift(),
                    vt.length > 0)
                        for (var bt, Rt = n0(vt = vt.join("?").split("&")); !(bt = Rt()).done; ) {
                            var It = bt.value.split("=");
                            try {
                                Tt[It[0]] = decodeURIComponent(It[1])
                            } catch {
                                Tt[It[0]] = It[1]
                            }
                        }
                    return Tt
                }
                  , na = function(At, Tt) {
                    var vt = "";
                    switch (At) {
                    case "":
                    case "text":
                    case "json":
                        if ($.HD(Tt))
                            try {
                                vt = JSON.parse(Tt),
                                vt = $.hZ(vt, {
                                    maxDepth: 10,
                                    keyMaxLen: 1e4,
                                    pretty: !0,
                                    standardJSON: !0
                                })
                            } catch {
                                vt = $.id(String(Tt), 1e4)
                            }
                        else
                            $.Kn(Tt) || $.kJ(Tt) ? vt = $.hZ(Tt, {
                                maxDepth: 10,
                                keyMaxLen: 1e4,
                                pretty: !0,
                                standardJSON: !0
                            }) : Tt !== void 0 && (vt = Object.prototype.toString.call(Tt));
                        break;
                    default:
                        Tt !== void 0 && (vt = Object.prototype.toString.call(Tt))
                    }
                    return vt
                }
                  , i0 = function(At) {
                    if (!At)
                        return null;
                    var Tt = null;
                    if (typeof At == "string")
                        try {
                            Tt = JSON.parse(At)
                        } catch {
                            var vt = At.split("&");
                            if (vt.length === 1)
                                Tt = At;
                            else {
                                Tt = {};
                                for (var bt, Rt = n0(vt); !(bt = Rt()).done; ) {
                                    var It = bt.value.split("=");
                                    Tt[It[0]] = It[1] === void 0 ? "undefined" : It[1]
                                }
                            }
                        }
                    else if ($.TW(At)) {
                        Tt = {};
                        for (var Bt, Zt = n0(At); !(Bt = Zt()).done; ) {
                            var tn = Bt.value
                              , dn = tn[0]
                              , mn = tn[1];
                            Tt[dn] = typeof mn == "string" ? mn : "[object Object]"
                        }
                    } else
                        $.PO(At) ? Tt = At : Tt = "[object " + $.zl(At) + "]";
                    return Tt
                }
                  , _h = function(At) {
                    return At === void 0 && (At = ""),
                    At.startsWith("//") && (At = "" + new URL(window.location.href).protocol + At),
                    At.startsWith("http") ? new URL(At) : new URL(At,window.location.href)
                }
                  , Hu = function() {
                    this.id = "",
                    this.name = "",
                    this.method = "",
                    this.url = "",
                    this.status = 0,
                    this.statusText = "",
                    this.cancelState = 0,
                    this.readyState = 0,
                    this.header = null,
                    this.responseType = "",
                    this.requestType = void 0,
                    this.requestHeader = null,
                    this.response = void 0,
                    this.responseSize = 0,
                    this.responseSizeText = "",
                    this.startTime = 0,
                    this.startTimeText = "",
                    this.endTime = 0,
                    this.costTime = 0,
                    this.getData = null,
                    this.postData = null,
                    this.actived = !1,
                    this.noVConsole = !1,
                    this.id = (0,
                    $.QI)()
                }
                  , _g = function(At) {
                    function Tt(vt) {
                        var bt;
                        return (bt = At.call(this) || this)._response = void 0,
                        new Proxy(vt,Tt.Handler) || (0,
                        nt.Z)(bt)
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    Tt
                }(Hu);
                _g.Handler = {
                    get: function(At, Tt) {
                        return Tt === "response" ? At._response : Reflect.get(At, Tt)
                    },
                    set: function(At, Tt, vt) {
                        var bt;
                        switch (Tt) {
                        case "response":
                            return At._response = na(At.responseType, vt),
                            !0;
                        case "url":
                            var Rt = ((bt = vt = String(vt)) == null ? void 0 : bt.replace(new RegExp("[/]*$"), "").split("/").pop()) || "Unknown";
                            Reflect.set(At, "name", Rt);
                            var It = _p(vt, At.getData);
                            Reflect.set(At, "getData", It);
                            break;
                        case "status":
                            var Bt = String(vt) || "Unknown";
                            Reflect.set(At, "statusText", Bt);
                            break;
                        case "startTime":
                            if (vt && At.endTime) {
                                var Zt = At.endTime - vt;
                                Reflect.set(At, "costTime", Zt)
                            }
                            break;
                        case "endTime":
                            if (vt && At.startTime) {
                                var tn = vt - At.startTime;
                                Reflect.set(At, "costTime", tn)
                            }
                        }
                        return Reflect.set(At, Tt, vt)
                    }
                };
                var o0 = function() {
                    function At(vt, bt) {
                        var Rt = this;
                        this.XMLReq = void 0,
                        this.item = void 0,
                        this.onUpdateCallback = void 0,
                        this.XMLReq = vt,
                        this.XMLReq.onreadystatechange = function() {
                            Rt.onReadyStateChange()
                        }
                        ,
                        this.XMLReq.onabort = function() {
                            Rt.onAbort()
                        }
                        ,
                        this.XMLReq.ontimeout = function() {
                            Rt.onTimeout()
                        }
                        ,
                        this.item = new Hu,
                        this.item.requestType = "xhr",
                        this.onUpdateCallback = bt
                    }
                    var Tt = At.prototype;
                    return Tt.get = function(vt, bt) {
                        switch (bt) {
                        case "_noVConsole":
                            return this.item.noVConsole;
                        case "open":
                            return this.getOpen(vt);
                        case "send":
                            return this.getSend(vt);
                        case "setRequestHeader":
                            return this.getSetRequestHeader(vt);
                        default:
                            var Rt = Reflect.get(vt, bt);
                            return typeof Rt == "function" ? Rt.bind(vt) : Rt
                        }
                    }
                    ,
                    Tt.set = function(vt, bt, Rt) {
                        switch (bt) {
                        case "_noVConsole":
                            return void (this.item.noVConsole = !!Rt);
                        case "onreadystatechange":
                            return this.setOnReadyStateChange(vt, bt, Rt);
                        case "onabort":
                            return this.setOnAbort(vt, bt, Rt);
                        case "ontimeout":
                            return this.setOnTimeout(vt, bt, Rt)
                        }
                        return Reflect.set(vt, bt, Rt)
                    }
                    ,
                    Tt.onReadyStateChange = function() {
                        this.item.readyState = this.XMLReq.readyState,
                        this.item.responseType = this.XMLReq.responseType,
                        this.item.endTime = Date.now(),
                        this.item.costTime = this.item.endTime - this.item.startTime,
                        this.updateItemByReadyState(),
                        this.item.response = na(this.item.responseType, this.item.response),
                        this.triggerUpdate()
                    }
                    ,
                    Tt.onAbort = function() {
                        this.item.cancelState = 1,
                        this.item.statusText = "Abort",
                        this.triggerUpdate()
                    }
                    ,
                    Tt.onTimeout = function() {
                        this.item.cancelState = 3,
                        this.item.statusText = "Timeout",
                        this.triggerUpdate()
                    }
                    ,
                    Tt.triggerUpdate = function() {
                        this.item.noVConsole || this.onUpdateCallback(this.item)
                    }
                    ,
                    Tt.getOpen = function(vt) {
                        var bt = this
                          , Rt = Reflect.get(vt, "open");
                        return function() {
                            for (var It = arguments.length, Bt = new Array(It), Zt = 0; Zt < It; Zt++)
                                Bt[Zt] = arguments[Zt];
                            var tn = Bt[0]
                              , dn = Bt[1];
                            return bt.item.method = tn ? tn.toUpperCase() : "GET",
                            bt.item.url = dn || "",
                            bt.item.name = bt.item.url.replace(new RegExp("[/]*$"), "").split("/").pop() || "",
                            bt.item.getData = _p(bt.item.url, {}),
                            bt.triggerUpdate(),
                            Rt.apply(vt, Bt)
                        }
                    }
                    ,
                    Tt.getSend = function(vt) {
                        var bt = this
                          , Rt = Reflect.get(vt, "send");
                        return function() {
                            for (var It = arguments.length, Bt = new Array(It), Zt = 0; Zt < It; Zt++)
                                Bt[Zt] = arguments[Zt];
                            var tn = Bt[0];
                            return bt.item.postData = i0(tn),
                            bt.triggerUpdate(),
                            Rt.apply(vt, Bt)
                        }
                    }
                    ,
                    Tt.getSetRequestHeader = function(vt) {
                        var bt = this
                          , Rt = Reflect.get(vt, "setRequestHeader");
                        return function() {
                            bt.item.requestHeader || (bt.item.requestHeader = {});
                            for (var It = arguments.length, Bt = new Array(It), Zt = 0; Zt < It; Zt++)
                                Bt[Zt] = arguments[Zt];
                            return bt.item.requestHeader[Bt[0]] = Bt[1],
                            bt.triggerUpdate(),
                            Rt.apply(vt, Bt)
                        }
                    }
                    ,
                    Tt.setOnReadyStateChange = function(vt, bt, Rt) {
                        var It = this;
                        return Reflect.set(vt, bt, function() {
                            It.onReadyStateChange();
                            for (var Bt = arguments.length, Zt = new Array(Bt), tn = 0; tn < Bt; tn++)
                                Zt[tn] = arguments[tn];
                            Rt.apply(vt, Zt)
                        })
                    }
                    ,
                    Tt.setOnAbort = function(vt, bt, Rt) {
                        var It = this;
                        return Reflect.set(vt, bt, function() {
                            It.onAbort();
                            for (var Bt = arguments.length, Zt = new Array(Bt), tn = 0; tn < Bt; tn++)
                                Zt[tn] = arguments[tn];
                            Rt.apply(vt, Zt)
                        })
                    }
                    ,
                    Tt.setOnTimeout = function(vt, bt, Rt) {
                        var It = this;
                        return Reflect.set(vt, bt, function() {
                            It.onTimeout();
                            for (var Bt = arguments.length, Zt = new Array(Bt), tn = 0; tn < Bt; tn++)
                                Zt[tn] = arguments[tn];
                            Rt.apply(vt, Zt)
                        })
                    }
                    ,
                    Tt.updateItemByReadyState = function() {
                        switch (this.XMLReq.readyState) {
                        case 0:
                        case 1:
                            if (this.item.status = 0,
                            this.item.statusText = "Pending",
                            !this.item.startTime) {
                                this.item.startTime = Date.now();
                                var vt = (0,
                                $._3)(this.item.startTime);
                                this.item.startTimeText = vt.year + "-" + vt.month + "-" + vt.day + " " + vt.hour + ":" + vt.minute + ":" + vt.second + "." + vt.millisecond
                            }
                            break;
                        case 2:
                            this.item.status = this.XMLReq.status,
                            this.item.statusText = "Loading",
                            this.item.header = {};
                            for (var bt = (this.XMLReq.getAllResponseHeaders() || "").split(`
`), Rt = 0; Rt < bt.length; Rt++) {
                                var It = bt[Rt];
                                if (It) {
                                    var Bt = It.split(": ")
                                      , Zt = Bt[0]
                                      , tn = Bt.slice(1).join(": ");
                                    this.item.header[Zt] = tn
                                }
                            }
                            break;
                        case 3:
                            this.item.status = this.XMLReq.status,
                            this.item.statusText = "Loading",
                            this.XMLReq.response && this.XMLReq.response.length && (this.item.responseSize = this.XMLReq.response.length,
                            this.item.responseSizeText = (0,
                            $.KL)(this.item.responseSize));
                            break;
                        case 4:
                            this.item.status = this.XMLReq.status || this.item.status || 0,
                            this.item.statusText = String(this.item.status),
                            this.item.endTime = Date.now(),
                            this.item.costTime = this.item.endTime - (this.item.startTime || this.item.endTime),
                            this.item.response = this.XMLReq.response,
                            this.XMLReq.response && this.XMLReq.response.length && (this.item.responseSize = this.XMLReq.response.length,
                            this.item.responseSizeText = (0,
                            $.KL)(this.item.responseSize));
                            break;
                        default:
                            this.item.status = this.XMLReq.status,
                            this.item.statusText = "Unknown"
                        }
                    }
                    ,
                    At
                }()
                  , em = function() {
                    function At() {}
                    return At.create = function(Tt) {
                        return new Proxy(XMLHttpRequest,{
                            construct: function(vt) {
                                var bt = new vt;
                                return new Proxy(bt,new o0(bt,Tt))
                            }
                        })
                    }
                    ,
                    At
                }();
                function s0(At, Tt) {
                    var vt = typeof Symbol < "u" && At[Symbol.iterator] || At["@@iterator"];
                    if (vt)
                        return (vt = vt.call(At)).next.bind(vt);
                    if (Array.isArray(At) || (vt = function(Rt, It) {
                        if (Rt) {
                            if (typeof Rt == "string")
                                return tm(Rt, It);
                            var Bt = Object.prototype.toString.call(Rt).slice(8, -1);
                            if (Bt === "Object" && Rt.constructor && (Bt = Rt.constructor.name),
                            Bt === "Map" || Bt === "Set")
                                return Array.from(Rt);
                            if (Bt === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Bt))
                                return tm(Rt, It)
                        }
                    }(At)) || Tt) {
                        vt && (At = vt);
                        var bt = 0;
                        return function() {
                            return bt >= At.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: At[bt++]
                            }
                        }
                    }
                    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                }
                function tm(At, Tt) {
                    (Tt == null || Tt > At.length) && (Tt = At.length);
                    for (var vt = 0, bt = new Array(Tt); vt < Tt; vt++)
                        bt[vt] = At[vt];
                    return bt
                }
                em.origXMLHttpRequest = XMLHttpRequest;
                var a0 = function() {
                    function At(vt, bt, Rt) {
                        this.resp = void 0,
                        this.item = void 0,
                        this.onUpdateCallback = void 0,
                        this.resp = vt,
                        this.item = bt,
                        this.onUpdateCallback = Rt,
                        this.mockReader()
                    }
                    var Tt = At.prototype;
                    return Tt.set = function(vt, bt, Rt) {
                        return Reflect.set(vt, bt, Rt)
                    }
                    ,
                    Tt.get = function(vt, bt) {
                        var Rt = this
                          , It = Reflect.get(vt, bt);
                        switch (bt) {
                        case "arrayBuffer":
                        case "blob":
                        case "formData":
                        case "json":
                        case "text":
                            return function() {
                                return Rt.item.responseType = bt.toLowerCase(),
                                It.apply(vt).then(function(Bt) {
                                    return Rt.item.response = na(Rt.item.responseType, Bt),
                                    Rt.onUpdateCallback(Rt.item),
                                    Bt
                                })
                            }
                        }
                        return typeof It == "function" ? It.bind(vt) : It
                    }
                    ,
                    Tt.mockReader = function() {
                        var vt, bt = this;
                        if (this.resp.body && typeof this.resp.body.getReader == "function") {
                            var Rt = this.resp.body.getReader;
                            this.resp.body.getReader = function() {
                                var It = Rt.apply(bt.resp.body);
                                if (bt.item.readyState === 4)
                                    return It;
                                var Bt = It.read
                                  , Zt = It.cancel;
                                return bt.item.responseType = "arraybuffer",
                                It.read = function() {
                                    return Bt.apply(It).then(function(tn) {
                                        if (vt) {
                                            var dn = new Uint8Array(vt.length + tn.value.length);
                                            dn.set(vt),
                                            dn.set(tn.value, vt.length),
                                            vt = dn
                                        } else
                                            vt = new Uint8Array(tn.value);
                                        return bt.item.endTime = Date.now(),
                                        bt.item.costTime = bt.item.endTime - (bt.item.startTime || bt.item.endTime),
                                        bt.item.readyState = tn.done ? 4 : 3,
                                        bt.item.statusText = tn.done ? String(bt.item.status) : "Loading",
                                        bt.item.responseSize = vt.length,
                                        bt.item.responseSizeText = $.KL(bt.item.responseSize),
                                        tn.done && (bt.item.response = na(bt.item.responseType, vt)),
                                        bt.onUpdateCallback(bt.item),
                                        tn
                                    })
                                }
                                ,
                                It.cancel = function() {
                                    bt.item.cancelState = 2,
                                    bt.item.statusText = "Cancel",
                                    bt.item.endTime = Date.now(),
                                    bt.item.costTime = bt.item.endTime - (bt.item.startTime || bt.item.endTime),
                                    bt.item.response = na(bt.item.responseType, vt),
                                    bt.onUpdateCallback(bt.item);
                                    for (var tn = arguments.length, dn = new Array(tn), mn = 0; mn < tn; mn++)
                                        dn[mn] = arguments[mn];
                                    return Zt.apply(It, dn)
                                }
                                ,
                                It
                            }
                        }
                    }
                    ,
                    At
                }()
                  , n1 = function() {
                    function At(vt) {
                        this.onUpdateCallback = void 0,
                        this.onUpdateCallback = vt
                    }
                    var Tt = At.prototype;
                    return Tt.apply = function(vt, bt, Rt) {
                        var It = this
                          , Bt = Rt[0]
                          , Zt = Rt[1]
                          , tn = new Hu;
                        return this.beforeFetch(tn, Bt, Zt),
                        vt.apply(window, Rt).then(this.afterFetch(tn)).catch(function(dn) {
                            throw tn.endTime = Date.now(),
                            tn.costTime = tn.endTime - (tn.startTime || tn.endTime),
                            It.onUpdateCallback(tn),
                            dn
                        })
                    }
                    ,
                    Tt.beforeFetch = function(vt, bt, Rt) {
                        var It, Bt = "GET", Zt = null;
                        if ($.HD(bt) ? (Bt = (Rt == null ? void 0 : Rt.method) || "GET",
                        It = _h(bt),
                        Zt = (Rt == null ? void 0 : Rt.headers) || null) : (Bt = bt.method || "GET",
                        It = _h(bt.url),
                        Zt = bt.headers),
                        vt.method = Bt,
                        vt.requestType = "fetch",
                        vt.requestHeader = Zt,
                        vt.url = It.toString(),
                        vt.name = (It.pathname.split("/").pop() || "") + It.search,
                        vt.status = 0,
                        vt.statusText = "Pending",
                        vt.readyState = 1,
                        !vt.startTime) {
                            vt.startTime = Date.now();
                            var tn = $._3(vt.startTime);
                            vt.startTimeText = tn.year + "-" + tn.month + "-" + tn.day + " " + tn.hour + ":" + tn.minute + ":" + tn.second + "." + tn.millisecond
                        }
                        if (Object.prototype.toString.call(Zt) === "[object Headers]") {
                            vt.requestHeader = {};
                            for (var dn, mn = s0(Zt); !(dn = mn()).done; ) {
                                var Sn = dn.value
                                  , yn = Sn[0]
                                  , On = Sn[1];
                                vt.requestHeader[yn] = On
                            }
                        } else
                            vt.requestHeader = Zt;
                        if (It.search && It.searchParams) {
                            vt.getData = {};
                            for (var An, Nn = s0(It.searchParams); !(An = Nn()).done; ) {
                                var Fn = An.value
                                  , Qn = Fn[0]
                                  , er = Fn[1];
                                vt.getData[Qn] = er
                            }
                        }
                        Rt != null && Rt.body && (vt.postData = i0(Rt.body)),
                        this.onUpdateCallback(vt)
                    }
                    ,
                    Tt.afterFetch = function(vt) {
                        var bt = this;
                        return function(Rt) {
                            vt.endTime = Date.now(),
                            vt.costTime = vt.endTime - (vt.startTime || vt.endTime),
                            vt.status = Rt.status,
                            vt.statusText = String(Rt.status);
                            var It = !1;
                            vt.header = {};
                            for (var Bt, Zt = s0(Rt.headers); !(Bt = Zt()).done; ) {
                                var tn = Bt.value
                                  , dn = tn[0]
                                  , mn = tn[1];
                                vt.header[dn] = mn,
                                It = mn.toLowerCase().indexOf("chunked") > -1 || It
                            }
                            return It ? vt.readyState = 3 : (vt.readyState = 4,
                            bt.handleResponseBody(Rt.clone(), vt).then(function(Sn) {
                                vt.responseSize = typeof Sn == "string" ? Sn.length : Sn.byteLength,
                                vt.responseSizeText = $.KL(vt.responseSize),
                                vt.response = na(vt.responseType, Sn),
                                bt.onUpdateCallback(vt)
                            })),
                            bt.onUpdateCallback(vt),
                            new Proxy(Rt,new a0(Rt,vt,bt.onUpdateCallback))
                        }
                    }
                    ,
                    Tt.handleResponseBody = function(vt, bt) {
                        var Rt = vt.headers.get("content-type");
                        return Rt && Rt.includes("application/json") ? (bt.responseType = "json",
                        vt.text()) : Rt && (Rt.includes("text/html") || Rt.includes("text/plain")) ? (bt.responseType = "text",
                        vt.text()) : (bt.responseType = "arraybuffer",
                        vt.arrayBuffer())
                    }
                    ,
                    At
                }()
                  , nm = function() {
                    function At() {}
                    return At.create = function(Tt) {
                        return new Proxy(fetch,new n1(Tt))
                    }
                    ,
                    At
                }();
                function Ns(At, Tt) {
                    var vt = typeof Symbol < "u" && At[Symbol.iterator] || At["@@iterator"];
                    if (vt)
                        return (vt = vt.call(At)).next.bind(vt);
                    if (Array.isArray(At) || (vt = function(Rt, It) {
                        if (Rt) {
                            if (typeof Rt == "string")
                                return rm(Rt, It);
                            var Bt = Object.prototype.toString.call(Rt).slice(8, -1);
                            if (Bt === "Object" && Rt.constructor && (Bt = Rt.constructor.name),
                            Bt === "Map" || Bt === "Set")
                                return Array.from(Rt);
                            if (Bt === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(Bt))
                                return rm(Rt, It)
                        }
                    }(At)) || Tt) {
                        vt && (At = vt);
                        var bt = 0;
                        return function() {
                            return bt >= At.length ? {
                                done: !0
                            } : {
                                done: !1,
                                value: At[bt++]
                            }
                        }
                    }
                    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
                }
                function rm(At, Tt) {
                    (Tt == null || Tt > At.length) && (Tt = At.length);
                    for (var vt = 0, bt = new Array(Tt); vt < Tt; vt++)
                        bt[vt] = At[vt];
                    return bt
                }
                nm.origFetch = fetch;
                var bp = function(At) {
                    return At instanceof Blob ? At.type : At instanceof FormData ? "multipart/form-data" : At instanceof URLSearchParams ? "application/x-www-form-urlencoded;charset=UTF-8" : "text/plain;charset=UTF-8"
                }
                  , ay = function() {
                    function At(Tt) {
                        this.onUpdateCallback = void 0,
                        this.onUpdateCallback = Tt
                    }
                    return At.prototype.apply = function(Tt, vt, bt) {
                        var Rt = bt[0]
                          , It = bt[1]
                          , Bt = new Hu
                          , Zt = _h(Rt);
                        if (Bt.method = "POST",
                        Bt.url = Rt,
                        Bt.name = (Zt.pathname.split("/").pop() || "") + Zt.search,
                        Bt.requestType = "ping",
                        Bt.requestHeader = {
                            "Content-Type": bp(It)
                        },
                        Bt.status = 0,
                        Bt.statusText = "Pending",
                        Zt.search && Zt.searchParams) {
                            Bt.getData = {};
                            for (var tn, dn = Ns(Zt.searchParams); !(tn = dn()).done; ) {
                                var mn = tn.value
                                  , Sn = mn[0]
                                  , yn = mn[1];
                                Bt.getData[Sn] = yn
                            }
                        }
                        Bt.postData = i0(It),
                        Bt.startTime || (Bt.startTime = Date.now()),
                        this.onUpdateCallback(Bt);
                        var On = Tt.apply(vt, bt);
                        return On ? (Bt.endTime = Date.now(),
                        Bt.costTime = Bt.endTime - (Bt.startTime || Bt.endTime),
                        Bt.status = 0,
                        Bt.statusText = "Sent",
                        Bt.readyState = 4) : (Bt.status = 500,
                        Bt.statusText = "Unknown"),
                        this.onUpdateCallback(Bt),
                        On
                    }
                    ,
                    At
                }()
                  , im = function() {
                    function At() {}
                    return At.create = function(Tt) {
                        return new Proxy(navigator.sendBeacon,new ay(Tt))
                    }
                    ,
                    At
                }();
                im.origSendBeacon = navigator.sendBeacon;
                var Yl = (0,
                os.fZ)({})
                  , om = function(At) {
                    function Tt() {
                        var bt;
                        return (bt = At.call(this) || this).maxNetworkNumber = 1e3,
                        bt.ignoreUrlRegExp = void 0,
                        bt.itemCounter = 0,
                        bt.mockXHR(),
                        bt.mockFetch(),
                        bt.mockSendBeacon(),
                        bt
                    }
                    (0,
                    rt.Z)(Tt, At);
                    var vt = Tt.prototype;
                    return vt.unMock = function() {
                        window.hasOwnProperty("XMLHttpRequest") && (window.XMLHttpRequest = em.origXMLHttpRequest),
                        window.hasOwnProperty("fetch") && (window.fetch = nm.origFetch),
                        window.navigator.sendBeacon && (window.navigator.sendBeacon = im.origSendBeacon)
                    }
                    ,
                    vt.clearLog = function() {
                        Yl.set({})
                    }
                    ,
                    vt.updateRequest = function(bt, Rt) {
                        var It, Bt = Rt.url;
                        if (!Bt || (It = this.ignoreUrlRegExp) == null || !It.test(Bt)) {
                            var Zt = (0,
                            os.U2)(Yl)
                              , tn = !!Zt[bt];
                            if (tn) {
                                var dn = Zt[bt];
                                for (var mn in Rt)
                                    dn[mn] = Rt[mn];
                                Rt = dn
                            }
                            Yl.update(function(Sn) {
                                return Sn[bt] = Rt,
                                Sn
                            }),
                            tn || (Ft.x.updateTime(),
                            this.limitListLength())
                        }
                    }
                    ,
                    vt.mockXHR = function() {
                        var bt = this;
                        window.hasOwnProperty("XMLHttpRequest") && (window.XMLHttpRequest = em.create(function(Rt) {
                            bt.updateRequest(Rt.id, Rt)
                        }))
                    }
                    ,
                    vt.mockFetch = function() {
                        var bt = this;
                        window.hasOwnProperty("fetch") && (window.fetch = nm.create(function(Rt) {
                            bt.updateRequest(Rt.id, Rt)
                        }))
                    }
                    ,
                    vt.mockSendBeacon = function() {
                        var bt, Rt, It = this;
                        (bt = window) != null && (Rt = bt.navigator) != null && Rt.sendBeacon && (window.navigator.sendBeacon = im.create(function(Bt) {
                            It.updateRequest(Bt.id, Bt)
                        }))
                    }
                    ,
                    vt.limitListLength = function() {
                        var bt = this;
                        if (this.itemCounter++,
                        this.itemCounter % 10 == 0) {
                            this.itemCounter = 0;
                            var Rt = (0,
                            os.U2)(Yl)
                              , It = Object.keys(Rt);
                            It.length > this.maxNetworkNumber - 10 && Yl.update(function(Bt) {
                                for (var Zt = It.splice(0, It.length - bt.maxNetworkNumber + 10), tn = 0; tn < Zt.length; tn++)
                                    Bt[Zt[tn]] = void 0,
                                    delete Bt[Zt[tn]];
                                return Bt
                            })
                        }
                    }
                    ,
                    Tt
                }(sy.N)
                  , sm = __webpack_require__(8747)
                  , Ep = {};
                sm.Z && sm.Z.locals && (Ep.locals = sm.Z.locals);
                var l0, Zl = 0, mu = {};
                mu.styleTagTransform = St(),
                mu.setAttributes = yt(),
                mu.insert = ht().bind(null, "head"),
                mu.domAPI = dt(),
                mu.insertStyleElement = _t(),
                Ep.use = function(At) {
                    return mu.options = At || {},
                    Zl++ || (l0 = lt()(sm.Z, mu)),
                    Ep
                }
                ,
                Ep.unuse = function() {
                    Zl > 0 && !--Zl && (l0(),
                    l0 = null)
                }
                ;
                var ly = Ep;
                function am(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[11] = Tt[vt][0],
                    bt[12] = Tt[vt][1],
                    bt
                }
                function c0(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[11] = Tt[vt][0],
                    bt[12] = Tt[vt][1],
                    bt
                }
                function Al(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[11] = Tt[vt][0],
                    bt[12] = Tt[vt][1],
                    bt
                }
                function Sp(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[11] = Tt[vt][0],
                    bt[12] = Tt[vt][1],
                    bt
                }
                function cy(At) {
                    var Tt, vt, bt;
                    return {
                        c: function() {
                            Tt = (0,
                            it.fLW)("("),
                            vt = (0,
                            it.fLW)(At[0]),
                            bt = (0,
                            it.fLW)(")")
                        },
                        m: function(Rt, It) {
                            (0,
                            it.$Tr)(Rt, Tt, It),
                            (0,
                            it.$Tr)(Rt, vt, It),
                            (0,
                            it.$Tr)(Rt, bt, It)
                        },
                        p: function(Rt, It) {
                            1 & It && (0,
                            it.rTO)(vt, Rt[0])
                        },
                        d: function(Rt) {
                            Rt && (0,
                            it.ogt)(Tt),
                            Rt && (0,
                            it.ogt)(vt),
                            Rt && (0,
                            it.ogt)(bt)
                        }
                    }
                }
                function r1(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt = At[0] > 0 && cy(At);
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("dl"),
                            vt = (0,
                            it.bGB)("dd"),
                            bt = (0,
                            it.fLW)("Name "),
                            Zt && Zt.c(),
                            (Rt = (0,
                            it.bGB)("dd")).textContent = "Method",
                            (It = (0,
                            it.bGB)("dd")).textContent = "Status",
                            (Bt = (0,
                            it.bGB)("dd")).textContent = "Time",
                            (0,
                            it.Ljt)(vt, "class", "vc-table-col vc-table-col-4"),
                            (0,
                            it.Ljt)(Rt, "class", "vc-table-col"),
                            (0,
                            it.Ljt)(It, "class", "vc-table-col"),
                            (0,
                            it.Ljt)(Bt, "class", "vc-table-col"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-table-row")
                        },
                        m: function(tn, dn) {
                            (0,
                            it.$Tr)(tn, Tt, dn),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(vt, bt),
                            Zt && Zt.m(vt, null),
                            (0,
                            it.R3I)(Tt, Rt),
                            (0,
                            it.R3I)(Tt, It),
                            (0,
                            it.R3I)(Tt, Bt)
                        },
                        p: function(tn, dn) {
                            tn[0] > 0 ? Zt ? Zt.p(tn, dn) : ((Zt = cy(tn)).c(),
                            Zt.m(vt, null)) : Zt && (Zt.d(1),
                            Zt = null)
                        },
                        d: function(tn) {
                            tn && (0,
                            it.ogt)(Tt),
                            Zt && Zt.d()
                        }
                    }
                }
                function i1(At) {
                    var Tt;
                    return {
                        c: function() {
                            (Tt = (0,
                            it.bGB)("div")).textContent = "Empty",
                            (0,
                            it.Ljt)(Tt, "slot", "empty"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-plugin-empty")
                        },
                        m: function(vt, bt) {
                            (0,
                            it.$Tr)(vt, Tt, bt)
                        },
                        p: it.ZTd,
                        d: function(vt) {
                            vt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function yu(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt, tn;
                    Bt = new an({
                        props: {
                            content: At[10].requestHeader
                        }
                    });
                    for (var dn = Object.entries(At[10].requestHeader), mn = [], Sn = 0; Sn < dn.length; Sn += 1)
                        mn[Sn] = Ks(Sp(At, dn, Sn));
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("dl"),
                            bt = (0,
                            it.bGB)("dt"),
                            Rt = (0,
                            it.fLW)(`Request Headers
                `),
                            It = (0,
                            it.bGB)("i"),
                            (0,
                            it.YCL)(Bt.$$.fragment),
                            Zt = (0,
                            it.DhX)();
                            for (var yn = 0; yn < mn.length; yn += 1)
                                mn[yn].c();
                            (0,
                            it.Ljt)(It, "class", "vc-table-row-icon"),
                            (0,
                            it.Ljt)(bt, "class", "vc-table-col vc-table-col-title"),
                            (0,
                            it.Ljt)(vt, "class", "vc-table-row vc-left-border")
                        },
                        m: function(yn, On) {
                            (0,
                            it.$Tr)(yn, Tt, On),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(vt, bt),
                            (0,
                            it.R3I)(bt, Rt),
                            (0,
                            it.R3I)(bt, It),
                            (0,
                            it.yef)(Bt, It, null),
                            (0,
                            it.R3I)(Tt, Zt);
                            for (var An = 0; An < mn.length; An += 1)
                                mn[An].m(Tt, null);
                            tn = !0
                        },
                        p: function(yn, On) {
                            var An = {};
                            if (1024 & On && (An.content = yn[10].requestHeader),
                            Bt.$set(An),
                            1040 & On) {
                                var Nn;
                                for (dn = Object.entries(yn[10].requestHeader),
                                Nn = 0; Nn < dn.length; Nn += 1) {
                                    var Fn = Sp(yn, dn, Nn);
                                    mn[Nn] ? mn[Nn].p(Fn, On) : (mn[Nn] = Ks(Fn),
                                    mn[Nn].c(),
                                    mn[Nn].m(Tt, null))
                                }
                                for (; Nn < mn.length; Nn += 1)
                                    mn[Nn].d(1);
                                mn.length = dn.length
                            }
                        },
                        i: function(yn) {
                            tn || ((0,
                            it.Ui)(Bt.$$.fragment, yn),
                            tn = !0)
                        },
                        o: function(yn) {
                            (0,
                            it.etI)(Bt.$$.fragment, yn),
                            tn = !1
                        },
                        d: function(yn) {
                            yn && (0,
                            it.ogt)(Tt),
                            (0,
                            it.vpE)(Bt),
                            (0,
                            it.RMB)(mn, yn)
                        }
                    }
                }
                function Ks(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt, tn = At[11] + "", dn = At[4](At[12]) + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("div"),
                            bt = (0,
                            it.fLW)(tn),
                            Rt = (0,
                            it.DhX)(),
                            It = (0,
                            it.bGB)("div"),
                            Bt = (0,
                            it.fLW)(dn),
                            Zt = (0,
                            it.DhX)(),
                            (0,
                            it.Ljt)(vt, "class", "vc-table-col vc-table-col-2"),
                            (0,
                            it.Ljt)(It, "class", "vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-table-row vc-left-border vc-small")
                        },
                        m: function(mn, Sn) {
                            (0,
                            it.$Tr)(mn, Tt, Sn),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(vt, bt),
                            (0,
                            it.R3I)(Tt, Rt),
                            (0,
                            it.R3I)(Tt, It),
                            (0,
                            it.R3I)(It, Bt),
                            (0,
                            it.R3I)(Tt, Zt)
                        },
                        p: function(mn, Sn) {
                            1024 & Sn && tn !== (tn = mn[11] + "") && (0,
                            it.rTO)(bt, tn),
                            1024 & Sn && dn !== (dn = mn[4](mn[12]) + "") && (0,
                            it.rTO)(Bt, dn)
                        },
                        d: function(mn) {
                            mn && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function u0(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt, tn;
                    Bt = new an({
                        props: {
                            content: At[10].getData
                        }
                    });
                    for (var dn = Object.entries(At[10].getData), mn = [], Sn = 0; Sn < dn.length; Sn += 1)
                        mn[Sn] = uy(Al(At, dn, Sn));
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("dl"),
                            bt = (0,
                            it.bGB)("dt"),
                            Rt = (0,
                            it.fLW)(`Query String Parameters
                `),
                            It = (0,
                            it.bGB)("i"),
                            (0,
                            it.YCL)(Bt.$$.fragment),
                            Zt = (0,
                            it.DhX)();
                            for (var yn = 0; yn < mn.length; yn += 1)
                                mn[yn].c();
                            (0,
                            it.Ljt)(It, "class", "vc-table-row-icon"),
                            (0,
                            it.Ljt)(bt, "class", "vc-table-col vc-table-col-title"),
                            (0,
                            it.Ljt)(vt, "class", "vc-table-row vc-left-border")
                        },
                        m: function(yn, On) {
                            (0,
                            it.$Tr)(yn, Tt, On),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(vt, bt),
                            (0,
                            it.R3I)(bt, Rt),
                            (0,
                            it.R3I)(bt, It),
                            (0,
                            it.yef)(Bt, It, null),
                            (0,
                            it.R3I)(Tt, Zt);
                            for (var An = 0; An < mn.length; An += 1)
                                mn[An].m(Tt, null);
                            tn = !0
                        },
                        p: function(yn, On) {
                            var An = {};
                            if (1024 & On && (An.content = yn[10].getData),
                            Bt.$set(An),
                            1040 & On) {
                                var Nn;
                                for (dn = Object.entries(yn[10].getData),
                                Nn = 0; Nn < dn.length; Nn += 1) {
                                    var Fn = Al(yn, dn, Nn);
                                    mn[Nn] ? mn[Nn].p(Fn, On) : (mn[Nn] = uy(Fn),
                                    mn[Nn].c(),
                                    mn[Nn].m(Tt, null))
                                }
                                for (; Nn < mn.length; Nn += 1)
                                    mn[Nn].d(1);
                                mn.length = dn.length
                            }
                        },
                        i: function(yn) {
                            tn || ((0,
                            it.Ui)(Bt.$$.fragment, yn),
                            tn = !0)
                        },
                        o: function(yn) {
                            (0,
                            it.etI)(Bt.$$.fragment, yn),
                            tn = !1
                        },
                        d: function(yn) {
                            yn && (0,
                            it.ogt)(Tt),
                            (0,
                            it.vpE)(Bt),
                            (0,
                            it.RMB)(mn, yn)
                        }
                    }
                }
                function uy(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt, tn = At[11] + "", dn = At[4](At[12]) + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("div"),
                            bt = (0,
                            it.fLW)(tn),
                            Rt = (0,
                            it.DhX)(),
                            It = (0,
                            it.bGB)("div"),
                            Bt = (0,
                            it.fLW)(dn),
                            Zt = (0,
                            it.DhX)(),
                            (0,
                            it.Ljt)(vt, "class", "vc-table-col vc-table-col-2"),
                            (0,
                            it.Ljt)(It, "class", "vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-table-row vc-left-border vc-small")
                        },
                        m: function(mn, Sn) {
                            (0,
                            it.$Tr)(mn, Tt, Sn),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(vt, bt),
                            (0,
                            it.R3I)(Tt, Rt),
                            (0,
                            it.R3I)(Tt, It),
                            (0,
                            it.R3I)(It, Bt),
                            (0,
                            it.R3I)(Tt, Zt)
                        },
                        p: function(mn, Sn) {
                            1024 & Sn && tn !== (tn = mn[11] + "") && (0,
                            it.rTO)(bt, tn),
                            1024 & Sn && dn !== (dn = mn[4](mn[12]) + "") && (0,
                            it.rTO)(Bt, dn)
                        },
                        d: function(mn) {
                            mn && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function dy(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt, tn;
                    function dn(yn, On) {
                        return typeof yn[10].postData == "string" ? s1 : o1
                    }
                    Bt = new an({
                        props: {
                            content: At[10].postData
                        }
                    });
                    var mn = dn(At)
                      , Sn = mn(At);
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("dl"),
                            bt = (0,
                            it.bGB)("dt"),
                            Rt = (0,
                            it.fLW)(`Request Payload
                `),
                            It = (0,
                            it.bGB)("i"),
                            (0,
                            it.YCL)(Bt.$$.fragment),
                            Zt = (0,
                            it.DhX)(),
                            Sn.c(),
                            (0,
                            it.Ljt)(It, "class", "vc-table-row-icon"),
                            (0,
                            it.Ljt)(bt, "class", "vc-table-col vc-table-col-title"),
                            (0,
                            it.Ljt)(vt, "class", "vc-table-row vc-left-border")
                        },
                        m: function(yn, On) {
                            (0,
                            it.$Tr)(yn, Tt, On),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(vt, bt),
                            (0,
                            it.R3I)(bt, Rt),
                            (0,
                            it.R3I)(bt, It),
                            (0,
                            it.yef)(Bt, It, null),
                            (0,
                            it.R3I)(Tt, Zt),
                            Sn.m(Tt, null),
                            tn = !0
                        },
                        p: function(yn, On) {
                            var An = {};
                            1024 & On && (An.content = yn[10].postData),
                            Bt.$set(An),
                            mn === (mn = dn(yn)) && Sn ? Sn.p(yn, On) : (Sn.d(1),
                            (Sn = mn(yn)) && (Sn.c(),
                            Sn.m(Tt, null)))
                        },
                        i: function(yn) {
                            tn || ((0,
                            it.Ui)(Bt.$$.fragment, yn),
                            tn = !0)
                        },
                        o: function(yn) {
                            (0,
                            it.etI)(Bt.$$.fragment, yn),
                            tn = !1
                        },
                        d: function(yn) {
                            yn && (0,
                            it.ogt)(Tt),
                            (0,
                            it.vpE)(Bt),
                            Sn.d()
                        }
                    }
                }
                function o1(At) {
                    for (var Tt, vt = Object.entries(At[10].postData), bt = [], Rt = 0; Rt < vt.length; Rt += 1)
                        bt[Rt] = fy(c0(At, vt, Rt));
                    return {
                        c: function() {
                            for (var It = 0; It < bt.length; It += 1)
                                bt[It].c();
                            Tt = (0,
                            it.cSb)()
                        },
                        m: function(It, Bt) {
                            for (var Zt = 0; Zt < bt.length; Zt += 1)
                                bt[Zt].m(It, Bt);
                            (0,
                            it.$Tr)(It, Tt, Bt)
                        },
                        p: function(It, Bt) {
                            if (1040 & Bt) {
                                var Zt;
                                for (vt = Object.entries(It[10].postData),
                                Zt = 0; Zt < vt.length; Zt += 1) {
                                    var tn = c0(It, vt, Zt);
                                    bt[Zt] ? bt[Zt].p(tn, Bt) : (bt[Zt] = fy(tn),
                                    bt[Zt].c(),
                                    bt[Zt].m(Tt.parentNode, Tt))
                                }
                                for (; Zt < bt.length; Zt += 1)
                                    bt[Zt].d(1);
                                bt.length = vt.length
                            }
                        },
                        d: function(It) {
                            (0,
                            it.RMB)(bt, It),
                            It && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function s1(At) {
                    var Tt, vt, bt, Rt = At[10].postData + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("pre"),
                            bt = (0,
                            it.fLW)(Rt),
                            (0,
                            it.Ljt)(vt, "class", "vc-table-col vc-table-col-value vc-max-height-line"),
                            (0,
                            it.Ljt)(vt, "data-scrollable", "1"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-table-row vc-left-border vc-small")
                        },
                        m: function(It, Bt) {
                            (0,
                            it.$Tr)(It, Tt, Bt),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(vt, bt)
                        },
                        p: function(It, Bt) {
                            1024 & Bt && Rt !== (Rt = It[10].postData + "") && (0,
                            it.rTO)(bt, Rt)
                        },
                        d: function(It) {
                            It && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function fy(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt, tn = At[11] + "", dn = At[4](At[12]) + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("div"),
                            bt = (0,
                            it.fLW)(tn),
                            Rt = (0,
                            it.DhX)(),
                            It = (0,
                            it.bGB)("div"),
                            Bt = (0,
                            it.fLW)(dn),
                            Zt = (0,
                            it.DhX)(),
                            (0,
                            it.Ljt)(vt, "class", "vc-table-col vc-table-col-2"),
                            (0,
                            it.Ljt)(It, "class", "vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),
                            (0,
                            it.Ljt)(It, "data-scrollable", "1"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-table-row vc-left-border vc-small")
                        },
                        m: function(mn, Sn) {
                            (0,
                            it.$Tr)(mn, Tt, Sn),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(vt, bt),
                            (0,
                            it.R3I)(Tt, Rt),
                            (0,
                            it.R3I)(Tt, It),
                            (0,
                            it.R3I)(It, Bt),
                            (0,
                            it.R3I)(Tt, Zt)
                        },
                        p: function(mn, Sn) {
                            1024 & Sn && tn !== (tn = mn[11] + "") && (0,
                            it.rTO)(bt, tn),
                            1024 & Sn && dn !== (dn = mn[4](mn[12]) + "") && (0,
                            it.rTO)(Bt, dn)
                        },
                        d: function(mn) {
                            mn && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function vu(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt, tn;
                    Bt = new an({
                        props: {
                            content: At[10].header
                        }
                    });
                    for (var dn = Object.entries(At[10].header), mn = [], Sn = 0; Sn < dn.length; Sn += 1)
                        mn[Sn] = In(am(At, dn, Sn));
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("dl"),
                            bt = (0,
                            it.bGB)("dt"),
                            Rt = (0,
                            it.fLW)(`Response Headers
                `),
                            It = (0,
                            it.bGB)("i"),
                            (0,
                            it.YCL)(Bt.$$.fragment),
                            Zt = (0,
                            it.DhX)();
                            for (var yn = 0; yn < mn.length; yn += 1)
                                mn[yn].c();
                            (0,
                            it.Ljt)(It, "class", "vc-table-row-icon"),
                            (0,
                            it.Ljt)(bt, "class", "vc-table-col vc-table-col-title"),
                            (0,
                            it.Ljt)(vt, "class", "vc-table-row vc-left-border")
                        },
                        m: function(yn, On) {
                            (0,
                            it.$Tr)(yn, Tt, On),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(vt, bt),
                            (0,
                            it.R3I)(bt, Rt),
                            (0,
                            it.R3I)(bt, It),
                            (0,
                            it.yef)(Bt, It, null),
                            (0,
                            it.R3I)(Tt, Zt);
                            for (var An = 0; An < mn.length; An += 1)
                                mn[An].m(Tt, null);
                            tn = !0
                        },
                        p: function(yn, On) {
                            var An = {};
                            if (1024 & On && (An.content = yn[10].header),
                            Bt.$set(An),
                            1040 & On) {
                                var Nn;
                                for (dn = Object.entries(yn[10].header),
                                Nn = 0; Nn < dn.length; Nn += 1) {
                                    var Fn = am(yn, dn, Nn);
                                    mn[Nn] ? mn[Nn].p(Fn, On) : (mn[Nn] = In(Fn),
                                    mn[Nn].c(),
                                    mn[Nn].m(Tt, null))
                                }
                                for (; Nn < mn.length; Nn += 1)
                                    mn[Nn].d(1);
                                mn.length = dn.length
                            }
                        },
                        i: function(yn) {
                            tn || ((0,
                            it.Ui)(Bt.$$.fragment, yn),
                            tn = !0)
                        },
                        o: function(yn) {
                            (0,
                            it.etI)(Bt.$$.fragment, yn),
                            tn = !1
                        },
                        d: function(yn) {
                            yn && (0,
                            it.ogt)(Tt),
                            (0,
                            it.vpE)(Bt),
                            (0,
                            it.RMB)(mn, yn)
                        }
                    }
                }
                function In(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt, tn = At[11] + "", dn = At[4](At[12]) + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("div"),
                            bt = (0,
                            it.fLW)(tn),
                            Rt = (0,
                            it.DhX)(),
                            It = (0,
                            it.bGB)("div"),
                            Bt = (0,
                            it.fLW)(dn),
                            Zt = (0,
                            it.DhX)(),
                            (0,
                            it.Ljt)(vt, "class", "vc-table-col vc-table-col-2"),
                            (0,
                            it.Ljt)(It, "class", "vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-table-row vc-left-border vc-small")
                        },
                        m: function(mn, Sn) {
                            (0,
                            it.$Tr)(mn, Tt, Sn),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(vt, bt),
                            (0,
                            it.R3I)(Tt, Rt),
                            (0,
                            it.R3I)(Tt, It),
                            (0,
                            it.R3I)(It, Bt),
                            (0,
                            it.R3I)(Tt, Zt)
                        },
                        p: function(mn, Sn) {
                            1024 & Sn && tn !== (tn = mn[11] + "") && (0,
                            it.rTO)(bt, tn),
                            1024 & Sn && dn !== (dn = mn[4](mn[12]) + "") && (0,
                            it.rTO)(Bt, dn)
                        },
                        d: function(mn) {
                            mn && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function Kn(At) {
                    var Tt, vt, bt, Rt, It, Bt = At[10].responseSizeText + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            (vt = (0,
                            it.bGB)("div")).textContent = "Size",
                            bt = (0,
                            it.DhX)(),
                            Rt = (0,
                            it.bGB)("div"),
                            It = (0,
                            it.fLW)(Bt),
                            (0,
                            it.Ljt)(vt, "class", "vc-table-col vc-table-col-2"),
                            (0,
                            it.Ljt)(Rt, "class", "vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-table-row vc-left-border vc-small")
                        },
                        m: function(Zt, tn) {
                            (0,
                            it.$Tr)(Zt, Tt, tn),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(Tt, bt),
                            (0,
                            it.R3I)(Tt, Rt),
                            (0,
                            it.R3I)(Rt, It)
                        },
                        p: function(Zt, tn) {
                            1024 & tn && Bt !== (Bt = Zt[10].responseSizeText + "") && (0,
                            it.rTO)(It, Bt)
                        },
                        d: function(Zt) {
                            Zt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function Wn(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt, tn, dn, mn, Sn, yn, On, An, Nn, Fn, Qn, er, fr, Nr, Rr, _i, eo, Gr, Ar, Or, Fr, Vo, lo, to, Kr, mr, _r, vo, ar, $r, Vr, Sr, Wr, Po, Wo, es, so, gs, Do, Bo, Uo, Ts, Go, Rs, ms, Eu, Ap, yr, qr, Hr, Lr, co, $o, Ho, ys, cs, Ao, vs, jo, us, b0, wy, mm = At[10].name + "", Qu = At[10].method + "", ym = At[10].statusText + "", _c = At[10].costTime + "", Ip = At[10].url + "", vm = At[10].method + "", _m = At[10].requestType + "", eu = At[10].status + "", bm = At[10].startTimeText + "", Em = (At[10].response || "") + "";
                    function E0() {
                        return At[7](At[10])
                    }
                    er = new an({
                        props: {
                            handler: At[3],
                            content: At[10]
                        }
                    });
                    var ss = At[10].requestHeader !== null && yu(At)
                      , ds = At[10].getData !== null && u0(At)
                      , fs = At[10].postData !== null && dy(At)
                      , ps = At[10].header !== null && vu(At);
                    $o = new an({
                        props: {
                            content: At[10].response
                        }
                    });
                    var Cs = At[10].responseSize > 0 && Kn(At);
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("dl"),
                            bt = (0,
                            it.bGB)("dd"),
                            Rt = (0,
                            it.fLW)(mm),
                            It = (0,
                            it.bGB)("dd"),
                            Bt = (0,
                            it.fLW)(Qu),
                            Zt = (0,
                            it.bGB)("dd"),
                            tn = (0,
                            it.fLW)(ym),
                            dn = (0,
                            it.bGB)("dd"),
                            mn = (0,
                            it.fLW)(_c),
                            Sn = (0,
                            it.DhX)(),
                            yn = (0,
                            it.bGB)("div"),
                            On = (0,
                            it.bGB)("div"),
                            An = (0,
                            it.bGB)("dl"),
                            Nn = (0,
                            it.bGB)("dt"),
                            Fn = (0,
                            it.fLW)(`General
                `),
                            Qn = (0,
                            it.bGB)("i"),
                            (0,
                            it.YCL)(er.$$.fragment),
                            fr = (0,
                            it.DhX)(),
                            Nr = (0,
                            it.bGB)("div"),
                            (Rr = (0,
                            it.bGB)("div")).textContent = "URL",
                            _i = (0,
                            it.DhX)(),
                            eo = (0,
                            it.bGB)("div"),
                            Gr = (0,
                            it.fLW)(Ip),
                            Ar = (0,
                            it.DhX)(),
                            Or = (0,
                            it.bGB)("div"),
                            (Fr = (0,
                            it.bGB)("div")).textContent = "Method",
                            Vo = (0,
                            it.DhX)(),
                            lo = (0,
                            it.bGB)("div"),
                            to = (0,
                            it.fLW)(vm),
                            Kr = (0,
                            it.DhX)(),
                            mr = (0,
                            it.bGB)("div"),
                            (_r = (0,
                            it.bGB)("div")).textContent = "Request Type",
                            vo = (0,
                            it.DhX)(),
                            ar = (0,
                            it.bGB)("div"),
                            $r = (0,
                            it.fLW)(_m),
                            Vr = (0,
                            it.DhX)(),
                            Sr = (0,
                            it.bGB)("div"),
                            (Wr = (0,
                            it.bGB)("div")).textContent = "HTTP Status",
                            Po = (0,
                            it.DhX)(),
                            Wo = (0,
                            it.bGB)("div"),
                            es = (0,
                            it.fLW)(eu),
                            so = (0,
                            it.DhX)(),
                            gs = (0,
                            it.bGB)("div"),
                            (Do = (0,
                            it.bGB)("div")).textContent = "Start Time",
                            Bo = (0,
                            it.DhX)(),
                            Uo = (0,
                            it.bGB)("div"),
                            Ts = (0,
                            it.fLW)(bm),
                            Go = (0,
                            it.DhX)(),
                            ss && ss.c(),
                            Rs = (0,
                            it.DhX)(),
                            ds && ds.c(),
                            ms = (0,
                            it.DhX)(),
                            fs && fs.c(),
                            Eu = (0,
                            it.DhX)(),
                            ps && ps.c(),
                            Ap = (0,
                            it.DhX)(),
                            yr = (0,
                            it.bGB)("div"),
                            qr = (0,
                            it.bGB)("dl"),
                            Hr = (0,
                            it.bGB)("dt"),
                            Lr = (0,
                            it.fLW)(`Response
                `),
                            co = (0,
                            it.bGB)("i"),
                            (0,
                            it.YCL)($o.$$.fragment),
                            Ho = (0,
                            it.DhX)(),
                            Cs && Cs.c(),
                            ys = (0,
                            it.DhX)(),
                            cs = (0,
                            it.bGB)("div"),
                            Ao = (0,
                            it.bGB)("pre"),
                            vs = (0,
                            it.fLW)(Em),
                            (0,
                            it.Ljt)(bt, "class", "vc-table-col vc-table-col-4"),
                            (0,
                            it.Ljt)(It, "class", "vc-table-col"),
                            (0,
                            it.Ljt)(Zt, "class", "vc-table-col"),
                            (0,
                            it.Ljt)(dn, "class", "vc-table-col"),
                            (0,
                            it.Ljt)(vt, "class", "vc-table-row vc-group-preview"),
                            (0,
                            it.VHj)(vt, "vc-table-row-error", At[10].status >= 400),
                            (0,
                            it.Ljt)(Qn, "class", "vc-table-row-icon"),
                            (0,
                            it.Ljt)(Nn, "class", "vc-table-col vc-table-col-title"),
                            (0,
                            it.Ljt)(An, "class", "vc-table-row vc-left-border"),
                            (0,
                            it.Ljt)(Rr, "class", "vc-table-col vc-table-col-2"),
                            (0,
                            it.Ljt)(eo, "class", "vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),
                            (0,
                            it.Ljt)(Nr, "class", "vc-table-row vc-left-border vc-small"),
                            (0,
                            it.Ljt)(Fr, "class", "vc-table-col vc-table-col-2"),
                            (0,
                            it.Ljt)(lo, "class", "vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),
                            (0,
                            it.Ljt)(Or, "class", "vc-table-row vc-left-border vc-small"),
                            (0,
                            it.Ljt)(_r, "class", "vc-table-col vc-table-col-2"),
                            (0,
                            it.Ljt)(ar, "class", "vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),
                            (0,
                            it.Ljt)(mr, "class", "vc-table-row vc-left-border vc-small"),
                            (0,
                            it.Ljt)(Wr, "class", "vc-table-col vc-table-col-2"),
                            (0,
                            it.Ljt)(Wo, "class", "vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),
                            (0,
                            it.Ljt)(Sr, "class", "vc-table-row vc-left-border vc-small"),
                            (0,
                            it.Ljt)(Do, "class", "vc-table-col vc-table-col-2"),
                            (0,
                            it.Ljt)(Uo, "class", "vc-table-col vc-table-col-4 vc-table-col-value vc-max-height-line"),
                            (0,
                            it.Ljt)(gs, "class", "vc-table-row vc-left-border vc-small"),
                            (0,
                            it.Ljt)(co, "class", "vc-table-row-icon"),
                            (0,
                            it.Ljt)(Hr, "class", "vc-table-col vc-table-col-title"),
                            (0,
                            it.Ljt)(qr, "class", "vc-table-row vc-left-border"),
                            (0,
                            it.Ljt)(Ao, "class", "vc-table-col vc-max-height vc-min-height"),
                            (0,
                            it.Ljt)(Ao, "data-scrollable", "1"),
                            (0,
                            it.Ljt)(cs, "class", "vc-table-row vc-left-border vc-small"),
                            (0,
                            it.Ljt)(yn, "class", "vc-group-detail"),
                            (0,
                            it.Ljt)(Tt, "slot", "item"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-group"),
                            (0,
                            it.Ljt)(Tt, "id", jo = At[10].id),
                            (0,
                            it.VHj)(Tt, "vc-actived", At[10].actived)
                        },
                        m: function(Ms, Lo) {
                            (0,
                            it.$Tr)(Ms, Tt, Lo),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(vt, bt),
                            (0,
                            it.R3I)(bt, Rt),
                            (0,
                            it.R3I)(vt, It),
                            (0,
                            it.R3I)(It, Bt),
                            (0,
                            it.R3I)(vt, Zt),
                            (0,
                            it.R3I)(Zt, tn),
                            (0,
                            it.R3I)(vt, dn),
                            (0,
                            it.R3I)(dn, mn),
                            (0,
                            it.R3I)(Tt, Sn),
                            (0,
                            it.R3I)(Tt, yn),
                            (0,
                            it.R3I)(yn, On),
                            (0,
                            it.R3I)(On, An),
                            (0,
                            it.R3I)(An, Nn),
                            (0,
                            it.R3I)(Nn, Fn),
                            (0,
                            it.R3I)(Nn, Qn),
                            (0,
                            it.yef)(er, Qn, null),
                            (0,
                            it.R3I)(On, fr),
                            (0,
                            it.R3I)(On, Nr),
                            (0,
                            it.R3I)(Nr, Rr),
                            (0,
                            it.R3I)(Nr, _i),
                            (0,
                            it.R3I)(Nr, eo),
                            (0,
                            it.R3I)(eo, Gr),
                            (0,
                            it.R3I)(On, Ar),
                            (0,
                            it.R3I)(On, Or),
                            (0,
                            it.R3I)(Or, Fr),
                            (0,
                            it.R3I)(Or, Vo),
                            (0,
                            it.R3I)(Or, lo),
                            (0,
                            it.R3I)(lo, to),
                            (0,
                            it.R3I)(On, Kr),
                            (0,
                            it.R3I)(On, mr),
                            (0,
                            it.R3I)(mr, _r),
                            (0,
                            it.R3I)(mr, vo),
                            (0,
                            it.R3I)(mr, ar),
                            (0,
                            it.R3I)(ar, $r),
                            (0,
                            it.R3I)(On, Vr),
                            (0,
                            it.R3I)(On, Sr),
                            (0,
                            it.R3I)(Sr, Wr),
                            (0,
                            it.R3I)(Sr, Po),
                            (0,
                            it.R3I)(Sr, Wo),
                            (0,
                            it.R3I)(Wo, es),
                            (0,
                            it.R3I)(On, so),
                            (0,
                            it.R3I)(On, gs),
                            (0,
                            it.R3I)(gs, Do),
                            (0,
                            it.R3I)(gs, Bo),
                            (0,
                            it.R3I)(gs, Uo),
                            (0,
                            it.R3I)(Uo, Ts),
                            (0,
                            it.R3I)(yn, Go),
                            ss && ss.m(yn, null),
                            (0,
                            it.R3I)(yn, Rs),
                            ds && ds.m(yn, null),
                            (0,
                            it.R3I)(yn, ms),
                            fs && fs.m(yn, null),
                            (0,
                            it.R3I)(yn, Eu),
                            ps && ps.m(yn, null),
                            (0,
                            it.R3I)(yn, Ap),
                            (0,
                            it.R3I)(yn, yr),
                            (0,
                            it.R3I)(yr, qr),
                            (0,
                            it.R3I)(qr, Hr),
                            (0,
                            it.R3I)(Hr, Lr),
                            (0,
                            it.R3I)(Hr, co),
                            (0,
                            it.yef)($o, co, null),
                            (0,
                            it.R3I)(yr, Ho),
                            Cs && Cs.m(yr, null),
                            (0,
                            it.R3I)(yr, ys),
                            (0,
                            it.R3I)(yr, cs),
                            (0,
                            it.R3I)(cs, Ao),
                            (0,
                            it.R3I)(Ao, vs),
                            us = !0,
                            b0 || (wy = (0,
                            it.oLt)(vt, "click", E0),
                            b0 = !0)
                        },
                        p: function(Ms, Lo) {
                            At = Ms,
                            (!us || 1024 & Lo) && mm !== (mm = At[10].name + "") && (0,
                            it.rTO)(Rt, mm),
                            (!us || 1024 & Lo) && Qu !== (Qu = At[10].method + "") && (0,
                            it.rTO)(Bt, Qu),
                            (!us || 1024 & Lo) && ym !== (ym = At[10].statusText + "") && (0,
                            it.rTO)(tn, ym),
                            (!us || 1024 & Lo) && _c !== (_c = At[10].costTime + "") && (0,
                            it.rTO)(mn, _c),
                            1024 & Lo && (0,
                            it.VHj)(vt, "vc-table-row-error", At[10].status >= 400);
                            var Sm = {};
                            1024 & Lo && (Sm.content = At[10]),
                            er.$set(Sm),
                            (!us || 1024 & Lo) && Ip !== (Ip = At[10].url + "") && (0,
                            it.rTO)(Gr, Ip),
                            (!us || 1024 & Lo) && vm !== (vm = At[10].method + "") && (0,
                            it.rTO)(to, vm),
                            (!us || 1024 & Lo) && _m !== (_m = At[10].requestType + "") && (0,
                            it.rTO)($r, _m),
                            (!us || 1024 & Lo) && eu !== (eu = At[10].status + "") && (0,
                            it.rTO)(es, eu),
                            (!us || 1024 & Lo) && bm !== (bm = At[10].startTimeText + "") && (0,
                            it.rTO)(Ts, bm),
                            At[10].requestHeader !== null ? ss ? (ss.p(At, Lo),
                            1024 & Lo && (0,
                            it.Ui)(ss, 1)) : ((ss = yu(At)).c(),
                            (0,
                            it.Ui)(ss, 1),
                            ss.m(yn, Rs)) : ss && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(ss, 1, 1, function() {
                                ss = null
                            }),
                            (0,
                            it.gbL)()),
                            At[10].getData !== null ? ds ? (ds.p(At, Lo),
                            1024 & Lo && (0,
                            it.Ui)(ds, 1)) : ((ds = u0(At)).c(),
                            (0,
                            it.Ui)(ds, 1),
                            ds.m(yn, ms)) : ds && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(ds, 1, 1, function() {
                                ds = null
                            }),
                            (0,
                            it.gbL)()),
                            At[10].postData !== null ? fs ? (fs.p(At, Lo),
                            1024 & Lo && (0,
                            it.Ui)(fs, 1)) : ((fs = dy(At)).c(),
                            (0,
                            it.Ui)(fs, 1),
                            fs.m(yn, Eu)) : fs && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(fs, 1, 1, function() {
                                fs = null
                            }),
                            (0,
                            it.gbL)()),
                            At[10].header !== null ? ps ? (ps.p(At, Lo),
                            1024 & Lo && (0,
                            it.Ui)(ps, 1)) : ((ps = vu(At)).c(),
                            (0,
                            it.Ui)(ps, 1),
                            ps.m(yn, Ap)) : ps && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(ps, 1, 1, function() {
                                ps = null
                            }),
                            (0,
                            it.gbL)());
                            var S0 = {};
                            1024 & Lo && (S0.content = At[10].response),
                            $o.$set(S0),
                            At[10].responseSize > 0 ? Cs ? Cs.p(At, Lo) : ((Cs = Kn(At)).c(),
                            Cs.m(yr, ys)) : Cs && (Cs.d(1),
                            Cs = null),
                            (!us || 1024 & Lo) && Em !== (Em = (At[10].response || "") + "") && (0,
                            it.rTO)(vs, Em),
                            (!us || 1024 & Lo && jo !== (jo = At[10].id)) && (0,
                            it.Ljt)(Tt, "id", jo),
                            1024 & Lo && (0,
                            it.VHj)(Tt, "vc-actived", At[10].actived)
                        },
                        i: function(Ms) {
                            us || ((0,
                            it.Ui)(er.$$.fragment, Ms),
                            (0,
                            it.Ui)(ss),
                            (0,
                            it.Ui)(ds),
                            (0,
                            it.Ui)(fs),
                            (0,
                            it.Ui)(ps),
                            (0,
                            it.Ui)($o.$$.fragment, Ms),
                            us = !0)
                        },
                        o: function(Ms) {
                            (0,
                            it.etI)(er.$$.fragment, Ms),
                            (0,
                            it.etI)(ss),
                            (0,
                            it.etI)(ds),
                            (0,
                            it.etI)(fs),
                            (0,
                            it.etI)(ps),
                            (0,
                            it.etI)($o.$$.fragment, Ms),
                            us = !1
                        },
                        d: function(Ms) {
                            Ms && (0,
                            it.ogt)(Tt),
                            (0,
                            it.vpE)(er),
                            ss && ss.d(),
                            ds && ds.d(),
                            fs && fs.d(),
                            ps && ps.d(),
                            (0,
                            it.vpE)($o),
                            Cs && Cs.d(),
                            b0 = !1,
                            wy()
                        }
                    }
                }
                function Tr(At) {
                    var Tt, vt, bt, Rt;
                    return bt = new t0({
                        props: {
                            items: At[1],
                            itemKey: "id",
                            itemHeight: 30,
                            buffer: 100,
                            stickToBottom: !0,
                            scrollbar: !0,
                            $$slots: {
                                item: [Wn, function(It) {
                                    return {
                                        10: It.item
                                    }
                                }
                                , function(It) {
                                    return It.item ? 1024 : 0
                                }
                                ],
                                empty: [i1],
                                header: [r1]
                            },
                            $$scope: {
                                ctx: At
                            }
                        }
                    }),
                    {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("div"),
                            (0,
                            it.YCL)(bt.$$.fragment),
                            (0,
                            it.Ljt)(vt, "class", "vc-plugin-content"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-table")
                        },
                        m: function(It, Bt) {
                            (0,
                            it.$Tr)(It, Tt, Bt),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.yef)(bt, vt, null),
                            Rt = !0
                        },
                        p: function(It, Bt) {
                            var Zt = Bt[0]
                              , tn = {};
                            2 & Zt && (tn.items = It[1]),
                            2098177 & Zt && (tn.$$scope = {
                                dirty: Zt,
                                ctx: It
                            }),
                            bt.$set(tn)
                        },
                        i: function(It) {
                            Rt || ((0,
                            it.Ui)(bt.$$.fragment, It),
                            Rt = !0)
                        },
                        o: function(It) {
                            (0,
                            it.etI)(bt.$$.fragment, It),
                            Rt = !1
                        },
                        d: function(It) {
                            It && (0,
                            it.ogt)(Tt),
                            (0,
                            it.vpE)(bt)
                        }
                    }
                }
                function zr(At, Tt, vt) {
                    var bt;
                    (0,
                    it.FIv)(At, Yl, function(dn) {
                        return vt(6, bt = dn)
                    });
                    var Rt = 0
                      , It = function(dn) {
                        vt(0, Rt = Object.keys(dn).length)
                    }
                      , Bt = Yl.subscribe(It);
                    It(bt);
                    var Zt = []
                      , tn = function(dn) {
                        (0,
                        it.fxP)(Yl, bt[dn].actived = !bt[dn].actived, bt)
                    };
                    return (0,
                    ot.H3)(function() {
                        ly.use()
                    }),
                    (0,
                    ot.ev)(function() {
                        Bt(),
                        ly.unuse()
                    }),
                    At.$$.update = function() {
                        64 & At.$$.dirty && vt(1, Zt = Object.values(bt))
                    }
                    ,
                    [Rt, Zt, tn, function(dn) {
                        var mn = "curl -X " + dn.method;
                        return typeof dn.postData == "string" ? mn += " -d '" + dn.postData + "'" : typeof dn.postData == "object" && dn.postData !== null && (mn += " -d '" + $.hZ(dn.postData) + "'"),
                        mn + " '" + dn.url + "'"
                    }
                    , function(dn) {
                        return $.Kn(dn) || $.kJ(dn) ? $.hZ(dn, {
                            maxDepth: 10,
                            keyMaxLen: 1e4,
                            pretty: !0
                        }) : dn
                    }
                    , {
                        fixedHeight: !0
                    }, bt, function(dn) {
                        return tn(dn.id)
                    }
                    ]
                }
                var po = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, zr, Tr, it.N8, {
                            options: 5
                        }),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    (0,
                    _e.Z)(Tt, [{
                        key: "options",
                        get: function() {
                            return this.$$.ctx[5]
                        }
                    }]),
                    Tt
                }(it.f_C)
                  , Xo = po
                  , Co = function(At) {
                    function Tt() {
                        for (var bt, Rt = arguments.length, It = new Array(Rt), Bt = 0; Bt < Rt; Bt++)
                            It[Bt] = arguments[Bt];
                        return (bt = At.call.apply(At, [this].concat(It)) || this).model = om.getSingleton(om, "VConsoleNetworkModel"),
                        bt
                    }
                    (0,
                    rt.Z)(Tt, At);
                    var vt = Tt.prototype;
                    return vt.add = function(bt) {
                        var Rt = new _g(new Hu);
                        for (var It in bt)
                            Rt[It] = bt[It];
                        return Rt.startTime = Rt.startTime || Date.now(),
                        Rt.requestType = Rt.requestType || "custom",
                        this.model.updateRequest(Rt.id, Rt),
                        Rt
                    }
                    ,
                    vt.update = function(bt, Rt) {
                        this.model.updateRequest(bt, Rt)
                    }
                    ,
                    vt.clear = function() {
                        this.model.clearLog()
                    }
                    ,
                    Tt
                }(Mo)
                  , lm = function(At) {
                    function Tt(bt, Rt, It) {
                        var Bt;
                        return It === void 0 && (It = {}),
                        (Bt = At.call(this, bt, Rt, Xo, It) || this).model = om.getSingleton(om, "VConsoleNetworkModel"),
                        Bt.exporter = void 0,
                        Bt.exporter = new Co(bt),
                        Bt
                    }
                    (0,
                    rt.Z)(Tt, At);
                    var vt = Tt.prototype;
                    return vt.onReady = function() {
                        At.prototype.onReady.call(this),
                        this.onUpdateOption()
                    }
                    ,
                    vt.onAddTool = function(bt) {
                        var Rt = this;
                        bt([{
                            name: "Clear",
                            global: !1,
                            onClick: function(It) {
                                Rt.model.clearLog()
                            }
                        }])
                    }
                    ,
                    vt.onRemove = function() {
                        At.prototype.onRemove.call(this),
                        this.model && this.model.unMock()
                    }
                    ,
                    vt.onUpdateOption = function() {
                        var bt, Rt, It;
                        ((bt = this.vConsole.option.network) == null ? void 0 : bt.maxNetworkNumber) !== this.model.maxNetworkNumber && (this.model.maxNetworkNumber = Number((It = this.vConsole.option.network) == null ? void 0 : It.maxNetworkNumber) || 1e3),
                        (Rt = this.vConsole.option.network) != null && Rt.ignoreUrlRegExp && (this.model.ignoreUrlRegExp = this.vConsole.option.network.ignoreUrlRegExp)
                    }
                    ,
                    Tt
                }(Vn)
                  , a1 = __webpack_require__(8679)
                  , Vs = __webpack_require__.n(a1)
                  , _u = (0,
                os.fZ)()
                  , wp = (0,
                os.fZ)()
                  , Il = __webpack_require__(5670)
                  , Xl = {};
                Il.Z && Il.Z.locals && (Xl.locals = Il.Z.locals);
                var Gu, ho = 0, bu = {};
                bu.styleTagTransform = St(),
                bu.setAttributes = yt(),
                bu.insert = ht().bind(null, "head"),
                bu.domAPI = dt(),
                bu.insertStyleElement = _t(),
                Xl.use = function(At) {
                    return bu.options = At || {},
                    ho++ || (Gu = lt()(Il.Z, bu)),
                    Xl
                }
                ,
                Xl.unuse = function() {
                    ho > 0 && !--ho && (Gu(),
                    Gu = null)
                }
                ;
                var d0 = Xl;
                function xp(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[8] = Tt[vt],
                    bt
                }
                function py(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[11] = Tt[vt],
                    bt
                }
                function hy(At) {
                    var Tt, vt, bt, Rt = At[0].nodeType === Node.ELEMENT_NODE && gy(At), It = At[0].nodeType === Node.TEXT_NODE && Jl(At);
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            Rt && Rt.c(),
                            vt = (0,
                            it.DhX)(),
                            It && It.c(),
                            (0,
                            it.Ljt)(Tt, "class", "vcelm-l"),
                            (0,
                            it.VHj)(Tt, "vc-actived", At[0]._isActived),
                            (0,
                            it.VHj)(Tt, "vc-toggle", At[0]._isExpand),
                            (0,
                            it.VHj)(Tt, "vcelm-noc", At[0]._isSingleLine)
                        },
                        m: function(Bt, Zt) {
                            (0,
                            it.$Tr)(Bt, Tt, Zt),
                            Rt && Rt.m(Tt, null),
                            (0,
                            it.R3I)(Tt, vt),
                            It && It.m(Tt, null),
                            bt = !0
                        },
                        p: function(Bt, Zt) {
                            Bt[0].nodeType === Node.ELEMENT_NODE ? Rt ? (Rt.p(Bt, Zt),
                            1 & Zt && (0,
                            it.Ui)(Rt, 1)) : ((Rt = gy(Bt)).c(),
                            (0,
                            it.Ui)(Rt, 1),
                            Rt.m(Tt, vt)) : Rt && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(Rt, 1, 1, function() {
                                Rt = null
                            }),
                            (0,
                            it.gbL)()),
                            Bt[0].nodeType === Node.TEXT_NODE ? It ? It.p(Bt, Zt) : ((It = Jl(Bt)).c(),
                            It.m(Tt, null)) : It && (It.d(1),
                            It = null),
                            1 & Zt && (0,
                            it.VHj)(Tt, "vc-actived", Bt[0]._isActived),
                            1 & Zt && (0,
                            it.VHj)(Tt, "vc-toggle", Bt[0]._isExpand),
                            1 & Zt && (0,
                            it.VHj)(Tt, "vcelm-noc", Bt[0]._isSingleLine)
                        },
                        i: function(Bt) {
                            bt || ((0,
                            it.Ui)(Rt),
                            bt = !0)
                        },
                        o: function(Bt) {
                            (0,
                            it.etI)(Rt),
                            bt = !1
                        },
                        d: function(Bt) {
                            Bt && (0,
                            it.ogt)(Tt),
                            Rt && Rt.d(),
                            It && It.d()
                        }
                    }
                }
                function gy(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt, tn, dn, mn, Sn = At[0].nodeName + "", yn = (At[0].className || At[0].attributes.length) && Tp(At), On = At[0]._isNullEndTag && Rp(), An = At[0].childNodes.length > 0 && p0(At), Nn = !At[0]._isNullEndTag && Ku(At);
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("span"),
                            vt = (0,
                            it.fLW)("<"),
                            bt = (0,
                            it.fLW)(Sn),
                            yn && yn.c(),
                            Rt = (0,
                            it.cSb)(),
                            On && On.c(),
                            It = (0,
                            it.fLW)(">"),
                            An && An.c(),
                            Bt = (0,
                            it.cSb)(),
                            Nn && Nn.c(),
                            Zt = (0,
                            it.cSb)(),
                            (0,
                            it.Ljt)(Tt, "class", "vcelm-node")
                        },
                        m: function(Fn, Qn) {
                            (0,
                            it.$Tr)(Fn, Tt, Qn),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(Tt, bt),
                            yn && yn.m(Tt, null),
                            (0,
                            it.R3I)(Tt, Rt),
                            On && On.m(Tt, null),
                            (0,
                            it.R3I)(Tt, It),
                            An && An.m(Fn, Qn),
                            (0,
                            it.$Tr)(Fn, Bt, Qn),
                            Nn && Nn.m(Fn, Qn),
                            (0,
                            it.$Tr)(Fn, Zt, Qn),
                            tn = !0,
                            dn || (mn = (0,
                            it.oLt)(Tt, "click", At[2]),
                            dn = !0)
                        },
                        p: function(Fn, Qn) {
                            (!tn || 1 & Qn) && Sn !== (Sn = Fn[0].nodeName + "") && (0,
                            it.rTO)(bt, Sn),
                            Fn[0].className || Fn[0].attributes.length ? yn ? yn.p(Fn, Qn) : ((yn = Tp(Fn)).c(),
                            yn.m(Tt, Rt)) : yn && (yn.d(1),
                            yn = null),
                            Fn[0]._isNullEndTag ? On || ((On = Rp()).c(),
                            On.m(Tt, It)) : On && (On.d(1),
                            On = null),
                            Fn[0].childNodes.length > 0 ? An ? (An.p(Fn, Qn),
                            1 & Qn && (0,
                            it.Ui)(An, 1)) : ((An = p0(Fn)).c(),
                            (0,
                            it.Ui)(An, 1),
                            An.m(Bt.parentNode, Bt)) : An && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(An, 1, 1, function() {
                                An = null
                            }),
                            (0,
                            it.gbL)()),
                            Fn[0]._isNullEndTag ? Nn && (Nn.d(1),
                            Nn = null) : Nn ? Nn.p(Fn, Qn) : ((Nn = Ku(Fn)).c(),
                            Nn.m(Zt.parentNode, Zt))
                        },
                        i: function(Fn) {
                            tn || ((0,
                            it.Ui)(An),
                            tn = !0)
                        },
                        o: function(Fn) {
                            (0,
                            it.etI)(An),
                            tn = !1
                        },
                        d: function(Fn) {
                            Fn && (0,
                            it.ogt)(Tt),
                            yn && yn.d(),
                            On && On.d(),
                            An && An.d(Fn),
                            Fn && (0,
                            it.ogt)(Bt),
                            Nn && Nn.d(Fn),
                            Fn && (0,
                            it.ogt)(Zt),
                            dn = !1,
                            mn()
                        }
                    }
                }
                function Tp(At) {
                    for (var Tt, vt = At[0].attributes, bt = [], Rt = 0; Rt < vt.length; Rt += 1)
                        bt[Rt] = f0(py(At, vt, Rt));
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("i");
                            for (var It = 0; It < bt.length; It += 1)
                                bt[It].c();
                            (0,
                            it.Ljt)(Tt, "class", "vcelm-k")
                        },
                        m: function(It, Bt) {
                            (0,
                            it.$Tr)(It, Tt, Bt);
                            for (var Zt = 0; Zt < bt.length; Zt += 1)
                                bt[Zt].m(Tt, null)
                        },
                        p: function(It, Bt) {
                            if (1 & Bt) {
                                var Zt;
                                for (vt = It[0].attributes,
                                Zt = 0; Zt < vt.length; Zt += 1) {
                                    var tn = py(It, vt, Zt);
                                    bt[Zt] ? bt[Zt].p(tn, Bt) : (bt[Zt] = f0(tn),
                                    bt[Zt].c(),
                                    bt[Zt].m(Tt, null))
                                }
                                for (; Zt < bt.length; Zt += 1)
                                    bt[Zt].d(1);
                                bt.length = vt.length
                            }
                        },
                        d: function(It) {
                            It && (0,
                            it.ogt)(Tt),
                            (0,
                            it.RMB)(bt, It)
                        }
                    }
                }
                function Ql(At) {
                    var Tt, vt = At[11].name + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.fLW)(vt)
                        },
                        m: function(bt, Rt) {
                            (0,
                            it.$Tr)(bt, Tt, Rt)
                        },
                        p: function(bt, Rt) {
                            1 & Rt && vt !== (vt = bt[11].name + "") && (0,
                            it.rTO)(Tt, vt)
                        },
                        d: function(bt) {
                            bt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function cm(At) {
                    var Tt, vt, bt, Rt, It, Bt = At[11].name + "", Zt = At[11].value + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.fLW)(Bt),
                            vt = (0,
                            it.fLW)('="'),
                            bt = (0,
                            it.bGB)("i"),
                            Rt = (0,
                            it.fLW)(Zt),
                            It = (0,
                            it.fLW)('"'),
                            (0,
                            it.Ljt)(bt, "class", "vcelm-v")
                        },
                        m: function(tn, dn) {
                            (0,
                            it.$Tr)(tn, Tt, dn),
                            (0,
                            it.$Tr)(tn, vt, dn),
                            (0,
                            it.$Tr)(tn, bt, dn),
                            (0,
                            it.R3I)(bt, Rt),
                            (0,
                            it.$Tr)(tn, It, dn)
                        },
                        p: function(tn, dn) {
                            1 & dn && Bt !== (Bt = tn[11].name + "") && (0,
                            it.rTO)(Tt, Bt),
                            1 & dn && Zt !== (Zt = tn[11].value + "") && (0,
                            it.rTO)(Rt, Zt)
                        },
                        d: function(tn) {
                            tn && (0,
                            it.ogt)(Tt),
                            tn && (0,
                            it.ogt)(vt),
                            tn && (0,
                            it.ogt)(bt),
                            tn && (0,
                            it.ogt)(It)
                        }
                    }
                }
                function f0(At) {
                    var Tt, vt;
                    function bt(Bt, Zt) {
                        return Bt[11].value !== "" ? cm : Ql
                    }
                    var Rt = bt(At)
                      , It = Rt(At);
                    return {
                        c: function() {
                            Tt = (0,
                            it.fLW)(`
            `),
                            It.c(),
                            vt = (0,
                            it.cSb)()
                        },
                        m: function(Bt, Zt) {
                            (0,
                            it.$Tr)(Bt, Tt, Zt),
                            It.m(Bt, Zt),
                            (0,
                            it.$Tr)(Bt, vt, Zt)
                        },
                        p: function(Bt, Zt) {
                            Rt === (Rt = bt(Bt)) && It ? It.p(Bt, Zt) : (It.d(1),
                            (It = Rt(Bt)) && (It.c(),
                            It.m(vt.parentNode, vt)))
                        },
                        d: function(Bt) {
                            Bt && (0,
                            it.ogt)(Tt),
                            It.d(Bt),
                            Bt && (0,
                            it.ogt)(vt)
                        }
                    }
                }
                function Rp(At) {
                    var Tt;
                    return {
                        c: function() {
                            Tt = (0,
                            it.fLW)("/")
                        },
                        m: function(vt, bt) {
                            (0,
                            it.$Tr)(vt, Tt, bt)
                        },
                        d: function(vt) {
                            vt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function p0(At) {
                    var Tt, vt, bt, Rt, It = [um, my], Bt = [];
                    function Zt(tn, dn) {
                        return tn[0]._isExpand ? 1 : 0
                    }
                    return Tt = Zt(At),
                    vt = Bt[Tt] = It[Tt](At),
                    {
                        c: function() {
                            vt.c(),
                            bt = (0,
                            it.cSb)()
                        },
                        m: function(tn, dn) {
                            Bt[Tt].m(tn, dn),
                            (0,
                            it.$Tr)(tn, bt, dn),
                            Rt = !0
                        },
                        p: function(tn, dn) {
                            var mn = Tt;
                            (Tt = Zt(tn)) === mn ? Bt[Tt].p(tn, dn) : ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(Bt[mn], 1, 1, function() {
                                Bt[mn] = null
                            }),
                            (0,
                            it.gbL)(),
                            (vt = Bt[Tt]) ? vt.p(tn, dn) : (vt = Bt[Tt] = It[Tt](tn)).c(),
                            (0,
                            it.Ui)(vt, 1),
                            vt.m(bt.parentNode, bt))
                        },
                        i: function(tn) {
                            Rt || ((0,
                            it.Ui)(vt),
                            Rt = !0)
                        },
                        o: function(tn) {
                            (0,
                            it.etI)(vt),
                            Rt = !1
                        },
                        d: function(tn) {
                            Bt[Tt].d(tn),
                            tn && (0,
                            it.ogt)(bt)
                        }
                    }
                }
                function my(At) {
                    for (var Tt, vt, bt = At[0].childNodes, Rt = [], It = 0; It < bt.length; It += 1)
                        Rt[It] = h0(xp(At, bt, It));
                    var Bt = function(Zt) {
                        return (0,
                        it.etI)(Rt[Zt], 1, 1, function() {
                            Rt[Zt] = null
                        })
                    };
                    return {
                        c: function() {
                            for (var Zt = 0; Zt < Rt.length; Zt += 1)
                                Rt[Zt].c();
                            Tt = (0,
                            it.cSb)()
                        },
                        m: function(Zt, tn) {
                            for (var dn = 0; dn < Rt.length; dn += 1)
                                Rt[dn].m(Zt, tn);
                            (0,
                            it.$Tr)(Zt, Tt, tn),
                            vt = !0
                        },
                        p: function(Zt, tn) {
                            if (1 & tn) {
                                var dn;
                                for (bt = Zt[0].childNodes,
                                dn = 0; dn < bt.length; dn += 1) {
                                    var mn = xp(Zt, bt, dn);
                                    Rt[dn] ? (Rt[dn].p(mn, tn),
                                    (0,
                                    it.Ui)(Rt[dn], 1)) : (Rt[dn] = h0(mn),
                                    Rt[dn].c(),
                                    (0,
                                    it.Ui)(Rt[dn], 1),
                                    Rt[dn].m(Tt.parentNode, Tt))
                                }
                                for ((0,
                                it.dvw)(),
                                dn = bt.length; dn < Rt.length; dn += 1)
                                    Bt(dn);
                                (0,
                                it.gbL)()
                            }
                        },
                        i: function(Zt) {
                            if (!vt) {
                                for (var tn = 0; tn < bt.length; tn += 1)
                                    (0,
                                    it.Ui)(Rt[tn]);
                                vt = !0
                            }
                        },
                        o: function(Zt) {
                            Rt = Rt.filter(Boolean);
                            for (var tn = 0; tn < Rt.length; tn += 1)
                                (0,
                                it.etI)(Rt[tn]);
                            vt = !1
                        },
                        d: function(Zt) {
                            (0,
                            it.RMB)(Rt, Zt),
                            Zt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function um(At) {
                    var Tt;
                    return {
                        c: function() {
                            Tt = (0,
                            it.fLW)("...")
                        },
                        m: function(vt, bt) {
                            (0,
                            it.$Tr)(vt, Tt, bt)
                        },
                        p: it.ZTd,
                        i: it.ZTd,
                        o: it.ZTd,
                        d: function(vt) {
                            vt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function h0(At) {
                    var Tt, vt, bt;
                    return (Tt = new yy({
                        props: {
                            node: At[8]
                        }
                    })).$on("toggleNode", At[4]),
                    {
                        c: function() {
                            (0,
                            it.YCL)(Tt.$$.fragment),
                            vt = (0,
                            it.DhX)()
                        },
                        m: function(Rt, It) {
                            (0,
                            it.yef)(Tt, Rt, It),
                            (0,
                            it.$Tr)(Rt, vt, It),
                            bt = !0
                        },
                        p: function(Rt, It) {
                            var Bt = {};
                            1 & It && (Bt.node = Rt[8]),
                            Tt.$set(Bt)
                        },
                        i: function(Rt) {
                            bt || ((0,
                            it.Ui)(Tt.$$.fragment, Rt),
                            bt = !0)
                        },
                        o: function(Rt) {
                            (0,
                            it.etI)(Tt.$$.fragment, Rt),
                            bt = !1
                        },
                        d: function(Rt) {
                            (0,
                            it.vpE)(Tt, Rt),
                            Rt && (0,
                            it.ogt)(vt)
                        }
                    }
                }
                function Ku(At) {
                    var Tt, vt, bt, Rt, It = At[0].nodeName + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("span"),
                            vt = (0,
                            it.fLW)("</"),
                            bt = (0,
                            it.fLW)(It),
                            Rt = (0,
                            it.fLW)(">"),
                            (0,
                            it.Ljt)(Tt, "class", "vcelm-node")
                        },
                        m: function(Bt, Zt) {
                            (0,
                            it.$Tr)(Bt, Tt, Zt),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(Tt, bt),
                            (0,
                            it.R3I)(Tt, Rt)
                        },
                        p: function(Bt, Zt) {
                            1 & Zt && It !== (It = Bt[0].nodeName + "") && (0,
                            it.rTO)(bt, It)
                        },
                        d: function(Bt) {
                            Bt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function Jl(At) {
                    var Tt, vt, bt = At[1](At[0].textContent) + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("span"),
                            vt = (0,
                            it.fLW)(bt),
                            (0,
                            it.Ljt)(Tt, "class", "vcelm-t vcelm-noc")
                        },
                        m: function(Rt, It) {
                            (0,
                            it.$Tr)(Rt, Tt, It),
                            (0,
                            it.R3I)(Tt, vt)
                        },
                        p: function(Rt, It) {
                            1 & It && bt !== (bt = Rt[1](Rt[0].textContent) + "") && (0,
                            it.rTO)(vt, bt)
                        },
                        d: function(Rt) {
                            Rt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function dm(At) {
                    var Tt, vt, bt = At[0] && hy(At);
                    return {
                        c: function() {
                            bt && bt.c(),
                            Tt = (0,
                            it.cSb)()
                        },
                        m: function(Rt, It) {
                            bt && bt.m(Rt, It),
                            (0,
                            it.$Tr)(Rt, Tt, It),
                            vt = !0
                        },
                        p: function(Rt, It) {
                            var Bt = It[0];
                            Rt[0] ? bt ? (bt.p(Rt, Bt),
                            1 & Bt && (0,
                            it.Ui)(bt, 1)) : ((bt = hy(Rt)).c(),
                            (0,
                            it.Ui)(bt, 1),
                            bt.m(Tt.parentNode, Tt)) : bt && ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(bt, 1, 1, function() {
                                bt = null
                            }),
                            (0,
                            it.gbL)())
                        },
                        i: function(Rt) {
                            vt || ((0,
                            it.Ui)(bt),
                            vt = !0)
                        },
                        o: function(Rt) {
                            (0,
                            it.etI)(bt),
                            vt = !1
                        },
                        d: function(Rt) {
                            bt && bt.d(Rt),
                            Rt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function l1(At, Tt, vt) {
                    var bt;
                    (0,
                    it.FIv)(At, wp, function(Zt) {
                        return vt(3, bt = Zt)
                    });
                    var Rt = Tt.node
                      , It = (0,
                    ot.x)()
                      , Bt = ["br", "hr", "img", "input", "link", "meta"];
                    return (0,
                    ot.H3)(function() {
                        d0.use()
                    }),
                    (0,
                    ot.ev)(function() {
                        d0.unuse()
                    }),
                    At.$$set = function(Zt) {
                        "node"in Zt && vt(0, Rt = Zt.node)
                    }
                    ,
                    At.$$.update = function() {
                        9 & At.$$.dirty && Rt && (vt(0, Rt._isActived = Rt === bt, Rt),
                        vt(0, Rt._isNullEndTag = function(Zt) {
                            return Bt.indexOf(Zt.nodeName) > -1
                        }(Rt), Rt),
                        vt(0, Rt._isSingleLine = Rt.childNodes.length === 0 || Rt._isNullEndTag, Rt))
                    }
                    ,
                    [Rt, function(Zt) {
                        return Zt.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
                    }
                    , function() {
                        Rt._isNullEndTag || (vt(0, Rt._isExpand = !Rt._isExpand, Rt),
                        It("toggleNode", {
                            node: Rt
                        }))
                    }
                    , bt, function(Zt) {
                        it.cKT.call(this, At, Zt)
                    }
                    ]
                }
                var yy = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, l1, dm, it.N8, {
                            node: 0
                        }),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    (0,
                    _e.Z)(Tt, [{
                        key: "node",
                        get: function() {
                            return this.$$.ctx[0]
                        },
                        set: function(vt) {
                            this.$$set({
                                node: vt
                            }),
                            (0,
                            it.yl1)()
                        }
                    }]),
                    Tt
                }(it.f_C)
                  , c1 = yy;
                function fm(At) {
                    var Tt, vt, bt;
                    return (vt = new c1({
                        props: {
                            node: At[0]
                        }
                    })).$on("toggleNode", At[1]),
                    {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            (0,
                            it.YCL)(vt.$$.fragment),
                            (0,
                            it.Ljt)(Tt, "class", "vc-plugin-content")
                        },
                        m: function(Rt, It) {
                            (0,
                            it.$Tr)(Rt, Tt, It),
                            (0,
                            it.yef)(vt, Tt, null),
                            bt = !0
                        },
                        p: function(Rt, It) {
                            var Bt = {};
                            1 & It[0] && (Bt.node = Rt[0]),
                            vt.$set(Bt)
                        },
                        i: function(Rt) {
                            bt || ((0,
                            it.Ui)(vt.$$.fragment, Rt),
                            bt = !0)
                        },
                        o: function(Rt) {
                            (0,
                            it.etI)(vt.$$.fragment, Rt),
                            bt = !1
                        },
                        d: function(Rt) {
                            Rt && (0,
                            it.ogt)(Tt),
                            (0,
                            it.vpE)(vt)
                        }
                    }
                }
                function pm(At, Tt, vt) {
                    var bt;
                    return (0,
                    it.FIv)(At, _u, function(Rt) {
                        return vt(0, bt = Rt)
                    }),
                    [bt, function(Rt) {
                        it.cKT.call(this, At, Rt)
                    }
                    ]
                }
                var g0 = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, pm, fm, it.N8, {}),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    Tt
                }(it.f_C)
                  , u1 = g0
                  , m0 = function(At) {
                    function Tt(bt, Rt, It) {
                        var Bt;
                        return It === void 0 && (It = {}),
                        (Bt = At.call(this, bt, Rt, u1, It) || this).isInited = !1,
                        Bt.observer = void 0,
                        Bt.nodeMap = void 0,
                        Bt
                    }
                    (0,
                    rt.Z)(Tt, At);
                    var vt = Tt.prototype;
                    return vt.onShow = function() {
                        this.isInited || this._init()
                    }
                    ,
                    vt.onRemove = function() {
                        At.prototype.onRemove.call(this),
                        this.isInited && (this.observer.disconnect(),
                        this.isInited = !1,
                        this.nodeMap = void 0,
                        _u.set(void 0))
                    }
                    ,
                    vt.onAddTool = function(bt) {
                        var Rt = this;
                        bt([{
                            name: "Expand",
                            global: !1,
                            onClick: function(It) {
                                Rt._expandActivedNode()
                            }
                        }, {
                            name: "Collapse",
                            global: !1,
                            onClick: function(It) {
                                Rt._collapseActivedNode()
                            }
                        }])
                    }
                    ,
                    vt._init = function() {
                        var bt = this;
                        this.isInited = !0,
                        this.nodeMap = new WeakMap;
                        var Rt = this._generateVNode(document.documentElement);
                        Rt._isExpand = !0,
                        wp.set(Rt),
                        _u.set(Rt),
                        this.compInstance.$on("toggleNode", function(It) {
                            wp.set(It.detail.node)
                        }),
                        this.observer = new (Vs())(function(It) {
                            for (var Bt = 0; Bt < It.length; Bt++) {
                                var Zt = It[Bt];
                                bt._isInVConsole(Zt.target) || bt._handleMutation(Zt)
                            }
                        }
                        ),
                        this.observer.observe(document.documentElement, {
                            attributes: !0,
                            childList: !0,
                            characterData: !0,
                            subtree: !0
                        })
                    }
                    ,
                    vt._handleMutation = function(bt) {
                        switch (bt.type) {
                        case "childList":
                            bt.removedNodes.length > 0 && this._onChildRemove(bt),
                            bt.addedNodes.length > 0 && this._onChildAdd(bt);
                            break;
                        case "attributes":
                            this._onAttributesChange(bt);
                            break;
                        case "characterData":
                            this._onCharacterDataChange(bt)
                        }
                    }
                    ,
                    vt._onChildRemove = function(bt) {
                        var Rt = this.nodeMap.get(bt.target);
                        if (Rt) {
                            for (var It = 0; It < bt.removedNodes.length; It++) {
                                var Bt = this.nodeMap.get(bt.removedNodes[It]);
                                if (Bt) {
                                    for (var Zt = 0; Zt < Rt.childNodes.length; Zt++)
                                        if (Rt.childNodes[Zt] === Bt) {
                                            Rt.childNodes.splice(Zt, 1);
                                            break
                                        }
                                    this.nodeMap.delete(bt.removedNodes[It])
                                }
                            }
                            this._refreshStore()
                        }
                    }
                    ,
                    vt._onChildAdd = function(bt) {
                        var Rt = this.nodeMap.get(bt.target);
                        if (Rt) {
                            for (var It = 0; It < bt.addedNodes.length; It++) {
                                var Bt = bt.addedNodes[It]
                                  , Zt = this._generateVNode(Bt);
                                if (Zt) {
                                    var tn = void 0
                                      , dn = Bt;
                                    do {
                                        if (dn.nextSibling === null)
                                            break;
                                        dn.nodeType === Node.ELEMENT_NODE && (tn = this.nodeMap.get(dn.nextSibling) || void 0),
                                        dn = dn.nextSibling
                                    } while (tn === void 0);
                                    if (tn === void 0)
                                        Rt.childNodes.push(Zt);
                                    else
                                        for (var mn = 0; mn < Rt.childNodes.length; mn++)
                                            if (Rt.childNodes[mn] === tn) {
                                                Rt.childNodes.splice(mn, 0, Zt);
                                                break
                                            }
                                }
                            }
                            this._refreshStore()
                        }
                    }
                    ,
                    vt._onAttributesChange = function(bt) {
                        this._updateVNodeAttributes(bt.target),
                        this._refreshStore()
                    }
                    ,
                    vt._onCharacterDataChange = function(bt) {
                        var Rt = this.nodeMap.get(bt.target);
                        Rt && (Rt.textContent = bt.target.textContent,
                        this._refreshStore())
                    }
                    ,
                    vt._generateVNode = function(bt) {
                        if (!this._isIgnoredNode(bt)) {
                            var Rt = {
                                nodeType: bt.nodeType,
                                nodeName: bt.nodeName.toLowerCase(),
                                textContent: "",
                                id: "",
                                className: "",
                                attributes: [],
                                childNodes: []
                            };
                            if (this.nodeMap.set(bt, Rt),
                            Rt.nodeType != bt.TEXT_NODE && Rt.nodeType != bt.DOCUMENT_TYPE_NODE || (Rt.textContent = bt.textContent),
                            bt.childNodes.length > 0) {
                                Rt.childNodes = [];
                                for (var It = 0; It < bt.childNodes.length; It++) {
                                    var Bt = this._generateVNode(bt.childNodes[It]);
                                    Bt && Rt.childNodes.push(Bt)
                                }
                            }
                            return this._updateVNodeAttributes(bt),
                            Rt
                        }
                    }
                    ,
                    vt._updateVNodeAttributes = function(bt) {
                        var Rt = this.nodeMap.get(bt);
                        if (Rt && bt instanceof Element && (Rt.id = bt.id || "",
                        Rt.className = bt.className || "",
                        bt.hasAttributes && bt.hasAttributes())) {
                            Rt.attributes = [];
                            for (var It = 0; It < bt.attributes.length; It++)
                                Rt.attributes.push({
                                    name: bt.attributes[It].name,
                                    value: bt.attributes[It].value || ""
                                })
                        }
                    }
                    ,
                    vt._expandActivedNode = function() {
                        var bt = (0,
                        os.U2)(wp);
                        if (bt._isExpand)
                            for (var Rt = 0; Rt < bt.childNodes.length; Rt++)
                                bt.childNodes[Rt]._isExpand = !0;
                        else
                            bt._isExpand = !0;
                        this._refreshStore()
                    }
                    ,
                    vt._collapseActivedNode = function() {
                        var bt = (0,
                        os.U2)(wp);
                        if (bt._isExpand) {
                            for (var Rt = !1, It = 0; It < bt.childNodes.length; It++)
                                bt.childNodes[It]._isExpand && (Rt = !0,
                                bt.childNodes[It]._isExpand = !1);
                            Rt || (bt._isExpand = !1),
                            this._refreshStore()
                        }
                    }
                    ,
                    vt._isIgnoredNode = function(bt) {
                        if (bt.nodeType === bt.TEXT_NODE) {
                            if (bt.textContent.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$|\n+/g, "") === "")
                                return !0
                        } else if (bt.nodeType === bt.COMMENT_NODE)
                            return !0;
                        return !1
                    }
                    ,
                    vt._isInVConsole = function(bt) {
                        for (var Rt = bt; Rt !== void 0; ) {
                            if (Rt.id == "__vconsole")
                                return !0;
                            Rt = Rt.parentElement || void 0
                        }
                        return !1
                    }
                    ,
                    vt._refreshStore = function() {
                        _u.update(function(bt) {
                            return bt
                        })
                    }
                    ,
                    Tt
                }(Vn);
                function vy(At, Tt, vt, bt, Rt, It, Bt) {
                    try {
                        var Zt = At[It](Bt)
                          , tn = Zt.value
                    } catch (dn) {
                        return void vt(dn)
                    }
                    Zt.done ? Tt(tn) : Promise.resolve(tn).then(bt, Rt)
                }
                function Vu(At) {
                    return function() {
                        var Tt = this
                          , vt = arguments;
                        return new Promise(function(bt, Rt) {
                            var It = At.apply(Tt, vt);
                            function Bt(tn) {
                                vy(It, bt, Rt, Bt, Zt, "next", tn)
                            }
                            function Zt(tn) {
                                vy(It, bt, Rt, Bt, Zt, "throw", tn)
                            }
                            Bt(void 0)
                        }
                        )
                    }
                }
                var Qo = __webpack_require__(8270);
                function ls(At, Tt) {
                    var vt = Object.keys(At);
                    if (Object.getOwnPropertySymbols) {
                        var bt = Object.getOwnPropertySymbols(At);
                        Tt && (bt = bt.filter(function(Rt) {
                            return Object.getOwnPropertyDescriptor(At, Rt).enumerable
                        })),
                        vt.push.apply(vt, bt)
                    }
                    return vt
                }
                function _y(At) {
                    for (var Tt = 1; Tt < arguments.length; Tt++) {
                        var vt = arguments[Tt] != null ? arguments[Tt] : {};
                        Tt % 2 ? ls(Object(vt), !0).forEach(function(bt) {
                            (0,
                            Qo.Z)(At, bt, vt[bt])
                        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(At, Object.getOwnPropertyDescriptors(vt)) : ls(Object(vt)).forEach(function(bt) {
                            Object.defineProperty(At, bt, Object.getOwnPropertyDescriptor(vt, bt))
                        })
                    }
                    return At
                }
                var by = function(At) {
                    if (!At || At.length === 0)
                        return {};
                    for (var Tt = {}, vt = At.split(";"), bt = 0; bt < vt.length; bt++) {
                        var Rt = vt[bt].indexOf("=");
                        if (!(Rt < 0)) {
                            var It = vt[bt].substring(0, Rt).replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
                              , Bt = vt[bt].substring(Rt + 1, vt[bt].length);
                            try {
                                It = decodeURIComponent(It)
                            } catch {}
                            try {
                                Bt = decodeURIComponent(Bt)
                            } catch {}
                            Tt[It] = Bt
                        }
                    }
                    return Tt
                }
                  , y0 = function(At, Tt, vt) {
                    typeof document < "u" && document.cookie !== void 0 && (document.cookie = encodeURIComponent(At) + "=" + encodeURIComponent(Tt) + function(bt) {
                        bt === void 0 && (bt = {});
                        var Rt = bt
                          , It = Rt.path
                          , Bt = Rt.domain
                          , Zt = Rt.expires
                          , tn = Rt.secure
                          , dn = Rt.sameSite
                          , mn = ["none", "lax", "strict"].indexOf((dn || "").toLowerCase()) > -1 ? dn : null;
                        return [It == null ? "" : ";path=" + It, Bt == null ? "" : ";domain=" + Bt, Zt == null ? "" : ";expires=" + Zt.toUTCString(), tn === void 0 || tn === !1 ? "" : ";secure", mn === null ? "" : ";SameSite=" + mn].join("")
                    }(vt))
                }
                  , Ey = function() {
                    return typeof document > "u" || document.cookie === void 0 ? "" : document.cookie
                }
                  , v0 = function() {
                    function At() {}
                    var Tt = At.prototype;
                    return Tt.key = function(vt) {
                        return vt < this.keys.length ? this.keys[vt] : null
                    }
                    ,
                    Tt.setItem = function(vt, bt, Rt) {
                        y0(vt, bt, Rt)
                    }
                    ,
                    Tt.getItem = function(vt) {
                        var bt = by(Ey());
                        return Object.prototype.hasOwnProperty.call(bt, vt) ? bt[vt] : null
                    }
                    ,
                    Tt.removeItem = function(vt, bt) {
                        for (var Rt, It, Bt = ["", "/"], Zt = ((Rt = location) == null || (It = Rt.hostname) == null ? void 0 : It.split(".")) || []; Zt.length > 1; )
                            Bt.push(Zt.join(".")),
                            Zt.shift();
                        for (var tn = 0; tn < Bt.length; tn++)
                            for (var dn, mn, Sn = ((dn = location) == null || (mn = dn.pathname) == null ? void 0 : mn.split("/")) || [], yn = ""; Sn.length > 0; ) {
                                yn += (yn === "/" ? "" : "/") + Sn.shift();
                                var On = _y(_y({}, bt), {}, {
                                    path: yn,
                                    domain: Bt[tn],
                                    expires: new Date(0)
                                });
                                y0(vt, "", On)
                            }
                    }
                    ,
                    Tt.clear = function() {
                        for (var vt = [].concat(this.keys), bt = 0; bt < vt.length; bt++)
                            this.removeItem(vt[bt])
                    }
                    ,
                    (0,
                    _e.Z)(At, [{
                        key: "length",
                        get: function() {
                            return this.keys.length
                        }
                    }, {
                        key: "keys",
                        get: function() {
                            var vt = by(Ey());
                            return Object.keys(vt).sort()
                        }
                    }]),
                    At
                }()
                  , Cp = function() {
                    function At() {
                        this.keys = [],
                        this.currentSize = 0,
                        this.limitSize = 0
                    }
                    var Tt = At.prototype;
                    return Tt.key = function(vt) {
                        return vt < this.keys.length ? this.keys[vt] : null
                    }
                    ,
                    Tt.prepare = function() {
                        var vt = Vu(Eo().mark(function bt() {
                            var Rt = this;
                            return Eo().wrap(function(It) {
                                for (; ; )
                                    switch (It.prev = It.next) {
                                    case 0:
                                        return It.abrupt("return", new Promise(function(Bt, Zt) {
                                            (0,
                                            $.qt)("getStorageInfo", {
                                                success: function(tn) {
                                                    Rt.keys = tn ? tn.keys.sort() : [],
                                                    Rt.currentSize = tn ? tn.currentSize : 0,
                                                    Rt.limitSize = tn ? tn.limitSize : 0,
                                                    Bt(!0)
                                                },
                                                fail: function() {
                                                    Zt(!1)
                                                }
                                            })
                                        }
                                        ));
                                    case 1:
                                    case "end":
                                        return It.stop()
                                    }
                            }, bt)
                        }));
                        return function() {
                            return vt.apply(this, arguments)
                        }
                    }(),
                    Tt.getItem = function(vt) {
                        return new Promise(function(bt, Rt) {
                            (0,
                            $.qt)("getStorage", {
                                key: vt,
                                success: function(It) {
                                    var Bt = It.data;
                                    if (typeof It.data == "object")
                                        try {
                                            Bt = JSON.stringify(It.data)
                                        } catch {}
                                    bt(Bt)
                                },
                                fail: function(It) {
                                    Rt(It)
                                }
                            })
                        }
                        )
                    }
                    ,
                    Tt.setItem = function(vt, bt) {
                        return new Promise(function(Rt, It) {
                            (0,
                            $.qt)("setStorage", {
                                key: vt,
                                data: bt,
                                success: function(Bt) {
                                    Rt(Bt)
                                },
                                fail: function(Bt) {
                                    It(Bt)
                                }
                            })
                        }
                        )
                    }
                    ,
                    Tt.removeItem = function(vt) {
                        return new Promise(function(bt, Rt) {
                            (0,
                            $.qt)("removeStorage", {
                                key: vt,
                                success: function(It) {
                                    bt(It)
                                },
                                fail: function(It) {
                                    Rt(It)
                                }
                            })
                        }
                        )
                    }
                    ,
                    Tt.clear = function() {
                        return new Promise(function(vt, bt) {
                            (0,
                            $.qt)("clearStorage", {
                                success: function(Rt) {
                                    vt(Rt)
                                },
                                fail: function(Rt) {
                                    bt(Rt)
                                }
                            })
                        }
                        )
                    }
                    ,
                    (0,
                    _e.Z)(At, [{
                        key: "length",
                        get: function() {
                            return this.keys.length
                        }
                    }]),
                    At
                }()
                  , Jo = {
                    updateTime: (0,
                    os.fZ)(0),
                    activedName: (0,
                    os.fZ)(null),
                    defaultStorages: (0,
                    os.fZ)(["cookies", "localStorage", "sessionStorage"])
                }
                  , Ol = function(At) {
                    function Tt() {
                        var bt;
                        return (bt = At.call(this) || this).storage = new Map,
                        Jo.activedName.subscribe(function(Rt) {
                            var It = (0,
                            os.U2)(Jo.defaultStorages);
                            It.length > 0 && It.indexOf(Rt) === -1 && Jo.activedName.set(It[0])
                        }),
                        Jo.defaultStorages.subscribe(function(Rt) {
                            Rt.indexOf((0,
                            os.U2)(Jo.activedName)) === -1 && Jo.activedName.set(Rt[0]),
                            bt.updateEnabledStorages()
                        }),
                        bt
                    }
                    (0,
                    rt.Z)(Tt, At);
                    var vt = Tt.prototype;
                    return vt.getItem = function() {
                        var bt = Vu(Eo().mark(function Rt(It) {
                            return Eo().wrap(function(Bt) {
                                for (; ; )
                                    switch (Bt.prev = Bt.next) {
                                    case 0:
                                        if (this.activedStorage) {
                                            Bt.next = 2;
                                            break
                                        }
                                        return Bt.abrupt("return", "");
                                    case 2:
                                        return Bt.next = 4,
                                        this.promisify(this.activedStorage.getItem(It));
                                    case 4:
                                        return Bt.abrupt("return", Bt.sent);
                                    case 5:
                                    case "end":
                                        return Bt.stop()
                                    }
                            }, Rt, this)
                        }));
                        return function(Rt) {
                            return bt.apply(this, arguments)
                        }
                    }(),
                    vt.setItem = function() {
                        var bt = Vu(Eo().mark(function Rt(It, Bt) {
                            var Zt;
                            return Eo().wrap(function(tn) {
                                for (; ; )
                                    switch (tn.prev = tn.next) {
                                    case 0:
                                        if (this.activedStorage) {
                                            tn.next = 2;
                                            break
                                        }
                                        return tn.abrupt("return");
                                    case 2:
                                        return tn.next = 4,
                                        this.promisify(this.activedStorage.setItem(It, Bt));
                                    case 4:
                                        return Zt = tn.sent,
                                        this.refresh(),
                                        tn.abrupt("return", Zt);
                                    case 7:
                                    case "end":
                                        return tn.stop()
                                    }
                            }, Rt, this)
                        }));
                        return function(Rt, It) {
                            return bt.apply(this, arguments)
                        }
                    }(),
                    vt.removeItem = function() {
                        var bt = Vu(Eo().mark(function Rt(It) {
                            var Bt;
                            return Eo().wrap(function(Zt) {
                                for (; ; )
                                    switch (Zt.prev = Zt.next) {
                                    case 0:
                                        if (this.activedStorage) {
                                            Zt.next = 2;
                                            break
                                        }
                                        return Zt.abrupt("return");
                                    case 2:
                                        return Zt.next = 4,
                                        this.promisify(this.activedStorage.removeItem(It));
                                    case 4:
                                        return Bt = Zt.sent,
                                        this.refresh(),
                                        Zt.abrupt("return", Bt);
                                    case 7:
                                    case "end":
                                        return Zt.stop()
                                    }
                            }, Rt, this)
                        }));
                        return function(Rt) {
                            return bt.apply(this, arguments)
                        }
                    }(),
                    vt.clear = function() {
                        var bt = Vu(Eo().mark(function Rt() {
                            var It;
                            return Eo().wrap(function(Bt) {
                                for (; ; )
                                    switch (Bt.prev = Bt.next) {
                                    case 0:
                                        if (this.activedStorage) {
                                            Bt.next = 2;
                                            break
                                        }
                                        return Bt.abrupt("return");
                                    case 2:
                                        return Bt.next = 4,
                                        this.promisify(this.activedStorage.clear());
                                    case 4:
                                        return It = Bt.sent,
                                        this.refresh(),
                                        Bt.abrupt("return", It);
                                    case 7:
                                    case "end":
                                        return Bt.stop()
                                    }
                            }, Rt, this)
                        }));
                        return function() {
                            return bt.apply(this, arguments)
                        }
                    }(),
                    vt.refresh = function() {
                        Jo.updateTime.set(Date.now())
                    }
                    ,
                    vt.getEntries = function() {
                        var bt = Vu(Eo().mark(function Rt() {
                            var It, Bt, Zt, tn, dn;
                            return Eo().wrap(function(mn) {
                                for (; ; )
                                    switch (mn.prev = mn.next) {
                                    case 0:
                                        if (It = this.activedStorage) {
                                            mn.next = 3;
                                            break
                                        }
                                        return mn.abrupt("return", []);
                                    case 3:
                                        if (typeof It.prepare != "function") {
                                            mn.next = 6;
                                            break
                                        }
                                        return mn.next = 6,
                                        It.prepare();
                                    case 6:
                                        Bt = [],
                                        Zt = 0;
                                    case 8:
                                        if (!(Zt < It.length)) {
                                            mn.next = 17;
                                            break
                                        }
                                        return tn = It.key(Zt),
                                        mn.next = 12,
                                        this.getItem(tn);
                                    case 12:
                                        dn = mn.sent,
                                        Bt.push([tn, dn]);
                                    case 14:
                                        Zt++,
                                        mn.next = 8;
                                        break;
                                    case 17:
                                        return mn.abrupt("return", Bt);
                                    case 18:
                                    case "end":
                                        return mn.stop()
                                    }
                            }, Rt, this)
                        }));
                        return function() {
                            return bt.apply(this, arguments)
                        }
                    }(),
                    vt.updateEnabledStorages = function() {
                        var bt = (0,
                        os.U2)(Jo.defaultStorages);
                        bt.indexOf("cookies") > -1 ? document.cookie !== void 0 && this.storage.set("cookies", new v0) : this.deleteStorage("cookies"),
                        bt.indexOf("localStorage") > -1 ? window.localStorage && this.storage.set("localStorage", window.localStorage) : this.deleteStorage("localStorage"),
                        bt.indexOf("sessionStorage") > -1 ? window.sessionStorage && this.storage.set("sessionStorage", window.sessionStorage) : this.deleteStorage("sessionStorage"),
                        bt.indexOf("wxStorage") > -1 ? (0,
                        $.H_)() && this.storage.set("wxStorage", new Cp) : this.deleteStorage("wxStorage")
                    }
                    ,
                    vt.promisify = function(bt) {
                        return typeof bt == "string" || bt == null ? Promise.resolve(bt) : bt
                    }
                    ,
                    vt.deleteStorage = function(bt) {
                        this.storage.has(bt) && this.storage.delete(bt)
                    }
                    ,
                    (0,
                    _e.Z)(Tt, [{
                        key: "activedStorage",
                        get: function() {
                            return this.storage.get((0,
                            os.U2)(Jo.activedName))
                        }
                    }]),
                    Tt
                }(sy.N);
                function Yu(At, Tt, vt) {
                    var bt = At.slice();
                    return bt[20] = Tt[vt][0],
                    bt[21] = Tt[vt][1],
                    bt[23] = vt,
                    bt
                }
                function qu(At) {
                    var Tt;
                    return {
                        c: function() {
                            (Tt = (0,
                            it.bGB)("div")).textContent = "Empty",
                            (0,
                            it.Ljt)(Tt, "class", "vc-plugin-empty")
                        },
                        m: function(vt, bt) {
                            (0,
                            it.$Tr)(vt, Tt, bt)
                        },
                        p: it.ZTd,
                        d: function(vt) {
                            vt && (0,
                            it.ogt)(Tt)
                        }
                    }
                }
                function hm(At) {
                    var Tt, vt, bt, Rt, It, Bt = At[20] + "", Zt = At[5](At[21]) + "";
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.fLW)(Bt),
                            bt = (0,
                            it.DhX)(),
                            Rt = (0,
                            it.bGB)("div"),
                            It = (0,
                            it.fLW)(Zt),
                            (0,
                            it.Ljt)(Tt, "class", "vc-table-col"),
                            (0,
                            it.Ljt)(Rt, "class", "vc-table-col vc-table-col-2")
                        },
                        m: function(tn, dn) {
                            (0,
                            it.$Tr)(tn, Tt, dn),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.$Tr)(tn, bt, dn),
                            (0,
                            it.$Tr)(tn, Rt, dn),
                            (0,
                            it.R3I)(Rt, It)
                        },
                        p: function(tn, dn) {
                            1 & dn && Bt !== (Bt = tn[20] + "") && (0,
                            it.rTO)(vt, Bt),
                            1 & dn && Zt !== (Zt = tn[5](tn[21]) + "") && (0,
                            it.rTO)(It, Zt)
                        },
                        d: function(tn) {
                            tn && (0,
                            it.ogt)(Tt),
                            tn && (0,
                            it.ogt)(bt),
                            tn && (0,
                            it.ogt)(Rt)
                        }
                    }
                }
                function Zu(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt;
                    return {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            vt = (0,
                            it.bGB)("textarea"),
                            bt = (0,
                            it.DhX)(),
                            Rt = (0,
                            it.bGB)("div"),
                            It = (0,
                            it.bGB)("textarea"),
                            (0,
                            it.Ljt)(vt, "class", "vc-table-input"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-table-col"),
                            (0,
                            it.Ljt)(It, "class", "vc-table-input"),
                            (0,
                            it.Ljt)(Rt, "class", "vc-table-col vc-table-col-2")
                        },
                        m: function(tn, dn) {
                            (0,
                            it.$Tr)(tn, Tt, dn),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.BmG)(vt, At[2]),
                            (0,
                            it.$Tr)(tn, bt, dn),
                            (0,
                            it.$Tr)(tn, Rt, dn),
                            (0,
                            it.R3I)(Rt, It),
                            (0,
                            it.BmG)(It, At[3]),
                            Bt || (Zt = [(0,
                            it.oLt)(vt, "input", At[11]), (0,
                            it.oLt)(It, "input", At[12])],
                            Bt = !0)
                        },
                        p: function(tn, dn) {
                            4 & dn && (0,
                            it.BmG)(vt, tn[2]),
                            8 & dn && (0,
                            it.BmG)(It, tn[3])
                        },
                        d: function(tn) {
                            tn && (0,
                            it.ogt)(Tt),
                            tn && (0,
                            it.ogt)(bt),
                            tn && (0,
                            it.ogt)(Rt),
                            Bt = !1,
                            (0,
                            it.j7q)(Zt)
                        }
                    }
                }
                function d1(At) {
                    var Tt, vt, bt, Rt, It, Bt;
                    return (Tt = new or.Z({
                        props: {
                            name: "delete"
                        }
                    })).$on("click", function() {
                        return At[14](At[20])
                    }),
                    bt = new an({
                        props: {
                            content: [At[20], At[21]].join("=")
                        }
                    }),
                    (It = new or.Z({
                        props: {
                            name: "edit"
                        }
                    })).$on("click", function() {
                        return At[15](At[20], At[21], At[23])
                    }),
                    {
                        c: function() {
                            (0,
                            it.YCL)(Tt.$$.fragment),
                            vt = (0,
                            it.DhX)(),
                            (0,
                            it.YCL)(bt.$$.fragment),
                            Rt = (0,
                            it.DhX)(),
                            (0,
                            it.YCL)(It.$$.fragment)
                        },
                        m: function(Zt, tn) {
                            (0,
                            it.yef)(Tt, Zt, tn),
                            (0,
                            it.$Tr)(Zt, vt, tn),
                            (0,
                            it.yef)(bt, Zt, tn),
                            (0,
                            it.$Tr)(Zt, Rt, tn),
                            (0,
                            it.yef)(It, Zt, tn),
                            Bt = !0
                        },
                        p: function(Zt, tn) {
                            At = Zt;
                            var dn = {};
                            1 & tn && (dn.content = [At[20], At[21]].join("=")),
                            bt.$set(dn)
                        },
                        i: function(Zt) {
                            Bt || ((0,
                            it.Ui)(Tt.$$.fragment, Zt),
                            (0,
                            it.Ui)(bt.$$.fragment, Zt),
                            (0,
                            it.Ui)(It.$$.fragment, Zt),
                            Bt = !0)
                        },
                        o: function(Zt) {
                            (0,
                            it.etI)(Tt.$$.fragment, Zt),
                            (0,
                            it.etI)(bt.$$.fragment, Zt),
                            (0,
                            it.etI)(It.$$.fragment, Zt),
                            Bt = !1
                        },
                        d: function(Zt) {
                            (0,
                            it.vpE)(Tt, Zt),
                            Zt && (0,
                            it.ogt)(vt),
                            (0,
                            it.vpE)(bt, Zt),
                            Zt && (0,
                            it.ogt)(Rt),
                            (0,
                            it.vpE)(It, Zt)
                        }
                    }
                }
                function f1(At) {
                    var Tt, vt, bt, Rt;
                    return (Tt = new or.Z({
                        props: {
                            name: "cancel"
                        }
                    })).$on("click", At[9]),
                    (bt = new or.Z({
                        props: {
                            name: "done"
                        }
                    })).$on("click", function() {
                        return At[13](At[20])
                    }),
                    {
                        c: function() {
                            (0,
                            it.YCL)(Tt.$$.fragment),
                            vt = (0,
                            it.DhX)(),
                            (0,
                            it.YCL)(bt.$$.fragment)
                        },
                        m: function(It, Bt) {
                            (0,
                            it.yef)(Tt, It, Bt),
                            (0,
                            it.$Tr)(It, vt, Bt),
                            (0,
                            it.yef)(bt, It, Bt),
                            Rt = !0
                        },
                        p: function(It, Bt) {
                            At = It
                        },
                        i: function(It) {
                            Rt || ((0,
                            it.Ui)(Tt.$$.fragment, It),
                            (0,
                            it.Ui)(bt.$$.fragment, It),
                            Rt = !0)
                        },
                        o: function(It) {
                            (0,
                            it.etI)(Tt.$$.fragment, It),
                            (0,
                            it.etI)(bt.$$.fragment, It),
                            Rt = !1
                        },
                        d: function(It) {
                            (0,
                            it.vpE)(Tt, It),
                            It && (0,
                            it.ogt)(vt),
                            (0,
                            it.vpE)(bt, It)
                        }
                    }
                }
                function Sy(At) {
                    var Tt, vt, bt, Rt, It, Bt, Zt;
                    function tn(An, Nn) {
                        return An[1] === An[23] ? Zu : hm
                    }
                    var dn = tn(At)
                      , mn = dn(At)
                      , Sn = [f1, d1]
                      , yn = [];
                    function On(An, Nn) {
                        return An[1] === An[23] ? 0 : 1
                    }
                    return Rt = On(At),
                    It = yn[Rt] = Sn[Rt](At),
                    {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            mn.c(),
                            vt = (0,
                            it.DhX)(),
                            bt = (0,
                            it.bGB)("div"),
                            It.c(),
                            Bt = (0,
                            it.DhX)(),
                            (0,
                            it.Ljt)(bt, "class", "vc-table-col vc-table-col-1 vc-table-action"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-table-row")
                        },
                        m: function(An, Nn) {
                            (0,
                            it.$Tr)(An, Tt, Nn),
                            mn.m(Tt, null),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(Tt, bt),
                            yn[Rt].m(bt, null),
                            (0,
                            it.R3I)(Tt, Bt),
                            Zt = !0
                        },
                        p: function(An, Nn) {
                            dn === (dn = tn(An)) && mn ? mn.p(An, Nn) : (mn.d(1),
                            (mn = dn(An)) && (mn.c(),
                            mn.m(Tt, vt)));
                            var Fn = Rt;
                            (Rt = On(An)) === Fn ? yn[Rt].p(An, Nn) : ((0,
                            it.dvw)(),
                            (0,
                            it.etI)(yn[Fn], 1, 1, function() {
                                yn[Fn] = null
                            }),
                            (0,
                            it.gbL)(),
                            (It = yn[Rt]) ? It.p(An, Nn) : (It = yn[Rt] = Sn[Rt](An)).c(),
                            (0,
                            it.Ui)(It, 1),
                            It.m(bt, null))
                        },
                        i: function(An) {
                            Zt || ((0,
                            it.Ui)(It),
                            Zt = !0)
                        },
                        o: function(An) {
                            (0,
                            it.etI)(It),
                            Zt = !1
                        },
                        d: function(An) {
                            An && (0,
                            it.ogt)(Tt),
                            mn.d(),
                            yn[Rt].d()
                        }
                    }
                }
                function p1(At) {
                    for (var Tt, vt, bt, Rt, It = At[0], Bt = [], Zt = 0; Zt < It.length; Zt += 1)
                        Bt[Zt] = Sy(Yu(At, It, Zt));
                    var tn = function(mn) {
                        return (0,
                        it.etI)(Bt[mn], 1, 1, function() {
                            Bt[mn] = null
                        })
                    }
                      , dn = null;
                    return It.length || (dn = qu()),
                    {
                        c: function() {
                            Tt = (0,
                            it.bGB)("div"),
                            (vt = (0,
                            it.bGB)("div")).innerHTML = `<div class="vc-table-col">Key</div>
    <div class="vc-table-col vc-table-col-2">Value</div>
    <div class="vc-table-col vc-table-col-1 vc-table-action"></div>`,
                            bt = (0,
                            it.DhX)();
                            for (var mn = 0; mn < Bt.length; mn += 1)
                                Bt[mn].c();
                            dn && dn.c(),
                            (0,
                            it.Ljt)(vt, "class", "vc-table-row"),
                            (0,
                            it.Ljt)(Tt, "class", "vc-table")
                        },
                        m: function(mn, Sn) {
                            (0,
                            it.$Tr)(mn, Tt, Sn),
                            (0,
                            it.R3I)(Tt, vt),
                            (0,
                            it.R3I)(Tt, bt);
                            for (var yn = 0; yn < Bt.length; yn += 1)
                                Bt[yn].m(Tt, null);
                            dn && dn.m(Tt, null),
                            Rt = !0
                        },
                        p: function(mn, Sn) {
                            var yn = Sn[0];
                            if (1007 & yn) {
                                var On;
                                for (It = mn[0],
                                On = 0; On < It.length; On += 1) {
                                    var An = Yu(mn, It, On);
                                    Bt[On] ? (Bt[On].p(An, yn),
                                    (0,
                                    it.Ui)(Bt[On], 1)) : (Bt[On] = Sy(An),
                                    Bt[On].c(),
                                    (0,
                                    it.Ui)(Bt[On], 1),
                                    Bt[On].m(Tt, null))
                                }
                                for ((0,
                                it.dvw)(),
                                On = It.length; On < Bt.length; On += 1)
                                    tn(On);
                                (0,
                                it.gbL)(),
                                !It.length && dn ? dn.p(mn, yn) : It.length ? dn && (dn.d(1),
                                dn = null) : ((dn = qu()).c(),
                                dn.m(Tt, null))
                            }
                        },
                        i: function(mn) {
                            if (!Rt) {
                                for (var Sn = 0; Sn < It.length; Sn += 1)
                                    (0,
                                    it.Ui)(Bt[Sn]);
                                Rt = !0
                            }
                        },
                        o: function(mn) {
                            Bt = Bt.filter(Boolean);
                            for (var Sn = 0; Sn < Bt.length; Sn += 1)
                                (0,
                                it.etI)(Bt[Sn]);
                            Rt = !1
                        },
                        d: function(mn) {
                            mn && (0,
                            it.ogt)(Tt),
                            (0,
                            it.RMB)(Bt, mn),
                            dn && dn.d()
                        }
                    }
                }
                function h1(At, Tt, vt) {
                    var bt, Rt = this && this.__awaiter || function(Nn, Fn, Qn, er) {
                        return new (Qn || (Qn = Promise))(function(fr, Nr) {
                            function Rr(Gr) {
                                try {
                                    eo(er.next(Gr))
                                } catch (Ar) {
                                    Nr(Ar)
                                }
                            }
                            function _i(Gr) {
                                try {
                                    eo(er.throw(Gr))
                                } catch (Ar) {
                                    Nr(Ar)
                                }
                            }
                            function eo(Gr) {
                                var Ar;
                                Gr.done ? fr(Gr.value) : (Ar = Gr.value,
                                Ar instanceof Qn ? Ar : new Qn(function(Or) {
                                    Or(Ar)
                                }
                                )).then(Rr, _i)
                            }
                            eo((er = er.apply(Nn, Fn || [])).next())
                        }
                        )
                    }
                    , It = Ol.getSingleton(Ol, "VConsoleStorageModel"), Bt = Jo.updateTime;
                    (0,
                    it.FIv)(At, Bt, function(Nn) {
                        return vt(10, bt = Nn)
                    });
                    var Zt = []
                      , tn = -1
                      , dn = ""
                      , mn = ""
                      , Sn = function() {
                        vt(1, tn = -1),
                        vt(2, dn = ""),
                        vt(3, mn = "")
                    }
                      , yn = function(Nn) {
                        return Rt(void 0, void 0, void 0, Eo().mark(function Fn() {
                            return Eo().wrap(function(Qn) {
                                for (; ; )
                                    switch (Qn.prev = Qn.next) {
                                    case 0:
                                        return Qn.next = 2,
                                        It.removeItem(Nn);
                                    case 2:
                                    case "end":
                                        return Qn.stop()
                                    }
                            }, Fn)
                        }))
                    }
                      , On = function(Nn) {
                        return Rt(void 0, void 0, void 0, Eo().mark(function Fn() {
                            return Eo().wrap(function(Qn) {
                                for (; ; )
                                    switch (Qn.prev = Qn.next) {
                                    case 0:
                                        if (dn === Nn) {
                                            Qn.next = 3;
                                            break
                                        }
                                        return Qn.next = 3,
                                        It.removeItem(Nn);
                                    case 3:
                                        It.setItem(dn, mn),
                                        Sn();
                                    case 5:
                                    case "end":
                                        return Qn.stop()
                                    }
                            }, Fn)
                        }))
                    }
                      , An = function(Nn, Fn, Qn) {
                        return Rt(void 0, void 0, void 0, Eo().mark(function er() {
                            return Eo().wrap(function(fr) {
                                for (; ; )
                                    switch (fr.prev = fr.next) {
                                    case 0:
                                        vt(2, dn = Nn),
                                        vt(3, mn = Fn),
                                        vt(1, tn = Qn);
                                    case 3:
                                    case "end":
                                        return fr.stop()
                                    }
                            }, er)
                        }))
                    };
                    return At.$$.update = function() {
                        1024 & At.$$.dirty && bt && Rt(void 0, void 0, void 0, Eo().mark(function Nn() {
                            return Eo().wrap(function(Fn) {
                                for (; ; )
                                    switch (Fn.prev = Fn.next) {
                                    case 0:
                                        return Sn(),
                                        Fn.t0 = vt,
                                        Fn.next = 4,
                                        It.getEntries();
                                    case 4:
                                        Fn.t1 = Zt = Fn.sent,
                                        (0,
                                        Fn.t0)(0, Fn.t1);
                                    case 6:
                                    case "end":
                                        return Fn.stop()
                                    }
                            }, Nn)
                        }))
                    }
                    ,
                    [Zt, tn, dn, mn, Bt, function(Nn) {
                        return (0,
                        $.id)(Nn, 1024)
                    }
                    , yn, On, An, function() {
                        Sn()
                    }
                    , bt, function() {
                        dn = this.value,
                        vt(2, dn)
                    }
                    , function() {
                        mn = this.value,
                        vt(3, mn)
                    }
                    , function(Nn) {
                        return On(Nn)
                    }
                    , function(Nn) {
                        return yn(Nn)
                    }
                    , function(Nn, Fn, Qn) {
                        return An(Nn, Fn, Qn)
                    }
                    ]
                }
                var gm = function(At) {
                    function Tt(vt) {
                        var bt;
                        return bt = At.call(this) || this,
                        (0,
                        it.S1n)((0,
                        nt.Z)(bt), vt, h1, p1, it.N8, {}),
                        bt
                    }
                    return (0,
                    rt.Z)(Tt, At),
                    Tt
                }(it.f_C)
                  , $p = gm
                  , _0 = function(At) {
                    function Tt(bt, Rt, It) {
                        var Bt;
                        return It === void 0 && (It = {}),
                        (Bt = At.call(this, bt, Rt, $p, It) || this).model = Ol.getSingleton(Ol, "VConsoleStorageModel"),
                        Bt.onAddTopBarCallback = void 0,
                        Bt
                    }
                    (0,
                    rt.Z)(Tt, At);
                    var vt = Tt.prototype;
                    return vt.onReady = function() {
                        At.prototype.onReady.call(this),
                        this.onUpdateOption()
                    }
                    ,
                    vt.onShow = function() {
                        this.model.refresh()
                    }
                    ,
                    vt.onAddTopBar = function(bt) {
                        this.onAddTopBarCallback = bt,
                        this.updateTopBar()
                    }
                    ,
                    vt.onAddTool = function(bt) {
                        var Rt = this;
                        bt([{
                            name: "Add",
                            global: !1,
                            onClick: function() {
                                Rt.model.setItem("new_" + Date.now(), "new_value")
                            }
                        }, {
                            name: "Refresh",
                            global: !1,
                            onClick: function() {
                                Rt.model.refresh()
                            }
                        }, {
                            name: "Clear",
                            global: !1,
                            onClick: function() {
                                Rt.model.clear()
                            }
                        }])
                    }
                    ,
                    vt.onUpdateOption = function() {
                        var bt, Rt = (bt = this.vConsole.option.storage) == null ? void 0 : bt.defaultStorages;
                        (0,
                        $.kJ)(Rt) && (Rt = Rt.length > 0 ? Rt : ["cookies"]) !== (0,
                        os.U2)(Jo.defaultStorages) && (Jo.defaultStorages.set(Rt),
                        Jo.activedName.set(Rt[0]),
                        this.updateTopBar())
                    }
                    ,
                    vt.updateTopBar = function() {
                        var bt = this;
                        if (typeof this.onAddTopBarCallback == "function") {
                            for (var Rt = (0,
                            os.U2)(Jo.defaultStorages), It = [], Bt = 0; Bt < Rt.length; Bt++) {
                                var Zt = Rt[Bt];
                                It.push({
                                    name: Zt[0].toUpperCase() + Zt.substring(1),
                                    data: {
                                        name: Zt
                                    },
                                    actived: Zt === (0,
                                    os.U2)(Jo.activedName),
                                    onClick: function(tn, dn) {
                                        var mn = (0,
                                        os.U2)(Jo.activedName);
                                        if (dn.name === mn)
                                            return !1;
                                        Jo.activedName.set(dn.name),
                                        bt.model.refresh()
                                    }
                                })
                            }
                            this.onAddTopBarCallback(It)
                        }
                    }
                    ,
                    Tt
                }(Vn)
                  , pn = function() {
                    function At(vt) {
                        var bt = this;
                        if (this.version = "3.15.1",
                        this.isInited = !1,
                        this.option = {},
                        this.compInstance = void 0,
                        this.pluginList = {},
                        this.log = void 0,
                        this.system = void 0,
                        this.network = void 0,
                        At.instance && At.instance instanceof At)
                            return At.instance;
                        if (At.instance = this,
                        this.isInited = !1,
                        this.option = {
                            defaultPlugins: ["system", "network", "element", "storage"],
                            log: {},
                            network: {},
                            storage: {}
                        },
                        $.Kn(vt))
                            for (var Rt in vt)
                                this.option[Rt] = vt[Rt];
                        this.option.maxLogNumber !== void 0 && (this.option.log.maxLogNumber = this.option.maxLogNumber),
                        this.option.onClearLog,
                        this.option.maxNetworkNumber !== void 0 && (this.option.network.maxNetworkNumber = this.option.maxNetworkNumber),
                        this._addBuiltInPlugins();
                        var It = function() {
                            bt.isInited || (bt._initComponent(),
                            bt._autoRun())
                        };
                        if (document !== void 0)
                            document.readyState === "loading" ? tt.bind(window, "DOMContentLoaded", It) : It();
                        else {
                            var Bt;
                            Bt = setTimeout(function Zt() {
                                document && document.readyState == "complete" ? (Bt && clearTimeout(Bt),
                                It()) : Bt = setTimeout(Zt, 1)
                            }, 1)
                        }
                    }
                    var Tt = At.prototype;
                    return Tt._addBuiltInPlugins = function() {
                        this.addPlugin(new oy("default","Log"));
                        var vt = this.option.defaultPlugins
                          , bt = {
                            system: {
                                proto: Jp,
                                name: "System"
                            }
                        };
                        if (bt.network = {
                            proto: lm,
                            name: "Network"
                        },
                        bt.element = {
                            proto: m0,
                            name: "Element"
                        },
                        bt.storage = {
                            proto: _0,
                            name: "Storage"
                        },
                        vt && $.kJ(vt))
                            for (var Rt = 0; Rt < vt.length; Rt++) {
                                var It = bt[vt[Rt]];
                                It && this.addPlugin(new It.proto(vt[Rt],It.name))
                            }
                    }
                    ,
                    Tt._initComponent = function() {
                        var vt = this;
                        if (!tt.one("#__vconsole")) {
                            var bt, Rt = 1 * $.cF("switch_x"), It = 1 * $.cF("switch_y");
                            typeof this.option.target == "string" ? bt = document.querySelector(this.option.target) : this.option.target instanceof HTMLElement && (bt = this.option.target),
                            bt instanceof HTMLElement || (bt = document.documentElement),
                            this.compInstance = new wr({
                                target: bt,
                                props: {
                                    switchButtonPosition: {
                                        x: Rt,
                                        y: It
                                    }
                                }
                            }),
                            this.compInstance.$on("show", function(Bt) {
                                Bt.detail.show ? vt.show() : vt.hide()
                            }),
                            this.compInstance.$on("changePanel", function(Bt) {
                                var Zt = Bt.detail.pluginId;
                                vt.showPlugin(Zt)
                            })
                        }
                        this._updateComponentByOptions()
                    }
                    ,
                    Tt._updateComponentByOptions = function() {
                        if (this.compInstance) {
                            if (this.compInstance.theme !== this.option.theme) {
                                var vt = this.option.theme;
                                vt = vt !== "light" && vt !== "dark" ? "" : vt,
                                this.compInstance.theme = vt
                            }
                            this.compInstance.disableScrolling !== this.option.disableLogScrolling && (this.compInstance.disableScrolling = !!this.option.disableLogScrolling)
                        }
                    }
                    ,
                    Tt.setSwitchPosition = function(vt, bt) {
                        this.compInstance.switchButtonPosition = {
                            x: vt,
                            y: bt
                        }
                    }
                    ,
                    Tt._autoRun = function() {
                        for (var vt in this.isInited = !0,
                        this.pluginList)
                            this._initPlugin(this.pluginList[vt]);
                        this._showFirstPluginWhenEmpty(),
                        this.triggerEvent("ready")
                    }
                    ,
                    Tt._showFirstPluginWhenEmpty = function() {
                        var vt = Object.keys(this.pluginList);
                        this.compInstance.activedPluginId === "" && vt.length > 0 && this.showPlugin(vt[0])
                    }
                    ,
                    Tt.triggerEvent = function(vt, bt) {
                        var Rt = this;
                        vt = "on" + vt.charAt(0).toUpperCase() + vt.slice(1),
                        $.mf(this.option[vt]) && setTimeout(function() {
                            Rt.option[vt].apply(Rt, bt)
                        }, 0)
                    }
                    ,
                    Tt._initPlugin = function(vt) {
                        var bt = this;
                        vt.vConsole = this,
                        this.compInstance.pluginList[vt.id] = {
                            id: vt.id,
                            name: vt.name,
                            hasTabPanel: !1,
                            tabOptions: void 0,
                            topbarList: [],
                            toolbarList: [],
                            content: void 0,
                            contentContainer: void 0
                        },
                        this.compInstance.pluginList = this._reorderPluginList(this.compInstance.pluginList),
                        vt.trigger("init"),
                        vt.trigger("renderTab", function(Rt, It) {
                            It === void 0 && (It = {});
                            var Bt = bt.compInstance.pluginList[vt.id];
                            Bt.hasTabPanel = !0,
                            Bt.tabOptions = It,
                            Rt && (bt.compInstance.pluginList[vt.id].content = Rt),
                            bt.compInstance.pluginList = bt.compInstance.pluginList
                        }),
                        vt.trigger("addTopBar", function(Rt) {
                            if (Rt) {
                                for (var It = [], Bt = 0; Bt < Rt.length; Bt++) {
                                    var Zt = Rt[Bt];
                                    It.push({
                                        name: Zt.name || "Undefined",
                                        className: Zt.className || "",
                                        actived: !!Zt.actived,
                                        data: Zt.data,
                                        onClick: Zt.onClick
                                    })
                                }
                                bt.compInstance.pluginList[vt.id].topbarList = It,
                                bt.compInstance.pluginList = bt.compInstance.pluginList
                            }
                        }),
                        vt.trigger("addTool", function(Rt) {
                            if (Rt) {
                                for (var It = [], Bt = 0; Bt < Rt.length; Bt++) {
                                    var Zt = Rt[Bt];
                                    It.push({
                                        name: Zt.name || "Undefined",
                                        global: !!Zt.global,
                                        data: Zt.data,
                                        onClick: Zt.onClick
                                    })
                                }
                                bt.compInstance.pluginList[vt.id].toolbarList = It,
                                bt.compInstance.pluginList = bt.compInstance.pluginList
                            }
                        }),
                        vt.isReady = !0,
                        vt.trigger("ready")
                    }
                    ,
                    Tt._triggerPluginsEvent = function(vt) {
                        for (var bt in this.pluginList)
                            this.pluginList[bt].isReady && this.pluginList[bt].trigger(vt)
                    }
                    ,
                    Tt._triggerPluginEvent = function(vt, bt) {
                        var Rt = this.pluginList[vt];
                        Rt && Rt.isReady && Rt.trigger(bt)
                    }
                    ,
                    Tt._reorderPluginList = function(vt) {
                        var bt = this;
                        if (!$.kJ(this.option.pluginOrder))
                            return vt;
                        for (var Rt = Object.keys(vt).sort(function(Zt, tn) {
                            var dn = bt.option.pluginOrder.indexOf(Zt)
                              , mn = bt.option.pluginOrder.indexOf(tn);
                            return dn === mn ? 0 : dn === -1 ? 1 : mn === -1 ? -1 : dn - mn
                        }), It = {}, Bt = 0; Bt < Rt.length; Bt++)
                            It[Rt[Bt]] = vt[Rt[Bt]];
                        return It
                    }
                    ,
                    Tt.addPlugin = function(vt) {
                        return this.pluginList[vt.id] !== void 0 ? !1 : (this.pluginList[vt.id] = vt,
                        this.isInited && (this._initPlugin(vt),
                        this._showFirstPluginWhenEmpty()),
                        !0)
                    }
                    ,
                    Tt.removePlugin = function(vt) {
                        vt = (vt + "").toLowerCase();
                        var bt = this.pluginList[vt];
                        if (bt === void 0)
                            return !1;
                        bt.trigger("remove");
                        try {
                            delete this.pluginList[vt],
                            delete this.compInstance.pluginList[vt]
                        } catch {
                            this.pluginList[vt] = void 0,
                            this.compInstance.pluginList[vt] = void 0
                        }
                        return this.compInstance.pluginList = this.compInstance.pluginList,
                        this.compInstance.activedPluginId == vt && (this.compInstance.activedPluginId = "",
                        this._showFirstPluginWhenEmpty()),
                        !0
                    }
                    ,
                    Tt.show = function() {
                        this.isInited && (this.compInstance.show = !0,
                        this._triggerPluginsEvent("showConsole"))
                    }
                    ,
                    Tt.hide = function() {
                        this.isInited && (this.compInstance.show = !1,
                        this._triggerPluginsEvent("hideConsole"))
                    }
                    ,
                    Tt.showSwitch = function() {
                        this.isInited && (this.compInstance.showSwitchButton = !0)
                    }
                    ,
                    Tt.hideSwitch = function() {
                        this.isInited && (this.compInstance.showSwitchButton = !1)
                    }
                    ,
                    Tt.showPlugin = function(vt) {
                        this.isInited && (this.pluginList[vt],
                        this.compInstance.activedPluginId && this._triggerPluginEvent(this.compInstance.activedPluginId, "hide"),
                        this.compInstance.activedPluginId = vt,
                        this._triggerPluginEvent(this.compInstance.activedPluginId, "show"))
                    }
                    ,
                    Tt.setOption = function(vt, bt) {
                        if (typeof vt == "string") {
                            for (var Rt = vt.split("."), It = this.option, Bt = 0; Bt < Rt.length; Bt++) {
                                if (Rt[Bt] === "__proto__" || Rt[Bt] === "constructor" || Rt[Bt] === "prototype")
                                    return;
                                It[Rt[Bt]] === void 0 && (It[Rt[Bt]] = {}),
                                Bt === Rt.length - 1 && (It[Rt[Bt]] = bt),
                                It = It[Rt[Bt]]
                            }
                            this._triggerPluginsEvent("updateOption"),
                            this._updateComponentByOptions()
                        } else if ($.Kn(vt)) {
                            for (var Zt in vt)
                                Zt !== "__proto__" && Zt !== "constructor" && Zt !== "prototype" && (this.option[Zt] = vt[Zt]);
                            this._triggerPluginsEvent("updateOption"),
                            this._updateComponentByOptions()
                        }
                    }
                    ,
                    Tt.destroy = function() {
                        if (this.isInited) {
                            this.isInited = !1,
                            At.instance = void 0;
                            for (var vt = Object.keys(this.pluginList), bt = vt.length - 1; bt >= 0; bt--)
                                this.removePlugin(vt[bt]);
                            this.compInstance.$destroy()
                        }
                    }
                    ,
                    (0,
                    _e.Z)(At, null, [{
                        key: "instance",
                        get: function() {
                            return window.__VCONSOLE_INSTANCE
                        },
                        set: function(vt) {
                            (vt === void 0 || vt instanceof At) && (window.__VCONSOLE_INSTANCE = vt)
                        }
                    }]),
                    At
                }();
                pn.VConsolePlugin = void 0,
                pn.VConsoleLogPlugin = void 0,
                pn.VConsoleDefaultPlugin = void 0,
                pn.VConsoleSystemPlugin = void 0,
                pn.VConsoleNetworkPlugin = void 0,
                pn.VConsoleElementPlugin = void 0,
                pn.VConsoleStoragePlugin = void 0,
                pn.VConsolePlugin = Rn,
                pn.VConsoleLogPlugin = vp,
                pn.VConsoleDefaultPlugin = oy,
                pn.VConsoleSystemPlugin = Jp,
                pn.VConsoleNetworkPlugin = lm,
                pn.VConsoleElementPlugin = m0,
                pn.VConsoleStoragePlugin = _0;
                var Xu = pn
            }(),
            __webpack_exports__ = __webpack_exports__.default,
            __webpack_exports__
        }()
    })
}
)(vconsole_min);
var vconsole_minExports = vconsole_min.exports;
const VConsole = getDefaultExportFromCjs$2(vconsole_minExports);
function CookieConsent() {
    const [_e,$] = reactExports.useState(!1)
      , [et,tt] = reactExports.useState(!1)
      , [nt,rt] = reactExports.useState({
        necessary: !0,
        analytics: !1,
        preferences: !1
    });
    reactExports.useEffect( () => {
        const ct = localStorage.getItem("cookie-consent");
        ct ? rt(JSON.parse(ct)) : $(!0)
    }
    , []);
    const it = (ct, dt) => {
        dt !== "clickaway" && $(!1)
    }
      , ot = () => {
        localStorage.setItem("cookie-consent", JSON.stringify(nt)),
        $(!1)
    }
      , st = ct => dt => {
        rt(pt => ({
            ...pt,
            [ct]: dt.target.checked
        }))
    }
      , lt = () => {
        tt(!et)
    }
    ;
    return jsxRuntimeExports.jsx(Snackbar, {
        open: _e,
        onClose: it,
        anchorOrigin: {
            vertical: "bottom",
            horizontal: "right"
        },
        message: jsxRuntimeExports.jsxs(Box, {
            className: "p-4 relative",
            children: [jsxRuntimeExports.jsx(IconButton, {
                className: "absolute right-0 top-0",
                onClick: it,
                children: jsxRuntimeExports.jsx(CloseIcon$1, {})
            }), jsxRuntimeExports.jsxs(Typography, {
                variant: "body2",
                color: "text.secondary",
                children: [jsxRuntimeExports.jsx(Trans, {
                    id: "enzF69"
                }), " ", jsxRuntimeExports.jsxs(Typography, {
                    color: "primary",
                    className: "inline cursor-pointer",
                    variant: "inherit",
                    onClick: lt,
                    children: [jsxRuntimeExports.jsx(Trans, {
                        id: "UCytWe"
                    }), " ", jsxRuntimeExports.jsx(KeyboardArrowDown, {
                        className: ""
                    })]
                })]
            }), et ? jsxRuntimeExports.jsxs(FormGroup, {
                row: !0,
                children: [jsxRuntimeExports.jsx(FormControlLabel, {
                    control: jsxRuntimeExports.jsx(Checkbox, {
                        checked: nt.necessary
                    }),
                    disabled: !0,
                    label: jsxRuntimeExports.jsx(Box, {
                        children: jsxRuntimeExports.jsx(Typography, {
                            variant: "body2",
                            children: jsxRuntimeExports.jsx(Trans, {
                                id: "oa1EOh"
                            })
                        })
                    })
                }), jsxRuntimeExports.jsx(FormControlLabel, {
                    control: jsxRuntimeExports.jsx(Checkbox, {
                        checked: nt.analytics,
                        onChange: st("analytics")
                    }),
                    label: jsxRuntimeExports.jsx(Box, {
                        children: jsxRuntimeExports.jsx(Typography, {
                            variant: "body2",
                            children: jsxRuntimeExports.jsx(Trans, {
                                id: "ZlwDi6"
                            })
                        })
                    })
                }), jsxRuntimeExports.jsx(FormControlLabel, {
                    control: jsxRuntimeExports.jsx(Checkbox, {
                        checked: nt.preferences,
                        onChange: st("preferences")
                    }),
                    label: jsxRuntimeExports.jsx(Box, {
                        children: jsxRuntimeExports.jsx(Typography, {
                            variant: "body2",
                            children: jsxRuntimeExports.jsx(Trans, {
                                id: "Q6hhn8"
                            })
                        })
                    })
                })]
            }) : null, jsxRuntimeExports.jsxs(Box, {
                className: "flex justify-end space-x-2 pt-4",
                children: [jsxRuntimeExports.jsx(Button, {
                    variant: "contained",
                    onClick: ot,
                    children: jsxRuntimeExports.jsx(Trans, {
                        id: "g3UF2V"
                    })
                }), jsxRuntimeExports.jsx(Button, {
                    variant: "outlined",
                    onClick: () => {
                        localStorage.setItem("cookie-consent", JSON.stringify(nt)),
                        $(!1)
                    }
                    ,
                    children: jsxRuntimeExports.jsx(Trans, {
                        id: "jbq7j2"
                    })
                })]
            })]
        })
    })
}
const __variableDynamicImportRuntimeHelper = (_e, $, et) => {
    const tt = _e[$];
    return tt ? typeof tt == "function" ? tt() : Promise.resolve(tt) : new Promise( (nt, rt) => {
        (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(rt.bind(null, new Error("Unknown variable dynamic import: " + $ + ($.split("/").length !== et ? ". Note that variables only represent file names one level deep." : ""))))
    }
    )
}
  , messages = JSON.parse(`{"+02G0w":"Points Details","+1Atxj":"Bal:","+K0AvT":"Disconnect","+SkR9N":"New Pairs","+Xjyeo":"Select File","+zy2Nq":"Type","0/C9og":"My Invite Link","0M9qe5":"Maximum sell quantity exceeded","0P1P67":"Slippage Limit","0hnqsg":"Rewards:","1+P9RR":["Switch to ",["0"]],"29lDpG":"Slippage:","2ZHVqE":"Referring frens:","3A/mG4":"Change Wallet","3M7tJB":"Unrealized","3awOET":"Rank","4SBV0R":"No data yet","4fdEs1":"Quick Buy:","5N3b5J":"Market Cap","5Wrnud":"Sign in to super.exchange","6V3Ea3":"Copied","6YtxFj":"Name","6f8S68":"Markets","6g1gi0":"Proposals","6t9BXr":"Priority Fee","6wKvID":["Spend at least ",["MIN_SOL_AMOUNT"]," ",["0"]],"6wmbtv":"Generated 24 hours after your first transaction is completed.","7+ufxI":"Trading points","7LUjiG":"Setting your slippage too high may result in bots front-running your trades. we highly recommend turning on front-running protection if you have high slippage.","7VpPHA":"Confirm","7yIbX8":"Twitter Link","8Imc1c":"Earn Points via:","8LSwp6":"Max buy quantity exceeded","A/X5hS":"Receive:","A1taO8":"Search","AHWd74":"MARKETS","AUYALh":"Coming soon","CI4Km7":"Holders","CK1KXz":"Max","COUcFd":"Points","CZ3pZR":"Sell All","Cg2X6Z":"Wallet not installed","ClqQqg":"Buy:","CpsAmO":"Place Trade","CtByM7":"Connect Wallet","DHhJ7s":"Previous","DOs1d6":"Ticker is not found.","Das8FF":"My Points","Du6bPw":"Address","Dw7UPC":"User rejected the request.","E9bKSA":"Creating","EOFF1k":"Created:","Er3bpO":"Are you sure you want to sell all tokens?","FAJ5Zb":"Connect wallet to view","FJr2P0":"24h Vol.","FPgHom":["Buy at least ",["MIN_TOKEN_AMOUNT"]," ",["0"]],"FS77M5":"Vol.","FYzHRF":"Holding","FZNlvN":"Total PnL","Fzy03y":"24h Txns","Gmrxif":"Points to be distributed in next 5 minutes:","HKnBHK":"Invitation earned","HeQ9Wo":"Buyback & Burn","Hp1l6f":"Current","I+x669":"Invitees","IOKD63":"Trading earned","It08CM":"Invitation points:","J0FA8p":"Total Points Earned:","JR4eC8":"Not holding any coin yet.","JprMpt":"Change%","KkldRS":"Invitation Details","LDLtaV":"Receive 25% of the points earned by the invitees through transactions.","LK9M3g":"Ticker","LhMjLm":"Time","M6jFls":"Updates detected. Please refresh the page.","MDYeYg":"Sign message","MFKlMB":"Invite","MjRR28":"Current Market Cap:","OJ/YxQ":"More Options","OfhWJH":"Reset","On0aF2":"Website","OwztUC":"Fixed creation fee:","P+769u":"You receive:","PIRkiz":"Except for the ticker, all coin-related information can be changed by voting.","Q6hhn8":"Preferences","QvIt9E":"Confirm in your wallet","RCU5PY":"Age","RPXn8S":"Invitation code","Rj01Fz":"Links","S4uIAF":"The ticker already exists.","Tc+yvT":"Enable front-running protection","UCytWe":"Cookie settings","UbRKMZ":"Pending","UuSyre":"Insufficient SOL balance","VbTpsk":"Buying a small amount of coins helps protect your coin from snipers.","WJUXN9":"POINTS","X7Tf8q":"Show PnL","XCYJWe":"Share Your Earnings","Xka+yN":"Market Cap:","ZFtwlj":"Trades","ZLjj1p":"Hide small assets","ZVYlhZ":"Select an image","ZlwDi6":"Analytics","a6tsFM":"SUPER","a7u1N9":"Price","aM8Y3P":"Telegram Link","bl5skE":"Trading points:","cDHoAv":"Tokens Purchased:","cEAtfR":"$SUPER","cRysHb":"Trade high-performing tokens to earn the most points!","ctMW2b":"Buy & Burn","dEgA5A":"Cancel","dxNth1":"View transaction","dzzTA7":"Cost:","e1Tc2l":"Invitation Time","e93Bho":"50% of the platform's trading fees buy back and burn $SUPER in real-time.","einzuA":"Insufficient token balance","enzF69":"We use cookies to ensure that we give you the best experience on our website.","etLShk":"Submitting","fJ8xC3":"PRIO:","fsBGk0":"Balance","fwIqjq":"(Max: 0.2 SOL)","g3UF2V":"Accept","gvAbMv":"Create a new coin","hG89Ed":"Image","hYgDIe":"Create","hehnjM":"Amount","i20cQ+":"Burned","iSLIjg":"Connect","j+Og3c":"All tickers on uper exchange are unique.","jbh7F5":"Creation failed: User rejected the request.","jbq7j2":"Decline","kWJmRL":"You","kbumyM":"This is the maximum amount of slippage you are willing to accept when placing trades.","l8Oh9a":"Hold:","lCF0wC":"Refresh","lNg25t":"Connecting ...","lRmWzG":"Please add a Name","laXI/l":"This fee goes directly to miners as an incentive to prioritize your transaction.","m8PNnZ":"Points:","mXGEjA":"PORTFOLIO","mnjeqO":"Each Point grants the right to purchase 1 $SUPER","mtjKfB":"points","n0DQBh":"Maker","nk+Rnj":"Transaction sent","nkzPQC":"Current market cap","no7jaB":"Front-running protection stops bots from front-running your buys. You can use high slippage with front-running protection turned on. We recommend setting a priority fee of at least 0.01 SOL with front-running protection enabled.","ntS/9Y":"1h Vol.","nuBbBr":"Chart","oa1EOh":"Necessary","ouGG/I":"Insufficient Points Balance","pBWUNI":"Trading:","pLSc6a":"Search Ticker","pe2Eus":"Image exceeds the maximum limit of 5M","qTk7nN":"How many tokens do you want to buy?","qiOIiY":"Buy","qqwapW":"Show holdings","s+0J56":"Invite frens and get 25% of the trading points they earn.","u3QMKC":"Unique and unchangeable, supports numbers and letters within 10 characters.","uRvjFC":"Exceeds buyable quantity","uSOUk/":"Txns","uaAeJs":"Bought/Avg","urqLzE":"Net Tokens Purchased:","uwTTA0":"Redeem and purchase","v0bjTs":"Save Image","vwq6Of":"Total Points Redeemed:","w+7M8c":"Please add a ticker","wMHvYH":"Value","xNB0TS":"Sell","xksCLq":"Sold/Avg","yRfzEC":"File types supported: JPG, JEPG, PNG, GIF, WEBP. Max size: 5 MB.","yo4aLW":"No records available.","ytJ2WG":"Select your wallet","zXagFp":"Copy Address"}`)
  , messages$1 = Object.freeze(Object.defineProperty({
    __proto__: null,
    messages
}, Symbol.toStringTag, {
    value: "Module"
}));
async function dynamicActivate(_e=DEFAULT_LOCALE) {
    const {messages: $} = await __variableDynamicImportRuntimeHelper(Object.assign({
        "../locales/en/messages.po": () => __vitePreload( () => Promise.resolve().then( () => messages$1), void 0),
        "../locales/ja/messages.po": () => __vitePreload( () => import("./messages-Dw1at3jJ.js"), []),
        "../locales/ko/messages.po": () => __vitePreload( () => import("./messages-DDpuZLOS.js"), []),
        "../locales/zh-CN/messages.po": () => __vitePreload( () => import("./messages-CtpWTMmN.js"), []),
        "../locales/zh-HK/messages.po": () => __vitePreload( () => import("./messages-2iKvhvNP.js"), [])
    }), `../locales/${_e}/messages.po`, 4);
    i18n.load(_e, $),
    i18n.activate(_e)
}
const defaultComponent = ({children: _e}) => jsxRuntimeExports.jsx("span", {
    children: _e
});
function Provider({locale: _e, onActivate: $, children: et}) {
    return reactExports.useEffect( () => {
        dynamicActivate(_e).then( () => {
            $ == null || $(_e),
            i18n.activate(_e)
        }
        ).catch(tt => {}
        )
    }
    , [_e, $]),
    !i18n.locale && _e === DEFAULT_LOCALE && (i18n.load(DEFAULT_LOCALE, messages),
    i18n.activate(DEFAULT_LOCALE)),
    jsxRuntimeExports.jsx(I18nProvider, {
        i18n,
        defaultComponent,
        children: et
    })
}
function LanguageProvider({children: _e}) {
    const {activeLocale: $, setActiveLocale: et} = useStore$1()
      , tt = reactExports.useCallback(nt => {
        document.documentElement.setAttribute("lang", nt),
        et(nt)
    }
    , []);
    return jsxRuntimeExports.jsx(Provider, {
        locale: $,
        onActivate: tt,
        children: _e
    })
}
const client = new QueryClient;
function Updaters() {
    return jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, {})
}
function App() {
    const {theme: _e} = useStore$1()
      , {isVisibleMediaViewer: $} = useApplicationStore()
      , et = localStorage.getItem("cookie-consent")
      , {isMatchMobile: tt} = useAppBreakpoints();
    Env_Mode.DEV === "production" && tt && new VConsole,
    reactExports.useEffect( () => {
        changeThemeForHtml(_e)
    }
    , [_e]);
    const nt = reactExports.useMemo( () => getTheme(_e), [_e])
      , rt = createTheme(nt);
    return jsxRuntimeExports.jsx(ThemeProvider, {
        theme: rt,
        children: jsxRuntimeExports.jsx(LanguageProvider, {
            children: jsxRuntimeExports.jsxs(PricesContextProvider, {
                children: [jsxRuntimeExports.jsx(CssBaseline, {}), jsxRuntimeExports.jsx(QueryClientProvider, {
                    client,
                    children: jsxRuntimeExports.jsx(ClusterProvider, {
                        children: jsxRuntimeExports.jsxs(SolanaProvider, {
                            children: [jsxRuntimeExports.jsx(ErrorBoundary, {}), jsxRuntimeExports.jsx(Updaters, {}), jsxRuntimeExports.jsx(GlobalComponents, {}), jsxRuntimeExports.jsx(AppRoutes, {}), $ && jsxRuntimeExports.jsx(MediaFullScreenViewer, {}), et ? null : jsxRuntimeExports.jsx(CookieConsent, {})]
                        })
                    })
                })]
            })
        })
    })
}
var en = {
    exports: {}
};
(function(_e, $) {
    (function(et, tt) {
        _e.exports = tt()
    }
    )(commonjsGlobal$1, function() {
        return {
            name: "en",
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            ordinal: function(et) {
                var tt = ["th", "st", "nd", "rd"]
                  , nt = et % 100;
                return "[" + et + (tt[(nt - 20) % 10] || tt[nt] || tt[0]) + "]"
            }
        }
    })
}
)(en);
var duration$1 = {
    exports: {}
};
(function(_e, $) {
    (function(et, tt) {
        _e.exports = tt()
    }
    )(commonjsGlobal$1, function() {
        var et, tt, nt = 1e3, rt = 6e4, it = 36e5, ot = 864e5, st = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, lt = 31536e6, ct = 2628e6, dt = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, pt = {
            years: lt,
            months: ct,
            days: ot,
            hours: it,
            minutes: rt,
            seconds: nt,
            milliseconds: 1,
            weeks: 6048e5
        }, ht = function(Lt) {
            return Lt instanceof Ct
        }, mt = function(Lt, kt, Ut) {
            return new Ct(Lt,Ut,kt.$l)
        }, yt = function(Lt) {
            return tt.p(Lt) + "s"
        }, Et = function(Lt) {
            return Lt < 0
        }, _t = function(Lt) {
            return Et(Lt) ? Math.ceil(Lt) : Math.floor(Lt)
        }, wt = function(Lt) {
            return Math.abs(Lt)
        }, St = function(Lt, kt) {
            return Lt ? Et(Lt) ? {
                negative: !0,
                format: "" + wt(Lt) + kt
            } : {
                negative: !1,
                format: "" + Lt + kt
            } : {
                negative: !1,
                format: ""
            }
        }, Ct = function() {
            function Lt(Ut, Jt, Pt) {
                var Xt = this;
                if (this.$d = {},
                this.$l = Pt,
                Ut === void 0 && (this.$ms = 0,
                this.parseFromMilliseconds()),
                Jt)
                    return mt(Ut * pt[yt(Jt)], this);
                if (typeof Ut == "number")
                    return this.$ms = Ut,
                    this.parseFromMilliseconds(),
                    this;
                if (typeof Ut == "object")
                    return Object.keys(Ut).forEach(function(xt) {
                        Xt.$d[yt(xt)] = Ut[xt]
                    }),
                    this.calMilliseconds(),
                    this;
                if (typeof Ut == "string") {
                    var rn = Ut.match(dt);
                    if (rn) {
                        var zt = rn.slice(2).map(function(xt) {
                            return xt != null ? Number(xt) : 0
                        });
                        return this.$d.years = zt[0],
                        this.$d.months = zt[1],
                        this.$d.weeks = zt[2],
                        this.$d.days = zt[3],
                        this.$d.hours = zt[4],
                        this.$d.minutes = zt[5],
                        this.$d.seconds = zt[6],
                        this.calMilliseconds(),
                        this
                    }
                }
                return this
            }
            var kt = Lt.prototype;
            return kt.calMilliseconds = function() {
                var Ut = this;
                this.$ms = Object.keys(this.$d).reduce(function(Jt, Pt) {
                    return Jt + (Ut.$d[Pt] || 0) * pt[Pt]
                }, 0)
            }
            ,
            kt.parseFromMilliseconds = function() {
                var Ut = this.$ms;
                this.$d.years = _t(Ut / lt),
                Ut %= lt,
                this.$d.months = _t(Ut / ct),
                Ut %= ct,
                this.$d.days = _t(Ut / ot),
                Ut %= ot,
                this.$d.hours = _t(Ut / it),
                Ut %= it,
                this.$d.minutes = _t(Ut / rt),
                Ut %= rt,
                this.$d.seconds = _t(Ut / nt),
                Ut %= nt,
                this.$d.milliseconds = Ut
            }
            ,
            kt.toISOString = function() {
                var Ut = St(this.$d.years, "Y")
                  , Jt = St(this.$d.months, "M")
                  , Pt = +this.$d.days || 0;
                this.$d.weeks && (Pt += 7 * this.$d.weeks);
                var Xt = St(Pt, "D")
                  , rn = St(this.$d.hours, "H")
                  , zt = St(this.$d.minutes, "M")
                  , xt = this.$d.seconds || 0;
                this.$d.milliseconds && (xt += this.$d.milliseconds / 1e3,
                xt = Math.round(1e3 * xt) / 1e3);
                var $t = St(xt, "S")
                  , Dt = Ut.negative || Jt.negative || Xt.negative || rn.negative || zt.negative || $t.negative
                  , jt = rn.format || zt.format || $t.format ? "T" : ""
                  , Ft = (Dt ? "-" : "") + "P" + Ut.format + Jt.format + Xt.format + jt + rn.format + zt.format + $t.format;
                return Ft === "P" || Ft === "-P" ? "P0D" : Ft
            }
            ,
            kt.toJSON = function() {
                return this.toISOString()
            }
            ,
            kt.format = function(Ut) {
                var Jt = Ut || "YYYY-MM-DDTHH:mm:ss"
                  , Pt = {
                    Y: this.$d.years,
                    YY: tt.s(this.$d.years, 2, "0"),
                    YYYY: tt.s(this.$d.years, 4, "0"),
                    M: this.$d.months,
                    MM: tt.s(this.$d.months, 2, "0"),
                    D: this.$d.days,
                    DD: tt.s(this.$d.days, 2, "0"),
                    H: this.$d.hours,
                    HH: tt.s(this.$d.hours, 2, "0"),
                    m: this.$d.minutes,
                    mm: tt.s(this.$d.minutes, 2, "0"),
                    s: this.$d.seconds,
                    ss: tt.s(this.$d.seconds, 2, "0"),
                    SSS: tt.s(this.$d.milliseconds, 3, "0")
                };
                return Jt.replace(st, function(Xt, rn) {
                    return rn || String(Pt[Xt])
                })
            }
            ,
            kt.as = function(Ut) {
                return this.$ms / pt[yt(Ut)]
            }
            ,
            kt.get = function(Ut) {
                var Jt = this.$ms
                  , Pt = yt(Ut);
                return Pt === "milliseconds" ? Jt %= 1e3 : Jt = Pt === "weeks" ? _t(Jt / pt[Pt]) : this.$d[Pt],
                Jt || 0
            }
            ,
            kt.add = function(Ut, Jt, Pt) {
                var Xt;
                return Xt = Jt ? Ut * pt[yt(Jt)] : ht(Ut) ? Ut.$ms : mt(Ut, this).$ms,
                mt(this.$ms + Xt * (Pt ? -1 : 1), this)
            }
            ,
            kt.subtract = function(Ut, Jt) {
                return this.add(Ut, Jt, !0)
            }
            ,
            kt.locale = function(Ut) {
                var Jt = this.clone();
                return Jt.$l = Ut,
                Jt
            }
            ,
            kt.clone = function() {
                return mt(this.$ms, this)
            }
            ,
            kt.humanize = function(Ut) {
                return et().add(this.$ms, "ms").locale(this.$l).fromNow(!Ut)
            }
            ,
            kt.valueOf = function() {
                return this.asMilliseconds()
            }
            ,
            kt.milliseconds = function() {
                return this.get("milliseconds")
            }
            ,
            kt.asMilliseconds = function() {
                return this.as("milliseconds")
            }
            ,
            kt.seconds = function() {
                return this.get("seconds")
            }
            ,
            kt.asSeconds = function() {
                return this.as("seconds")
            }
            ,
            kt.minutes = function() {
                return this.get("minutes")
            }
            ,
            kt.asMinutes = function() {
                return this.as("minutes")
            }
            ,
            kt.hours = function() {
                return this.get("hours")
            }
            ,
            kt.asHours = function() {
                return this.as("hours")
            }
            ,
            kt.days = function() {
                return this.get("days")
            }
            ,
            kt.asDays = function() {
                return this.as("days")
            }
            ,
            kt.weeks = function() {
                return this.get("weeks")
            }
            ,
            kt.asWeeks = function() {
                return this.as("weeks")
            }
            ,
            kt.months = function() {
                return this.get("months")
            }
            ,
            kt.asMonths = function() {
                return this.as("months")
            }
            ,
            kt.years = function() {
                return this.get("years")
            }
            ,
            kt.asYears = function() {
                return this.as("years")
            }
            ,
            Lt
        }(), Nt = function(Lt, kt, Ut) {
            return Lt.add(kt.years() * Ut, "y").add(kt.months() * Ut, "M").add(kt.days() * Ut, "d").add(kt.hours() * Ut, "h").add(kt.minutes() * Ut, "m").add(kt.seconds() * Ut, "s").add(kt.milliseconds() * Ut, "ms")
        };
        return function(Lt, kt, Ut) {
            et = Ut,
            tt = Ut().$utils(),
            Ut.duration = function(Xt, rn) {
                var zt = Ut.locale();
                return mt(Xt, {
                    $l: zt
                }, rn)
            }
            ,
            Ut.isDuration = ht;
            var Jt = kt.prototype.add
              , Pt = kt.prototype.subtract;
            kt.prototype.add = function(Xt, rn) {
                return ht(Xt) ? Nt(this, Xt, 1) : Jt.bind(this)(Xt, rn)
            }
            ,
            kt.prototype.subtract = function(Xt, rn) {
                return ht(Xt) ? Nt(this, Xt, -1) : Pt.bind(this)(Xt, rn)
            }
        }
    })
}
)(duration$1);
var durationExports = duration$1.exports;
const duration = getDefaultExportFromCjs$2(durationExports);
var relativeTime$1 = {
    exports: {}
};
(function(_e, $) {
    (function(et, tt) {
        _e.exports = tt()
    }
    )(commonjsGlobal$1, function() {
        return function(et, tt, nt) {
            et = et || {};
            var rt = tt.prototype
              , it = {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            };
            function ot(lt, ct, dt, pt) {
                return rt.fromToBase(lt, ct, dt, pt)
            }
            nt.en.relativeTime = it,
            rt.fromToBase = function(lt, ct, dt, pt, ht) {
                for (var mt, yt, Et, _t = dt.$locale().relativeTime || it, wt = et.thresholds || [{
                    l: "s",
                    r: 44,
                    d: "second"
                }, {
                    l: "m",
                    r: 89
                }, {
                    l: "mm",
                    r: 44,
                    d: "minute"
                }, {
                    l: "h",
                    r: 89
                }, {
                    l: "hh",
                    r: 21,
                    d: "hour"
                }, {
                    l: "d",
                    r: 35
                }, {
                    l: "dd",
                    r: 25,
                    d: "day"
                }, {
                    l: "M",
                    r: 45
                }, {
                    l: "MM",
                    r: 10,
                    d: "month"
                }, {
                    l: "y",
                    r: 17
                }, {
                    l: "yy",
                    d: "year"
                }], St = wt.length, Ct = 0; Ct < St; Ct += 1) {
                    var Nt = wt[Ct];
                    Nt.d && (mt = pt ? nt(lt).diff(dt, Nt.d, !0) : dt.diff(lt, Nt.d, !0));
                    var Lt = (et.rounding || Math.round)(Math.abs(mt));
                    if (Et = mt > 0,
                    Lt <= Nt.r || !Nt.r) {
                        Lt <= 1 && Ct > 0 && (Nt = wt[Ct - 1]);
                        var kt = _t[Nt.l];
                        ht && (Lt = ht("" + Lt)),
                        yt = typeof kt == "string" ? kt.replace("%d", Lt) : kt(Lt, ct, Nt.l, Et);
                        break
                    }
                }
                if (ct)
                    return yt;
                var Ut = Et ? _t.future : _t.past;
                return typeof Ut == "function" ? Ut(yt) : Ut.replace("%s", yt)
            }
            ,
            rt.to = function(lt, ct) {
                return ot(lt, ct, this, !0)
            }
            ,
            rt.from = function(lt, ct) {
                return ot(lt, ct, this)
            }
            ;
            var st = function(lt) {
                return lt.$u ? nt.utc() : nt()
            };
            rt.toNow = function(lt) {
                return this.to(st(this), lt)
            }
            ,
            rt.fromNow = function(lt) {
                return this.from(st(this), lt)
            }
        }
    })
}
)(relativeTime$1);
var relativeTimeExports = relativeTime$1.exports;
const relativeTime = getDefaultExportFromCjs$2(relativeTimeExports);
var updateLocale$1 = {
    exports: {}
};
(function(_e, $) {
    (function(et, tt) {
        _e.exports = tt()
    }
    )(commonjsGlobal$1, function() {
        return function(et, tt, nt) {
            nt.updateLocale = function(rt, it) {
                var ot = nt.Ls[rt];
                if (ot)
                    return (it ? Object.keys(it) : []).forEach(function(st) {
                        ot[st] = it[st]
                    }),
                    ot
            }
        }
    })
}
)(updateLocale$1);
var updateLocaleExports = updateLocale$1.exports;
const updateLocale = getDefaultExportFromCjs$2(updateLocaleExports);
var utc$1 = {
    exports: {}
};
(function(_e, $) {
    (function(et, tt) {
        _e.exports = tt()
    }
    )(commonjsGlobal$1, function() {
        var et = "minute"
          , tt = /[+-]\d\d(?::?\d\d)?/g
          , nt = /([+-]|\d\d)/g;
        return function(rt, it, ot) {
            var st = it.prototype;
            ot.utc = function(yt) {
                var Et = {
                    date: yt,
                    utc: !0,
                    args: arguments
                };
                return new it(Et)
            }
            ,
            st.utc = function(yt) {
                var Et = ot(this.toDate(), {
                    locale: this.$L,
                    utc: !0
                });
                return yt ? Et.add(this.utcOffset(), et) : Et
            }
            ,
            st.local = function() {
                return ot(this.toDate(), {
                    locale: this.$L,
                    utc: !1
                })
            }
            ;
            var lt = st.parse;
            st.parse = function(yt) {
                yt.utc && (this.$u = !0),
                this.$utils().u(yt.$offset) || (this.$offset = yt.$offset),
                lt.call(this, yt)
            }
            ;
            var ct = st.init;
            st.init = function() {
                if (this.$u) {
                    var yt = this.$d;
                    this.$y = yt.getUTCFullYear(),
                    this.$M = yt.getUTCMonth(),
                    this.$D = yt.getUTCDate(),
                    this.$W = yt.getUTCDay(),
                    this.$H = yt.getUTCHours(),
                    this.$m = yt.getUTCMinutes(),
                    this.$s = yt.getUTCSeconds(),
                    this.$ms = yt.getUTCMilliseconds()
                } else
                    ct.call(this)
            }
            ;
            var dt = st.utcOffset;
            st.utcOffset = function(yt, Et) {
                var _t = this.$utils().u;
                if (_t(yt))
                    return this.$u ? 0 : _t(this.$offset) ? dt.call(this) : this.$offset;
                if (typeof yt == "string" && (yt = function(Nt) {
                    Nt === void 0 && (Nt = "");
                    var Lt = Nt.match(tt);
                    if (!Lt)
                        return null;
                    var kt = ("" + Lt[0]).match(nt) || ["-", 0, 0]
                      , Ut = kt[0]
                      , Jt = 60 * +kt[1] + +kt[2];
                    return Jt === 0 ? 0 : Ut === "+" ? Jt : -Jt
                }(yt),
                yt === null))
                    return this;
                var wt = Math.abs(yt) <= 16 ? 60 * yt : yt
                  , St = this;
                if (Et)
                    return St.$offset = wt,
                    St.$u = yt === 0,
                    St;
                if (yt !== 0) {
                    var Ct = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset();
                    (St = this.local().add(wt + Ct, et)).$offset = wt,
                    St.$x.$localOffset = Ct
                } else
                    St = this.utc();
                return St
            }
            ;
            var pt = st.format;
            st.format = function(yt) {
                var Et = yt || (this.$u ? "YYYY-MM-DDTHH:mm:ss[Z]" : "");
                return pt.call(this, Et)
            }
            ,
            st.valueOf = function() {
                var yt = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset());
                return this.$d.valueOf() - 6e4 * yt
            }
            ,
            st.isUTC = function() {
                return !!this.$u
            }
            ,
            st.toISOString = function() {
                return this.toDate().toISOString()
            }
            ,
            st.toString = function() {
                return this.toDate().toUTCString()
            }
            ;
            var ht = st.toDate;
            st.toDate = function(yt) {
                return yt === "s" && this.$offset ? ot(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : ht.call(this)
            }
            ;
            var mt = st.diff;
            st.diff = function(yt, Et, _t) {
                if (yt && this.$u === yt.$u)
                    return mt.call(this, yt, Et, _t);
                var wt = this.local()
                  , St = ot(yt).local();
                return mt.call(wt, St, Et, _t)
            }
        }
    })
}
)(utc$1);
var utcExports = utc$1.exports;
const utc = getDefaultExportFromCjs$2(utcExports);
var timezone$1 = {
    exports: {}
};
(function(_e, $) {
    (function(et, tt) {
        _e.exports = tt()
    }
    )(commonjsGlobal$1, function() {
        var et = {
            year: 0,
            month: 1,
            day: 2,
            hour: 3,
            minute: 4,
            second: 5
        }
          , tt = {};
        return function(nt, rt, it) {
            var ot, st = function(pt, ht, mt) {
                mt === void 0 && (mt = {});
                var yt = new Date(pt)
                  , Et = function(_t, wt) {
                    wt === void 0 && (wt = {});
                    var St = wt.timeZoneName || "short"
                      , Ct = _t + "|" + St
                      , Nt = tt[Ct];
                    return Nt || (Nt = new Intl.DateTimeFormat("en-US",{
                        hour12: !1,
                        timeZone: _t,
                        year: "numeric",
                        month: "2-digit",
                        day: "2-digit",
                        hour: "2-digit",
                        minute: "2-digit",
                        second: "2-digit",
                        timeZoneName: St
                    }),
                    tt[Ct] = Nt),
                    Nt
                }(ht, mt);
                return Et.formatToParts(yt)
            }, lt = function(pt, ht) {
                for (var mt = st(pt, ht), yt = [], Et = 0; Et < mt.length; Et += 1) {
                    var _t = mt[Et]
                      , wt = _t.type
                      , St = _t.value
                      , Ct = et[wt];
                    Ct >= 0 && (yt[Ct] = parseInt(St, 10))
                }
                var Nt = yt[3]
                  , Lt = Nt === 24 ? 0 : Nt
                  , kt = yt[0] + "-" + yt[1] + "-" + yt[2] + " " + Lt + ":" + yt[4] + ":" + yt[5] + ":000"
                  , Ut = +pt;
                return (it.utc(kt).valueOf() - (Ut -= Ut % 1e3)) / 6e4
            }, ct = rt.prototype;
            ct.tz = function(pt, ht) {
                pt === void 0 && (pt = ot);
                var mt, yt = this.utcOffset(), Et = this.toDate(), _t = Et.toLocaleString("en-US", {
                    timeZone: pt
                }), wt = Math.round((Et - new Date(_t)) / 1e3 / 60), St = 15 * -Math.round(Et.getTimezoneOffset() / 15) - wt;
                if (!Number(St))
                    mt = this.utcOffset(0, ht);
                else if (mt = it(_t, {
                    locale: this.$L
                }).$set("millisecond", this.$ms).utcOffset(St, !0),
                ht) {
                    var Ct = mt.utcOffset();
                    mt = mt.add(yt - Ct, "minute")
                }
                return mt.$x.$timezone = pt,
                mt
            }
            ,
            ct.offsetName = function(pt) {
                var ht = this.$x.$timezone || it.tz.guess()
                  , mt = st(this.valueOf(), ht, {
                    timeZoneName: pt
                }).find(function(yt) {
                    return yt.type.toLowerCase() === "timezonename"
                });
                return mt && mt.value
            }
            ;
            var dt = ct.startOf;
            ct.startOf = function(pt, ht) {
                if (!this.$x || !this.$x.$timezone)
                    return dt.call(this, pt, ht);
                var mt = it(this.format("YYYY-MM-DD HH:mm:ss:SSS"), {
                    locale: this.$L
                });
                return dt.call(mt, pt, ht).tz(this.$x.$timezone, !0)
            }
            ,
            it.tz = function(pt, ht, mt) {
                var yt = mt && ht
                  , Et = mt || ht || ot
                  , _t = lt(+it(), Et);
                if (typeof pt != "string")
                    return it(pt).tz(Et);
                var wt = function(Lt, kt, Ut) {
                    var Jt = Lt - 60 * kt * 1e3
                      , Pt = lt(Jt, Ut);
                    if (kt === Pt)
                        return [Jt, kt];
                    var Xt = lt(Jt -= 60 * (Pt - kt) * 1e3, Ut);
                    return Pt === Xt ? [Jt, Pt] : [Lt - 60 * Math.min(Pt, Xt) * 1e3, Math.max(Pt, Xt)]
                }(it.utc(pt, yt).valueOf(), _t, Et)
                  , St = wt[0]
                  , Ct = wt[1]
                  , Nt = it(St).utcOffset(Ct);
                return Nt.$x.$timezone = Et,
                Nt
            }
            ,
            it.tz.guess = function() {
                return Intl.DateTimeFormat().resolvedOptions().timeZone
            }
            ,
            it.tz.setDefault = function(pt) {
                ot = pt
            }
        }
    })
}
)(timezone$1);
var timezoneExports = timezone$1.exports;
const timezone = getDefaultExportFromCjs$2(timezoneExports)
  , useStore = create$1()(persist(_e => ({
    slippage: "3.5",
    setSlippage: $ => _e(et => ({
        slippage: $ || "0"
    })),
    solPrice: "",
    setSolPrice: $ => _e(et => (store$2.set(STORAGE_KEY_SOL, $),
    {
        solPrice: $
    })),
    quickValue: "0.1",
    setQuickValue: $ => _e({
        quickValue: $
    }),
    tickersSort: {
        sort_by: Tiker_Sorted_By.MARKET_CAP,
        direction: Sort_Direction.DESC
    },
    newTickersSort: {
        sort_by: Tiker_Sorted_By.INITIALIZE_AT,
        direction: Sort_Direction.DESC
    },
    setTickerSortBy: ($, et) => _e(tt => et === Market_Type.Markets ? {
        tickersSort: {
            ...tt.tickersSort,
            sort_by: $
        }
    } : {
        newTickersSort: {
            ...tt.newTickersSort,
            sort_by: $
        }
    }),
    seTickerSortDirection: ($, et) => _e(tt => et === Market_Type.Markets ? {
        tickersSort: {
            ...tt.tickersSort,
            direction: $
        }
    } : {
        newTickersSort: {
            ...tt.newTickersSort,
            direction: $
        }
    })
}), {
    name: "settings"
}));
function Updater() {
    const {setSolPrice: _e} = useStore()
      , {data: $} = globalEthPriceUsd(null);
    return reactExports.useEffect( () => {
        $ && _e($.data.price)
    }
    , [$]),
    null
}
var zhHk = {
    exports: {}
};
(function(_e, $) {
    (function(et, tt) {
        _e.exports = tt(dayjs_minExports)
    }
    )(commonjsGlobal$1, function(et) {
        function tt(it) {
            return it && typeof it == "object" && "default"in it ? it : {
                default: it
            }
        }
        var nt = tt(et)
          , rt = {
            name: "zh-hk",
            months: "___________".split("_"),
            monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            ordinal: function(it, ot) {
                return ot === "W" ? it + "" : it + ""
            },
            formats: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY/MM/DD",
                LL: "YYYYMD",
                LLL: "YYYYMD HH:mm",
                LLLL: "YYYYMDdddd HH:mm",
                l: "YYYY/M/D",
                ll: "YYYYMD",
                lll: "YYYYMD HH:mm",
                llll: "YYYYMDdddd HH:mm"
            },
            relativeTime: {
                future: "%s",
                past: "%s",
                s: "",
                m: "",
                mm: "%d ",
                h: "",
                hh: "%d ",
                d: "",
                dd: "%d ",
                M: "",
                MM: "%d ",
                y: "",
                yy: "%d "
            },
            meridiem: function(it, ot) {
                var st = 100 * it + ot;
                return st < 600 ? "" : st < 900 ? "" : st < 1100 ? "" : st < 1300 ? "" : st < 1800 ? "" : ""
            }
        };
        return nt.default.locale(rt, null, !0),
        rt
    })
}
)(zhHk);
var zhCn = {
    exports: {}
};
(function(_e, $) {
    (function(et, tt) {
        _e.exports = tt(dayjs_minExports)
    }
    )(commonjsGlobal$1, function(et) {
        function tt(it) {
            return it && typeof it == "object" && "default"in it ? it : {
                default: it
            }
        }
        var nt = tt(et)
          , rt = {
            name: "zh-cn",
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            months: "___________".split("_"),
            monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            ordinal: function(it, ot) {
                return ot === "W" ? it + "" : it + ""
            },
            weekStart: 1,
            yearStart: 4,
            formats: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY/MM/DD",
                LL: "YYYYMD",
                LLL: "YYYYMDAhmm",
                LLLL: "YYYYMDddddAhmm",
                l: "YYYY/M/D",
                ll: "YYYYMD",
                lll: "YYYYMD HH:mm",
                llll: "YYYYMDdddd HH:mm"
            },
            relativeTime: {
                future: "%s",
                past: "%s",
                s: "",
                m: "1 ",
                mm: "%d ",
                h: "1 ",
                hh: "%d ",
                d: "1 ",
                dd: "%d ",
                M: "1 ",
                MM: "%d ",
                y: "1 ",
                yy: "%d "
            },
            meridiem: function(it, ot) {
                var st = 100 * it + ot;
                return st < 600 ? "" : st < 900 ? "" : st < 1100 ? "" : st < 1300 ? "" : st < 1800 ? "" : ""
            }
        };
        return nt.default.locale(rt, null, !0),
        rt
    })
}
)(zhCn);
var ko = {
    exports: {}
};
(function(_e, $) {
    (function(et, tt) {
        _e.exports = tt(dayjs_minExports)
    }
    )(commonjsGlobal$1, function(et) {
        function tt(it) {
            return it && typeof it == "object" && "default"in it ? it : {
                default: it
            }
        }
        var nt = tt(et)
          , rt = {
            name: "ko",
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            ordinal: function(it) {
                return it + ""
            },
            formats: {
                LT: "A h:mm",
                LTS: "A h:mm:ss",
                L: "YYYY.MM.DD.",
                LL: "YYYY MMMM D",
                LLL: "YYYY MMMM D A h:mm",
                LLLL: "YYYY MMMM D dddd A h:mm",
                l: "YYYY.MM.DD.",
                ll: "YYYY MMMM D",
                lll: "YYYY MMMM D A h:mm",
                llll: "YYYY MMMM D dddd A h:mm"
            },
            meridiem: function(it) {
                return it < 12 ? "" : ""
            },
            relativeTime: {
                future: "%s ",
                past: "%s ",
                s: " ",
                m: "1",
                mm: "%d",
                h: " ",
                hh: "%d",
                d: "",
                dd: "%d",
                M: " ",
                MM: "%d",
                y: " ",
                yy: "%d"
            }
        };
        return nt.default.locale(rt, null, !0),
        rt
    })
}
)(ko);
var ja = {
    exports: {}
};
(function(_e, $) {
    (function(et, tt) {
        _e.exports = tt(dayjs_minExports)
    }
    )(commonjsGlobal$1, function(et) {
        function tt(it) {
            return it && typeof it == "object" && "default"in it ? it : {
                default: it
            }
        }
        var nt = tt(et)
          , rt = {
            name: "ja",
            weekdays: "______".split("_"),
            weekdaysShort: "______".split("_"),
            weekdaysMin: "______".split("_"),
            months: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            monthsShort: "1_2_3_4_5_6_7_8_9_10_11_12".split("_"),
            ordinal: function(it) {
                return it + ""
            },
            formats: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY/MM/DD",
                LL: "YYYYMD",
                LLL: "YYYYMD HH:mm",
                LLLL: "YYYYMD dddd HH:mm",
                l: "YYYY/MM/DD",
                ll: "YYYYMD",
                lll: "YYYYMD HH:mm",
                llll: "YYYYMD(ddd) HH:mm"
            },
            meridiem: function(it) {
                return it < 12 ? "" : ""
            },
            relativeTime: {
                future: "%s",
                past: "%s",
                s: "",
                m: "1",
                mm: "%d",
                h: "1",
                hh: "%d",
                d: "1",
                dd: "%d",
                M: "1",
                MM: "%d",
                y: "1",
                yy: "%d"
            }
        };
        return nt.default.locale(rt, null, !0),
        rt
    })
}
)(ja);
const DEBUG_BUILD$3 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
  , GLOBAL_OBJ = globalThis
  , DEBUG_BUILD$2 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
  , SDK_VERSION = "9.2.0";
function getMainCarrier() {
    return getSentryCarrier(GLOBAL_OBJ),
    GLOBAL_OBJ
}
function getSentryCarrier(_e) {
    const $ = _e.__SENTRY__ = _e.__SENTRY__ || {};
    return $.version = $.version || SDK_VERSION,
    $[SDK_VERSION] = $[SDK_VERSION] || {}
}
function getGlobalSingleton(_e, $, et=GLOBAL_OBJ) {
    const tt = et.__SENTRY__ = et.__SENTRY__ || {}
      , nt = tt[SDK_VERSION] = tt[SDK_VERSION] || {};
    return nt[_e] || (nt[_e] = $())
}
const PREFIX = "Sentry Logger "
  , CONSOLE_LEVELS = ["debug", "info", "warn", "error", "log", "assert", "trace"]
  , originalConsoleMethods = {};
function consoleSandbox(_e) {
    if (!("console"in GLOBAL_OBJ))
        return _e();
    const $ = GLOBAL_OBJ.console
      , et = {}
      , tt = Object.keys(originalConsoleMethods);
    tt.forEach(nt => {
        const rt = originalConsoleMethods[nt];
        et[nt] = $[nt],
        $[nt] = rt
    }
    );
    try {
        return _e()
    } finally {
        tt.forEach(nt => {
            $[nt] = et[nt]
        }
        )
    }
}
function makeLogger() {
    let _e = !1;
    const $ = {
        enable: () => {
            _e = !0
        }
        ,
        disable: () => {
            _e = !1
        }
        ,
        isEnabled: () => _e
    };
    return DEBUG_BUILD$2 ? CONSOLE_LEVELS.forEach(et => {
        $[et] = (...tt) => {
            _e && consoleSandbox( () => {
                GLOBAL_OBJ.console[et](`${PREFIX}[${et}]:`, ...tt)
            }
            )
        }
    }
    ) : CONSOLE_LEVELS.forEach(et => {
        $[et] = () => {}
    }
    ),
    $
}
const logger = getGlobalSingleton("logger", makeLogger)
  , STACKTRACE_FRAME_LIMIT = 50
  , UNKNOWN_FUNCTION = "?"
  , WEBPACK_ERROR_REGEXP = /\(error: (.*)\)/
  , STRIP_FRAME_REGEXP = /captureMessage|captureException/;
function createStackParser(..._e) {
    const $ = _e.sort( (et, tt) => et[0] - tt[0]).map(et => et[1]);
    return (et, tt=0, nt=0) => {
        const rt = []
          , it = et.split(`
`);
        for (let ot = tt; ot < it.length; ot++) {
            const st = it[ot];
            if (st.length > 1024)
                continue;
            const lt = WEBPACK_ERROR_REGEXP.test(st) ? st.replace(WEBPACK_ERROR_REGEXP, "$1") : st;
            if (!lt.match(/\S*Error: /)) {
                for (const ct of $) {
                    const dt = ct(lt);
                    if (dt) {
                        rt.push(dt);
                        break
                    }
                }
                if (rt.length >= STACKTRACE_FRAME_LIMIT + nt)
                    break
            }
        }
        return stripSentryFramesAndReverse(rt.slice(nt))
    }
}
function stackParserFromStackParserOptions(_e) {
    return Array.isArray(_e) ? createStackParser(..._e) : _e
}
function stripSentryFramesAndReverse(_e) {
    if (!_e.length)
        return [];
    const $ = Array.from(_e);
    return /sentryWrapped/.test(getLastStackFrame($).function || "") && $.pop(),
    $.reverse(),
    STRIP_FRAME_REGEXP.test(getLastStackFrame($).function || "") && ($.pop(),
    STRIP_FRAME_REGEXP.test(getLastStackFrame($).function || "") && $.pop()),
    $.slice(0, STACKTRACE_FRAME_LIMIT).map(et => ({
        ...et,
        filename: et.filename || getLastStackFrame($).filename,
        function: et.function || UNKNOWN_FUNCTION
    }))
}
function getLastStackFrame(_e) {
    return _e[_e.length - 1] || {}
}
const defaultFunctionName = "<anonymous>";
function getFunctionName(_e) {
    try {
        return !_e || typeof _e != "function" ? defaultFunctionName : _e.name || defaultFunctionName
    } catch {
        return defaultFunctionName
    }
}
function getFramesFromEvent(_e) {
    const $ = _e.exception;
    if ($) {
        const et = [];
        try {
            return $.values.forEach(tt => {
                tt.stacktrace.frames && et.push(...tt.stacktrace.frames)
            }
            ),
            et
        } catch {
            return
        }
    }
}
const handlers = {}
  , instrumented = {};
function addHandler(_e, $) {
    handlers[_e] = handlers[_e] || [],
    handlers[_e].push($)
}
function maybeInstrument(_e, $) {
    if (!instrumented[_e]) {
        instrumented[_e] = !0;
        try {
            $()
        } catch (et) {
            DEBUG_BUILD$2 && logger.error(`Error while instrumenting ${_e}`, et)
        }
    }
}
function triggerHandlers(_e, $) {
    const et = _e && handlers[_e];
    if (et)
        for (const tt of et)
            try {
                tt($)
            } catch (nt) {
                DEBUG_BUILD$2 && logger.error(`Error while triggering instrumentation handler.
Type: ${_e}
Name: ${getFunctionName(tt)}
Error:`, nt)
            }
}
let _oldOnErrorHandler = null;
function addGlobalErrorInstrumentationHandler(_e) {
    const $ = "error";
    addHandler($, _e),
    maybeInstrument($, instrumentError)
}
function instrumentError() {
    _oldOnErrorHandler = GLOBAL_OBJ.onerror,
    GLOBAL_OBJ.onerror = function(_e, $, et, tt, nt) {
        return triggerHandlers("error", {
            column: tt,
            error: nt,
            line: et,
            msg: _e,
            url: $
        }),
        _oldOnErrorHandler ? _oldOnErrorHandler.apply(this, arguments) : !1
    }
    ,
    GLOBAL_OBJ.onerror.__SENTRY_INSTRUMENTED__ = !0
}
let _oldOnUnhandledRejectionHandler = null;
function addGlobalUnhandledRejectionInstrumentationHandler(_e) {
    const $ = "unhandledrejection";
    addHandler($, _e),
    maybeInstrument($, instrumentUnhandledRejection)
}
function instrumentUnhandledRejection() {
    _oldOnUnhandledRejectionHandler = GLOBAL_OBJ.onunhandledrejection,
    GLOBAL_OBJ.onunhandledrejection = function(_e) {
        return triggerHandlers("unhandledrejection", _e),
        _oldOnUnhandledRejectionHandler ? _oldOnUnhandledRejectionHandler.apply(this, arguments) : !0
    }
    ,
    GLOBAL_OBJ.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0
}
const objectToString = Object.prototype.toString;
function isError(_e) {
    switch (objectToString.call(_e)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
    case "[object WebAssembly.Exception]":
        return !0;
    default:
        return isInstanceOf(_e, Error)
    }
}
function isBuiltin(_e, $) {
    return objectToString.call(_e) === `[object ${$}]`
}
function isErrorEvent$1(_e) {
    return isBuiltin(_e, "ErrorEvent")
}
function isDOMError(_e) {
    return isBuiltin(_e, "DOMError")
}
function isDOMException(_e) {
    return isBuiltin(_e, "DOMException")
}
function isString(_e) {
    return isBuiltin(_e, "String")
}
function isParameterizedString(_e) {
    return typeof _e == "object" && _e !== null && "__sentry_template_string__"in _e && "__sentry_template_values__"in _e
}
function isPrimitive(_e) {
    return _e === null || isParameterizedString(_e) || typeof _e != "object" && typeof _e != "function"
}
function isPlainObject(_e) {
    return isBuiltin(_e, "Object")
}
function isEvent(_e) {
    return typeof Event < "u" && isInstanceOf(_e, Event)
}
function isElement(_e) {
    return typeof Element < "u" && isInstanceOf(_e, Element)
}
function isRegExp(_e) {
    return isBuiltin(_e, "RegExp")
}
function isThenable(_e) {
    return !!(_e != null && _e.then && typeof _e.then == "function")
}
function isSyntheticEvent(_e) {
    return isPlainObject(_e) && "nativeEvent"in _e && "preventDefault"in _e && "stopPropagation"in _e
}
function isInstanceOf(_e, $) {
    try {
        return _e instanceof $
    } catch {
        return !1
    }
}
function isVueViewModel(_e) {
    return !!(typeof _e == "object" && _e !== null && (_e.__isVue || _e._isVue))
}
const WINDOW$3 = GLOBAL_OBJ
  , DEFAULT_MAX_STRING_LENGTH = 80;
function htmlTreeAsString(_e, $={}) {
    if (!_e)
        return "<unknown>";
    try {
        let et = _e;
        const tt = 5
          , nt = [];
        let rt = 0
          , it = 0;
        const ot = " > "
          , st = ot.length;
        let lt;
        const ct = Array.isArray($) ? $ : $.keyAttrs
          , dt = !Array.isArray($) && $.maxStringLength || DEFAULT_MAX_STRING_LENGTH;
        for (; et && rt++ < tt && (lt = _htmlElementAsString(et, ct),
        !(lt === "html" || rt > 1 && it + nt.length * st + lt.length >= dt)); )
            nt.push(lt),
            it += lt.length,
            et = et.parentNode;
        return nt.reverse().join(ot)
    } catch {
        return "<unknown>"
    }
}
function _htmlElementAsString(_e, $) {
    const et = _e
      , tt = [];
    if (!(et != null && et.tagName))
        return "";
    if (WINDOW$3.HTMLElement && et instanceof HTMLElement && et.dataset) {
        if (et.dataset.sentryComponent)
            return et.dataset.sentryComponent;
        if (et.dataset.sentryElement)
            return et.dataset.sentryElement
    }
    tt.push(et.tagName.toLowerCase());
    const nt = $ != null && $.length ? $.filter(it => et.getAttribute(it)).map(it => [it, et.getAttribute(it)]) : null;
    if (nt != null && nt.length)
        nt.forEach(it => {
            tt.push(`[${it[0]}="${it[1]}"]`)
        }
        );
    else {
        et.id && tt.push(`#${et.id}`);
        const it = et.className;
        if (it && isString(it)) {
            const ot = it.split(/\s+/);
            for (const st of ot)
                tt.push(`.${st}`)
        }
    }
    const rt = ["aria-label", "type", "name", "title", "alt"];
    for (const it of rt) {
        const ot = et.getAttribute(it);
        ot && tt.push(`[${it}="${ot}"]`)
    }
    return tt.join("")
}
function getLocationHref() {
    try {
        return WINDOW$3.document.location.href
    } catch {
        return ""
    }
}
function getComponentName(_e) {
    if (!WINDOW$3.HTMLElement)
        return null;
    let $ = _e;
    const et = 5;
    for (let tt = 0; tt < et; tt++) {
        if (!$)
            return null;
        if ($ instanceof HTMLElement) {
            if ($.dataset.sentryComponent)
                return $.dataset.sentryComponent;
            if ($.dataset.sentryElement)
                return $.dataset.sentryElement
        }
        $ = $.parentNode
    }
    return null
}
function truncate(_e, $=0) {
    return typeof _e != "string" || $ === 0 || _e.length <= $ ? _e : `${_e.slice(0, $)}...`
}
function safeJoin(_e, $) {
    if (!Array.isArray(_e))
        return "";
    const et = [];
    for (let tt = 0; tt < _e.length; tt++) {
        const nt = _e[tt];
        try {
            isVueViewModel(nt) ? et.push("[VueViewModel]") : et.push(String(nt))
        } catch {
            et.push("[value cannot be serialized]")
        }
    }
    return et.join($)
}
function isMatchingPattern(_e, $, et=!1) {
    return isString(_e) ? isRegExp($) ? $.test(_e) : isString($) ? et ? _e === $ : _e.includes($) : !1 : !1
}
function stringMatchesSomePattern(_e, $=[], et=!1) {
    return $.some(tt => isMatchingPattern(_e, tt, et))
}
function fill(_e, $, et) {
    if (!($ in _e))
        return;
    const tt = _e[$]
      , nt = et(tt);
    typeof nt == "function" && markFunctionWrapped(nt, tt);
    try {
        _e[$] = nt
    } catch {
        DEBUG_BUILD$2 && logger.log(`Failed to replace method "${$}" in object`, _e)
    }
}
function addNonEnumerableProperty(_e, $, et) {
    try {
        Object.defineProperty(_e, $, {
            value: et,
            writable: !0,
            configurable: !0
        })
    } catch {
        DEBUG_BUILD$2 && logger.log(`Failed to add non-enumerable property "${$}" to object`, _e)
    }
}
function markFunctionWrapped(_e, $) {
    try {
        const et = $.prototype || {};
        _e.prototype = $.prototype = et,
        addNonEnumerableProperty(_e, "__sentry_original__", $)
    } catch {}
}
function getOriginalFunction(_e) {
    return _e.__sentry_original__
}
function convertToPlainObject(_e) {
    if (isError(_e))
        return {
            message: _e.message,
            name: _e.name,
            stack: _e.stack,
            ...getOwnProperties(_e)
        };
    if (isEvent(_e)) {
        const $ = {
            type: _e.type,
            target: serializeEventTarget(_e.target),
            currentTarget: serializeEventTarget(_e.currentTarget),
            ...getOwnProperties(_e)
        };
        return typeof CustomEvent < "u" && isInstanceOf(_e, CustomEvent) && ($.detail = _e.detail),
        $
    } else
        return _e
}
function serializeEventTarget(_e) {
    try {
        return isElement(_e) ? htmlTreeAsString(_e) : Object.prototype.toString.call(_e)
    } catch {
        return "<unknown>"
    }
}
function getOwnProperties(_e) {
    if (typeof _e == "object" && _e !== null) {
        const $ = {};
        for (const et in _e)
            Object.prototype.hasOwnProperty.call(_e, et) && ($[et] = _e[et]);
        return $
    } else
        return {}
}
function extractExceptionKeysForMessage(_e, $=40) {
    const et = Object.keys(convertToPlainObject(_e));
    et.sort();
    const tt = et[0];
    if (!tt)
        return "[object has no keys]";
    if (tt.length >= $)
        return truncate(tt, $);
    for (let nt = et.length; nt > 0; nt--) {
        const rt = et.slice(0, nt).join(", ");
        if (!(rt.length > $))
            return nt === et.length ? rt : truncate(rt, $)
    }
    return ""
}
function dropUndefinedKeys(_e) {
    return _dropUndefinedKeys(_e, new Map)
}
function _dropUndefinedKeys(_e, $) {
    if (isPojo(_e)) {
        const et = $.get(_e);
        if (et !== void 0)
            return et;
        const tt = {};
        $.set(_e, tt);
        for (const nt of Object.getOwnPropertyNames(_e))
            typeof _e[nt] < "u" && (tt[nt] = _dropUndefinedKeys(_e[nt], $));
        return tt
    }
    if (Array.isArray(_e)) {
        const et = $.get(_e);
        if (et !== void 0)
            return et;
        const tt = [];
        return $.set(_e, tt),
        _e.forEach(nt => {
            tt.push(_dropUndefinedKeys(nt, $))
        }
        ),
        tt
    }
    return _e
}
function isPojo(_e) {
    if (!isPlainObject(_e))
        return !1;
    try {
        const $ = Object.getPrototypeOf(_e).constructor.name;
        return !$ || $ === "Object"
    } catch {
        return !0
    }
}
const ONE_SECOND_IN_MS = 1e3;
function dateTimestampInSeconds() {
    return Date.now() / ONE_SECOND_IN_MS
}
function createUnixTimestampInSecondsFunc() {
    const {performance: _e} = GLOBAL_OBJ;
    if (!(_e != null && _e.now))
        return dateTimestampInSeconds;
    const $ = Date.now() - _e.now()
      , et = _e.timeOrigin == null ? $ : _e.timeOrigin;
    return () => (et + _e.now()) / ONE_SECOND_IN_MS
}
const timestampInSeconds = createUnixTimestampInSecondsFunc();
function uuid4() {
    const _e = GLOBAL_OBJ
      , $ = _e.crypto || _e.msCrypto;
    let et = () => Math.random() * 16;
    try {
        if ($ != null && $.randomUUID)
            return $.randomUUID().replace(/-/g, "");
        $ != null && $.getRandomValues && (et = () => {
            const tt = new Uint8Array(1);
            return $.getRandomValues(tt),
            tt[0]
        }
        )
    } catch {}
    return ("10000000100040008000" + 1e11).replace(/[018]/g, tt => (tt ^ (et() & 15) >> tt / 4).toString(16))
}
function getFirstException(_e) {
    var $, et;
    return (et = ($ = _e.exception) == null ? void 0 : $.values) == null ? void 0 : et[0]
}
function getEventDescription(_e) {
    const {message: $, event_id: et} = _e;
    if ($)
        return $;
    const tt = getFirstException(_e);
    return tt ? tt.type && tt.value ? `${tt.type}: ${tt.value}` : tt.type || tt.value || et || "<unknown>" : et || "<unknown>"
}
function addExceptionTypeValue(_e, $, et) {
    const tt = _e.exception = _e.exception || {}
      , nt = tt.values = tt.values || []
      , rt = nt[0] = nt[0] || {};
    rt.value || (rt.value = $ || ""),
    rt.type || (rt.type = "Error")
}
function addExceptionMechanism(_e, $) {
    const et = getFirstException(_e);
    if (!et)
        return;
    const tt = {
        type: "generic",
        handled: !0
    }
      , nt = et.mechanism;
    if (et.mechanism = {
        ...tt,
        ...nt,
        ...$
    },
    $ && "data"in $) {
        const rt = {
            ...nt == null ? void 0 : nt.data,
            ...$.data
        };
        et.mechanism.data = rt
    }
}
function checkOrSetAlreadyCaught(_e) {
    if (isAlreadyCaptured(_e))
        return !0;
    try {
        addNonEnumerableProperty(_e, "__sentry_captured__", !0)
    } catch {}
    return !1
}
function isAlreadyCaptured(_e) {
    try {
        return _e.__sentry_captured__
    } catch {}
}
var States;
(function(_e) {
    _e[_e.PENDING = 0] = "PENDING";
    const et = 1;
    _e[_e.RESOLVED = et] = "RESOLVED";
    const tt = 2;
    _e[_e.REJECTED = tt] = "REJECTED"
}
)(States || (States = {}));
function resolvedSyncPromise(_e) {
    return new SyncPromise($ => {
        $(_e)
    }
    )
}
function rejectedSyncPromise(_e) {
    return new SyncPromise( ($, et) => {
        et(_e)
    }
    )
}
class SyncPromise {
    constructor($) {
        this._state = States.PENDING,
        this._handlers = [],
        this._runExecutor($)
    }
    then($, et) {
        return new SyncPromise( (tt, nt) => {
            this._handlers.push([!1, rt => {
                if (!$)
                    tt(rt);
                else
                    try {
                        tt($(rt))
                    } catch (it) {
                        nt(it)
                    }
            }
            , rt => {
                if (!et)
                    nt(rt);
                else
                    try {
                        tt(et(rt))
                    } catch (it) {
                        nt(it)
                    }
            }
            ]),
            this._executeHandlers()
        }
        )
    }
    catch($) {
        return this.then(et => et, $)
    }
    finally($) {
        return new SyncPromise( (et, tt) => {
            let nt, rt;
            return this.then(it => {
                rt = !1,
                nt = it,
                $ && $()
            }
            , it => {
                rt = !0,
                nt = it,
                $ && $()
            }
            ).then( () => {
                if (rt) {
                    tt(nt);
                    return
                }
                et(nt)
            }
            )
        }
        )
    }
    _executeHandlers() {
        if (this._state === States.PENDING)
            return;
        const $ = this._handlers.slice();
        this._handlers = [],
        $.forEach(et => {
            et[0] || (this._state === States.RESOLVED && et[1](this._value),
            this._state === States.REJECTED && et[2](this._value),
            et[0] = !0)
        }
        )
    }
    _runExecutor($) {
        const et = (rt, it) => {
            if (this._state === States.PENDING) {
                if (isThenable(it)) {
                    it.then(tt, nt);
                    return
                }
                this._state = rt,
                this._value = it,
                this._executeHandlers()
            }
        }
          , tt = rt => {
            et(States.RESOLVED, rt)
        }
          , nt = rt => {
            et(States.REJECTED, rt)
        }
        ;
        try {
            $(tt, nt)
        } catch (rt) {
            nt(rt)
        }
    }
}
function makeSession(_e) {
    const $ = timestampInSeconds()
      , et = {
        sid: uuid4(),
        init: !0,
        timestamp: $,
        started: $,
        duration: 0,
        status: "ok",
        errors: 0,
        ignoreDuration: !1,
        toJSON: () => sessionToJSON(et)
    };
    return _e && updateSession(et, _e),
    et
}
function updateSession(_e, $={}) {
    if ($.user && (!_e.ipAddress && $.user.ip_address && (_e.ipAddress = $.user.ip_address),
    !_e.did && !$.did && (_e.did = $.user.id || $.user.email || $.user.username)),
    _e.timestamp = $.timestamp || timestampInSeconds(),
    $.abnormal_mechanism && (_e.abnormal_mechanism = $.abnormal_mechanism),
    $.ignoreDuration && (_e.ignoreDuration = $.ignoreDuration),
    $.sid && (_e.sid = $.sid.length === 32 ? $.sid : uuid4()),
    $.init !== void 0 && (_e.init = $.init),
    !_e.did && $.did && (_e.did = `${$.did}`),
    typeof $.started == "number" && (_e.started = $.started),
    _e.ignoreDuration)
        _e.duration = void 0;
    else if (typeof $.duration == "number")
        _e.duration = $.duration;
    else {
        const et = _e.timestamp - _e.started;
        _e.duration = et >= 0 ? et : 0
    }
    $.release && (_e.release = $.release),
    $.environment && (_e.environment = $.environment),
    !_e.ipAddress && $.ipAddress && (_e.ipAddress = $.ipAddress),
    !_e.userAgent && $.userAgent && (_e.userAgent = $.userAgent),
    typeof $.errors == "number" && (_e.errors = $.errors),
    $.status && (_e.status = $.status)
}
function closeSession(_e, $) {
    let et = {};
    _e.status === "ok" && (et = {
        status: "exited"
    }),
    updateSession(_e, et)
}
function sessionToJSON(_e) {
    return dropUndefinedKeys({
        sid: `${_e.sid}`,
        init: _e.init,
        started: new Date(_e.started * 1e3).toISOString(),
        timestamp: new Date(_e.timestamp * 1e3).toISOString(),
        status: _e.status,
        errors: _e.errors,
        did: typeof _e.did == "number" || typeof _e.did == "string" ? `${_e.did}` : void 0,
        duration: _e.duration,
        abnormal_mechanism: _e.abnormal_mechanism,
        attrs: {
            release: _e.release,
            environment: _e.environment,
            ip_address: _e.ipAddress,
            user_agent: _e.userAgent
        }
    })
}
function generateTraceId() {
    return uuid4()
}
function generateSpanId() {
    return uuid4().substring(16)
}
function merge(_e, $, et=2) {
    if (!$ || typeof $ != "object" || et <= 0)
        return $;
    if (_e && Object.keys($).length === 0)
        return _e;
    const tt = {
        ..._e
    };
    for (const nt in $)
        Object.prototype.hasOwnProperty.call($, nt) && (tt[nt] = merge(tt[nt], $[nt], et - 1));
    return tt
}
const SCOPE_SPAN_FIELD = "_sentrySpan";
function _setSpanForScope(_e, $) {
    $ ? addNonEnumerableProperty(_e, SCOPE_SPAN_FIELD, $) : delete _e[SCOPE_SPAN_FIELD]
}
function _getSpanForScope(_e) {
    return _e[SCOPE_SPAN_FIELD]
}
const DEFAULT_MAX_BREADCRUMBS = 100;
class Scope {
    constructor() {
        this._notifyingListeners = !1,
        this._scopeListeners = [],
        this._eventProcessors = [],
        this._breadcrumbs = [],
        this._attachments = [],
        this._user = {},
        this._tags = {},
        this._extra = {},
        this._contexts = {},
        this._sdkProcessingMetadata = {},
        this._propagationContext = {
            traceId: generateTraceId(),
            sampleRand: Math.random()
        }
    }
    clone() {
        const $ = new Scope;
        return $._breadcrumbs = [...this._breadcrumbs],
        $._tags = {
            ...this._tags
        },
        $._extra = {
            ...this._extra
        },
        $._contexts = {
            ...this._contexts
        },
        this._contexts.flags && ($._contexts.flags = {
            values: [...this._contexts.flags.values]
        }),
        $._user = this._user,
        $._level = this._level,
        $._session = this._session,
        $._transactionName = this._transactionName,
        $._fingerprint = this._fingerprint,
        $._eventProcessors = [...this._eventProcessors],
        $._attachments = [...this._attachments],
        $._sdkProcessingMetadata = {
            ...this._sdkProcessingMetadata
        },
        $._propagationContext = {
            ...this._propagationContext
        },
        $._client = this._client,
        $._lastEventId = this._lastEventId,
        _setSpanForScope($, _getSpanForScope(this)),
        $
    }
    setClient($) {
        this._client = $
    }
    setLastEventId($) {
        this._lastEventId = $
    }
    getClient() {
        return this._client
    }
    lastEventId() {
        return this._lastEventId
    }
    addScopeListener($) {
        this._scopeListeners.push($)
    }
    addEventProcessor($) {
        return this._eventProcessors.push($),
        this
    }
    setUser($) {
        return this._user = $ || {
            email: void 0,
            id: void 0,
            ip_address: void 0,
            username: void 0
        },
        this._session && updateSession(this._session, {
            user: $
        }),
        this._notifyScopeListeners(),
        this
    }
    getUser() {
        return this._user
    }
    setTags($) {
        return this._tags = {
            ...this._tags,
            ...$
        },
        this._notifyScopeListeners(),
        this
    }
    setTag($, et) {
        return this._tags = {
            ...this._tags,
            [$]: et
        },
        this._notifyScopeListeners(),
        this
    }
    setExtras($) {
        return this._extra = {
            ...this._extra,
            ...$
        },
        this._notifyScopeListeners(),
        this
    }
    setExtra($, et) {
        return this._extra = {
            ...this._extra,
            [$]: et
        },
        this._notifyScopeListeners(),
        this
    }
    setFingerprint($) {
        return this._fingerprint = $,
        this._notifyScopeListeners(),
        this
    }
    setLevel($) {
        return this._level = $,
        this._notifyScopeListeners(),
        this
    }
    setTransactionName($) {
        return this._transactionName = $,
        this._notifyScopeListeners(),
        this
    }
    setContext($, et) {
        return et === null ? delete this._contexts[$] : this._contexts[$] = et,
        this._notifyScopeListeners(),
        this
    }
    setSession($) {
        return $ ? this._session = $ : delete this._session,
        this._notifyScopeListeners(),
        this
    }
    getSession() {
        return this._session
    }
    update($) {
        if (!$)
            return this;
        const et = typeof $ == "function" ? $(this) : $
          , tt = et instanceof Scope ? et.getScopeData() : isPlainObject(et) ? $ : void 0
          , {tags: nt, extra: rt, user: it, contexts: ot, level: st, fingerprint: lt=[], propagationContext: ct} = tt || {};
        return this._tags = {
            ...this._tags,
            ...nt
        },
        this._extra = {
            ...this._extra,
            ...rt
        },
        this._contexts = {
            ...this._contexts,
            ...ot
        },
        it && Object.keys(it).length && (this._user = it),
        st && (this._level = st),
        lt.length && (this._fingerprint = lt),
        ct && (this._propagationContext = ct),
        this
    }
    clear() {
        return this._breadcrumbs = [],
        this._tags = {},
        this._extra = {},
        this._user = {},
        this._contexts = {},
        this._level = void 0,
        this._transactionName = void 0,
        this._fingerprint = void 0,
        this._session = void 0,
        _setSpanForScope(this, void 0),
        this._attachments = [],
        this.setPropagationContext({
            traceId: generateTraceId(),
            sampleRand: Math.random()
        }),
        this._notifyScopeListeners(),
        this
    }
    addBreadcrumb($, et) {
        var rt;
        const tt = typeof et == "number" ? et : DEFAULT_MAX_BREADCRUMBS;
        if (tt <= 0)
            return this;
        const nt = {
            timestamp: dateTimestampInSeconds(),
            ...$
        };
        return this._breadcrumbs.push(nt),
        this._breadcrumbs.length > tt && (this._breadcrumbs = this._breadcrumbs.slice(-tt),
        (rt = this._client) == null || rt.recordDroppedEvent("buffer_overflow", "log_item")),
        this._notifyScopeListeners(),
        this
    }
    getLastBreadcrumb() {
        return this._breadcrumbs[this._breadcrumbs.length - 1]
    }
    clearBreadcrumbs() {
        return this._breadcrumbs = [],
        this._notifyScopeListeners(),
        this
    }
    addAttachment($) {
        return this._attachments.push($),
        this
    }
    clearAttachments() {
        return this._attachments = [],
        this
    }
    getScopeData() {
        return {
            breadcrumbs: this._breadcrumbs,
            attachments: this._attachments,
            contexts: this._contexts,
            tags: this._tags,
            extra: this._extra,
            user: this._user,
            level: this._level,
            fingerprint: this._fingerprint || [],
            eventProcessors: this._eventProcessors,
            propagationContext: this._propagationContext,
            sdkProcessingMetadata: this._sdkProcessingMetadata,
            transactionName: this._transactionName,
            span: _getSpanForScope(this)
        }
    }
    setSDKProcessingMetadata($) {
        return this._sdkProcessingMetadata = merge(this._sdkProcessingMetadata, $, 2),
        this
    }
    setPropagationContext($) {
        return this._propagationContext = $,
        this
    }
    getPropagationContext() {
        return this._propagationContext
    }
    captureException($, et) {
        const tt = (et == null ? void 0 : et.event_id) || uuid4();
        if (!this._client)
            return logger.warn("No client configured on scope - will not capture exception!"),
            tt;
        const nt = new Error("Sentry syntheticException");
        return this._client.captureException($, {
            originalException: $,
            syntheticException: nt,
            ...et,
            event_id: tt
        }, this),
        tt
    }
    captureMessage($, et, tt) {
        const nt = (tt == null ? void 0 : tt.event_id) || uuid4();
        if (!this._client)
            return logger.warn("No client configured on scope - will not capture message!"),
            nt;
        const rt = new Error($);
        return this._client.captureMessage($, et, {
            originalException: $,
            syntheticException: rt,
            ...tt,
            event_id: nt
        }, this),
        nt
    }
    captureEvent($, et) {
        const tt = (et == null ? void 0 : et.event_id) || uuid4();
        return this._client ? (this._client.captureEvent($, {
            ...et,
            event_id: tt
        }, this),
        tt) : (logger.warn("No client configured on scope - will not capture event!"),
        tt)
    }
    _notifyScopeListeners() {
        this._notifyingListeners || (this._notifyingListeners = !0,
        this._scopeListeners.forEach($ => {
            $(this)
        }
        ),
        this._notifyingListeners = !1)
    }
}
function getDefaultCurrentScope() {
    return getGlobalSingleton("defaultCurrentScope", () => new Scope)
}
function getDefaultIsolationScope() {
    return getGlobalSingleton("defaultIsolationScope", () => new Scope)
}
class AsyncContextStack {
    constructor($, et) {
        let tt;
        $ ? tt = $ : tt = new Scope;
        let nt;
        et ? nt = et : nt = new Scope,
        this._stack = [{
            scope: tt
        }],
        this._isolationScope = nt
    }
    withScope($) {
        const et = this._pushScope();
        let tt;
        try {
            tt = $(et)
        } catch (nt) {
            throw this._popScope(),
            nt
        }
        return isThenable(tt) ? tt.then(nt => (this._popScope(),
        nt), nt => {
            throw this._popScope(),
            nt
        }
        ) : (this._popScope(),
        tt)
    }
    getClient() {
        return this.getStackTop().client
    }
    getScope() {
        return this.getStackTop().scope
    }
    getIsolationScope() {
        return this._isolationScope
    }
    getStackTop() {
        return this._stack[this._stack.length - 1]
    }
    _pushScope() {
        const $ = this.getScope().clone();
        return this._stack.push({
            client: this.getClient(),
            scope: $
        }),
        $
    }
    _popScope() {
        return this._stack.length <= 1 ? !1 : !!this._stack.pop()
    }
}
function getAsyncContextStack() {
    const _e = getMainCarrier()
      , $ = getSentryCarrier(_e);
    return $.stack = $.stack || new AsyncContextStack(getDefaultCurrentScope(),getDefaultIsolationScope())
}
function withScope$1(_e) {
    return getAsyncContextStack().withScope(_e)
}
function withSetScope(_e, $) {
    const et = getAsyncContextStack();
    return et.withScope( () => (et.getStackTop().scope = _e,
    $(_e)))
}
function withIsolationScope(_e) {
    return getAsyncContextStack().withScope( () => _e(getAsyncContextStack().getIsolationScope()))
}
function getStackAsyncContextStrategy() {
    return {
        withIsolationScope,
        withScope: withScope$1,
        withSetScope,
        withSetIsolationScope: (_e, $) => withIsolationScope($),
        getCurrentScope: () => getAsyncContextStack().getScope(),
        getIsolationScope: () => getAsyncContextStack().getIsolationScope()
    }
}
function getAsyncContextStrategy(_e) {
    const $ = getSentryCarrier(_e);
    return $.acs ? $.acs : getStackAsyncContextStrategy()
}
function getCurrentScope() {
    const _e = getMainCarrier();
    return getAsyncContextStrategy(_e).getCurrentScope()
}
function getIsolationScope() {
    const _e = getMainCarrier();
    return getAsyncContextStrategy(_e).getIsolationScope()
}
function getGlobalScope() {
    return getGlobalSingleton("globalScope", () => new Scope)
}
function withScope(..._e) {
    const $ = getMainCarrier()
      , et = getAsyncContextStrategy($);
    if (_e.length === 2) {
        const [tt,nt] = _e;
        return tt ? et.withSetScope(tt, nt) : et.withScope(nt)
    }
    return et.withScope(_e[0])
}
function getClient() {
    return getCurrentScope().getClient()
}
function getTraceContextFromScope(_e) {
    const $ = _e.getPropagationContext()
      , {traceId: et, parentSpanId: tt, propagationSpanId: nt} = $;
    return dropUndefinedKeys({
        trace_id: et,
        span_id: nt || generateSpanId(),
        parent_span_id: tt
    })
}
const SEMANTIC_ATTRIBUTE_SENTRY_SOURCE = "sentry.source"
  , SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE = "sentry.sample_rate"
  , SEMANTIC_ATTRIBUTE_SENTRY_OP = "sentry.op"
  , SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN = "sentry.origin"
  , SEMANTIC_ATTRIBUTE_PROFILE_ID = "sentry.profile_id"
  , SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME = "sentry.exclusive_time"
  , SPAN_STATUS_UNSET = 0
  , SPAN_STATUS_OK = 1
  , SCOPE_ON_START_SPAN_FIELD = "_sentryScope"
  , ISOLATION_SCOPE_ON_START_SPAN_FIELD = "_sentryIsolationScope";
function getCapturedScopesOnSpan(_e) {
    return {
        scope: _e[SCOPE_ON_START_SPAN_FIELD],
        isolationScope: _e[ISOLATION_SCOPE_ON_START_SPAN_FIELD]
    }
}
function parseSampleRate(_e) {
    if (typeof _e == "boolean")
        return Number(_e);
    const $ = typeof _e == "string" ? parseFloat(_e) : _e;
    if (!(typeof $ != "number" || isNaN($) || $ < 0 || $ > 1))
        return $
}
const SENTRY_BAGGAGE_KEY_PREFIX = "sentry-"
  , SENTRY_BAGGAGE_KEY_PREFIX_REGEX = /^sentry-/;
function baggageHeaderToDynamicSamplingContext(_e) {
    const $ = parseBaggageHeader(_e);
    if (!$)
        return;
    const et = Object.entries($).reduce( (tt, [nt,rt]) => {
        if (nt.match(SENTRY_BAGGAGE_KEY_PREFIX_REGEX)) {
            const it = nt.slice(SENTRY_BAGGAGE_KEY_PREFIX.length);
            tt[it] = rt
        }
        return tt
    }
    , {});
    if (Object.keys(et).length > 0)
        return et
}
function parseBaggageHeader(_e) {
    if (!(!_e || !isString(_e) && !Array.isArray(_e)))
        return Array.isArray(_e) ? _e.reduce( ($, et) => {
            const tt = baggageHeaderToObject(et);
            return Object.entries(tt).forEach( ([nt,rt]) => {
                $[nt] = rt
            }
            ),
            $
        }
        , {}) : baggageHeaderToObject(_e)
}
function baggageHeaderToObject(_e) {
    return _e.split(",").map($ => $.split("=").map(et => decodeURIComponent(et.trim()))).reduce( ($, [et,tt]) => (et && tt && ($[et] = tt),
    $), {})
}
const TRACE_FLAG_SAMPLED = 1;
let hasShownSpanDropWarning = !1;
function spanToTraceContext(_e) {
    const {spanId: $, traceId: et, isRemote: tt} = _e.spanContext()
      , nt = tt ? $ : spanToJSON(_e).parent_span_id
      , rt = getCapturedScopesOnSpan(_e).scope
      , it = tt ? (rt == null ? void 0 : rt.getPropagationContext().propagationSpanId) || generateSpanId() : $;
    return dropUndefinedKeys({
        parent_span_id: nt,
        span_id: it,
        trace_id: et
    })
}
function convertSpanLinksForEnvelope(_e) {
    if (_e && _e.length > 0)
        return _e.map( ({context: {spanId: $, traceId: et, traceFlags: tt, ...nt}, attributes: rt}) => ({
            span_id: $,
            trace_id: et,
            sampled: tt === TRACE_FLAG_SAMPLED,
            attributes: rt,
            ...nt
        }))
}
function spanTimeInputToSeconds(_e) {
    return typeof _e == "number" ? ensureTimestampInSeconds(_e) : Array.isArray(_e) ? _e[0] + _e[1] / 1e9 : _e instanceof Date ? ensureTimestampInSeconds(_e.getTime()) : timestampInSeconds()
}
function ensureTimestampInSeconds(_e) {
    return _e > 9999999999 ? _e / 1e3 : _e
}
function spanToJSON(_e) {
    if (spanIsSentrySpan(_e))
        return _e.getSpanJSON();
    const {spanId: $, traceId: et} = _e.spanContext();
    if (spanIsOpenTelemetrySdkTraceBaseSpan(_e)) {
        const {attributes: tt, startTime: nt, name: rt, endTime: it, parentSpanId: ot, status: st, links: lt} = _e;
        return dropUndefinedKeys({
            span_id: $,
            trace_id: et,
            data: tt,
            description: rt,
            parent_span_id: ot,
            start_timestamp: spanTimeInputToSeconds(nt),
            timestamp: spanTimeInputToSeconds(it) || void 0,
            status: getStatusMessage(st),
            op: tt[SEMANTIC_ATTRIBUTE_SENTRY_OP],
            origin: tt[SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN],
            links: convertSpanLinksForEnvelope(lt)
        })
    }
    return {
        span_id: $,
        trace_id: et,
        start_timestamp: 0,
        data: {}
    }
}
function spanIsOpenTelemetrySdkTraceBaseSpan(_e) {
    const $ = _e;
    return !!$.attributes && !!$.startTime && !!$.name && !!$.endTime && !!$.status
}
function spanIsSentrySpan(_e) {
    return typeof _e.getSpanJSON == "function"
}
function spanIsSampled(_e) {
    const {traceFlags: $} = _e.spanContext();
    return $ === TRACE_FLAG_SAMPLED
}
function getStatusMessage(_e) {
    if (!(!_e || _e.code === SPAN_STATUS_UNSET))
        return _e.code === SPAN_STATUS_OK ? "ok" : _e.message || "unknown_error"
}
const ROOT_SPAN_FIELD = "_sentryRootSpan";
function getRootSpan(_e) {
    return _e[ROOT_SPAN_FIELD] || _e
}
function showSpanDropWarning() {
    hasShownSpanDropWarning || (consoleSandbox( () => {}
    ),
    hasShownSpanDropWarning = !0)
}
function hasSpansEnabled(_e) {
    var et;
    if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__)
        return !1;
    const $ = _e || ((et = getClient()) == null ? void 0 : et.getOptions());
    return !!$ && ($.tracesSampleRate != null || !!$.tracesSampler)
}
const DEFAULT_ENVIRONMENT = "production"
  , FROZEN_DSC_FIELD = "_frozenDsc";
function getDynamicSamplingContextFromClient(_e, $) {
    const et = $.getOptions()
      , {publicKey: tt} = $.getDsn() || {}
      , nt = dropUndefinedKeys({
        environment: et.environment || DEFAULT_ENVIRONMENT,
        release: et.release,
        public_key: tt,
        trace_id: _e
    });
    return $.emit("createDsc", nt),
    nt
}
function getDynamicSamplingContextFromScope(_e, $) {
    const et = $.getPropagationContext();
    return et.dsc || getDynamicSamplingContextFromClient(et.traceId, _e)
}
function getDynamicSamplingContextFromSpan(_e) {
    var mt;
    const $ = getClient();
    if (!$)
        return {};
    const et = getRootSpan(_e)
      , tt = spanToJSON(et)
      , nt = tt.data
      , rt = et.spanContext().traceState
      , it = (rt == null ? void 0 : rt.get("sentry.sample_rate")) ?? nt[SEMANTIC_ATTRIBUTE_SENTRY_SAMPLE_RATE];
    function ot(yt) {
        return (typeof it == "number" || typeof it == "string") && (yt.sample_rate = `${it}`),
        yt
    }
    const st = et[FROZEN_DSC_FIELD];
    if (st)
        return ot(st);
    const lt = rt == null ? void 0 : rt.get("sentry.dsc")
      , ct = lt && baggageHeaderToDynamicSamplingContext(lt);
    if (ct)
        return ot(ct);
    const dt = getDynamicSamplingContextFromClient(_e.spanContext().traceId, $)
      , pt = nt[SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]
      , ht = tt.description;
    return pt !== "url" && ht && (dt.transaction = ht),
    hasSpansEnabled() && (dt.sampled = String(spanIsSampled(et)),
    dt.sample_rand = (rt == null ? void 0 : rt.get("sentry.sample_rand")) ?? ((mt = getCapturedScopesOnSpan(et).scope) == null ? void 0 : mt.getPropagationContext().sampleRand.toString())),
    ot(dt),
    $.emit("createDsc", dt, et),
    dt
}
const DSN_REGEX = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function isValidProtocol(_e) {
    return _e === "http" || _e === "https"
}
function dsnToString(_e, $=!1) {
    const {host: et, path: tt, pass: nt, port: rt, projectId: it, protocol: ot, publicKey: st} = _e;
    return `${ot}://${st}${$ && nt ? `:${nt}` : ""}@${et}${rt ? `:${rt}` : ""}/${tt && `${tt}/`}${it}`
}
function dsnFromString(_e) {
    const $ = DSN_REGEX.exec(_e);
    if (!$) {
        consoleSandbox( () => {}
        );
        return
    }
    const [et,tt,nt="",rt="",it="",ot=""] = $.slice(1);
    let st = ""
      , lt = ot;
    const ct = lt.split("/");
    if (ct.length > 1 && (st = ct.slice(0, -1).join("/"),
    lt = ct.pop()),
    lt) {
        const dt = lt.match(/^\d+/);
        dt && (lt = dt[0])
    }
    return dsnFromComponents({
        host: rt,
        pass: nt,
        path: st,
        projectId: lt,
        port: it,
        protocol: et,
        publicKey: tt
    })
}
function dsnFromComponents(_e) {
    return {
        protocol: _e.protocol,
        publicKey: _e.publicKey || "",
        pass: _e.pass || "",
        host: _e.host,
        port: _e.port || "",
        path: _e.path || "",
        projectId: _e.projectId
    }
}
function validateDsn(_e) {
    if (!DEBUG_BUILD$2)
        return !0;
    const {port: $, projectId: et, protocol: tt} = _e;
    return ["protocol", "publicKey", "host", "projectId"].find(it => _e[it] ? !1 : (logger.error(`Invalid Sentry Dsn: ${it} missing`),
    !0)) ? !1 : et.match(/^\d+$/) ? isValidProtocol(tt) ? $ && isNaN(parseInt($, 10)) ? (logger.error(`Invalid Sentry Dsn: Invalid port ${$}`),
    !1) : !0 : (logger.error(`Invalid Sentry Dsn: Invalid protocol ${tt}`),
    !1) : (logger.error(`Invalid Sentry Dsn: Invalid projectId ${et}`),
    !1)
}
function makeDsn(_e) {
    const $ = typeof _e == "string" ? dsnFromString(_e) : dsnFromComponents(_e);
    if (!(!$ || !validateDsn($)))
        return $
}
function normalize(_e, $=100, et=1 / 0) {
    try {
        return visit("", _e, $, et)
    } catch (tt) {
        return {
            ERROR: `**non-serializable** (${tt})`
        }
    }
}
function normalizeToSize(_e, $=3, et=100 * 1024) {
    const tt = normalize(_e, $);
    return jsonSize(tt) > et ? normalizeToSize(_e, $ - 1, et) : tt
}
function visit(_e, $, et=1 / 0, tt=1 / 0, nt=memoBuilder()) {
    const [rt,it] = nt;
    if ($ == null || ["boolean", "string"].includes(typeof $) || typeof $ == "number" && Number.isFinite($))
        return $;
    const ot = stringifyValue(_e, $);
    if (!ot.startsWith("[object "))
        return ot;
    if ($.__sentry_skip_normalization__)
        return $;
    const st = typeof $.__sentry_override_normalization_depth__ == "number" ? $.__sentry_override_normalization_depth__ : et;
    if (st === 0)
        return ot.replace("object ", "");
    if (rt($))
        return "[Circular ~]";
    const lt = $;
    if (lt && typeof lt.toJSON == "function")
        try {
            const ht = lt.toJSON();
            return visit("", ht, st - 1, tt, nt)
        } catch {}
    const ct = Array.isArray($) ? [] : {};
    let dt = 0;
    const pt = convertToPlainObject($);
    for (const ht in pt) {
        if (!Object.prototype.hasOwnProperty.call(pt, ht))
            continue;
        if (dt >= tt) {
            ct[ht] = "[MaxProperties ~]";
            break
        }
        const mt = pt[ht];
        ct[ht] = visit(ht, mt, st - 1, tt, nt),
        dt++
    }
    return it($),
    ct
}
function stringifyValue(_e, $) {
    try {
        if (_e === "domain" && $ && typeof $ == "object" && $._events)
            return "[Domain]";
        if (_e === "domainEmitter")
            return "[DomainEmitter]";
        if (typeof globalThis < "u" && $ === globalThis)
            return "[Global]";
        if (typeof window < "u" && $ === window)
            return "[Window]";
        if (typeof document < "u" && $ === document)
            return "[Document]";
        if (isVueViewModel($))
            return "[VueViewModel]";
        if (isSyntheticEvent($))
            return "[SyntheticEvent]";
        if (typeof $ == "number" && !Number.isFinite($))
            return `[${$}]`;
        if (typeof $ == "function")
            return `[Function: ${getFunctionName($)}]`;
        if (typeof $ == "symbol")
            return `[${String($)}]`;
        if (typeof $ == "bigint")
            return `[BigInt: ${String($)}]`;
        const et = getConstructorName($);
        return /^HTML(\w*)Element$/.test(et) ? `[HTMLElement: ${et}]` : `[object ${et}]`
    } catch (et) {
        return `**non-serializable** (${et})`
    }
}
function getConstructorName(_e) {
    const $ = Object.getPrototypeOf(_e);
    return $ ? $.constructor.name : "null prototype"
}
function utf8Length(_e) {
    return ~-encodeURI(_e).split(/%..|./).length
}
function jsonSize(_e) {
    return utf8Length(JSON.stringify(_e))
}
function memoBuilder() {
    const _e = new WeakSet;
    function $(tt) {
        return _e.has(tt) ? !0 : (_e.add(tt),
        !1)
    }
    function et(tt) {
        _e.delete(tt)
    }
    return [$, et]
}
function createEnvelope(_e, $=[]) {
    return [_e, $]
}
function addItemToEnvelope(_e, $) {
    const [et,tt] = _e;
    return [et, [...tt, $]]
}
function forEachEnvelopeItem(_e, $) {
    const et = _e[1];
    for (const tt of et) {
        const nt = tt[0].type;
        if ($(tt, nt))
            return !0
    }
    return !1
}
function encodeUTF8(_e) {
    const $ = getSentryCarrier(GLOBAL_OBJ);
    return $.encodePolyfill ? $.encodePolyfill(_e) : new TextEncoder().encode(_e)
}
function serializeEnvelope(_e) {
    const [$,et] = _e;
    let tt = JSON.stringify($);
    function nt(rt) {
        typeof tt == "string" ? tt = typeof rt == "string" ? tt + rt : [encodeUTF8(tt), rt] : tt.push(typeof rt == "string" ? encodeUTF8(rt) : rt)
    }
    for (const rt of et) {
        const [it,ot] = rt;
        if (nt(`
${JSON.stringify(it)}
`),
        typeof ot == "string" || ot instanceof Uint8Array)
            nt(ot);
        else {
            let st;
            try {
                st = JSON.stringify(ot)
            } catch {
                st = JSON.stringify(normalize(ot))
            }
            nt(st)
        }
    }
    return typeof tt == "string" ? tt : concatBuffers(tt)
}
function concatBuffers(_e) {
    const $ = _e.reduce( (nt, rt) => nt + rt.length, 0)
      , et = new Uint8Array($);
    let tt = 0;
    for (const nt of _e)
        et.set(nt, tt),
        tt += nt.length;
    return et
}
function createAttachmentEnvelopeItem(_e) {
    const $ = typeof _e.data == "string" ? encodeUTF8(_e.data) : _e.data;
    return [dropUndefinedKeys({
        type: "attachment",
        length: $.length,
        filename: _e.filename,
        content_type: _e.contentType,
        attachment_type: _e.attachmentType
    }), $]
}
const ITEM_TYPE_TO_DATA_CATEGORY_MAP = {
    session: "session",
    sessions: "session",
    attachment: "attachment",
    transaction: "transaction",
    event: "error",
    client_report: "internal",
    user_report: "default",
    profile: "profile",
    profile_chunk: "profile",
    replay_event: "replay",
    replay_recording: "replay",
    check_in: "monitor",
    feedback: "feedback",
    span: "span",
    raw_security: "security"
};
function envelopeItemTypeToDataCategory(_e) {
    return ITEM_TYPE_TO_DATA_CATEGORY_MAP[_e]
}
function getSdkMetadataForEnvelopeHeader(_e) {
    if (!(_e != null && _e.sdk))
        return;
    const {name: $, version: et} = _e.sdk;
    return {
        name: $,
        version: et
    }
}
function createEventEnvelopeHeaders(_e, $, et, tt) {
    var rt;
    const nt = (rt = _e.sdkProcessingMetadata) == null ? void 0 : rt.dynamicSamplingContext;
    return {
        event_id: _e.event_id,
        sent_at: new Date().toISOString(),
        ...$ && {
            sdk: $
        },
        ...!!et && tt && {
            dsn: dsnToString(tt)
        },
        ...nt && {
            trace: dropUndefinedKeys({
                ...nt
            })
        }
    }
}
function enhanceEventWithSdkInfo(_e, $) {
    return $ && (_e.sdk = _e.sdk || {},
    _e.sdk.name = _e.sdk.name || $.name,
    _e.sdk.version = _e.sdk.version || $.version,
    _e.sdk.integrations = [..._e.sdk.integrations || [], ...$.integrations || []],
    _e.sdk.packages = [..._e.sdk.packages || [], ...$.packages || []]),
    _e
}
function createSessionEnvelope(_e, $, et, tt) {
    const nt = getSdkMetadataForEnvelopeHeader(et)
      , rt = {
        sent_at: new Date().toISOString(),
        ...nt && {
            sdk: nt
        },
        ...!!tt && $ && {
            dsn: dsnToString($)
        }
    }
      , it = "aggregates"in _e ? [{
        type: "sessions"
    }, _e] : [{
        type: "session"
    }, _e.toJSON()];
    return createEnvelope(rt, [it])
}
function createEventEnvelope(_e, $, et, tt) {
    const nt = getSdkMetadataForEnvelopeHeader(et)
      , rt = _e.type && _e.type !== "replay_event" ? _e.type : "event";
    enhanceEventWithSdkInfo(_e, et == null ? void 0 : et.sdk);
    const it = createEventEnvelopeHeaders(_e, nt, tt, $);
    return delete _e.sdkProcessingMetadata,
    createEnvelope(it, [[{
        type: rt
    }, _e]])
}
function notifyEventProcessors(_e, $, et, tt=0) {
    return new SyncPromise( (nt, rt) => {
        const it = _e[tt];
        if ($ === null || typeof it != "function")
            nt($);
        else {
            const ot = it({
                ...$
            }, et);
            DEBUG_BUILD$3 && it.id && ot === null && logger.log(`Event processor "${it.id}" dropped event`),
            isThenable(ot) ? ot.then(st => notifyEventProcessors(_e, st, et, tt + 1).then(nt)).then(null, rt) : notifyEventProcessors(_e, ot, et, tt + 1).then(nt).then(null, rt)
        }
    }
    )
}
let parsedStackResults, lastKeysCount, cachedFilenameDebugIds;
function getFilenameToDebugIdMap(_e) {
    const $ = GLOBAL_OBJ._sentryDebugIds;
    if (!$)
        return {};
    const et = Object.keys($);
    return cachedFilenameDebugIds && et.length === lastKeysCount || (lastKeysCount = et.length,
    cachedFilenameDebugIds = et.reduce( (tt, nt) => {
        parsedStackResults || (parsedStackResults = {});
        const rt = parsedStackResults[nt];
        if (rt)
            tt[rt[0]] = rt[1];
        else {
            const it = _e(nt);
            for (let ot = it.length - 1; ot >= 0; ot--) {
                const st = it[ot]
                  , lt = st == null ? void 0 : st.filename
                  , ct = $[nt];
                if (lt && ct) {
                    tt[lt] = ct,
                    parsedStackResults[nt] = [lt, ct];
                    break
                }
            }
        }
        return tt
    }
    , {})),
    cachedFilenameDebugIds
}
function applyScopeDataToEvent(_e, $) {
    const {fingerprint: et, span: tt, breadcrumbs: nt, sdkProcessingMetadata: rt} = $;
    applyDataToEvent(_e, $),
    tt && applySpanToEvent(_e, tt),
    applyFingerprintToEvent(_e, et),
    applyBreadcrumbsToEvent(_e, nt),
    applySdkMetadataToEvent(_e, rt)
}
function mergeScopeData(_e, $) {
    const {extra: et, tags: tt, user: nt, contexts: rt, level: it, sdkProcessingMetadata: ot, breadcrumbs: st, fingerprint: lt, eventProcessors: ct, attachments: dt, propagationContext: pt, transactionName: ht, span: mt} = $;
    mergeAndOverwriteScopeData(_e, "extra", et),
    mergeAndOverwriteScopeData(_e, "tags", tt),
    mergeAndOverwriteScopeData(_e, "user", nt),
    mergeAndOverwriteScopeData(_e, "contexts", rt),
    _e.sdkProcessingMetadata = merge(_e.sdkProcessingMetadata, ot, 2),
    it && (_e.level = it),
    ht && (_e.transactionName = ht),
    mt && (_e.span = mt),
    st.length && (_e.breadcrumbs = [..._e.breadcrumbs, ...st]),
    lt.length && (_e.fingerprint = [..._e.fingerprint, ...lt]),
    ct.length && (_e.eventProcessors = [..._e.eventProcessors, ...ct]),
    dt.length && (_e.attachments = [..._e.attachments, ...dt]),
    _e.propagationContext = {
        ..._e.propagationContext,
        ...pt
    }
}
function mergeAndOverwriteScopeData(_e, $, et) {
    _e[$] = merge(_e[$], et, 1)
}
function applyDataToEvent(_e, $) {
    const {extra: et, tags: tt, user: nt, contexts: rt, level: it, transactionName: ot} = $
      , st = dropUndefinedKeys(et);
    Object.keys(st).length && (_e.extra = {
        ...st,
        ..._e.extra
    });
    const lt = dropUndefinedKeys(tt);
    Object.keys(lt).length && (_e.tags = {
        ...lt,
        ..._e.tags
    });
    const ct = dropUndefinedKeys(nt);
    Object.keys(ct).length && (_e.user = {
        ...ct,
        ..._e.user
    });
    const dt = dropUndefinedKeys(rt);
    Object.keys(dt).length && (_e.contexts = {
        ...dt,
        ..._e.contexts
    }),
    it && (_e.level = it),
    ot && _e.type !== "transaction" && (_e.transaction = ot)
}
function applyBreadcrumbsToEvent(_e, $) {
    const et = [..._e.breadcrumbs || [], ...$];
    _e.breadcrumbs = et.length ? et : void 0
}
function applySdkMetadataToEvent(_e, $) {
    _e.sdkProcessingMetadata = {
        ..._e.sdkProcessingMetadata,
        ...$
    }
}
function applySpanToEvent(_e, $) {
    _e.contexts = {
        trace: spanToTraceContext($),
        ..._e.contexts
    },
    _e.sdkProcessingMetadata = {
        dynamicSamplingContext: getDynamicSamplingContextFromSpan($),
        ..._e.sdkProcessingMetadata
    };
    const et = getRootSpan($)
      , tt = spanToJSON(et).description;
    tt && !_e.transaction && _e.type === "transaction" && (_e.transaction = tt)
}
function applyFingerprintToEvent(_e, $) {
    _e.fingerprint = _e.fingerprint ? Array.isArray(_e.fingerprint) ? _e.fingerprint : [_e.fingerprint] : [],
    $ && (_e.fingerprint = _e.fingerprint.concat($)),
    _e.fingerprint.length || delete _e.fingerprint
}
function prepareEvent(_e, $, et, tt, nt, rt) {
    const {normalizeDepth: it=3, normalizeMaxBreadth: ot=1e3} = _e
      , st = {
        ...$,
        event_id: $.event_id || et.event_id || uuid4(),
        timestamp: $.timestamp || dateTimestampInSeconds()
    }
      , lt = et.integrations || _e.integrations.map(Et => Et.name);
    applyClientOptions(st, _e),
    applyIntegrationsMetadata(st, lt),
    nt && nt.emit("applyFrameMetadata", $),
    $.type === void 0 && applyDebugIds(st, _e.stackParser);
    const ct = getFinalScope(tt, et.captureContext);
    et.mechanism && addExceptionMechanism(st, et.mechanism);
    const dt = nt ? nt.getEventProcessors() : []
      , pt = getGlobalScope().getScopeData();
    if (rt) {
        const Et = rt.getScopeData();
        mergeScopeData(pt, Et)
    }
    if (ct) {
        const Et = ct.getScopeData();
        mergeScopeData(pt, Et)
    }
    const ht = [...et.attachments || [], ...pt.attachments];
    ht.length && (et.attachments = ht),
    applyScopeDataToEvent(st, pt);
    const mt = [...dt, ...pt.eventProcessors];
    return notifyEventProcessors(mt, st, et).then(Et => (Et && applyDebugMeta(Et),
    typeof it == "number" && it > 0 ? normalizeEvent(Et, it, ot) : Et))
}
function applyClientOptions(_e, $) {
    var st, lt;
    const {environment: et, release: tt, dist: nt, maxValueLength: rt=250} = $;
    _e.environment = _e.environment || et || DEFAULT_ENVIRONMENT,
    !_e.release && tt && (_e.release = tt),
    !_e.dist && nt && (_e.dist = nt),
    _e.message && (_e.message = truncate(_e.message, rt));
    const it = (lt = (st = _e.exception) == null ? void 0 : st.values) == null ? void 0 : lt[0];
    it != null && it.value && (it.value = truncate(it.value, rt));
    const ot = _e.request;
    ot != null && ot.url && (ot.url = truncate(ot.url, rt))
}
function applyDebugIds(_e, $) {
    var tt, nt;
    const et = getFilenameToDebugIdMap($);
    (nt = (tt = _e.exception) == null ? void 0 : tt.values) == null || nt.forEach(rt => {
        var it, ot;
        (ot = (it = rt.stacktrace) == null ? void 0 : it.frames) == null || ot.forEach(st => {
            st.filename && (st.debug_id = et[st.filename])
        }
        )
    }
    )
}
function applyDebugMeta(_e) {
    var tt, nt;
    const $ = {};
    if ((nt = (tt = _e.exception) == null ? void 0 : tt.values) == null || nt.forEach(rt => {
        var it, ot;
        (ot = (it = rt.stacktrace) == null ? void 0 : it.frames) == null || ot.forEach(st => {
            st.debug_id && (st.abs_path ? $[st.abs_path] = st.debug_id : st.filename && ($[st.filename] = st.debug_id),
            delete st.debug_id)
        }
        )
    }
    ),
    Object.keys($).length === 0)
        return;
    _e.debug_meta = _e.debug_meta || {},
    _e.debug_meta.images = _e.debug_meta.images || [];
    const et = _e.debug_meta.images;
    Object.entries($).forEach( ([rt,it]) => {
        et.push({
            type: "sourcemap",
            code_file: rt,
            debug_id: it
        })
    }
    )
}
function applyIntegrationsMetadata(_e, $) {
    $.length > 0 && (_e.sdk = _e.sdk || {},
    _e.sdk.integrations = [..._e.sdk.integrations || [], ...$])
}
function normalizeEvent(_e, $, et) {
    var nt, rt;
    if (!_e)
        return null;
    const tt = {
        ..._e,
        ..._e.breadcrumbs && {
            breadcrumbs: _e.breadcrumbs.map(it => ({
                ...it,
                ...it.data && {
                    data: normalize(it.data, $, et)
                }
            }))
        },
        ..._e.user && {
            user: normalize(_e.user, $, et)
        },
        ..._e.contexts && {
            contexts: normalize(_e.contexts, $, et)
        },
        ..._e.extra && {
            extra: normalize(_e.extra, $, et)
        }
    };
    return (nt = _e.contexts) != null && nt.trace && tt.contexts && (tt.contexts.trace = _e.contexts.trace,
    _e.contexts.trace.data && (tt.contexts.trace.data = normalize(_e.contexts.trace.data, $, et))),
    _e.spans && (tt.spans = _e.spans.map(it => ({
        ...it,
        ...it.data && {
            data: normalize(it.data, $, et)
        }
    }))),
    (rt = _e.contexts) != null && rt.flags && tt.contexts && (tt.contexts.flags = normalize(_e.contexts.flags, 3, et)),
    tt
}
function getFinalScope(_e, $) {
    if (!$)
        return _e;
    const et = _e ? _e.clone() : new Scope;
    return et.update($),
    et
}
function parseEventHintOrCaptureContext(_e) {}
function captureException(_e, $) {
    return getCurrentScope().captureException(_e, void 0)
}
function captureEvent(_e, $) {
    return getCurrentScope().captureEvent(_e, $)
}
function setContext(_e, $) {
    getIsolationScope().setContext(_e, $)
}
function startSession(_e) {
    const $ = getIsolationScope()
      , et = getCurrentScope()
      , {userAgent: tt} = GLOBAL_OBJ.navigator || {}
      , nt = makeSession({
        user: et.getUser() || $.getUser(),
        ...tt && {
            userAgent: tt
        },
        ..._e
    })
      , rt = $.getSession();
    return (rt == null ? void 0 : rt.status) === "ok" && updateSession(rt, {
        status: "exited"
    }),
    endSession(),
    $.setSession(nt),
    nt
}
function endSession() {
    const _e = getIsolationScope()
      , et = getCurrentScope().getSession() || _e.getSession();
    et && closeSession(et),
    _sendSessionUpdate(),
    _e.setSession()
}
function _sendSessionUpdate() {
    const _e = getIsolationScope()
      , $ = getClient()
      , et = _e.getSession();
    et && $ && $.captureSession(et)
}
function captureSession(_e=!1) {
    if (_e) {
        endSession();
        return
    }
    _sendSessionUpdate()
}
const SENTRY_API_VERSION = "7";
function getBaseApiEndpoint(_e) {
    const $ = _e.protocol ? `${_e.protocol}:` : ""
      , et = _e.port ? `:${_e.port}` : "";
    return `${$}//${_e.host}${et}${_e.path ? `/${_e.path}` : ""}/api/`
}
function _getIngestEndpoint(_e) {
    return `${getBaseApiEndpoint(_e)}${_e.projectId}/envelope/`
}
function _encodedAuth(_e, $) {
    const et = {
        sentry_version: SENTRY_API_VERSION
    };
    return _e.publicKey && (et.sentry_key = _e.publicKey),
    $ && (et.sentry_client = `${$.name}/${$.version}`),
    new URLSearchParams(et).toString()
}
function getEnvelopeEndpointWithUrlEncodedAuth(_e, $, et) {
    return $ || `${_getIngestEndpoint(_e)}?${_encodedAuth(_e, et)}`
}
const installedIntegrations = [];
function filterDuplicates(_e) {
    const $ = {};
    return _e.forEach(et => {
        const {name: tt} = et
          , nt = $[tt];
        nt && !nt.isDefaultInstance && et.isDefaultInstance || ($[tt] = et)
    }
    ),
    Object.values($)
}
function getIntegrationsToSetup(_e) {
    const $ = _e.defaultIntegrations || []
      , et = _e.integrations;
    $.forEach(nt => {
        nt.isDefaultInstance = !0
    }
    );
    let tt;
    if (Array.isArray(et))
        tt = [...$, ...et];
    else if (typeof et == "function") {
        const nt = et($);
        tt = Array.isArray(nt) ? nt : [nt]
    } else
        tt = $;
    return filterDuplicates(tt)
}
function setupIntegrations(_e, $) {
    const et = {};
    return $.forEach(tt => {
        tt && setupIntegration(_e, tt, et)
    }
    ),
    et
}
function afterSetupIntegrations(_e, $) {
    for (const et of $)
        et != null && et.afterAllSetup && et.afterAllSetup(_e)
}
function setupIntegration(_e, $, et) {
    if (et[$.name]) {
        DEBUG_BUILD$3 && logger.log(`Integration skipped because it was already installed: ${$.name}`);
        return
    }
    if (et[$.name] = $,
    installedIntegrations.indexOf($.name) === -1 && typeof $.setupOnce == "function" && ($.setupOnce(),
    installedIntegrations.push($.name)),
    $.setup && typeof $.setup == "function" && $.setup(_e),
    typeof $.preprocessEvent == "function") {
        const tt = $.preprocessEvent.bind($);
        _e.on("preprocessEvent", (nt, rt) => tt(nt, rt, _e))
    }
    if (typeof $.processEvent == "function") {
        const tt = $.processEvent.bind($)
          , nt = Object.assign( (rt, it) => tt(rt, it, _e), {
            id: $.name
        });
        _e.addEventProcessor(nt)
    }
    DEBUG_BUILD$3 && logger.log(`Integration installed: ${$.name}`)
}
function defineIntegration(_e) {
    return _e
}
function createClientReportEnvelope(_e, $, et) {
    const tt = [{
        type: "client_report"
    }, {
        timestamp: dateTimestampInSeconds(),
        discarded_events: _e
    }];
    return createEnvelope($ ? {
        dsn: $
    } : {}, [tt])
}
class SentryError extends Error {
    constructor($, et="warn") {
        super($),
        this.message = $,
        this.logLevel = et
    }
}
function getPossibleEventMessages(_e) {
    const $ = [];
    _e.message && $.push(_e.message);
    try {
        const et = _e.exception.values[_e.exception.values.length - 1];
        et != null && et.value && ($.push(et.value),
        et.type && $.push(`${et.type}: ${et.value}`))
    } catch {}
    return $
}
function convertTransactionEventToSpanJson(_e) {
    var st;
    const {trace_id: $, parent_span_id: et, span_id: tt, status: nt, origin: rt, data: it, op: ot} = ((st = _e.contexts) == null ? void 0 : st.trace) ?? {};
    return dropUndefinedKeys({
        data: it ?? {},
        description: _e.transaction,
        op: ot,
        parent_span_id: et,
        span_id: tt ?? "",
        start_timestamp: _e.start_timestamp ?? 0,
        status: nt,
        timestamp: _e.timestamp,
        trace_id: $ ?? "",
        origin: rt,
        profile_id: it == null ? void 0 : it[SEMANTIC_ATTRIBUTE_PROFILE_ID],
        exclusive_time: it == null ? void 0 : it[SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME],
        measurements: _e.measurements,
        is_segment: !0
    })
}
function convertSpanJsonToTransactionEvent(_e) {
    const $ = {
        type: "transaction",
        timestamp: _e.timestamp,
        start_timestamp: _e.start_timestamp,
        transaction: _e.description,
        contexts: {
            trace: {
                trace_id: _e.trace_id,
                span_id: _e.span_id,
                parent_span_id: _e.parent_span_id,
                op: _e.op,
                status: _e.status,
                origin: _e.origin,
                data: {
                    ..._e.data,
                    ..._e.profile_id && {
                        [SEMANTIC_ATTRIBUTE_PROFILE_ID]: _e.profile_id
                    },
                    ..._e.exclusive_time && {
                        [SEMANTIC_ATTRIBUTE_EXCLUSIVE_TIME]: _e.exclusive_time
                    }
                }
            }
        },
        measurements: _e.measurements
    };
    return dropUndefinedKeys($)
}
const ALREADY_SEEN_ERROR = "Not capturing exception because it's already been captured."
  , MISSING_RELEASE_FOR_SESSION_ERROR = "Discarded session because of missing or non-string release";
class Client {
    constructor($) {
        if (this._options = $,
        this._integrations = {},
        this._numProcessing = 0,
        this._outcomes = {},
        this._hooks = {},
        this._eventProcessors = [],
        $.dsn ? this._dsn = makeDsn($.dsn) : DEBUG_BUILD$3 && logger.warn("No DSN provided, client will not send events."),
        this._dsn) {
            const et = getEnvelopeEndpointWithUrlEncodedAuth(this._dsn, $.tunnel, $._metadata ? $._metadata.sdk : void 0);
            this._transport = $.transport({
                tunnel: this._options.tunnel,
                recordDroppedEvent: this.recordDroppedEvent.bind(this),
                ...$.transportOptions,
                url: et
            })
        }
    }
    captureException($, et, tt) {
        const nt = uuid4();
        if (checkOrSetAlreadyCaught($))
            return DEBUG_BUILD$3 && logger.log(ALREADY_SEEN_ERROR),
            nt;
        const rt = {
            event_id: nt,
            ...et
        };
        return this._process(this.eventFromException($, rt).then(it => this._captureEvent(it, rt, tt))),
        rt.event_id
    }
    captureMessage($, et, tt, nt) {
        const rt = {
            event_id: uuid4(),
            ...tt
        }
          , it = isParameterizedString($) ? $ : String($)
          , ot = isPrimitive($) ? this.eventFromMessage(it, et, rt) : this.eventFromException($, rt);
        return this._process(ot.then(st => this._captureEvent(st, rt, nt))),
        rt.event_id
    }
    captureEvent($, et, tt) {
        const nt = uuid4();
        if (et != null && et.originalException && checkOrSetAlreadyCaught(et.originalException))
            return DEBUG_BUILD$3 && logger.log(ALREADY_SEEN_ERROR),
            nt;
        const rt = {
            event_id: nt,
            ...et
        }
          , it = $.sdkProcessingMetadata || {}
          , ot = it.capturedSpanScope
          , st = it.capturedSpanIsolationScope;
        return this._process(this._captureEvent($, rt, ot || tt, st)),
        rt.event_id
    }
    captureSession($) {
        this.sendSession($),
        updateSession($, {
            init: !1
        })
    }
    getDsn() {
        return this._dsn
    }
    getOptions() {
        return this._options
    }
    getSdkMetadata() {
        return this._options._metadata
    }
    getTransport() {
        return this._transport
    }
    flush($) {
        const et = this._transport;
        return et ? (this.emit("flush"),
        this._isClientDoneProcessing($).then(tt => et.flush($).then(nt => tt && nt))) : resolvedSyncPromise(!0)
    }
    close($) {
        return this.flush($).then(et => (this.getOptions().enabled = !1,
        this.emit("close"),
        et))
    }
    getEventProcessors() {
        return this._eventProcessors
    }
    addEventProcessor($) {
        this._eventProcessors.push($)
    }
    init() {
        (this._isEnabled() || this._options.integrations.some( ({name: $}) => $.startsWith("Spotlight"))) && this._setupIntegrations()
    }
    getIntegrationByName($) {
        return this._integrations[$]
    }
    addIntegration($) {
        const et = this._integrations[$.name];
        setupIntegration(this, $, this._integrations),
        et || afterSetupIntegrations(this, [$])
    }
    sendEvent($, et={}) {
        this.emit("beforeSendEvent", $, et);
        let tt = createEventEnvelope($, this._dsn, this._options._metadata, this._options.tunnel);
        for (const rt of et.attachments || [])
            tt = addItemToEnvelope(tt, createAttachmentEnvelopeItem(rt));
        const nt = this.sendEnvelope(tt);
        nt && nt.then(rt => this.emit("afterSendEvent", $, rt), null)
    }
    sendSession($) {
        const {release: et, environment: tt=DEFAULT_ENVIRONMENT} = this._options;
        if ("aggregates"in $) {
            const rt = $.attrs || {};
            if (!rt.release && !et) {
                DEBUG_BUILD$3 && logger.warn(MISSING_RELEASE_FOR_SESSION_ERROR);
                return
            }
            rt.release = rt.release || et,
            rt.environment = rt.environment || tt,
            $.attrs = rt
        } else {
            if (!$.release && !et) {
                DEBUG_BUILD$3 && logger.warn(MISSING_RELEASE_FOR_SESSION_ERROR);
                return
            }
            $.release = $.release || et,
            $.environment = $.environment || tt
        }
        this.emit("beforeSendSession", $);
        const nt = createSessionEnvelope($, this._dsn, this._options._metadata, this._options.tunnel);
        this.sendEnvelope(nt)
    }
    recordDroppedEvent($, et, tt=1) {
        if (this._options.sendClientReports) {
            const nt = `${$}:${et}`;
            DEBUG_BUILD$3 && logger.log(`Recording outcome: "${nt}"${tt > 1 ? ` (${tt} times)` : ""}`),
            this._outcomes[nt] = (this._outcomes[nt] || 0) + tt
        }
    }
    on($, et) {
        const tt = this._hooks[$] = this._hooks[$] || [];
        return tt.push(et),
        () => {
            const nt = tt.indexOf(et);
            nt > -1 && tt.splice(nt, 1)
        }
    }
    emit($, ...et) {
        const tt = this._hooks[$];
        tt && tt.forEach(nt => nt(...et))
    }
    sendEnvelope($) {
        return this.emit("beforeEnvelope", $),
        this._isEnabled() && this._transport ? this._transport.send($).then(null, et => (DEBUG_BUILD$3 && logger.error("Error while sending envelope:", et),
        et)) : (DEBUG_BUILD$3 && logger.error("Transport disabled"),
        resolvedSyncPromise({}))
    }
    _setupIntegrations() {
        const {integrations: $} = this._options;
        this._integrations = setupIntegrations(this, $),
        afterSetupIntegrations(this, $)
    }
    _updateSessionFromEvent($, et) {
        var st;
        let tt = et.level === "fatal"
          , nt = !1;
        const rt = (st = et.exception) == null ? void 0 : st.values;
        if (rt) {
            nt = !0;
            for (const lt of rt) {
                const ct = lt.mechanism;
                if ((ct == null ? void 0 : ct.handled) === !1) {
                    tt = !0;
                    break
                }
            }
        }
        const it = $.status === "ok";
        (it && $.errors === 0 || it && tt) && (updateSession($, {
            ...tt && {
                status: "crashed"
            },
            errors: $.errors || Number(nt || tt)
        }),
        this.captureSession($))
    }
    _isClientDoneProcessing($) {
        return new SyncPromise(et => {
            let tt = 0;
            const nt = 1
              , rt = setInterval( () => {
                this._numProcessing == 0 ? (clearInterval(rt),
                et(!0)) : (tt += nt,
                $ && tt >= $ && (clearInterval(rt),
                et(!1)))
            }
            , nt)
        }
        )
    }
    _isEnabled() {
        return this.getOptions().enabled !== !1 && this._transport !== void 0
    }
    _prepareEvent($, et, tt, nt) {
        const rt = this.getOptions()
          , it = Object.keys(this._integrations);
        return !et.integrations && (it != null && it.length) && (et.integrations = it),
        this.emit("preprocessEvent", $, et),
        $.type || nt.setLastEventId($.event_id || et.event_id),
        prepareEvent(rt, $, et, tt, this, nt).then(ot => {
            if (ot === null)
                return ot;
            this.emit("postprocessEvent", ot, et),
            ot.contexts = {
                trace: getTraceContextFromScope(tt),
                ...ot.contexts
            };
            const st = getDynamicSamplingContextFromScope(this, tt);
            return ot.sdkProcessingMetadata = {
                dynamicSamplingContext: st,
                ...ot.sdkProcessingMetadata
            },
            ot
        }
        )
    }
    _captureEvent($, et={}, tt=getCurrentScope(), nt=getIsolationScope()) {
        return DEBUG_BUILD$3 && isErrorEvent($) && logger.log(`Captured error event \`${getPossibleEventMessages($)[0] || "<unknown>"}\``),
        this._processEvent($, et, tt, nt).then(rt => rt.event_id, rt => {
            DEBUG_BUILD$3 && (rt instanceof SentryError && rt.logLevel === "log" ? logger.log(rt.message) : logger.warn(rt))
        }
        )
    }
    _processEvent($, et, tt, nt) {
        const rt = this.getOptions()
          , {sampleRate: it} = rt
          , ot = isTransactionEvent($)
          , st = isErrorEvent($)
          , lt = $.type || "error"
          , ct = `before send for type \`${lt}\``
          , dt = typeof it > "u" ? void 0 : parseSampleRate(it);
        if (st && typeof dt == "number" && Math.random() > dt)
            return this.recordDroppedEvent("sample_rate", "error"),
            rejectedSyncPromise(new SentryError(`Discarding event because it's not included in the random sample (sampling rate = ${it})`,"log"));
        const pt = lt === "replay_event" ? "replay" : lt;
        return this._prepareEvent($, et, tt, nt).then(ht => {
            if (ht === null)
                throw this.recordDroppedEvent("event_processor", pt),
                new SentryError("An event processor returned `null`, will not send event.","log");
            if (et.data && et.data.__sentry__ === !0)
                return ht;
            const yt = processBeforeSend(this, rt, ht, et);
            return _validateBeforeSendResult(yt, ct)
        }
        ).then(ht => {
            var Et;
            if (ht === null) {
                if (this.recordDroppedEvent("before_send", pt),
                ot) {
                    const wt = 1 + ($.spans || []).length;
                    this.recordDroppedEvent("before_send", "span", wt)
                }
                throw new SentryError(`${ct} returned \`null\`, will not send event.`,"log")
            }
            const mt = tt.getSession() || nt.getSession();
            if (st && mt && this._updateSessionFromEvent(mt, ht),
            ot) {
                const _t = ((Et = ht.sdkProcessingMetadata) == null ? void 0 : Et.spanCountBeforeProcessing) || 0
                  , wt = ht.spans ? ht.spans.length : 0
                  , St = _t - wt;
                St > 0 && this.recordDroppedEvent("before_send", "span", St)
            }
            const yt = ht.transaction_info;
            if (ot && yt && ht.transaction !== $.transaction) {
                const _t = "custom";
                ht.transaction_info = {
                    ...yt,
                    source: _t
                }
            }
            return this.sendEvent(ht, et),
            ht
        }
        ).then(null, ht => {
            throw ht instanceof SentryError ? ht : (this.captureException(ht, {
                data: {
                    __sentry__: !0
                },
                originalException: ht
            }),
            new SentryError(`Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${ht}`))
        }
        )
    }
    _process($) {
        this._numProcessing++,
        $.then(et => (this._numProcessing--,
        et), et => (this._numProcessing--,
        et))
    }
    _clearOutcomes() {
        const $ = this._outcomes;
        return this._outcomes = {},
        Object.entries($).map( ([et,tt]) => {
            const [nt,rt] = et.split(":");
            return {
                reason: nt,
                category: rt,
                quantity: tt
            }
        }
        )
    }
    _flushOutcomes() {
        DEBUG_BUILD$3 && logger.log("Flushing outcomes...");
        const $ = this._clearOutcomes();
        if ($.length === 0) {
            DEBUG_BUILD$3 && logger.log("No outcomes to send");
            return
        }
        if (!this._dsn) {
            DEBUG_BUILD$3 && logger.log("No dsn provided, will not send outcomes");
            return
        }
        DEBUG_BUILD$3 && logger.log("Sending outcomes:", $);
        const et = createClientReportEnvelope($, this._options.tunnel && dsnToString(this._dsn));
        this.sendEnvelope(et)
    }
}
function _validateBeforeSendResult(_e, $) {
    const et = `${$} must return \`null\` or a valid event.`;
    if (isThenable(_e))
        return _e.then(tt => {
            if (!isPlainObject(tt) && tt !== null)
                throw new SentryError(et);
            return tt
        }
        , tt => {
            throw new SentryError(`${$} rejected with ${tt}`)
        }
        );
    if (!isPlainObject(_e) && _e !== null)
        throw new SentryError(et);
    return _e
}
function processBeforeSend(_e, $, et, tt) {
    const {beforeSend: nt, beforeSendTransaction: rt, beforeSendSpan: it} = $;
    let ot = et;
    if (isErrorEvent(ot) && nt)
        return nt(ot, tt);
    if (isTransactionEvent(ot)) {
        if (it) {
            const st = it(convertTransactionEventToSpanJson(ot));
            if (st ? ot = merge(et, convertSpanJsonToTransactionEvent(st)) : showSpanDropWarning(),
            ot.spans) {
                const lt = [];
                for (const ct of ot.spans) {
                    const dt = it(ct);
                    dt ? lt.push(dt) : (showSpanDropWarning(),
                    lt.push(ct))
                }
                ot.spans = lt
            }
        }
        if (rt) {
            if (ot.spans) {
                const st = ot.spans.length;
                ot.sdkProcessingMetadata = {
                    ...et.sdkProcessingMetadata,
                    spanCountBeforeProcessing: st
                }
            }
            return rt(ot, tt)
        }
    }
    return ot
}
function isErrorEvent(_e) {
    return _e.type === void 0
}
function isTransactionEvent(_e) {
    return _e.type === "transaction"
}
function initAndBind(_e, $) {
    $.debug === !0 && (DEBUG_BUILD$3 ? logger.enable() : consoleSandbox( () => {}
    )),
    getCurrentScope().update($.initialScope);
    const tt = new _e($);
    return setCurrentClient(tt),
    tt.init(),
    tt
}
function setCurrentClient(_e) {
    getCurrentScope().setClient(_e)
}
function makePromiseBuffer(_e) {
    const $ = [];
    function et() {
        return _e === void 0 || $.length < _e
    }
    function tt(it) {
        return $.splice($.indexOf(it), 1)[0] || Promise.resolve(void 0)
    }
    function nt(it) {
        if (!et())
            return rejectedSyncPromise(new SentryError("Not adding Promise because buffer limit was reached."));
        const ot = it();
        return $.indexOf(ot) === -1 && $.push(ot),
        ot.then( () => tt(ot)).then(null, () => tt(ot).then(null, () => {}
        )),
        ot
    }
    function rt(it) {
        return new SyncPromise( (ot, st) => {
            let lt = $.length;
            if (!lt)
                return ot(!0);
            const ct = setTimeout( () => {
                it && it > 0 && ot(!1)
            }
            , it);
            $.forEach(dt => {
                resolvedSyncPromise(dt).then( () => {
                    --lt || (clearTimeout(ct),
                    ot(!0))
                }
                , st)
            }
            )
        }
        )
    }
    return {
        $,
        add: nt,
        drain: rt
    }
}
const DEFAULT_RETRY_AFTER = 60 * 1e3;
function parseRetryAfterHeader(_e, $=Date.now()) {
    const et = parseInt(`${_e}`, 10);
    if (!isNaN(et))
        return et * 1e3;
    const tt = Date.parse(`${_e}`);
    return isNaN(tt) ? DEFAULT_RETRY_AFTER : tt - $
}
function disabledUntil(_e, $) {
    return _e[$] || _e.all || 0
}
function isRateLimited(_e, $, et=Date.now()) {
    return disabledUntil(_e, $) > et
}
function updateRateLimits(_e, {statusCode: $, headers: et}, tt=Date.now()) {
    const nt = {
        ..._e
    }
      , rt = et == null ? void 0 : et["x-sentry-rate-limits"]
      , it = et == null ? void 0 : et["retry-after"];
    if (rt)
        for (const ot of rt.trim().split(",")) {
            const [st,lt,,,ct] = ot.split(":", 5)
              , dt = parseInt(st, 10)
              , pt = (isNaN(dt) ? 60 : dt) * 1e3;
            if (!lt)
                nt.all = tt + pt;
            else
                for (const ht of lt.split(";"))
                    ht === "metric_bucket" ? (!ct || ct.split(";").includes("custom")) && (nt[ht] = tt + pt) : nt[ht] = tt + pt
        }
    else
        it ? nt.all = tt + parseRetryAfterHeader(it, tt) : $ === 429 && (nt.all = tt + 60 * 1e3);
    return nt
}
const DEFAULT_TRANSPORT_BUFFER_SIZE = 64;
function createTransport(_e, $, et=makePromiseBuffer(_e.bufferSize || DEFAULT_TRANSPORT_BUFFER_SIZE)) {
    let tt = {};
    const nt = it => et.drain(it);
    function rt(it) {
        const ot = [];
        if (forEachEnvelopeItem(it, (dt, pt) => {
            const ht = envelopeItemTypeToDataCategory(pt);
            isRateLimited(tt, ht) ? _e.recordDroppedEvent("ratelimit_backoff", ht) : ot.push(dt)
        }
        ),
        ot.length === 0)
            return resolvedSyncPromise({});
        const st = createEnvelope(it[0], ot)
          , lt = dt => {
            forEachEnvelopeItem(st, (pt, ht) => {
                _e.recordDroppedEvent(dt, envelopeItemTypeToDataCategory(ht))
            }
            )
        }
          , ct = () => $({
            body: serializeEnvelope(st)
        }).then(dt => (dt.statusCode !== void 0 && (dt.statusCode < 200 || dt.statusCode >= 300) && DEBUG_BUILD$3 && logger.warn(`Sentry responded with status code ${dt.statusCode} to sent event.`),
        tt = updateRateLimits(tt, dt),
        dt), dt => {
            throw lt("network_error"),
            dt
        }
        );
        return et.add(ct).then(dt => dt, dt => {
            if (dt instanceof SentryError)
                return DEBUG_BUILD$3 && logger.error("Skipped sending event because buffer is full."),
                lt("queue_overflow"),
                resolvedSyncPromise({});
            throw dt
        }
        )
    }
    return {
        send: rt,
        flush: nt
    }
}
function addAutoIpAddressToUser(_e) {
    var $;
    (($ = _e.user) == null ? void 0 : $.ip_address) === void 0 && (_e.user = {
        ..._e.user,
        ip_address: "{{auto}}"
    })
}
function addAutoIpAddressToSession(_e) {
    var $;
    "aggregates"in _e ? (($ = _e.attrs) == null ? void 0 : $.ip_address) === void 0 && (_e.attrs = {
        ..._e.attrs,
        ip_address: "{{auto}}"
    }) : _e.ipAddress === void 0 && (_e.ipAddress = "{{auto}}")
}
function applySdkMetadata(_e, $, et=[$], tt="npm") {
    const nt = _e._metadata || {};
    nt.sdk || (nt.sdk = {
        name: `sentry.javascript.${$}`,
        packages: et.map(rt => ({
            name: `${tt}:@sentry/${rt}`,
            version: SDK_VERSION
        })),
        version: SDK_VERSION
    }),
    _e._metadata = nt
}
const DEFAULT_BREADCRUMBS = 100;
function addBreadcrumb(_e, $) {
    const et = getClient()
      , tt = getIsolationScope();
    if (!et)
        return;
    const {beforeBreadcrumb: nt=null, maxBreadcrumbs: rt=DEFAULT_BREADCRUMBS} = et.getOptions();
    if (rt <= 0)
        return;
    const ot = {
        timestamp: dateTimestampInSeconds(),
        ..._e
    }
      , st = nt ? consoleSandbox( () => nt(ot, $)) : ot;
    st !== null && (et.emit && et.emit("beforeAddBreadcrumb", st, $),
    tt.addBreadcrumb(st, rt))
}
let originalFunctionToString;
const INTEGRATION_NAME$6 = "FunctionToString"
  , SETUP_CLIENTS = new WeakMap
  , _functionToStringIntegration = () => ({
    name: INTEGRATION_NAME$6,
    setupOnce() {
        originalFunctionToString = Function.prototype.toString;
        try {
            Function.prototype.toString = function(..._e) {
                const $ = getOriginalFunction(this)
                  , et = SETUP_CLIENTS.has(getClient()) && $ !== void 0 ? $ : this;
                return originalFunctionToString.apply(et, _e)
            }
        } catch {}
    },
    setup(_e) {
        SETUP_CLIENTS.set(_e, !0)
    }
})
  , functionToStringIntegration = _functionToStringIntegration
  , DEFAULT_IGNORE_ERRORS = [/^Script error\.?$/, /^Javascript error: Script error\.? on line 0$/, /^ResizeObserver loop completed with undelivered notifications.$/, /^Cannot redefine property: googletag$/, /^Can't find variable: gmo$/, "undefined is not an object (evaluating 'a.L')", `can't redefine non-configurable property "solana"`, "vv().getRestrictions is not a function. (In 'vv().getRestrictions(1,a)', 'vv().getRestrictions' is undefined)", "Can't find variable: _AutofillCallbackHandler", /^Non-Error promise rejection captured with value: Object Not Found Matching Id:\d+, MethodName:simulateEvent, ParamCount:\d+$/, /^Java exception was raised during method invocation$/]
  , INTEGRATION_NAME$5 = "InboundFilters"
  , _inboundFiltersIntegration = (_e={}) => ({
    name: INTEGRATION_NAME$5,
    processEvent($, et, tt) {
        const nt = tt.getOptions()
          , rt = _mergeOptions(_e, nt);
        return _shouldDropEvent$1($, rt) ? null : $
    }
})
  , inboundFiltersIntegration = _inboundFiltersIntegration;
function _mergeOptions(_e={}, $={}) {
    return {
        allowUrls: [..._e.allowUrls || [], ...$.allowUrls || []],
        denyUrls: [..._e.denyUrls || [], ...$.denyUrls || []],
        ignoreErrors: [..._e.ignoreErrors || [], ...$.ignoreErrors || [], ..._e.disableErrorDefaults ? [] : DEFAULT_IGNORE_ERRORS],
        ignoreTransactions: [..._e.ignoreTransactions || [], ...$.ignoreTransactions || []],
        ignoreInternal: _e.ignoreInternal !== void 0 ? _e.ignoreInternal : !0
    }
}
function _shouldDropEvent$1(_e, $) {
    return $.ignoreInternal && _isSentryError(_e) ? (DEBUG_BUILD$3 && logger.warn(`Event dropped due to being internal Sentry Error.
Event: ${getEventDescription(_e)}`),
    !0) : _isIgnoredError(_e, $.ignoreErrors) ? (DEBUG_BUILD$3 && logger.warn(`Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${getEventDescription(_e)}`),
    !0) : _isUselessError(_e) ? (DEBUG_BUILD$3 && logger.warn(`Event dropped due to not having an error message, error type or stacktrace.
Event: ${getEventDescription(_e)}`),
    !0) : _isIgnoredTransaction(_e, $.ignoreTransactions) ? (DEBUG_BUILD$3 && logger.warn(`Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${getEventDescription(_e)}`),
    !0) : _isDeniedUrl(_e, $.denyUrls) ? (DEBUG_BUILD$3 && logger.warn(`Event dropped due to being matched by \`denyUrls\` option.
Event: ${getEventDescription(_e)}.
Url: ${_getEventFilterUrl(_e)}`),
    !0) : _isAllowedUrl(_e, $.allowUrls) ? !1 : (DEBUG_BUILD$3 && logger.warn(`Event dropped due to not being matched by \`allowUrls\` option.
Event: ${getEventDescription(_e)}.
Url: ${_getEventFilterUrl(_e)}`),
    !0)
}
function _isIgnoredError(_e, $) {
    return _e.type || !$ || !$.length ? !1 : getPossibleEventMessages(_e).some(et => stringMatchesSomePattern(et, $))
}
function _isIgnoredTransaction(_e, $) {
    if (_e.type !== "transaction" || !$ || !$.length)
        return !1;
    const et = _e.transaction;
    return et ? stringMatchesSomePattern(et, $) : !1
}
function _isDeniedUrl(_e, $) {
    if (!($ != null && $.length))
        return !1;
    const et = _getEventFilterUrl(_e);
    return et ? stringMatchesSomePattern(et, $) : !1
}
function _isAllowedUrl(_e, $) {
    if (!($ != null && $.length))
        return !0;
    const et = _getEventFilterUrl(_e);
    return et ? stringMatchesSomePattern(et, $) : !0
}
function _isSentryError(_e) {
    try {
        return _e.exception.values[0].type === "SentryError"
    } catch {}
    return !1
}
function _getLastValidUrl(_e=[]) {
    for (let $ = _e.length - 1; $ >= 0; $--) {
        const et = _e[$];
        if (et && et.filename !== "<anonymous>" && et.filename !== "[native code]")
            return et.filename || null
    }
    return null
}
function _getEventFilterUrl(_e) {
    try {
        let $;
        try {
            $ = _e.exception.values[0].stacktrace.frames
        } catch {}
        return $ ? _getLastValidUrl($) : null
    } catch {
        return DEBUG_BUILD$3 && logger.error(`Cannot extract url for event ${getEventDescription(_e)}`),
        null
    }
}
function _isUselessError(_e) {
    var $, et;
    return _e.type || !((et = ($ = _e.exception) == null ? void 0 : $.values) != null && et.length) ? !1 : !_e.message && !_e.exception.values.some(tt => tt.stacktrace || tt.type && tt.type !== "Error" || tt.value)
}
function applyAggregateErrorsToEvent(_e, $, et=250, tt, nt, rt, it) {
    var st;
    if (!((st = rt.exception) != null && st.values) || !it || !isInstanceOf(it.originalException, Error))
        return;
    const ot = rt.exception.values.length > 0 ? rt.exception.values[rt.exception.values.length - 1] : void 0;
    ot && (rt.exception.values = truncateAggregateExceptions(aggregateExceptionsFromError(_e, $, nt, it.originalException, tt, rt.exception.values, ot, 0), et))
}
function aggregateExceptionsFromError(_e, $, et, tt, nt, rt, it, ot) {
    if (rt.length >= et + 1)
        return rt;
    let st = [...rt];
    if (isInstanceOf(tt[nt], Error)) {
        applyExceptionGroupFieldsForParentException(it, ot);
        const lt = _e($, tt[nt])
          , ct = st.length;
        applyExceptionGroupFieldsForChildException(lt, nt, ct, ot),
        st = aggregateExceptionsFromError(_e, $, et, tt[nt], nt, [lt, ...st], lt, ct)
    }
    return Array.isArray(tt.errors) && tt.errors.forEach( (lt, ct) => {
        if (isInstanceOf(lt, Error)) {
            applyExceptionGroupFieldsForParentException(it, ot);
            const dt = _e($, lt)
              , pt = st.length;
            applyExceptionGroupFieldsForChildException(dt, `errors[${ct}]`, pt, ot),
            st = aggregateExceptionsFromError(_e, $, et, lt, nt, [dt, ...st], dt, pt)
        }
    }
    ),
    st
}
function applyExceptionGroupFieldsForParentException(_e, $) {
    _e.mechanism = _e.mechanism || {
        type: "generic",
        handled: !0
    },
    _e.mechanism = {
        ..._e.mechanism,
        ..._e.type === "AggregateError" && {
            is_exception_group: !0
        },
        exception_id: $
    }
}
function applyExceptionGroupFieldsForChildException(_e, $, et, tt) {
    _e.mechanism = _e.mechanism || {
        type: "generic",
        handled: !0
    },
    _e.mechanism = {
        ..._e.mechanism,
        type: "chained",
        source: $,
        exception_id: et,
        parent_id: tt
    }
}
function truncateAggregateExceptions(_e, $) {
    return _e.map(et => (et.value && (et.value = truncate(et.value, $)),
    et))
}
function addConsoleInstrumentationHandler(_e) {
    const $ = "console";
    addHandler($, _e),
    maybeInstrument($, instrumentConsole)
}
function instrumentConsole() {
    "console"in GLOBAL_OBJ && CONSOLE_LEVELS.forEach(function(_e) {
        _e in GLOBAL_OBJ.console && fill(GLOBAL_OBJ.console, _e, function($) {
            return originalConsoleMethods[_e] = $,
            function(...et) {
                triggerHandlers("console", {
                    args: et,
                    level: _e
                });
                const nt = originalConsoleMethods[_e];
                nt == null || nt.apply(GLOBAL_OBJ.console, et)
            }
        })
    })
}
function severityLevelFromString(_e) {
    return _e === "warn" ? "warning" : ["fatal", "error", "warning", "log", "info", "debug"].includes(_e) ? _e : "log"
}
const INTEGRATION_NAME$4 = "Dedupe"
  , _dedupeIntegration = () => {
    let _e;
    return {
        name: INTEGRATION_NAME$4,
        processEvent($) {
            if ($.type)
                return $;
            try {
                if (_shouldDropEvent($, _e))
                    return DEBUG_BUILD$3 && logger.warn("Event dropped due to being a duplicate of previously captured event."),
                    null
            } catch {}
            return _e = $
        }
    }
}
  , dedupeIntegration = _dedupeIntegration;
function _shouldDropEvent(_e, $) {
    return $ ? !!(_isSameMessageEvent(_e, $) || _isSameExceptionEvent(_e, $)) : !1
}
function _isSameMessageEvent(_e, $) {
    const et = _e.message
      , tt = $.message;
    return !(!et && !tt || et && !tt || !et && tt || et !== tt || !_isSameFingerprint(_e, $) || !_isSameStacktrace(_e, $))
}
function _isSameExceptionEvent(_e, $) {
    const et = _getExceptionFromEvent($)
      , tt = _getExceptionFromEvent(_e);
    return !(!et || !tt || et.type !== tt.type || et.value !== tt.value || !_isSameFingerprint(_e, $) || !_isSameStacktrace(_e, $))
}
function _isSameStacktrace(_e, $) {
    let et = getFramesFromEvent(_e)
      , tt = getFramesFromEvent($);
    if (!et && !tt)
        return !0;
    if (et && !tt || !et && tt || (et = et,
    tt = tt,
    tt.length !== et.length))
        return !1;
    for (let nt = 0; nt < tt.length; nt++) {
        const rt = tt[nt]
          , it = et[nt];
        if (rt.filename !== it.filename || rt.lineno !== it.lineno || rt.colno !== it.colno || rt.function !== it.function)
            return !1
    }
    return !0
}
function _isSameFingerprint(_e, $) {
    let et = _e.fingerprint
      , tt = $.fingerprint;
    if (!et && !tt)
        return !0;
    if (et && !tt || !et && tt)
        return !1;
    et = et,
    tt = tt;
    try {
        return et.join("") === tt.join("")
    } catch {
        return !1
    }
}
function _getExceptionFromEvent(_e) {
    var $;
    return (($ = _e.exception) == null ? void 0 : $.values) && _e.exception.values[0]
}
function parseUrl$1(_e) {
    if (!_e)
        return {};
    const $ = _e.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
    if (!$)
        return {};
    const et = $[6] || ""
      , tt = $[8] || "";
    return {
        host: $[4],
        path: $[5],
        protocol: $[2],
        search: et,
        hash: tt,
        relative: $[5] + et + tt
    }
}
function getBreadcrumbLogLevelFromHttpStatusCode(_e) {
    if (_e !== void 0)
        return _e >= 400 && _e < 500 ? "warning" : _e >= 500 ? "error" : void 0
}
const WINDOW$2 = GLOBAL_OBJ;
function supportsHistory() {
    return "history"in WINDOW$2
}
function supportsFetch() {
    if (!("fetch"in WINDOW$2))
        return !1;
    try {
        return new Headers,
        new Request("http://www.example.com"),
        new Response,
        !0
    } catch {
        return !1
    }
}
function isNativeFunction(_e) {
    return _e && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(_e.toString())
}
function supportsNativeFetch() {
    var et;
    if (typeof EdgeRuntime == "string")
        return !0;
    if (!supportsFetch())
        return !1;
    if (isNativeFunction(WINDOW$2.fetch))
        return !0;
    let _e = !1;
    const $ = WINDOW$2.document;
    if ($ && typeof $.createElement == "function")
        try {
            const tt = $.createElement("iframe");
            tt.hidden = !0,
            $.head.appendChild(tt),
            (et = tt.contentWindow) != null && et.fetch && (_e = isNativeFunction(tt.contentWindow.fetch)),
            $.head.removeChild(tt)
        } catch (tt) {
            DEBUG_BUILD$2 && logger.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", tt)
        }
    return _e
}
function addFetchInstrumentationHandler(_e, $) {
    const et = "fetch";
    addHandler(et, _e),
    maybeInstrument(et, () => instrumentFetch(void 0, $))
}
function instrumentFetch(_e, $=!1) {
    $ && !supportsNativeFetch() || fill(GLOBAL_OBJ, "fetch", function(et) {
        return function(...tt) {
            const nt = new Error
              , {method: rt, url: it} = parseFetchArgs(tt)
              , ot = {
                args: tt,
                fetchData: {
                    method: rt,
                    url: it
                },
                startTimestamp: timestampInSeconds() * 1e3,
                virtualError: nt
            };
            return triggerHandlers("fetch", {
                ...ot
            }),
            et.apply(GLOBAL_OBJ, tt).then(async st => (triggerHandlers("fetch", {
                ...ot,
                endTimestamp: timestampInSeconds() * 1e3,
                response: st
            }),
            st), st => {
                throw triggerHandlers("fetch", {
                    ...ot,
                    endTimestamp: timestampInSeconds() * 1e3,
                    error: st
                }),
                isError(st) && st.stack === void 0 && (st.stack = nt.stack,
                addNonEnumerableProperty(st, "framesToPop", 1)),
                st
            }
            )
        }
    })
}
function hasProp(_e, $) {
    return !!_e && typeof _e == "object" && !!_e[$]
}
function getUrlFromResource(_e) {
    return typeof _e == "string" ? _e : _e ? hasProp(_e, "url") ? _e.url : _e.toString ? _e.toString() : "" : ""
}
function parseFetchArgs(_e) {
    if (_e.length === 0)
        return {
            method: "GET",
            url: ""
        };
    if (_e.length === 2) {
        const [et,tt] = _e;
        return {
            url: getUrlFromResource(et),
            method: hasProp(tt, "method") ? String(tt.method).toUpperCase() : "GET"
        }
    }
    const $ = _e[0];
    return {
        url: getUrlFromResource($),
        method: hasProp($, "method") ? String($.method).toUpperCase() : "GET"
    }
}
function getSDKSource() {
    return "npm"
}
const WINDOW$1 = GLOBAL_OBJ;
let ignoreOnError = 0;
function shouldIgnoreOnError() {
    return ignoreOnError > 0
}
function ignoreNextOnError() {
    ignoreOnError++,
    setTimeout( () => {
        ignoreOnError--
    }
    )
}
function wrap(_e, $={}) {
    function et(nt) {
        return typeof nt == "function"
    }
    if (!et(_e))
        return _e;
    try {
        const nt = _e.__sentry_wrapped__;
        if (nt)
            return typeof nt == "function" ? nt : _e;
        if (getOriginalFunction(_e))
            return _e
    } catch {
        return _e
    }
    const tt = function(...nt) {
        try {
            const rt = nt.map(it => wrap(it, $));
            return _e.apply(this, rt)
        } catch (rt) {
            throw ignoreNextOnError(),
            withScope(it => {
                it.addEventProcessor(ot => ($.mechanism && (addExceptionTypeValue(ot, void 0),
                addExceptionMechanism(ot, $.mechanism)),
                ot.extra = {
                    ...ot.extra,
                    arguments: nt
                },
                ot)),
                captureException(rt)
            }
            ),
            rt
        }
    };
    try {
        for (const nt in _e)
            Object.prototype.hasOwnProperty.call(_e, nt) && (tt[nt] = _e[nt])
    } catch {}
    markFunctionWrapped(tt, _e),
    addNonEnumerableProperty(_e, "__sentry_wrapped__", tt);
    try {
        Object.getOwnPropertyDescriptor(tt, "name").configurable && Object.defineProperty(tt, "name", {
            get() {
                return _e.name
            }
        })
    } catch {}
    return tt
}
function exceptionFromError(_e, $) {
    const et = parseStackFrames(_e, $)
      , tt = {
        type: extractType($),
        value: extractMessage($)
    };
    return et.length && (tt.stacktrace = {
        frames: et
    }),
    tt.type === void 0 && tt.value === "" && (tt.value = "Unrecoverable error caught"),
    tt
}
function eventFromPlainObject(_e, $, et, tt) {
    const nt = getClient()
      , rt = nt == null ? void 0 : nt.getOptions().normalizeDepth
      , it = getErrorPropertyFromObject($)
      , ot = {
        __serialized__: normalizeToSize($, rt)
    };
    if (it)
        return {
            exception: {
                values: [exceptionFromError(_e, it)]
            },
            extra: ot
        };
    const st = {
        exception: {
            values: [{
                type: isEvent($) ? $.constructor.name : tt ? "UnhandledRejection" : "Error",
                value: getNonErrorObjectExceptionValue($, {
                    isUnhandledRejection: tt
                })
            }]
        },
        extra: ot
    };
    if (et) {
        const lt = parseStackFrames(_e, et);
        lt.length && (st.exception.values[0].stacktrace = {
            frames: lt
        })
    }
    return st
}
function eventFromError(_e, $) {
    return {
        exception: {
            values: [exceptionFromError(_e, $)]
        }
    }
}
function parseStackFrames(_e, $) {
    const et = $.stacktrace || $.stack || ""
      , tt = getSkipFirstStackStringLines($)
      , nt = getPopFirstTopFrames($);
    try {
        return _e(et, tt, nt)
    } catch {}
    return []
}
const reactMinifiedRegexp = /Minified React error #\d+;/i;
function getSkipFirstStackStringLines(_e) {
    return _e && reactMinifiedRegexp.test(_e.message) ? 1 : 0
}
function getPopFirstTopFrames(_e) {
    return typeof _e.framesToPop == "number" ? _e.framesToPop : 0
}
function isWebAssemblyException(_e) {
    return typeof WebAssembly < "u" && typeof WebAssembly.Exception < "u" ? _e instanceof WebAssembly.Exception : !1
}
function extractType(_e) {
    const $ = _e == null ? void 0 : _e.name;
    return !$ && isWebAssemblyException(_e) ? _e.message && Array.isArray(_e.message) && _e.message.length == 2 ? _e.message[0] : "WebAssembly.Exception" : $
}
function extractMessage(_e) {
    const $ = _e == null ? void 0 : _e.message;
    return isWebAssemblyException(_e) ? Array.isArray(_e.message) && _e.message.length == 2 ? _e.message[1] : "wasm exception" : $ ? $.error && typeof $.error.message == "string" ? $.error.message : $ : "No error message"
}
function eventFromException(_e, $, et, tt) {
    const nt = (et == null ? void 0 : et.syntheticException) || void 0
      , rt = eventFromUnknownInput(_e, $, nt, tt);
    return addExceptionMechanism(rt),
    rt.level = "error",
    et != null && et.event_id && (rt.event_id = et.event_id),
    resolvedSyncPromise(rt)
}
function eventFromMessage(_e, $, et="info", tt, nt) {
    const rt = (tt == null ? void 0 : tt.syntheticException) || void 0
      , it = eventFromString(_e, $, rt, nt);
    return it.level = et,
    tt != null && tt.event_id && (it.event_id = tt.event_id),
    resolvedSyncPromise(it)
}
function eventFromUnknownInput(_e, $, et, tt, nt) {
    let rt;
    if (isErrorEvent$1($) && $.error)
        return eventFromError(_e, $.error);
    if (isDOMError($) || isDOMException($)) {
        const it = $;
        if ("stack"in $)
            rt = eventFromError(_e, $);
        else {
            const ot = it.name || (isDOMError(it) ? "DOMError" : "DOMException")
              , st = it.message ? `${ot}: ${it.message}` : ot;
            rt = eventFromString(_e, st, et, tt),
            addExceptionTypeValue(rt, st)
        }
        return "code"in it && (rt.tags = {
            ...rt.tags,
            "DOMException.code": `${it.code}`
        }),
        rt
    }
    return isError($) ? eventFromError(_e, $) : isPlainObject($) || isEvent($) ? (rt = eventFromPlainObject(_e, $, et, nt),
    addExceptionMechanism(rt, {
        synthetic: !0
    }),
    rt) : (rt = eventFromString(_e, $, et, tt),
    addExceptionTypeValue(rt, `${$}`),
    addExceptionMechanism(rt, {
        synthetic: !0
    }),
    rt)
}
function eventFromString(_e, $, et, tt) {
    const nt = {};
    if (tt && et) {
        const rt = parseStackFrames(_e, et);
        rt.length && (nt.exception = {
            values: [{
                value: $,
                stacktrace: {
                    frames: rt
                }
            }]
        }),
        addExceptionMechanism(nt, {
            synthetic: !0
        })
    }
    if (isParameterizedString($)) {
        const {__sentry_template_string__: rt, __sentry_template_values__: it} = $;
        return nt.logentry = {
            message: rt,
            params: it
        },
        nt
    }
    return nt.message = $,
    nt
}
function getNonErrorObjectExceptionValue(_e, {isUnhandledRejection: $}) {
    const et = extractExceptionKeysForMessage(_e)
      , tt = $ ? "promise rejection" : "exception";
    return isErrorEvent$1(_e) ? `Event \`ErrorEvent\` captured as ${tt} with message \`${_e.message}\`` : isEvent(_e) ? `Event \`${getObjectClassName(_e)}\` (type=${_e.type}) captured as ${tt}` : `Object captured as ${tt} with keys: ${et}`
}
function getObjectClassName(_e) {
    try {
        const $ = Object.getPrototypeOf(_e);
        return $ ? $.constructor.name : void 0
    } catch {}
}
function getErrorPropertyFromObject(_e) {
    for (const $ in _e)
        if (Object.prototype.hasOwnProperty.call(_e, $)) {
            const et = _e[$];
            if (et instanceof Error)
                return et
        }
}
class BrowserClient extends Client {
    constructor($) {
        const et = {
            parentSpanIsAlwaysRootSpan: !0,
            ...$
        }
          , tt = WINDOW$1.SENTRY_SDK_SOURCE || getSDKSource();
        applySdkMetadata(et, "browser", ["browser"], tt),
        super(et),
        et.sendClientReports && WINDOW$1.document && WINDOW$1.document.addEventListener("visibilitychange", () => {
            WINDOW$1.document.visibilityState === "hidden" && this._flushOutcomes()
        }
        ),
        this._options.sendDefaultPii && (this.on("postprocessEvent", addAutoIpAddressToUser),
        this.on("beforeSendSession", addAutoIpAddressToSession))
    }
    eventFromException($, et) {
        return eventFromException(this._options.stackParser, $, et, this._options.attachStacktrace)
    }
    eventFromMessage($, et="info", tt) {
        return eventFromMessage(this._options.stackParser, $, et, tt, this._options.attachStacktrace)
    }
    _prepareEvent($, et, tt, nt) {
        return $.platform = $.platform || "javascript",
        super._prepareEvent($, et, tt, nt)
    }
}
const DEBUG_BUILD$1 = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
  , WINDOW = GLOBAL_OBJ
  , DEBOUNCE_DURATION = 1e3;
let debounceTimerID, lastCapturedEventType, lastCapturedEventTargetId;
function addClickKeypressInstrumentationHandler(_e) {
    const $ = "dom";
    addHandler($, _e),
    maybeInstrument($, instrumentDOM)
}
function instrumentDOM() {
    if (!WINDOW.document)
        return;
    const _e = triggerHandlers.bind(null, "dom")
      , $ = makeDOMEventHandler(_e, !0);
    WINDOW.document.addEventListener("click", $, !1),
    WINDOW.document.addEventListener("keypress", $, !1),
    ["EventTarget", "Node"].forEach(et => {
        var rt, it;
        const nt = (rt = WINDOW[et]) == null ? void 0 : rt.prototype;
        (it = nt == null ? void 0 : nt.hasOwnProperty) != null && it.call(nt, "addEventListener") && (fill(nt, "addEventListener", function(ot) {
            return function(st, lt, ct) {
                if (st === "click" || st == "keypress")
                    try {
                        const dt = this.__sentry_instrumentation_handlers__ = this.__sentry_instrumentation_handlers__ || {}
                          , pt = dt[st] = dt[st] || {
                            refCount: 0
                        };
                        if (!pt.handler) {
                            const ht = makeDOMEventHandler(_e);
                            pt.handler = ht,
                            ot.call(this, st, ht, ct)
                        }
                        pt.refCount++
                    } catch {}
                return ot.call(this, st, lt, ct)
            }
        }),
        fill(nt, "removeEventListener", function(ot) {
            return function(st, lt, ct) {
                if (st === "click" || st == "keypress")
                    try {
                        const dt = this.__sentry_instrumentation_handlers__ || {}
                          , pt = dt[st];
                        pt && (pt.refCount--,
                        pt.refCount <= 0 && (ot.call(this, st, pt.handler, ct),
                        pt.handler = void 0,
                        delete dt[st]),
                        Object.keys(dt).length === 0 && delete this.__sentry_instrumentation_handlers__)
                    } catch {}
                return ot.call(this, st, lt, ct)
            }
        }))
    }
    )
}
function isSimilarToLastCapturedEvent(_e) {
    if (_e.type !== lastCapturedEventType)
        return !1;
    try {
        if (!_e.target || _e.target._sentryId !== lastCapturedEventTargetId)
            return !1
    } catch {}
    return !0
}
function shouldSkipDOMEvent(_e, $) {
    return _e !== "keypress" ? !1 : $ != null && $.tagName ? !($.tagName === "INPUT" || $.tagName === "TEXTAREA" || $.isContentEditable) : !0
}
function makeDOMEventHandler(_e, $=!1) {
    return et => {
        if (!et || et._sentryCaptured)
            return;
        const tt = getEventTarget(et);
        if (shouldSkipDOMEvent(et.type, tt))
            return;
        addNonEnumerableProperty(et, "_sentryCaptured", !0),
        tt && !tt._sentryId && addNonEnumerableProperty(tt, "_sentryId", uuid4());
        const nt = et.type === "keypress" ? "input" : et.type;
        isSimilarToLastCapturedEvent(et) || (_e({
            event: et,
            name: nt,
            global: $
        }),
        lastCapturedEventType = et.type,
        lastCapturedEventTargetId = tt ? tt._sentryId : void 0),
        clearTimeout(debounceTimerID),
        debounceTimerID = WINDOW.setTimeout( () => {
            lastCapturedEventTargetId = void 0,
            lastCapturedEventType = void 0
        }
        , DEBOUNCE_DURATION)
    }
}
function getEventTarget(_e) {
    try {
        return _e.target
    } catch {
        return null
    }
}
let lastHref;
function addHistoryInstrumentationHandler(_e) {
    const $ = "history";
    addHandler($, _e),
    maybeInstrument($, instrumentHistory)
}
function instrumentHistory() {
    if (WINDOW.addEventListener("popstate", () => {
        const $ = WINDOW.location.href
          , et = lastHref;
        if (lastHref = $,
        et === $)
            return;
        triggerHandlers("history", {
            from: et,
            to: $
        })
    }
    ),
    !supportsHistory())
        return;
    function _e($) {
        return function(...et) {
            const tt = et.length > 2 ? et[2] : void 0;
            if (tt) {
                const nt = lastHref
                  , rt = String(tt);
                if (lastHref = rt,
                nt === rt)
                    return;
                triggerHandlers("history", {
                    from: nt,
                    to: rt
                })
            }
            return $.apply(this, et)
        }
    }
    fill(WINDOW.history, "pushState", _e),
    fill(WINDOW.history, "replaceState", _e)
}
const cachedImplementations = {};
function getNativeImplementation(_e) {
    const $ = cachedImplementations[_e];
    if ($)
        return $;
    let et = WINDOW[_e];
    if (isNativeFunction(et))
        return cachedImplementations[_e] = et.bind(WINDOW);
    const tt = WINDOW.document;
    if (tt && typeof tt.createElement == "function")
        try {
            const nt = tt.createElement("iframe");
            nt.hidden = !0,
            tt.head.appendChild(nt);
            const rt = nt.contentWindow;
            rt != null && rt[_e] && (et = rt[_e]),
            tt.head.removeChild(nt)
        } catch (nt) {
            DEBUG_BUILD$1 && logger.warn(`Could not create sandbox iframe for ${_e} check, bailing to window.${_e}: `, nt)
        }
    return et && (cachedImplementations[_e] = et.bind(WINDOW))
}
function clearCachedImplementation(_e) {
    cachedImplementations[_e] = void 0
}
const SENTRY_XHR_DATA_KEY = "__sentry_xhr_v3__";
function addXhrInstrumentationHandler(_e) {
    const $ = "xhr";
    addHandler($, _e),
    maybeInstrument($, instrumentXHR)
}
function instrumentXHR() {
    if (!WINDOW.XMLHttpRequest)
        return;
    const _e = XMLHttpRequest.prototype;
    _e.open = new Proxy(_e.open,{
        apply($, et, tt) {
            const nt = new Error
              , rt = timestampInSeconds() * 1e3
              , it = isString(tt[0]) ? tt[0].toUpperCase() : void 0
              , ot = parseUrl(tt[1]);
            if (!it || !ot)
                return $.apply(et, tt);
            et[SENTRY_XHR_DATA_KEY] = {
                method: it,
                url: ot,
                request_headers: {}
            },
            it === "POST" && ot.match(/sentry_key/) && (et.__sentry_own_request__ = !0);
            const st = () => {
                const lt = et[SENTRY_XHR_DATA_KEY];
                if (lt && et.readyState === 4) {
                    try {
                        lt.status_code = et.status
                    } catch {}
                    const ct = {
                        endTimestamp: timestampInSeconds() * 1e3,
                        startTimestamp: rt,
                        xhr: et,
                        virtualError: nt
                    };
                    triggerHandlers("xhr", ct)
                }
            }
            ;
            return "onreadystatechange"in et && typeof et.onreadystatechange == "function" ? et.onreadystatechange = new Proxy(et.onreadystatechange,{
                apply(lt, ct, dt) {
                    return st(),
                    lt.apply(ct, dt)
                }
            }) : et.addEventListener("readystatechange", st),
            et.setRequestHeader = new Proxy(et.setRequestHeader,{
                apply(lt, ct, dt) {
                    const [pt,ht] = dt
                      , mt = ct[SENTRY_XHR_DATA_KEY];
                    return mt && isString(pt) && isString(ht) && (mt.request_headers[pt.toLowerCase()] = ht),
                    lt.apply(ct, dt)
                }
            }),
            $.apply(et, tt)
        }
    }),
    _e.send = new Proxy(_e.send,{
        apply($, et, tt) {
            const nt = et[SENTRY_XHR_DATA_KEY];
            if (!nt)
                return $.apply(et, tt);
            tt[0] !== void 0 && (nt.body = tt[0]);
            const rt = {
                startTimestamp: timestampInSeconds() * 1e3,
                xhr: et
            };
            return triggerHandlers("xhr", rt),
            $.apply(et, tt)
        }
    })
}
function parseUrl(_e) {
    if (isString(_e))
        return _e;
    try {
        return _e.toString()
    } catch {}
}
function makeFetchTransport(_e, $=getNativeImplementation("fetch")) {
    let et = 0
      , tt = 0;
    function nt(rt) {
        const it = rt.body.length;
        et += it,
        tt++;
        const ot = {
            body: rt.body,
            method: "POST",
            referrerPolicy: "strict-origin",
            headers: _e.headers,
            keepalive: et <= 6e4 && tt < 15,
            ..._e.fetchOptions
        };
        if (!$)
            return clearCachedImplementation("fetch"),
            rejectedSyncPromise("No fetch implementation available");
        try {
            return $(_e.url, ot).then(st => (et -= it,
            tt--,
            {
                statusCode: st.status,
                headers: {
                    "x-sentry-rate-limits": st.headers.get("X-Sentry-Rate-Limits"),
                    "retry-after": st.headers.get("Retry-After")
                }
            }))
        } catch (st) {
            return clearCachedImplementation("fetch"),
            et -= it,
            tt--,
            rejectedSyncPromise(st)
        }
    }
    return createTransport(_e, nt)
}
const CHROME_PRIORITY = 30
  , GECKO_PRIORITY = 50;
function createFrame(_e, $, et, tt) {
    const nt = {
        filename: _e,
        function: $ === "<anonymous>" ? UNKNOWN_FUNCTION : $,
        in_app: !0
    };
    return et !== void 0 && (nt.lineno = et),
    tt !== void 0 && (nt.colno = tt),
    nt
}
const chromeRegexNoFnName = /^\s*at (\S+?)(?::(\d+))(?::(\d+))\s*$/i
  , chromeRegex = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i
  , chromeEvalRegex = /\((\S*)(?::(\d+))(?::(\d+))\)/
  , chromeStackParserFn = _e => {
    const $ = chromeRegexNoFnName.exec(_e);
    if ($) {
        const [,tt,nt,rt] = $;
        return createFrame(tt, UNKNOWN_FUNCTION, +nt, +rt)
    }
    const et = chromeRegex.exec(_e);
    if (et) {
        if (et[2] && et[2].indexOf("eval") === 0) {
            const it = chromeEvalRegex.exec(et[2]);
            it && (et[2] = it[1],
            et[3] = it[2],
            et[4] = it[3])
        }
        const [nt,rt] = extractSafariExtensionDetails(et[1] || UNKNOWN_FUNCTION, et[2]);
        return createFrame(rt, nt, et[3] ? +et[3] : void 0, et[4] ? +et[4] : void 0)
    }
}
  , chromeStackLineParser = [CHROME_PRIORITY, chromeStackParserFn]
  , geckoREgex = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i
  , geckoEvalRegex = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i
  , gecko = _e => {
    const $ = geckoREgex.exec(_e);
    if ($) {
        if ($[3] && $[3].indexOf(" > eval") > -1) {
            const rt = geckoEvalRegex.exec($[3]);
            rt && ($[1] = $[1] || "eval",
            $[3] = rt[1],
            $[4] = rt[2],
            $[5] = "")
        }
        let tt = $[3]
          , nt = $[1] || UNKNOWN_FUNCTION;
        return [nt,tt] = extractSafariExtensionDetails(nt, tt),
        createFrame(tt, nt, $[4] ? +$[4] : void 0, $[5] ? +$[5] : void 0)
    }
}
  , geckoStackLineParser = [GECKO_PRIORITY, gecko]
  , defaultStackLineParsers = [chromeStackLineParser, geckoStackLineParser]
  , defaultStackParser = createStackParser(...defaultStackLineParsers)
  , extractSafariExtensionDetails = (_e, $) => {
    const et = _e.indexOf("safari-extension") !== -1
      , tt = _e.indexOf("safari-web-extension") !== -1;
    return et || tt ? [_e.indexOf("@") !== -1 ? _e.split("@")[0] : UNKNOWN_FUNCTION, et ? `safari-extension:${$}` : `safari-web-extension:${$}`] : [_e, $]
}
  , DEBUG_BUILD = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__
  , MAX_ALLOWED_STRING_LENGTH = 1024
  , INTEGRATION_NAME$3 = "Breadcrumbs"
  , _breadcrumbsIntegration = (_e={}) => {
    const $ = {
        console: !0,
        dom: !0,
        fetch: !0,
        history: !0,
        sentry: !0,
        xhr: !0,
        ..._e
    };
    return {
        name: INTEGRATION_NAME$3,
        setup(et) {
            $.console && addConsoleInstrumentationHandler(_getConsoleBreadcrumbHandler(et)),
            $.dom && addClickKeypressInstrumentationHandler(_getDomBreadcrumbHandler(et, $.dom)),
            $.xhr && addXhrInstrumentationHandler(_getXhrBreadcrumbHandler(et)),
            $.fetch && addFetchInstrumentationHandler(_getFetchBreadcrumbHandler(et)),
            $.history && addHistoryInstrumentationHandler(_getHistoryBreadcrumbHandler(et)),
            $.sentry && et.on("beforeSendEvent", _getSentryBreadcrumbHandler(et))
        }
    }
}
  , breadcrumbsIntegration = _breadcrumbsIntegration;
function _getSentryBreadcrumbHandler(_e) {
    return function(et) {
        getClient() === _e && addBreadcrumb({
            category: `sentry.${et.type === "transaction" ? "transaction" : "event"}`,
            event_id: et.event_id,
            level: et.level,
            message: getEventDescription(et)
        }, {
            event: et
        })
    }
}
function _getDomBreadcrumbHandler(_e, $) {
    return function(tt) {
        if (getClient() !== _e)
            return;
        let nt, rt, it = typeof $ == "object" ? $.serializeAttribute : void 0, ot = typeof $ == "object" && typeof $.maxStringLength == "number" ? $.maxStringLength : void 0;
        ot && ot > MAX_ALLOWED_STRING_LENGTH && (DEBUG_BUILD && logger.warn(`\`dom.maxStringLength\` cannot exceed ${MAX_ALLOWED_STRING_LENGTH}, but a value of ${ot} was configured. Sentry will use ${MAX_ALLOWED_STRING_LENGTH} instead.`),
        ot = MAX_ALLOWED_STRING_LENGTH),
        typeof it == "string" && (it = [it]);
        try {
            const lt = tt.event
              , ct = _isEvent(lt) ? lt.target : lt;
            nt = htmlTreeAsString(ct, {
                keyAttrs: it,
                maxStringLength: ot
            }),
            rt = getComponentName(ct)
        } catch {
            nt = "<unknown>"
        }
        if (nt.length === 0)
            return;
        const st = {
            category: `ui.${tt.name}`,
            message: nt
        };
        rt && (st.data = {
            "ui.component_name": rt
        }),
        addBreadcrumb(st, {
            event: tt.event,
            name: tt.name,
            global: tt.global
        })
    }
}
function _getConsoleBreadcrumbHandler(_e) {
    return function(et) {
        if (getClient() !== _e)
            return;
        const tt = {
            category: "console",
            data: {
                arguments: et.args,
                logger: "console"
            },
            level: severityLevelFromString(et.level),
            message: safeJoin(et.args, " ")
        };
        if (et.level === "assert")
            if (et.args[0] === !1)
                tt.message = `Assertion failed: ${safeJoin(et.args.slice(1), " ") || "console.assert"}`,
                tt.data.arguments = et.args.slice(1);
            else
                return;
        addBreadcrumb(tt, {
            input: et.args,
            level: et.level
        })
    }
}
function _getXhrBreadcrumbHandler(_e) {
    return function(et) {
        if (getClient() !== _e)
            return;
        const {startTimestamp: tt, endTimestamp: nt} = et
          , rt = et.xhr[SENTRY_XHR_DATA_KEY];
        if (!tt || !nt || !rt)
            return;
        const {method: it, url: ot, status_code: st, body: lt} = rt
          , ct = {
            method: it,
            url: ot,
            status_code: st
        }
          , dt = {
            xhr: et.xhr,
            input: lt,
            startTimestamp: tt,
            endTimestamp: nt
        }
          , pt = {
            category: "xhr",
            data: ct,
            type: "http",
            level: getBreadcrumbLogLevelFromHttpStatusCode(st)
        };
        _e.emit("beforeOutgoingRequestBreadcrumb", pt, dt),
        addBreadcrumb(pt, dt)
    }
}
function _getFetchBreadcrumbHandler(_e) {
    return function(et) {
        if (getClient() !== _e)
            return;
        const {startTimestamp: tt, endTimestamp: nt} = et;
        if (nt && !(et.fetchData.url.match(/sentry_key/) && et.fetchData.method === "POST"))
            if (et.fetchData.method,
            et.fetchData.url,
            et.error) {
                const rt = et.fetchData
                  , it = {
                    data: et.error,
                    input: et.args,
                    startTimestamp: tt,
                    endTimestamp: nt
                }
                  , ot = {
                    category: "fetch",
                    data: rt,
                    level: "error",
                    type: "http"
                };
                _e.emit("beforeOutgoingRequestBreadcrumb", ot, it),
                addBreadcrumb(ot, it)
            } else {
                const rt = et.response
                  , it = {
                    ...et.fetchData,
                    status_code: rt == null ? void 0 : rt.status
                };
                et.fetchData.request_body_size,
                et.fetchData.response_body_size,
                rt == null || rt.status;
                const ot = {
                    input: et.args,
                    response: rt,
                    startTimestamp: tt,
                    endTimestamp: nt
                }
                  , st = {
                    category: "fetch",
                    data: it,
                    type: "http",
                    level: getBreadcrumbLogLevelFromHttpStatusCode(it.status_code)
                };
                _e.emit("beforeOutgoingRequestBreadcrumb", st, ot),
                addBreadcrumb(st, ot)
            }
    }
}
function _getHistoryBreadcrumbHandler(_e) {
    return function(et) {
        if (getClient() !== _e)
            return;
        let tt = et.from
          , nt = et.to;
        const rt = parseUrl$1(WINDOW$1.location.href);
        let it = tt ? parseUrl$1(tt) : void 0;
        const ot = parseUrl$1(nt);
        it != null && it.path || (it = rt),
        rt.protocol === ot.protocol && rt.host === ot.host && (nt = ot.relative),
        rt.protocol === it.protocol && rt.host === it.host && (tt = it.relative),
        addBreadcrumb({
            category: "navigation",
            data: {
                from: tt,
                to: nt
            }
        })
    }
}
function _isEvent(_e) {
    return !!_e && !!_e.target
}
const DEFAULT_EVENT_TARGET = ["EventTarget", "Window", "Node", "ApplicationCache", "AudioTrackList", "BroadcastChannel", "ChannelMergerNode", "CryptoOperation", "EventSource", "FileReader", "HTMLUnknownElement", "IDBDatabase", "IDBRequest", "IDBTransaction", "KeyOperation", "MediaController", "MessagePort", "ModalWindow", "Notification", "SVGElementInstance", "Screen", "SharedWorker", "TextTrack", "TextTrackCue", "TextTrackList", "WebSocket", "WebSocketWorker", "Worker", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestUpload"]
  , INTEGRATION_NAME$2 = "BrowserApiErrors"
  , _browserApiErrorsIntegration = (_e={}) => {
    const $ = {
        XMLHttpRequest: !0,
        eventTarget: !0,
        requestAnimationFrame: !0,
        setInterval: !0,
        setTimeout: !0,
        ..._e
    };
    return {
        name: INTEGRATION_NAME$2,
        setupOnce() {
            $.setTimeout && fill(WINDOW$1, "setTimeout", _wrapTimeFunction),
            $.setInterval && fill(WINDOW$1, "setInterval", _wrapTimeFunction),
            $.requestAnimationFrame && fill(WINDOW$1, "requestAnimationFrame", _wrapRAF),
            $.XMLHttpRequest && "XMLHttpRequest"in WINDOW$1 && fill(XMLHttpRequest.prototype, "send", _wrapXHR);
            const et = $.eventTarget;
            et && (Array.isArray(et) ? et : DEFAULT_EVENT_TARGET).forEach(_wrapEventTarget)
        }
    }
}
  , browserApiErrorsIntegration = _browserApiErrorsIntegration;
function _wrapTimeFunction(_e) {
    return function(...$) {
        const et = $[0];
        return $[0] = wrap(et, {
            mechanism: {
                data: {
                    function: getFunctionName(_e)
                },
                handled: !1,
                type: "instrument"
            }
        }),
        _e.apply(this, $)
    }
}
function _wrapRAF(_e) {
    return function($) {
        return _e.apply(this, [wrap($, {
            mechanism: {
                data: {
                    function: "requestAnimationFrame",
                    handler: getFunctionName(_e)
                },
                handled: !1,
                type: "instrument"
            }
        })])
    }
}
function _wrapXHR(_e) {
    return function(...$) {
        const et = this;
        return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach(nt => {
            nt in et && typeof et[nt] == "function" && fill(et, nt, function(rt) {
                const it = {
                    mechanism: {
                        data: {
                            function: nt,
                            handler: getFunctionName(rt)
                        },
                        handled: !1,
                        type: "instrument"
                    }
                }
                  , ot = getOriginalFunction(rt);
                return ot && (it.mechanism.data.handler = getFunctionName(ot)),
                wrap(rt, it)
            })
        }
        ),
        _e.apply(this, $)
    }
}
function _wrapEventTarget(_e) {
    var tt, nt;
    const et = (tt = WINDOW$1[_e]) == null ? void 0 : tt.prototype;
    (nt = et == null ? void 0 : et.hasOwnProperty) != null && nt.call(et, "addEventListener") && (fill(et, "addEventListener", function(rt) {
        return function(it, ot, st) {
            try {
                isEventListenerObject(ot) && (ot.handleEvent = wrap(ot.handleEvent, {
                    mechanism: {
                        data: {
                            function: "handleEvent",
                            handler: getFunctionName(ot),
                            target: _e
                        },
                        handled: !1,
                        type: "instrument"
                    }
                }))
            } catch {}
            return rt.apply(this, [it, wrap(ot, {
                mechanism: {
                    data: {
                        function: "addEventListener",
                        handler: getFunctionName(ot),
                        target: _e
                    },
                    handled: !1,
                    type: "instrument"
                }
            }), st])
        }
    }),
    fill(et, "removeEventListener", function(rt) {
        return function(it, ot, st) {
            try {
                const lt = ot.__sentry_wrapped__;
                lt && rt.call(this, it, lt, st)
            } catch {}
            return rt.call(this, it, ot, st)
        }
    }))
}
function isEventListenerObject(_e) {
    return typeof _e.handleEvent == "function"
}
const browserSessionIntegration = () => ({
    name: "BrowserSession",
    setupOnce() {
        if (typeof WINDOW$1.document > "u") {
            DEBUG_BUILD && logger.warn("Using the `browserSessionIntegration` in non-browser environments is not supported.");
            return
        }
        startSession({
            ignoreDuration: !0
        }),
        captureSession(),
        addHistoryInstrumentationHandler( ({from: _e, to: $}) => {
            _e !== void 0 && _e !== $ && (startSession({
                ignoreDuration: !0
            }),
            captureSession())
        }
        )
    }
})
  , INTEGRATION_NAME$1 = "GlobalHandlers"
  , _globalHandlersIntegration = (_e={}) => {
    const $ = {
        onerror: !0,
        onunhandledrejection: !0,
        ..._e
    };
    return {
        name: INTEGRATION_NAME$1,
        setupOnce() {
            Error.stackTraceLimit = 50
        },
        setup(et) {
            $.onerror && (_installGlobalOnErrorHandler(et),
            globalHandlerLog("onerror")),
            $.onunhandledrejection && (_installGlobalOnUnhandledRejectionHandler(et),
            globalHandlerLog("onunhandledrejection"))
        }
    }
}
  , globalHandlersIntegration = _globalHandlersIntegration;
function _installGlobalOnErrorHandler(_e) {
    addGlobalErrorInstrumentationHandler($ => {
        const {stackParser: et, attachStacktrace: tt} = getOptions();
        if (getClient() !== _e || shouldIgnoreOnError())
            return;
        const {msg: nt, url: rt, line: it, column: ot, error: st} = $
          , lt = _enhanceEventWithInitialFrame(eventFromUnknownInput(et, st || nt, void 0, tt, !1), rt, it, ot);
        lt.level = "error",
        captureEvent(lt, {
            originalException: st,
            mechanism: {
                handled: !1,
                type: "onerror"
            }
        })
    }
    )
}
function _installGlobalOnUnhandledRejectionHandler(_e) {
    addGlobalUnhandledRejectionInstrumentationHandler($ => {
        const {stackParser: et, attachStacktrace: tt} = getOptions();
        if (getClient() !== _e || shouldIgnoreOnError())
            return;
        const nt = _getUnhandledRejectionError($)
          , rt = isPrimitive(nt) ? _eventFromRejectionWithPrimitive(nt) : eventFromUnknownInput(et, nt, void 0, tt, !0);
        rt.level = "error",
        captureEvent(rt, {
            originalException: nt,
            mechanism: {
                handled: !1,
                type: "onunhandledrejection"
            }
        })
    }
    )
}
function _getUnhandledRejectionError(_e) {
    if (isPrimitive(_e))
        return _e;
    try {
        if ("reason"in _e)
            return _e.reason;
        if ("detail"in _e && "reason"in _e.detail)
            return _e.detail.reason
    } catch {}
    return _e
}
function _eventFromRejectionWithPrimitive(_e) {
    return {
        exception: {
            values: [{
                type: "UnhandledRejection",
                value: `Non-Error promise rejection captured with value: ${String(_e)}`
            }]
        }
    }
}
function _enhanceEventWithInitialFrame(_e, $, et, tt) {
    const nt = _e.exception = _e.exception || {}
      , rt = nt.values = nt.values || []
      , it = rt[0] = rt[0] || {}
      , ot = it.stacktrace = it.stacktrace || {}
      , st = ot.frames = ot.frames || []
      , lt = tt
      , ct = et
      , dt = isString($) && $.length > 0 ? $ : getLocationHref();
    return st.length === 0 && st.push({
        colno: lt,
        filename: dt,
        function: UNKNOWN_FUNCTION,
        in_app: !0,
        lineno: ct
    }),
    _e
}
function globalHandlerLog(_e) {
    DEBUG_BUILD && logger.log(`Global Handler attached: ${_e}`)
}
function getOptions() {
    const _e = getClient();
    return (_e == null ? void 0 : _e.getOptions()) || {
        stackParser: () => [],
        attachStacktrace: !1
    }
}
const httpContextIntegration = () => ({
    name: "HttpContext",
    preprocessEvent(_e) {
        var it, ot;
        if (!WINDOW$1.navigator && !WINDOW$1.location && !WINDOW$1.document)
            return;
        const $ = ((it = _e.request) == null ? void 0 : it.url) || getLocationHref()
          , {referrer: et} = WINDOW$1.document || {}
          , {userAgent: tt} = WINDOW$1.navigator || {}
          , nt = {
            ...(ot = _e.request) == null ? void 0 : ot.headers,
            ...et && {
                Referer: et
            },
            ...tt && {
                "User-Agent": tt
            }
        }
          , rt = {
            ..._e.request,
            ...$ && {
                url: $
            },
            headers: nt
        };
        _e.request = rt
    }
})
  , DEFAULT_KEY = "cause"
  , DEFAULT_LIMIT = 5
  , INTEGRATION_NAME = "LinkedErrors"
  , _linkedErrorsIntegration = (_e={}) => {
    const $ = _e.limit || DEFAULT_LIMIT
      , et = _e.key || DEFAULT_KEY;
    return {
        name: INTEGRATION_NAME,
        preprocessEvent(tt, nt, rt) {
            const it = rt.getOptions();
            applyAggregateErrorsToEvent(exceptionFromError, it.stackParser, it.maxValueLength, et, $, tt, nt)
        }
    }
}
  , linkedErrorsIntegration = _linkedErrorsIntegration;
function getDefaultIntegrations(_e) {
    return [inboundFiltersIntegration(), functionToStringIntegration(), browserApiErrorsIntegration(), breadcrumbsIntegration(), globalHandlersIntegration(), linkedErrorsIntegration(), dedupeIntegration(), httpContextIntegration(), browserSessionIntegration()]
}
function applyDefaultOptions(_e={}) {
    var et;
    return {
        ...{
            defaultIntegrations: getDefaultIntegrations(),
            release: typeof __SENTRY_RELEASE__ == "string" ? __SENTRY_RELEASE__ : (et = WINDOW$1.SENTRY_RELEASE) == null ? void 0 : et.id,
            sendClientReports: !0
        },
        ...dropTopLevelUndefinedKeys(_e)
    }
}
function dropTopLevelUndefinedKeys(_e) {
    const $ = {};
    for (const et of Object.getOwnPropertyNames(_e)) {
        const tt = et;
        _e[tt] !== void 0 && ($[tt] = _e[tt])
    }
    return $
}
function shouldShowBrowserExtensionError() {
    var st;
    const _e = typeof WINDOW$1.window < "u" && WINDOW$1;
    if (!_e)
        return !1;
    const $ = _e.chrome ? "chrome" : "browser"
      , et = _e[$]
      , tt = (st = et == null ? void 0 : et.runtime) == null ? void 0 : st.id
      , nt = getLocationHref() || ""
      , rt = ["chrome-extension:", "moz-extension:", "ms-browser-extension:", "safari-web-extension:"]
      , it = !!tt && WINDOW$1 === WINDOW$1.top && rt.some(lt => nt.startsWith(`${lt}//`))
      , ot = typeof _e.nw < "u";
    return !!tt && !it && !ot
}
function init$1(_e={}) {
    const $ = applyDefaultOptions(_e);
    if (!$.skipBrowserExtensionCheck && shouldShowBrowserExtensionError()) {
        DEBUG_BUILD && consoleSandbox( () => {}
        );
        return
    }
    DEBUG_BUILD && !supportsFetch() && logger.warn("No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill.");
    const et = {
        ...$,
        stackParser: stackParserFromStackParserOptions($.stackParser || defaultStackParser),
        integrations: getIntegrationsToSetup($),
        transport: $.transport || makeFetchTransport
    };
    return initAndBind(BrowserClient, et)
}
function init(_e) {
    const $ = {
        ..._e
    };
    return applySdkMetadata($, "react"),
    setContext("react", {
        version: reactExports.version
    }),
    init$1($)
}
typeof structuredClone != "function" && (globalThis.structuredClone = _e => JSON.parse(JSON.stringify(_e)));
Object.hasOwn || (Object.hasOwn = (_e, $) => Object.prototype.hasOwnProperty.call(_e, $));
dayjs.extend(utc);
dayjs.extend(timezone);
dayjs.locale("en");
dayjs.extend(duration);
dayjs.extend(updateLocale);
dayjs.extend(relativeTime, {
    thresholds: [{
        l: "s",
        r: 1
    }, {
        l: "ss",
        r: 59,
        d: "second"
    }, {
        l: "m",
        r: 1
    }, {
        l: "mm",
        r: 59,
        d: "minute"
    }, {
        l: "h",
        r: 1
    }, {
        l: "hh",
        r: 23,
        d: "hour"
    }, {
        l: "d",
        r: 1
    }, {
        l: "dd",
        r: 30,
        d: "day"
    }, {
        l: "M",
        r: 1
    }, {
        l: "MM",
        r: 11,
        d: "month"
    }, {
        l: "y",
        r: 1
    }, {
        l: "yy",
        d: "year"
    }]
});
dayjs.updateLocale("zh-cn", {
    relativeTime: {
        future: "%s",
        past: "%s",
        s: "%d",
        ss: "%",
        m: "%d",
        mm: "%d",
        h: "%d",
        hh: "%d",
        d: "%d",
        dd: "%d",
        w: "%d",
        ww: "%d",
        M: "%d",
        MM: "%d",
        y: "%d",
        yy: "%d"
    }
});
init({
    dsn: "https://afe157cfbe205ba9f1cf5dd1a016a428@o4508886041362432.ingest.us.sentry.io/4508886061481985",
    ignoreErrors: ["ResizeObserver loop limit exceeded", "Script error.", "Non-Error promise rejection captured"],
    denyUrls: [/.*google-analytics\.com/i, /.*chrome-extension/i],
    beforeBreadcrumb(_e, $) {
        return _e.category === "console" && _e.message.includes("[DEBUG]") || _e.category === "xhr" && _e.data.url.includes("/health-check") ? null : _e
    },
    beforeSend(_e, $) {
        return Env.production !== "production" ? null : _e
    }
});
dayjs.updateLocale("en", {
    relativeTime: {
        future: "in %s",
        past: "%s ago",
        s: "a few seconds",
        ss: "a few seconds",
        m: "%dmin",
        mm: "%dmin",
        h: "%dh",
        hh: "%dh",
        d: "%dd",
        dd: "%dd",
        w: "%d week",
        ww: "%d weeks",
        M: "%dmth",
        MM: "%dmth",
        y: "%dyr",
        yy: "%dyr"
    }
});
createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsxs(BrowserRouter, {
    children: [jsxRuntimeExports.jsx(App, {}), jsxRuntimeExports.jsx(Updater, {})]
}));
export {solIcon as $, API_Code as A, Box as B, isGreaterThanOrEqual as C, Dom_Size as D, Button as E, Sort_Direction as F, isGreaterThan as G, formatNativeBalance as H, i18n as I, formatTokenBalance as J, DEFAULT_TOKEN_DECIMALS as K, LAMPORTS_PER_SOL$1 as L, Market_Type as M, GLOBAL_INTERVAL_TIMEOUT as N, Trending_Type as O, PLATFORM_TOKEN as P, IconButton as Q, React as R, SectionLoadingContainer as S, Typography as T, formatLinkUrl as U, Vt as V, TelegramIcon as W, XIcon as X, Stack$5 as Y, LoadingForSection as Z, OutlinedInput as _, isNegative as a, isLessThan as a$, formatUnits as a0, UNITS_CONSUMED as a1, isNumeric as a2, checkInputNumberic as a3, SOL_DECIMAL as a4, createSvgIcon as a5, generateUtilityClasses as a6, generateUtilityClass as a7, useDefaultProps as a8, useForkRef as a9, toNearestValue as aA, shortenAddress as aB, userSearchModeratorUsers as aC, Loading as aD, cn as aE, UserAvatar as aF, getFullImageUrl as aG, moderatorRestrictedUsers as aH, moderatorAddRestriction as aI, moderatorRemoveRestriction as aJ, Dialog as aK, Divider as aL, StyledTabs as aM, StyledTab as aN, useStore$1 as aO, Moderator_Status as aP, List as aQ, ListItem as aR, Text as aS, Ticker_Detail_Tabs as aT, TradeContext as aU, useCopyClipboard as aV, TradeDirection as aW, useConnection as aX, useWallet as aY, useAccountSubscribeContext as aZ, pointsQueryPoints as a_, ButtonBase as aa, clsx as ab, styled as ac, capitalize as ad, composeClasses as ae, memoTheme as af, alpha as ag, createSimplePaletteValueFilter as ah, useRtl as ai, lighten as aj, darken as ak, css as al, keyframes as am, isBrowser as an, noop$2 as ao, ExploreTypes as ap, Env_Mode as aq, Page as ar, usePricesContext as as, useParams as at, useTradeContext as au, getAssociatedTokenAddressSync as av, blackHoleAddress as aw, SubscribeTypes as ax, transactionQuerySwapTransactionHistories as ay, dayjs as az, useGgMemeProgram as b, pointsQueryEstimatedPoints as b$, getAccountLen as b0, ExtensionType as b1, isEqualTo as b2, compute_swap_with_fee as b3, isLessThanOrEqualTo as b4, WalletButton as b5, ExpandMore as b6, Popover as b7, MenuItem as b8, ExpandMoreIcon as b9, _arrayPush as bA, isSymbol_1 as bB, _arrayMap as bC, _baseGet as bD, identity_1 as bE, _baseUnary as bF, _baseMap as bG, _getNative as bH, isObject_1 as bI, isArrayLike_1 as bJ, _isIndex as bK, eq_1 as bL, _root as bM, map_1 as bN, _baseIsEqual as bO, _overArg as bP, _baseEach as bQ, _arraySome as bR, _baseForOwn as bS, memoize$3 as bT, EventEmitter as bU, curve_points as bV, Charts_Tabs as bW, StyleContainer as bX, NoDataSay as bY, useQuery$1 as bZ, InfiniteScroll as b_, Dialog$1 as ba, axios as bb, store$2 as bc, STORAGE_KEY_SOL as bd, EVENT_CHART_PRICE as be, STORAGE_KEY_PRICES as bf, PropTypes as bg, create$1 as bh, persist as bi, PriceTypes as bj, UnitTypes as bk, getDefaultExportFromCjs$2 as bl, isObjectLike_1 as bm, isArray_1 as bn, _baseGetTag as bo, get$2 as bp, isObject$j as bq, isFunction$6 as br, toString_1 as bs, _setToArray as bt, _Set as bu, _SetCache as bv, _cacheHas as bw, _baseIteratee as bx, _Symbol as by, isArguments_1 as bz, PublicKey as c, _defineProperty as c$, plus as c0, Link as c1, pointsQueryInviteCode as c2, pointsQueryPointsDetail as c3, DEFAULT_PAGE_LIMIT as c4, pointsQueryInviteDetail as c5, userQueryMyInfo as c6, PageContainer as c7, abs as c8, Logo as c9, TransactionMessage as cA, bs58 as cB, Transaction as cC, createAssociatedTokenAccountInstruction as cD, ownerDocument as cE, Portal as cF, useEnhancedEffect as cG, useSlotProps as cH, useTimeout as cI, useControlled as cJ, useId as cK, useEventCallback$1 as cL, Timeout as cM, getReactElementRef as cN, useSlot as cO, Grow as cP, isFocusVisible as cQ, on as cR, off as cS, EventEmitter$2 as cT, base58 as cU, process$1 as cV, require$$2$1 as cW, safeBufferExports as cX, getAugmentedNamespace as cY, commonjsGlobal$1 as cZ, require$$0 as c_, FormControlLabel as ca, Checkbox as cb, tokenHoldingsServiceQueryTokenHoldings as cc, toUsd as cd, tokenHoldingsServiceQueryTokenHoldingsHistories as ce, FormGroup as cf, Tabs as cg, Tab as ch, io as ci, SwitchBase as cj, isZero as ck, toDecimalPlaces as cl, Avatar$1 as cm, DEFAULT_SLIPPAGE as cn, useCluster as co, getProgramAccountPublicKey as cp, Program_Account_Name as cq, useQueryClient as cr, pointsGetPointsExchangeSign as cs, useMutation as ct, useTransactionToast as cu, Buffer$2 as cv, BN as cw, ComputeBudgetProgram as cx, UNITS_CONSUMED_MULTIPLIER as cy, VersionedTransaction as cz, Decimal as d, SolanaSignAndSendTransaction as d0, SolanaSignTransaction as d1, SolanaSignMessage as d2, compute_buy_token_exact_in_with_fee as e, useStore as f, green as g, useTheme as h, isPositive as i, jsxRuntimeExports as j, useAppBreakpoints as k, lodashExports as l, useNavigate as m, useInterval as n, Tiker_Sorted_By as o, Trans as p, useCheckLogin as q, reactExports as r, div as s, tickerGetTickers as t, useUpdateEffect as u, TokenAvatar as v, amountFormatter as w, multipliedBy as x, minus as y, formatNumber as z};
//# sourceMappingURL=index-bdam-jY8.js.map
